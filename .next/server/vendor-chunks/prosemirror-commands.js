"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-commands";
exports.ids = ["vendor-chunks/prosemirror-commands"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* binding */ autoJoin),\n/* harmony export */   baseKeymap: () => (/* binding */ baseKeymap),\n/* harmony export */   chainCommands: () => (/* binding */ chainCommands),\n/* harmony export */   createParagraphNear: () => (/* binding */ createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* binding */ deleteSelection),\n/* harmony export */   exitCode: () => (/* binding */ exitCode),\n/* harmony export */   joinBackward: () => (/* binding */ joinBackward),\n/* harmony export */   joinDown: () => (/* binding */ joinDown),\n/* harmony export */   joinForward: () => (/* binding */ joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* binding */ joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* binding */ joinTextblockForward),\n/* harmony export */   joinUp: () => (/* binding */ joinUp),\n/* harmony export */   lift: () => (/* binding */ lift),\n/* harmony export */   liftEmptyBlock: () => (/* binding */ liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* binding */ macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* binding */ newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* binding */ pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   selectNodeBackward: () => (/* binding */ selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* binding */ selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* binding */ selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* binding */ selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* binding */ selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* binding */ setBlockType),\n/* harmony export */   splitBlock: () => (/* binding */ splitBlock),\n/* harmony export */   splitBlockAs: () => (/* binding */ splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* binding */ splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* binding */ toggleMark),\n/* harmony export */   wrapIn: () => (/* binding */ wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n/**\nDelete the selection, if there is one.\n*/ const deleteSelection = (state, dispatch)=>{\n    if (state.selection.empty) return false;\n    if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());\n    return true;\n};\nfunction atBlockStart(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0)) return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and at the start of a textblock, try to\nreduce the distance between that block and the one before itâ€”if\nthere's a block directly before it that can be joined, join them.\nIf not, try to move the selected block closer to the next one in\nthe document structure by lifting it out of its parent or moving it\ninto a parent of the previous block. Will use the view for accurate\n(bidi-aware) start-of-textblock detection if given.\n*/ const joinBackward = (state, dispatch, view)=>{\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutBefore($cursor);\n    // If there is no node before this, try to lift\n    if (!$cut) {\n        let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n        if (target == null) return false;\n        if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    let before = $cut.nodeBefore;\n    // Apply the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch, -1)) return true;\n    // If the node below has no content and the node above is\n    // selectable, delete the node below and select the one above.\n    if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(before))) {\n        for(let depth = $cursor.depth;; depth--){\n            let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(depth), $cursor.after(depth), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n            if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n                if (dispatch) {\n                    let tr = state.tr.step(delStep);\n                    tr.setSelection(textblockAt(before, \"end\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n                    dispatch(tr.scrollIntoView());\n                }\n                return true;\n            }\n            if (depth == 1 || $cursor.node(depth - 1).childCount > 1) break;\n        }\n    }\n    // If the node before is an atom, delete it\n    if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nA more limited form of [`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward)\nthat only tries to join the current textblock to the one before\nit, if the cursor is at the start of a textblock.\n*/ const joinTextblockBackward = (state, dispatch, view)=>{\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutBefore($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\n/**\nA more limited form of [`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward)\nthat only tries to join the current textblock to the one after\nit, if the cursor is at the end of a textblock.\n*/ const joinTextblockForward = (state, dispatch, view)=>{\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutAfter($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nfunction joinTextblocksAround(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;\n    for(; !beforeText.isTextblock; beforePos--){\n        if (beforeText.type.spec.isolating) return false;\n        let child = beforeText.lastChild;\n        if (!child) return false;\n        beforeText = child;\n    }\n    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;\n    for(; !afterText.isTextblock; afterPos++){\n        if (afterText.type.spec.isolating) return false;\n        let child = afterText.firstChild;\n        if (!child) return false;\n        afterText = child;\n    }\n    let step = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, beforePos, afterPos, prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n    if (!step || step.from != beforePos || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep && step.slice.size >= afterPos - beforePos) return false;\n    if (dispatch) {\n        let tr = state.tr.step(step);\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, beforePos));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n}\nfunction textblockAt(node, side, only = false) {\n    for(let scan = node; scan; scan = side == \"start\" ? scan.firstChild : scan.lastChild){\n        if (scan.isTextblock) return true;\n        if (only && scan.childCount != 1) return false;\n    }\n    return false;\n}\n/**\nWhen the selection is empty and at the start of a textblock, select\nthe node before that textblock, if possible. This is intended to be\nbound to keys like backspace, after\n[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting\ncommands, as a fall-back behavior when the schema doesn't allow\ndeletion at the selected point.\n*/ const selectNodeBackward = (state, dispatch, view)=>{\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty) return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false;\n        $cut = findCutBefore($head);\n    }\n    let node = $cut && $cut.nodeBefore;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) return false;\n    if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n    return true;\n};\nfunction findCutBefore($pos) {\n    if (!$pos.parent.type.spec.isolating) for(let i = $pos.depth - 1; i >= 0; i--){\n        if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1));\n        if ($pos.node(i).type.spec.isolating) break;\n    }\n    return null;\n}\nfunction atBlockEnd(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size)) return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and the cursor is at the end of a\ntextblock, try to reduce or remove the boundary between that block\nand the one after it, either by joining them or by moving the other\nblock closer to this one in the tree structure. Will use the view\nfor accurate start-of-textblock detection if given.\n*/ const joinForward = (state, dispatch, view)=>{\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutAfter($cursor);\n    // If there is no node after this, there's nothing to do\n    if (!$cut) return false;\n    let after = $cut.nodeAfter;\n    // Try the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch, 1)) return true;\n    // If the node above has no content and the node below is\n    // selectable, delete the node above and select the one below.\n    if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(after))) {\n        let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(after, \"start\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the next node is an atom, delete it\n    if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nWhen the selection is empty and at the end of a textblock, select\nthe node coming after that textblock, if possible. This is intended\nto be bound to keys like delete, after\n[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting\ncommands, to provide a fall-back behavior when the schema doesn't\nallow deletion at the selected point.\n*/ const selectNodeForward = (state, dispatch, view)=>{\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty) return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size) return false;\n        $cut = findCutAfter($head);\n    }\n    let node = $cut && $cut.nodeAfter;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) return false;\n    if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n    return true;\n};\nfunction findCutAfter($pos) {\n    if (!$pos.parent.type.spec.isolating) for(let i = $pos.depth - 1; i >= 0; i--){\n        let parent = $pos.node(i);\n        if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1));\n        if (parent.type.spec.isolating) break;\n    }\n    return null;\n}\n/**\nJoin the selected block or, if there is a text selection, the\nclosest ancestor block of the selection that can be joined, with\nthe sibling above it.\n*/ const joinUp = (state, dispatch)=>{\n    let sel = state.selection, nodeSel = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection, point;\n    if (nodeSel) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.from)) return false;\n        point = sel.from;\n    } else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.from, -1);\n        if (point == null) return false;\n    }\n    if (dispatch) {\n        let tr = state.tr.join(point);\n        if (nodeSel) tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nJoin the selected block, or the closest ancestor of the selection\nthat can be joined, with the sibling after it.\n*/ const joinDown = (state, dispatch)=>{\n    let sel = state.selection, point;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.to)) return false;\n        point = sel.to;\n    } else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.to, 1);\n        if (point == null) return false;\n    }\n    if (dispatch) dispatch(state.tr.join(point).scrollIntoView());\n    return true;\n};\n/**\nLift the selected block, or the closest ancestor block of the\nselection that can be lifted, out of its parent node.\n*/ const lift = (state, dispatch)=>{\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null) return false;\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nIf the selection is in a node whose type has a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the\nselection with a newline character.\n*/ const newlineInCode = (state, dispatch)=>{\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n    if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n    return true;\n};\nfunction defaultBlockAt(match) {\n    for(let i = 0; i < match.edgeCount; i++){\n        let { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs()) return type;\n    }\n    return null;\n}\n/**\nWhen the selection is in a node with a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a\ndefault block after the code block, and move the cursor there.\n*/ const exitCode = (state, dispatch)=>{\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n    if (!type || !above.canReplaceWith(after, after, type)) return false;\n    if (dispatch) {\n        let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(tr.doc.resolve(pos), 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf a block node is selected, create an empty paragraph before (if\nit is its parent's first child) or after it.\n*/ const createParagraphNear = (state, dispatch)=>{\n    let sel = state.selection, { $from, $to } = sel;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false;\n    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n    if (!type || !type.isTextblock) return false;\n    if (dispatch) {\n        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n        let tr = state.tr.insert(side, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, side + 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf the cursor is in an empty textblock that can be lifted, lift the\nblock.\n*/ const liftEmptyBlock = (state, dispatch)=>{\n    let { $cursor } = state.selection;\n    if (!$cursor || $cursor.parent.content.size) return false;\n    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n        let before = $cursor.before();\n        if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, before)) {\n            if (dispatch) dispatch(state.tr.split(before).scrollIntoView());\n            return true;\n        }\n    }\n    let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null) return false;\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nCreate a variant of [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock) that uses\na custom function to determine the type of the newly split off block.\n*/ function splitBlockAs(splitNode) {\n    return (state, dispatch)=>{\n        let { $from, $to } = state.selection;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && state.selection.node.isBlock) {\n            if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, $from.pos)) return false;\n            if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());\n            return true;\n        }\n        if (!$from.depth) return false;\n        let types = [];\n        let splitDepth, deflt, atEnd = false, atStart = false;\n        for(let d = $from.depth;; d--){\n            let node = $from.node(d);\n            if (node.isBlock) {\n                atEnd = $from.end(d) == $from.pos + ($from.depth - d);\n                atStart = $from.start(d) == $from.pos - ($from.depth - d);\n                deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));\n                let splitType = splitNode && splitNode($to.parent, atEnd, $from);\n                types.unshift(splitType || (atEnd && deflt ? {\n                    type: deflt\n                } : null));\n                splitDepth = d;\n                break;\n            } else {\n                if (d == 1) return false;\n                types.unshift(null);\n            }\n        }\n        let tr = state.tr;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection || state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection) tr.deleteSelection();\n        let splitPos = tr.mapping.map($from.pos);\n        let can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, splitPos, types.length, types);\n        if (!can) {\n            types[0] = deflt ? {\n                type: deflt\n            } : null;\n            can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, splitPos, types.length, types);\n        }\n        tr.split(splitPos, types.length, types);\n        if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {\n            let first = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first);\n            if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt)) tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);\n        }\n        if (dispatch) dispatch(tr.scrollIntoView());\n        return true;\n    };\n}\n/**\nSplit the parent block of the selection. If the selection is a text\nselection, also delete its content.\n*/ const splitBlock = splitBlockAs();\n/**\nActs like [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock), but without\nresetting the set of active marks at the cursor.\n*/ const splitBlockKeepMarks = (state, dispatch)=>{\n    return splitBlock(state, dispatch && ((tr)=>{\n        let marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n        if (marks) tr.ensureMarks(marks);\n        dispatch(tr);\n    }));\n};\n/**\nMove the selection to the node wrapping the current selection, if\nany. (Will not select the document node.)\n*/ const selectParentNode = (state, dispatch)=>{\n    let { $from, to } = state.selection, pos;\n    let same = $from.sharedDepth(to);\n    if (same == 0) return false;\n    pos = $from.before(same);\n    if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, pos)));\n    return true;\n};\n/**\nSelect the whole document.\n*/ const selectAll = (state, dispatch)=>{\n    if (dispatch) dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection(state.doc)));\n    return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n    if (!before || !after || !before.type.compatibleContent(after.type)) return false;\n    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n        if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n        return true;\n    }\n    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, $pos.pos))) return false;\n    if (dispatch) dispatch(state.tr.join($pos.pos).scrollIntoView());\n    return true;\n}\nfunction deleteBarrier(state, $cut, dispatch, dir) {\n    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n    let isolated = before.type.spec.isolating || after.type.spec.isolating;\n    if (!isolated && joinMaybeClear(state, $cut, dispatch)) return true;\n    let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n        if (dispatch) {\n            let end = $cut.pos + after.nodeSize, wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n            for(let i = conn.length - 1; i >= 0; i--)wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(conn[i].create(null, wrap));\n            wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(before.copy(wrap));\n            let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(wrap, 1, 0), conn.length, true));\n            let $joinAt = tr.doc.resolve(end + 2 * conn.length);\n            if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, $joinAt.pos)) tr.join($joinAt.pos);\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    }\n    let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($cut, 1);\n    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target != null && target >= $cut.depth) {\n        if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n        let at = before, wrap = [];\n        for(;;){\n            wrap.push(at);\n            if (at.isTextblock) break;\n            at = at.lastChild;\n        }\n        let afterText = after, afterDepth = 1;\n        for(; !afterText.isTextblock; afterText = afterText.firstChild)afterDepth++;\n        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n            if (dispatch) {\n                let end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n                for(let i = wrap.length - 1; i >= 0; i--)end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(wrap[i].copy(end));\n                let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(end, wrap.length, 0), 0, true));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction selectTextblockSide(side) {\n    return function(state, dispatch) {\n        let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n        let depth = $pos.depth;\n        while($pos.node(depth).isInline){\n            if (!depth) return false;\n            depth--;\n        }\n        if (!$pos.node(depth).isTextblock) return false;\n        if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n        return true;\n    };\n}\n/**\nMoves the cursor to the start of current text block.\n*/ const selectTextblockStart = selectTextblockSide(-1);\n/**\nMoves the cursor to the end of current text block.\n*/ const selectTextblockEnd = selectTextblockSide(1);\n// Parameterized commands\n/**\nWrap the selection in a node of the given type with the given\nattributes.\n*/ function wrapIn(nodeType, attrs = null) {\n    return function(state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(range, nodeType, attrs);\n        if (!wrapping) return false;\n        if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n        return true;\n    };\n}\n/**\nReturns a command that tries to set the selected textblocks to the\ngiven node type with the given attributes.\n*/ function setBlockType(nodeType, attrs = null) {\n    return function(state, dispatch) {\n        let applicable = false;\n        for(let i = 0; i < state.selection.ranges.length && !applicable; i++){\n            let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n            state.doc.nodesBetween(from, to, (node, pos)=>{\n                if (applicable) return false;\n                if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;\n                if (node.type == nodeType) {\n                    applicable = true;\n                } else {\n                    let $pos = state.doc.resolve(pos), index = $pos.index();\n                    applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n                }\n            });\n        }\n        if (!applicable) return false;\n        if (dispatch) {\n            let tr = state.tr;\n            for(let i = 0; i < state.selection.ranges.length; i++){\n                let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n                tr.setBlockType(from, to, nodeType, attrs);\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\nfunction markApplies(doc, ranges, type, enterAtoms) {\n    for(let i = 0; i < ranges.length; i++){\n        let { $from, $to } = ranges[i];\n        let can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, (node, pos)=>{\n            if (can || !enterAtoms && node.isAtom && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos) return false;\n            can = node.inlineContent && node.type.allowsMarkType(type);\n        });\n        if (can) return true;\n    }\n    return false;\n}\nfunction removeInlineAtoms(ranges) {\n    let result = [];\n    for(let i = 0; i < ranges.length; i++){\n        let { $from, $to } = ranges[i];\n        $from.doc.nodesBetween($from.pos, $to.pos, (node, pos)=>{\n            if (node.isAtom && node.content.size && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos) {\n                if (pos + 1 > $from.pos) result.push(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.SelectionRange($from, $from.doc.resolve(pos + 1)));\n                $from = $from.doc.resolve(pos + 1 + node.content.size);\n                return false;\n            }\n        });\n        if ($from.pos < $to.pos) result.push(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.SelectionRange($from, $to));\n    }\n    return result;\n}\n/**\nCreate a command function that toggles the given mark with the\ngiven attributes. Will return `false` when the current selection\ndoesn't support that mark. This will remove the mark if any marks\nof that type exist in the selection, or add it otherwise. If the\nselection is empty, this applies to the [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks) instead of a range of the\ndocument.\n*/ function toggleMark(markType, attrs = null, options) {\n    let removeWhenPresent = (options && options.removeWhenPresent) !== false;\n    let enterAtoms = (options && options.enterInlineAtoms) !== false;\n    let dropSpace = !(options && options.includeWhitespace);\n    return function(state, dispatch) {\n        let { empty, $cursor, ranges } = state.selection;\n        if (empty && !$cursor || !markApplies(state.doc, ranges, markType, enterAtoms)) return false;\n        if (dispatch) {\n            if ($cursor) {\n                if (markType.isInSet(state.storedMarks || $cursor.marks())) dispatch(state.tr.removeStoredMark(markType));\n                else dispatch(state.tr.addStoredMark(markType.create(attrs)));\n            } else {\n                let add, tr = state.tr;\n                if (!enterAtoms) ranges = removeInlineAtoms(ranges);\n                if (removeWhenPresent) {\n                    add = !ranges.some((r)=>state.doc.rangeHasMark(r.$from.pos, r.$to.pos, markType));\n                } else {\n                    add = !ranges.every((r)=>{\n                        let missing = false;\n                        tr.doc.nodesBetween(r.$from.pos, r.$to.pos, (node, pos, parent)=>{\n                            if (missing) return false;\n                            missing = !markType.isInSet(node.marks) && !!parent && parent.type.allowsMarkType(markType) && !(node.isText && /^\\s*$/.test(node.textBetween(Math.max(0, r.$from.pos - pos), Math.min(node.nodeSize, r.$to.pos - pos))));\n                        });\n                        return !missing;\n                    });\n                }\n                for(let i = 0; i < ranges.length; i++){\n                    let { $from, $to } = ranges[i];\n                    if (!add) {\n                        tr.removeMark($from.pos, $to.pos, markType);\n                    } else {\n                        let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;\n                        let spaceStart = dropSpace && start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n                        let spaceEnd = dropSpace && end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n                        if (from + spaceStart < to) {\n                            from += spaceStart;\n                            to -= spaceEnd;\n                        }\n                        tr.addMark(from, to, markType.create(attrs));\n                    }\n                }\n                dispatch(tr.scrollIntoView());\n            }\n        }\n        return true;\n    };\n}\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n    return (tr)=>{\n        if (!tr.isGeneric) return dispatch(tr);\n        let ranges = [];\n        for(let i = 0; i < tr.mapping.maps.length; i++){\n            let map = tr.mapping.maps[i];\n            for(let j = 0; j < ranges.length; j++)ranges[j] = map.map(ranges[j]);\n            map.forEach((_s, _e, from, to)=>ranges.push(from, to));\n        }\n        // Figure out which joinable points exist inside those ranges,\n        // by checking all node boundaries in their parent nodes.\n        let joinable = [];\n        for(let i = 0; i < ranges.length; i += 2){\n            let from = ranges[i], to = ranges[i + 1];\n            let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n            for(let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index){\n                let after = parent.maybeChild(index);\n                if (!after) break;\n                if (index && joinable.indexOf(pos) == -1) {\n                    let before = parent.child(index - 1);\n                    if (before.type == after.type && isJoinable(before, after)) joinable.push(pos);\n                }\n                pos += after.nodeSize;\n            }\n        }\n        // Join the joinable points\n        joinable.sort((a, b)=>a - b);\n        for(let i = joinable.length - 1; i >= 0; i--){\n            if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinable[i])) tr.join(joinable[i]);\n        }\n        dispatch(tr);\n    };\n}\n/**\nWrap a command so that, when it produces a transform that causes\ntwo joinable nodes to end up next to each other, those are joined.\nNodes are considered joinable when they are of the same type and\nwhen the `isJoinable` predicate returns true for them or, if an\narray of strings was passed, if their node type name is in that\narray.\n*/ function autoJoin(command, isJoinable) {\n    let canJoin = Array.isArray(isJoinable) ? (node)=>isJoinable.indexOf(node.type.name) > -1 : isJoinable;\n    return (state, dispatch, view)=>command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);\n}\n/**\nCombine a number of command functions into a single function (which\ncalls them one by one until one returns true).\n*/ function chainCommands(...commands) {\n    return function(state, dispatch, view) {\n        for(let i = 0; i < commands.length; i++)if (commands[i](state, dispatch, view)) return true;\n        return false;\n    };\n}\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n/**\nA basic keymap containing bindings not specific to any schema.\nBinds the following keys (when multiple commands are listed, they\nare chained with [`chainCommands`](https://prosemirror.net/docs/ref/#commands.chainCommands)):\n\n* **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n* **Mod-Enter** to `exitCode`\n* **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n* **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-a** to `selectAll`\n*/ const pcBaseKeymap = {\n    \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n    \"Mod-Enter\": exitCode,\n    \"Backspace\": backspace,\n    \"Mod-Backspace\": backspace,\n    \"Shift-Backspace\": backspace,\n    \"Delete\": del,\n    \"Mod-Delete\": del,\n    \"Mod-a\": selectAll\n};\n/**\nA copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n**Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n**Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\nCtrl-Delete.\n*/ const macBaseKeymap = {\n    \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n    \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n    \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n    \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Ctrl-a\": selectTextblockStart,\n    \"Ctrl-e\": selectTextblockEnd\n};\nfor(let key in pcBaseKeymap)macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\n/**\nDepending on the detected platform, this will hold\n[`pcBasekeymap`](https://prosemirror.net/docs/ref/#commands.pcBaseKeymap) or\n[`macBaseKeymap`](https://prosemirror.net/docs/ref/#commands.macBaseKeymap).\n*/ const baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0STtBQUN4RjtBQUNzRDtBQUUxRzs7QUFFQSxHQUNBLE1BQU1lLGtCQUFrQixDQUFDQyxPQUFPQztJQUM1QixJQUFJRCxNQUFNRSxTQUFTLENBQUNDLEtBQUssRUFDckIsT0FBTztJQUNYLElBQUlGLFVBQ0FBLFNBQVNELE1BQU1JLEVBQUUsQ0FBQ0wsZUFBZSxHQUFHTSxjQUFjO0lBQ3RELE9BQU87QUFDWDtBQUNBLFNBQVNDLGFBQWFOLEtBQUssRUFBRU8sSUFBSTtJQUM3QixJQUFJLEVBQUVDLE9BQU8sRUFBRSxHQUFHUixNQUFNRSxTQUFTO0lBQ2pDLElBQUksQ0FBQ00sV0FBWUQsQ0FBQUEsT0FBTyxDQUFDQSxLQUFLRSxjQUFjLENBQUMsWUFBWVQsU0FDbkRRLFFBQVFFLFlBQVksR0FBRyxJQUN6QixPQUFPO0lBQ1gsT0FBT0Y7QUFDWDtBQUNBOzs7Ozs7OztBQVFBLEdBQ0EsTUFBTUcsZUFBZSxDQUFDWCxPQUFPQyxVQUFVTTtJQUNuQyxJQUFJQyxVQUFVRixhQUFhTixPQUFPTztJQUNsQyxJQUFJLENBQUNDLFNBQ0QsT0FBTztJQUNYLElBQUlJLE9BQU9DLGNBQWNMO0lBQ3pCLCtDQUErQztJQUMvQyxJQUFJLENBQUNJLE1BQU07UUFDUCxJQUFJRSxRQUFRTixRQUFRTyxVQUFVLElBQUlDLFNBQVNGLFNBQVM5QixpRUFBVUEsQ0FBQzhCO1FBQy9ELElBQUlFLFVBQVUsTUFDVixPQUFPO1FBQ1gsSUFBSWYsVUFDQUEsU0FBU0QsTUFBTUksRUFBRSxDQUFDYSxJQUFJLENBQUNILE9BQU9FLFFBQVFYLGNBQWM7UUFDeEQsT0FBTztJQUNYO0lBQ0EsSUFBSWEsU0FBU04sS0FBS08sVUFBVTtJQUM1Qiw4QkFBOEI7SUFDOUIsSUFBSUMsY0FBY3BCLE9BQU9ZLE1BQU1Y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YUFBYTtJQUN4QyxTQUFTQSxZQUFZLENBQUMsYUFBYTtJQUNuQyxVQUFVbkU7SUFDVixVQUFVQztBQUNkO0FBQ0EsSUFBSyxJQUFJb0UsT0FBT0YsYUFDWkMsYUFBYSxDQUFDQyxJQUFJLEdBQUdGLFlBQVksQ0FBQ0UsSUFBSTtBQUMxQyxNQUFNQyxNQUFNLE9BQU9DLGFBQWEsY0FBYyxxQkFBcUJ0QyxJQUFJLENBQUNzQyxVQUFVQyxRQUFRLElBRXBGLE9BQU9DLE1BQU0sZUFBZUEsR0FBR0QsUUFBUSxHQUFHQyxHQUFHRCxRQUFRLE1BQU0sV0FBVztBQUM1RTs7OztBQUlBLEdBQ0EsTUFBTUUsYUFBYUosTUFBTUYsZ0JBQWdCRDtBQUVpWiIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItY29tbWFuZHMvZGlzdC9pbmRleC5qcz8yOGY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxpZnRUYXJnZXQsIHJlcGxhY2VTdGVwLCBSZXBsYWNlU3RlcCwgY2FuSm9pbiwgam9pblBvaW50LCBjYW5TcGxpdCwgUmVwbGFjZUFyb3VuZFN0ZXAsIGZpbmRXcmFwcGluZyB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uLCBTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24sIEFsbFNlbGVjdGlvbiwgU2VsZWN0aW9uUmFuZ2UgfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIGlmIHRoZXJlIGlzIG9uZS5cbiovXG5jb25zdCBkZWxldGVTZWxlY3Rpb24gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlU2VsZWN0aW9uKCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KSB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpXG4gICAgICAgIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPiAwKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuICRjdXJzb3I7XG59XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jaywgdHJ5IHRvXG5yZWR1Y2UgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhhdCBibG9jayBhbmQgdGhlIG9uZSBiZWZvcmUgaXTigJRpZlxudGhlcmUncyBhIGJsb2NrIGRpcmVjdGx5IGJlZm9yZSBpdCB0aGF0IGNhbiBiZSBqb2luZWQsIGpvaW4gdGhlbS5cbklmIG5vdCwgdHJ5IHRvIG1vdmUgdGhlIHNlbGVjdGVkIGJsb2NrIGNsb3NlciB0byB0aGUgbmV4dCBvbmUgaW5cbnRoZSBkb2N1bWVudCBzdHJ1Y3R1cmUgYnkgbGlmdGluZyBpdCBvdXQgb2YgaXRzIHBhcmVudCBvciBtb3ZpbmcgaXRcbmludG8gYSBwYXJlbnQgb2YgdGhlIHByZXZpb3VzIGJsb2NrLiBXaWxsIHVzZSB0aGUgdmlldyBmb3IgYWNjdXJhdGVcbihiaWRpLWF3YXJlKSBzdGFydC1vZi10ZXh0YmxvY2sgZGV0ZWN0aW9uIGlmIGdpdmVuLlxuKi9cbmNvbnN0IGpvaW5CYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlIHRoaXMsIHRyeSB0byBsaWZ0XG4gICAgaWYgKCEkY3V0KSB7XG4gICAgICAgIGxldCByYW5nZSA9ICRjdXJzb3IuYmxvY2tSYW5nZSgpLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZTtcbiAgICAvLyBBcHBseSB0aGUgam9pbmluZyBhbGdvcml0aG1cbiAgICBpZiAoZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gsIC0xKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gSWYgdGhlIG5vZGUgYmVsb3cgaGFzIG5vIGNvbnRlbnQgYW5kIHRoZSBub2RlIGFib3ZlIGlzXG4gICAgLy8gc2VsZWN0YWJsZSwgZGVsZXRlIHRoZSBub2RlIGJlbG93IGFuZCBzZWxlY3QgdGhlIG9uZSBhYm92ZS5cbiAgICBpZiAoJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiZcbiAgICAgICAgKHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikgfHwgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoYmVmb3JlKSkpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAkY3Vyc29yLmRlcHRoOzsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGRlbFN0ZXAgPSByZXBsYWNlU3RlcChzdGF0ZS5kb2MsICRjdXJzb3IuYmVmb3JlKGRlcHRoKSwgJGN1cnNvci5hZnRlcihkZXB0aCksIFNsaWNlLmVtcHR5KTtcbiAgICAgICAgICAgIGlmIChkZWxTdGVwICYmIGRlbFN0ZXAuc2xpY2Uuc2l6ZSA8IGRlbFN0ZXAudG8gLSBkZWxTdGVwLmZyb20pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gU2VsZWN0aW9uLmZpbmRGcm9tKHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcubWFwKCRjdXQucG9zLCAtMSkpLCAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVwdGggPT0gMSB8fCAkY3Vyc29yLm5vZGUoZGVwdGggLSAxKS5jaGlsZENvdW50ID4gMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgbm9kZSBiZWZvcmUgaXMgYW4gYXRvbSwgZGVsZXRlIGl0XG4gICAgaWYgKGJlZm9yZS5pc0F0b20gJiYgJGN1dC5kZXB0aCA9PSAkY3Vyc29yLmRlcHRoIC0gMSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJGN1dC5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRjdXQucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbkEgbW9yZSBsaW1pdGVkIGZvcm0gb2YgW2Bqb2luQmFja3dhcmRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuam9pbkJhY2t3YXJkKVxudGhhdCBvbmx5IHRyaWVzIHRvIGpvaW4gdGhlIGN1cnJlbnQgdGV4dGJsb2NrIHRvIHRoZSBvbmUgYmVmb3JlXG5pdCwgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXG4qL1xuY29uc3Qgam9pblRleHRibG9ja0JhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGN1cnNvcik7XG4gICAgcmV0dXJuICRjdXQgPyBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIDogZmFsc2U7XG59O1xuLyoqXG5BIG1vcmUgbGltaXRlZCBmb3JtIG9mIFtgam9pbkZvcndhcmRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuam9pbkZvcndhcmQpXG50aGF0IG9ubHkgdHJpZXMgdG8gam9pbiB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gdGhlIG9uZSBhZnRlclxuaXQsIGlmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jay5cbiovXG5jb25zdCBqb2luVGV4dGJsb2NrRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuICAgIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkge1xuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmUsIGJlZm9yZVRleHQgPSBiZWZvcmUsIGJlZm9yZVBvcyA9ICRjdXQucG9zIC0gMTtcbiAgICBmb3IgKDsgIWJlZm9yZVRleHQuaXNUZXh0YmxvY2s7IGJlZm9yZVBvcy0tKSB7XG4gICAgICAgIGlmIChiZWZvcmVUZXh0LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGlsZCA9IGJlZm9yZVRleHQubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBiZWZvcmVUZXh0ID0gY2hpbGQ7XG4gICAgfVxuICAgIGxldCBhZnRlciA9ICRjdXQubm9kZUFmdGVyLCBhZnRlclRleHQgPSBhZnRlciwgYWZ0ZXJQb3MgPSAkY3V0LnBvcyArIDE7XG4gICAgZm9yICg7ICFhZnRlclRleHQuaXNUZXh0YmxvY2s7IGFmdGVyUG9zKyspIHtcbiAgICAgICAgaWYgKGFmdGVyVGV4dC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSBhZnRlclRleHQuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYWZ0ZXJUZXh0ID0gY2hpbGQ7XG4gICAgfVxuICAgIGxldCBzdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCBiZWZvcmVQb3MsIGFmdGVyUG9zLCBTbGljZS5lbXB0eSk7XG4gICAgaWYgKCFzdGVwIHx8IHN0ZXAuZnJvbSAhPSBiZWZvcmVQb3MgfHxcbiAgICAgICAgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwICYmIHN0ZXAuc2xpY2Uuc2l6ZSA+PSBhZnRlclBvcyAtIGJlZm9yZVBvcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKHN0ZXApO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBiZWZvcmVQb3MpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdGV4dGJsb2NrQXQobm9kZSwgc2lkZSwgb25seSA9IGZhbHNlKSB7XG4gICAgZm9yIChsZXQgc2NhbiA9IG5vZGU7IHNjYW47IHNjYW4gPSAoc2lkZSA9PSBcInN0YXJ0XCIgPyBzY2FuLmZpcnN0Q2hpbGQgOiBzY2FuLmxhc3RDaGlsZCkpIHtcbiAgICAgICAgaWYgKHNjYW4uaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG9ubHkgJiYgc2Nhbi5jaGlsZENvdW50ICE9IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHNlbGVjdFxudGhlIG5vZGUgYmVmb3JlIHRoYXQgdGV4dGJsb2NrLCBpZiBwb3NzaWJsZS4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuYm91bmQgdG8ga2V5cyBsaWtlIGJhY2tzcGFjZSwgYWZ0ZXJcbltgam9pbkJhY2t3YXJkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmpvaW5CYWNrd2FyZCkgb3Igb3RoZXIgZGVsZXRpbmdcbmNvbW1hbmRzLCBhcyBhIGZhbGwtYmFjayBiZWhhdmlvciB3aGVuIHRoZSBzY2hlbWEgZG9lc24ndCBhbGxvd1xuZGVsZXRpb24gYXQgdGhlIHNlbGVjdGVkIHBvaW50LlxuKi9cbmNvbnN0IHNlbGVjdE5vZGVCYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbiwgJGN1dCA9ICRoZWFkO1xuICAgIGlmICghZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKSB7XG4gICAgICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAkY3V0ID0gZmluZEN1dEJlZm9yZSgkaGVhZCk7XG4gICAgfVxuICAgIGxldCBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVCZWZvcmU7XG4gICAgaWYgKCFub2RlIHx8ICFOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MgLSBub2RlLm5vZGVTaXplKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZmluZEN1dEJlZm9yZSgkcG9zKSB7XG4gICAgaWYgKCEkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoJHBvcy5pbmRleChpKSA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5iZWZvcmUoaSArIDEpKTtcbiAgICAgICAgICAgIGlmICgkcG9zLm5vZGUoaSkudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYXRCbG9ja0VuZChzdGF0ZSwgdmlldykge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImZvcndhcmRcIiwgc3RhdGUpXG4gICAgICAgIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gJGN1cnNvcjtcbn1cbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgdGhlIGN1cnNvciBpcyBhdCB0aGUgZW5kIG9mIGFcbnRleHRibG9jaywgdHJ5IHRvIHJlZHVjZSBvciByZW1vdmUgdGhlIGJvdW5kYXJ5IGJldHdlZW4gdGhhdCBibG9ja1xuYW5kIHRoZSBvbmUgYWZ0ZXIgaXQsIGVpdGhlciBieSBqb2luaW5nIHRoZW0gb3IgYnkgbW92aW5nIHRoZSBvdGhlclxuYmxvY2sgY2xvc2VyIHRvIHRoaXMgb25lIGluIHRoZSB0cmVlIHN0cnVjdHVyZS4gV2lsbCB1c2UgdGhlIHZpZXdcbmZvciBhY2N1cmF0ZSBzdGFydC1vZi10ZXh0YmxvY2sgZGV0ZWN0aW9uIGlmIGdpdmVuLlxuKi9cbmNvbnN0IGpvaW5Gb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja0VuZChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGN1cnNvcik7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbm9kZSBhZnRlciB0aGlzLCB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cbiAgICBpZiAoISRjdXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlcjtcbiAgICAvLyBUcnkgdGhlIGpvaW5pbmcgYWxnb3JpdGhtXG4gICAgaWYgKGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoLCAxKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gSWYgdGhlIG5vZGUgYWJvdmUgaGFzIG5vIGNvbnRlbnQgYW5kIHRoZSBub2RlIGJlbG93IGlzXG4gICAgLy8gc2VsZWN0YWJsZSwgZGVsZXRlIHRoZSBub2RlIGFib3ZlIGFuZCBzZWxlY3QgdGhlIG9uZSBiZWxvdy5cbiAgICBpZiAoJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiZcbiAgICAgICAgKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpIHx8IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGFmdGVyKSkpIHtcbiAgICAgICAgbGV0IGRlbFN0ZXAgPSByZXBsYWNlU3RlcChzdGF0ZS5kb2MsICRjdXJzb3IuYmVmb3JlKCksICRjdXJzb3IuYWZ0ZXIoKSwgU2xpY2UuZW1wdHkpO1xuICAgICAgICBpZiAoZGVsU3RlcCAmJiBkZWxTdGVwLnNsaWNlLnNpemUgPCBkZWxTdGVwLnRvIC0gZGVsU3RlcC5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKGRlbFN0ZXApO1xuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbih0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSA/IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcykpLCAxKVxuICAgICAgICAgICAgICAgICAgICA6IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGFuIGF0b20sIGRlbGV0ZSBpdFxuICAgIGlmIChhZnRlci5pc0F0b20gJiYgJGN1dC5kZXB0aCA9PSAkY3Vyc29yLmRlcHRoIC0gMSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJGN1dC5wb3MsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrLCBzZWxlY3RcbnRoZSBub2RlIGNvbWluZyBhZnRlciB0aGF0IHRleHRibG9jaywgaWYgcG9zc2libGUuIFRoaXMgaXMgaW50ZW5kZWRcbnRvIGJlIGJvdW5kIHRvIGtleXMgbGlrZSBkZWxldGUsIGFmdGVyXG5bYGpvaW5Gb3J3YXJkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmpvaW5Gb3J3YXJkKSBhbmQgc2ltaWxhciBkZWxldGluZ1xuY29tbWFuZHMsIHRvIHByb3ZpZGUgYSBmYWxsLWJhY2sgYmVoYXZpb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXNuJ3RcbmFsbG93IGRlbGV0aW9uIGF0IHRoZSBzZWxlY3RlZCBwb2ludC5cbiovXG5jb25zdCBzZWxlY3ROb2RlRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbiwgJGN1dCA9ICRoZWFkO1xuICAgIGlmICghZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKSB7XG4gICAgICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKSA6ICRoZWFkLnBhcmVudE9mZnNldCA8ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGhlYWQpO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQWZ0ZXI7XG4gICAgaWYgKCFub2RlIHx8ICFOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBmaW5kQ3V0QWZ0ZXIoJHBvcykge1xuICAgIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShpKTtcbiAgICAgICAgICAgIGlmICgkcG9zLmluZGV4KGkpICsgMSA8IHBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYWZ0ZXIoaSArIDEpKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5Kb2luIHRoZSBzZWxlY3RlZCBibG9jayBvciwgaWYgdGhlcmUgaXMgYSB0ZXh0IHNlbGVjdGlvbiwgdGhlXG5jbG9zZXN0IGFuY2VzdG9yIGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24gdGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoXG50aGUgc2libGluZyBhYm92ZSBpdC5cbiovXG5jb25zdCBqb2luVXAgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgbm9kZVNlbCA9IHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24sIHBvaW50O1xuICAgIGlmIChub2RlU2VsKSB7XG4gICAgICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC5mcm9tKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcG9pbnQgPSBzZWwuZnJvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc2VsLmZyb20sIC0xKTtcbiAgICAgICAgaWYgKHBvaW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5qb2luKHBvaW50KTtcbiAgICAgICAgaWYgKG5vZGVTZWwpXG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb2ludCAtIHN0YXRlLmRvYy5yZXNvbHZlKHBvaW50KS5ub2RlQmVmb3JlLm5vZGVTaXplKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkpvaW4gdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBvZiB0aGUgc2VsZWN0aW9uXG50aGF0IGNhbiBiZSBqb2luZWQsIHdpdGggdGhlIHNpYmxpbmcgYWZ0ZXIgaXQuXG4qL1xuY29uc3Qgam9pbkRvd24gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgcG9pbnQ7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlbC5ub2RlLmlzVGV4dGJsb2NrIHx8ICFjYW5Kb2luKHN0YXRlLmRvYywgc2VsLnRvKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcG9pbnQgPSBzZWwudG87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC50bywgMSk7XG4gICAgICAgIGlmIChwb2ludCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmpvaW4ocG9pbnQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTGlmdCB0aGUgc2VsZWN0ZWQgYmxvY2ssIG9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGJsb2NrIG9mIHRoZVxuc2VsZWN0aW9uIHRoYXQgY2FuIGJlIGxpZnRlZCwgb3V0IG9mIGl0cyBwYXJlbnQgbm9kZS5cbiovXG5jb25zdCBsaWZ0ID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgaW4gYSBub2RlIHdob3NlIHR5cGUgaGFzIGEgdHJ1dGh5XG5bYGNvZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29kZSkgcHJvcGVydHkgaW4gaXRzIHNwZWMsIHJlcGxhY2UgdGhlXG5zZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUgY2hhcmFjdGVyLlxuKi9cbmNvbnN0IG5ld2xpbmVJbkNvZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnBhcmVudC50eXBlLnNwZWMuY29kZSB8fCAhJGhlYWQuc2FtZVBhcmVudCgkYW5jaG9yKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuaW5zZXJ0VGV4dChcIlxcblwiKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBkZWZhdWx0QmxvY2tBdChtYXRjaCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IHsgdHlwZSB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICAgICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgaW4gYSBub2RlIHdpdGggYSB0cnV0aHlcbltgY29kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb2RlKSBwcm9wZXJ0eSBpbiBpdHMgc3BlYywgY3JlYXRlIGFcbmRlZmF1bHQgYmxvY2sgYWZ0ZXIgdGhlIGNvZGUgYmxvY2ssIGFuZCBtb3ZlIHRoZSBjdXJzb3IgdGhlcmUuXG4qL1xuY29uc3QgZXhpdENvZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnBhcmVudC50eXBlLnNwZWMuY29kZSB8fCAhJGhlYWQuc2FtZVBhcmVudCgkYW5jaG9yKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhYm92ZSA9ICRoZWFkLm5vZGUoLTEpLCBhZnRlciA9ICRoZWFkLmluZGV4QWZ0ZXIoLTEpLCB0eXBlID0gZGVmYXVsdEJsb2NrQXQoYWJvdmUuY29udGVudE1hdGNoQXQoYWZ0ZXIpKTtcbiAgICBpZiAoIXR5cGUgfHwgIWFib3ZlLmNhblJlcGxhY2VXaXRoKGFmdGVyLCBhZnRlciwgdHlwZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHBvcyA9ICRoZWFkLmFmdGVyKCksIHRyID0gc3RhdGUudHIucmVwbGFjZVdpdGgocG9zLCBwb3MsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHBvcyksIDEpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgYSBibG9jayBub2RlIGlzIHNlbGVjdGVkLCBjcmVhdGUgYW4gZW1wdHkgcGFyYWdyYXBoIGJlZm9yZSAoaWZcbml0IGlzIGl0cyBwYXJlbnQncyBmaXJzdCBjaGlsZCkgb3IgYWZ0ZXIgaXQuXG4qL1xuY29uc3QgY3JlYXRlUGFyYWdyYXBoTmVhciA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCB7ICRmcm9tLCAkdG8gfSA9IHNlbDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uIHx8ICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50IHx8ICR0by5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0eXBlID0gZGVmYXVsdEJsb2NrQXQoJHRvLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkdG8uaW5kZXhBZnRlcigpKSk7XG4gICAgaWYgKCF0eXBlIHx8ICF0eXBlLmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBzaWRlID0gKCEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJHRvLmluZGV4KCkgPCAkdG8ucGFyZW50LmNoaWxkQ291bnQgPyAkZnJvbSA6ICR0bykucG9zO1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5pbnNlcnQoc2lkZSwgdHlwZS5jcmVhdGVBbmRGaWxsKCkpO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBzaWRlICsgMSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiB0aGUgY3Vyc29yIGlzIGluIGFuIGVtcHR5IHRleHRibG9jayB0aGF0IGNhbiBiZSBsaWZ0ZWQsIGxpZnQgdGhlXG5ibG9jay5cbiovXG5jb25zdCBsaWZ0RW1wdHlCbG9jayA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkY3Vyc29yLmRlcHRoID4gMSAmJiAkY3Vyc29yLmFmdGVyKCkgIT0gJGN1cnNvci5lbmQoLTEpKSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSAkY3Vyc29yLmJlZm9yZSgpO1xuICAgICAgICBpZiAoY2FuU3BsaXQoc3RhdGUuZG9jLCBiZWZvcmUpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoYmVmb3JlKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByYW5nZSA9ICRjdXJzb3IuYmxvY2tSYW5nZSgpLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DcmVhdGUgYSB2YXJpYW50IG9mIFtgc3BsaXRCbG9ja2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdEJsb2NrKSB0aGF0IHVzZXNcbmEgY3VzdG9tIGZ1bmN0aW9uIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiB0aGUgbmV3bHkgc3BsaXQgb2ZmIGJsb2NrLlxuKi9cbmZ1bmN0aW9uIHNwbGl0QmxvY2tBcyhzcGxpdE5vZGUpIHtcbiAgICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHN0YXRlLnNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFjYW5TcGxpdChzdGF0ZS5kb2MsICRmcm9tLnBvcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNwbGl0KCRmcm9tLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISRmcm9tLmRlcHRoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdHlwZXMgPSBbXTtcbiAgICAgICAgbGV0IHNwbGl0RGVwdGgsIGRlZmx0LCBhdEVuZCA9IGZhbHNlLCBhdFN0YXJ0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aDs7IGQtLSkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSAkZnJvbS5ub2RlKGQpO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNCbG9jaykge1xuICAgICAgICAgICAgICAgIGF0RW5kID0gJGZyb20uZW5kKGQpID09ICRmcm9tLnBvcyArICgkZnJvbS5kZXB0aCAtIGQpO1xuICAgICAgICAgICAgICAgIGF0U3RhcnQgPSAkZnJvbS5zdGFydChkKSA9PSAkZnJvbS5wb3MgLSAoJGZyb20uZGVwdGggLSBkKTtcbiAgICAgICAgICAgICAgICBkZWZsdCA9IGRlZmF1bHRCbG9ja0F0KCRmcm9tLm5vZGUoZCAtIDEpLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoZCAtIDEpKSk7XG4gICAgICAgICAgICAgICAgbGV0IHNwbGl0VHlwZSA9IHNwbGl0Tm9kZSAmJiBzcGxpdE5vZGUoJHRvLnBhcmVudCwgYXRFbmQsICRmcm9tKTtcbiAgICAgICAgICAgICAgICB0eXBlcy51bnNoaWZ0KHNwbGl0VHlwZSB8fCAoYXRFbmQgJiYgZGVmbHQgPyB7IHR5cGU6IGRlZmx0IH0gOiBudWxsKSk7XG4gICAgICAgICAgICAgICAgc3BsaXREZXB0aCA9IGQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZCA9PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgdHlwZXMudW5zaGlmdChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gfHwgc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uKVxuICAgICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgIGxldCBzcGxpdFBvcyA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyk7XG4gICAgICAgIGxldCBjYW4gPSBjYW5TcGxpdCh0ci5kb2MsIHNwbGl0UG9zLCB0eXBlcy5sZW5ndGgsIHR5cGVzKTtcbiAgICAgICAgaWYgKCFjYW4pIHtcbiAgICAgICAgICAgIHR5cGVzWzBdID0gZGVmbHQgPyB7IHR5cGU6IGRlZmx0IH0gOiBudWxsO1xuICAgICAgICAgICAgY2FuID0gY2FuU3BsaXQodHIuZG9jLCBzcGxpdFBvcywgdHlwZXMubGVuZ3RoLCB0eXBlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdHIuc3BsaXQoc3BsaXRQb3MsIHR5cGVzLmxlbmd0aCwgdHlwZXMpO1xuICAgICAgICBpZiAoIWF0RW5kICYmIGF0U3RhcnQgJiYgJGZyb20ubm9kZShzcGxpdERlcHRoKS50eXBlICE9IGRlZmx0KSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoc3BsaXREZXB0aCkpLCAkZmlyc3QgPSB0ci5kb2MucmVzb2x2ZShmaXJzdCk7XG4gICAgICAgICAgICBpZiAoZGVmbHQgJiYgJGZyb20ubm9kZShzcGxpdERlcHRoIC0gMSkuY2FuUmVwbGFjZVdpdGgoJGZpcnN0LmluZGV4KCksICRmaXJzdC5pbmRleCgpICsgMSwgZGVmbHQpKVxuICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKHNwbGl0RGVwdGgpKSwgZGVmbHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5TcGxpdCB0aGUgcGFyZW50IGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24uIElmIHRoZSBzZWxlY3Rpb24gaXMgYSB0ZXh0XG5zZWxlY3Rpb24sIGFsc28gZGVsZXRlIGl0cyBjb250ZW50LlxuKi9cbmNvbnN0IHNwbGl0QmxvY2sgPSBzcGxpdEJsb2NrQXMoKTtcbi8qKlxuQWN0cyBsaWtlIFtgc3BsaXRCbG9ja2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdEJsb2NrKSwgYnV0IHdpdGhvdXRcbnJlc2V0dGluZyB0aGUgc2V0IG9mIGFjdGl2ZSBtYXJrcyBhdCB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IHNwbGl0QmxvY2tLZWVwTWFya3MgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgcmV0dXJuIHNwbGl0QmxvY2soc3RhdGUsIGRpc3BhdGNoICYmICh0ciA9PiB7XG4gICAgICAgIGxldCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH0pKTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbm9kZSB3cmFwcGluZyB0aGUgY3VycmVudCBzZWxlY3Rpb24sIGlmXG5hbnkuIChXaWxsIG5vdCBzZWxlY3QgdGhlIGRvY3VtZW50IG5vZGUuKVxuKi9cbmNvbnN0IHNlbGVjdFBhcmVudE5vZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb24sIHBvcztcbiAgICBsZXQgc2FtZSA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgICBpZiAoc2FtZSA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcG9zID0gJGZyb20uYmVmb3JlKHNhbWUpO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgcG9zKSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSB3aG9sZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEFsbFNlbGVjdGlvbihzdGF0ZS5kb2MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gam9pbk1heWJlQ2xlYXIoc3RhdGUsICRwb3MsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlciwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8ICFiZWZvcmUudHlwZS5jb21wYXRpYmxlQ29udGVudChhZnRlci50eXBlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghYmVmb3JlLmNvbnRlbnQuc2l6ZSAmJiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4IC0gMSwgaW5kZXgpKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkcG9zLnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJHBvcy5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCEkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpIHx8ICEoYWZ0ZXIuaXNUZXh0YmxvY2sgfHwgY2FuSm9pbihzdGF0ZS5kb2MsICRwb3MucG9zKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmpvaW4oJHBvcy5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gsIGRpcikge1xuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmUsIGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXIsIGNvbm4sIG1hdGNoO1xuICAgIGxldCBpc29sYXRlZCA9IGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmc7XG4gICAgaWYgKCFpc29sYXRlZCAmJiBqb2luTWF5YmVDbGVhcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgY2FuRGVsQWZ0ZXIgPSAhaXNvbGF0ZWQgJiYgJGN1dC5wYXJlbnQuY2FuUmVwbGFjZSgkY3V0LmluZGV4KCksICRjdXQuaW5kZXgoKSArIDEpO1xuICAgIGlmIChjYW5EZWxBZnRlciAmJlxuICAgICAgICAoY29ubiA9IChtYXRjaCA9IGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpLmZpbmRXcmFwcGluZyhhZnRlci50eXBlKSkgJiZcbiAgICAgICAgbWF0Y2gubWF0Y2hUeXBlKGNvbm5bMF0gfHwgYWZ0ZXIudHlwZSkudmFsaWRFbmQpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbm4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oY29ubltpXS5jcmVhdGUobnVsbCwgd3JhcCkpO1xuICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oYmVmb3JlLmNvcHkod3JhcCkpO1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSAxLCBlbmQsICRjdXQucG9zLCBlbmQsIG5ldyBTbGljZSh3cmFwLCAxLCAwKSwgY29ubi5sZW5ndGgsIHRydWUpKTtcbiAgICAgICAgICAgIGxldCAkam9pbkF0ID0gdHIuZG9jLnJlc29sdmUoZW5kICsgMiAqIGNvbm4ubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICgkam9pbkF0Lm5vZGVBZnRlciAmJiAkam9pbkF0Lm5vZGVBZnRlci50eXBlID09IGJlZm9yZS50eXBlICYmXG4gICAgICAgICAgICAgICAgY2FuSm9pbih0ci5kb2MsICRqb2luQXQucG9zKSlcbiAgICAgICAgICAgICAgICB0ci5qb2luKCRqb2luQXQucG9zKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgc2VsQWZ0ZXIgPSBhZnRlci50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IChkaXIgPiAwICYmIGlzb2xhdGVkKSA/IG51bGwgOiBTZWxlY3Rpb24uZmluZEZyb20oJGN1dCwgMSk7XG4gICAgbGV0IHJhbmdlID0gc2VsQWZ0ZXIgJiYgc2VsQWZ0ZXIuJGZyb20uYmxvY2tSYW5nZShzZWxBZnRlci4kdG8pLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0ID49ICRjdXQuZGVwdGgpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjYW5EZWxBZnRlciAmJiB0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiLCB0cnVlKSAmJiB0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpKSB7XG4gICAgICAgIGxldCBhdCA9IGJlZm9yZSwgd3JhcCA9IFtdO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB3cmFwLnB1c2goYXQpO1xuICAgICAgICAgICAgaWYgKGF0LmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgYXQgPSBhdC5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFmdGVyVGV4dCA9IGFmdGVyLCBhZnRlckRlcHRoID0gMTtcbiAgICAgICAgZm9yICg7ICFhZnRlclRleHQuaXNUZXh0YmxvY2s7IGFmdGVyVGV4dCA9IGFmdGVyVGV4dC5maXJzdENoaWxkKVxuICAgICAgICAgICAgYWZ0ZXJEZXB0aCsrO1xuICAgICAgICBpZiAoYXQuY2FuUmVwbGFjZShhdC5jaGlsZENvdW50LCBhdC5jaGlsZENvdW50LCBhZnRlclRleHQuY29udGVudCkpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gd3JhcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gRnJhZ21lbnQuZnJvbSh3cmFwW2ldLmNvcHkoZW5kKSk7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSB3cmFwLmxlbmd0aCwgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgJGN1dC5wb3MgKyBhZnRlckRlcHRoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplIC0gYWZ0ZXJEZXB0aCwgbmV3IFNsaWNlKGVuZCwgd3JhcC5sZW5ndGgsIDApLCAwLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RUZXh0YmxvY2tTaWRlKHNpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCAkcG9zID0gc2lkZSA8IDAgPyBzZWwuJGZyb20gOiBzZWwuJHRvO1xuICAgICAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoO1xuICAgICAgICB3aGlsZSAoJHBvcy5ub2RlKGRlcHRoKS5pc0lubGluZSkge1xuICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJHBvcy5ub2RlKGRlcHRoKS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgc2lkZSA8IDAgPyAkcG9zLnN0YXJ0KGRlcHRoKSA6ICRwb3MuZW5kKGRlcHRoKSkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgc3RhcnQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuKi9cbmNvbnN0IHNlbGVjdFRleHRibG9ja1N0YXJ0ID0gc2VsZWN0VGV4dGJsb2NrU2lkZSgtMSk7XG4vKipcbk1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIGVuZCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4qL1xuY29uc3Qgc2VsZWN0VGV4dGJsb2NrRW5kID0gc2VsZWN0VGV4dGJsb2NrU2lkZSgxKTtcbi8vIFBhcmFtZXRlcml6ZWQgY29tbWFuZHNcbi8qKlxuV3JhcCB0aGUgc2VsZWN0aW9uIGluIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSB3aXRoIHRoZSBnaXZlblxuYXR0cmlidXRlcy5cbiovXG5mdW5jdGlvbiB3cmFwSW4obm9kZVR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB3cmFwcGluZyA9IHJhbmdlICYmIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICAgICAgaWYgKCF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIud3JhcChyYW5nZSwgd3JhcHBpbmcpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCB0aGF0IHRyaWVzIHRvIHNldCB0aGUgc2VsZWN0ZWQgdGV4dGJsb2NrcyB0byB0aGVcbmdpdmVuIG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIHNldEJsb2NrVHlwZShub2RlVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IGFwcGxpY2FibGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aCAmJiAhYXBwbGljYWJsZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbTogeyBwb3M6IGZyb20gfSwgJHRvOiB7IHBvczogdG8gfSB9ID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1tpXTtcbiAgICAgICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwbGljYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLmhhc01hcmt1cChub2RlVHlwZSwgYXR0cnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCAkcG9zID0gc3RhdGUuZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2FibGUgPSAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCBub2RlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcHBsaWNhYmxlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgJGZyb206IHsgcG9zOiBmcm9tIH0sICR0bzogeyBwb3M6IHRvIH0gfSA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgdHIuc2V0QmxvY2tUeXBlKGZyb20sIHRvLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtBcHBsaWVzKGRvYywgcmFuZ2VzLCB0eXBlLCBlbnRlckF0b21zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICBsZXQgY2FuID0gJGZyb20uZGVwdGggPT0gMCA/IGRvYy5pbmxpbmVDb250ZW50ICYmIGRvYy50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpIDogZmFsc2U7XG4gICAgICAgIGRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuIHx8ICFlbnRlckF0b21zICYmIG5vZGUuaXNBdG9tICYmIG5vZGUuaXNJbmxpbmUgJiYgcG9zID49ICRmcm9tLnBvcyAmJiBwb3MgKyBub2RlLm5vZGVTaXplIDw9ICR0by5wb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FuID0gbm9kZS5pbmxpbmVDb250ZW50ICYmIG5vZGUudHlwZS5hbGxvd3NNYXJrVHlwZSh0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYW4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVtb3ZlSW5saW5lQXRvbXMocmFuZ2VzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgJGZyb20uZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzQXRvbSAmJiBub2RlLmNvbnRlbnQuc2l6ZSAmJiBub2RlLmlzSW5saW5lICYmIHBvcyA+PSAkZnJvbS5wb3MgJiYgcG9zICsgbm9kZS5ub2RlU2l6ZSA8PSAkdG8ucG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyArIDEgPiAkZnJvbS5wb3MpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTZWxlY3Rpb25SYW5nZSgkZnJvbSwgJGZyb20uZG9jLnJlc29sdmUocG9zICsgMSkpKTtcbiAgICAgICAgICAgICAgICAkZnJvbSA9ICRmcm9tLmRvYy5yZXNvbHZlKHBvcyArIDEgKyBub2RlLmNvbnRlbnQuc2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCRmcm9tLnBvcyA8ICR0by5wb3MpXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU2VsZWN0aW9uUmFuZ2UoJGZyb20sICR0bykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5DcmVhdGUgYSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgdG9nZ2xlcyB0aGUgZ2l2ZW4gbWFyayB3aXRoIHRoZVxuZ2l2ZW4gYXR0cmlidXRlcy4gV2lsbCByZXR1cm4gYGZhbHNlYCB3aGVuIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuZG9lc24ndCBzdXBwb3J0IHRoYXQgbWFyay4gVGhpcyB3aWxsIHJlbW92ZSB0aGUgbWFyayBpZiBhbnkgbWFya3Ncbm9mIHRoYXQgdHlwZSBleGlzdCBpbiB0aGUgc2VsZWN0aW9uLCBvciBhZGQgaXQgb3RoZXJ3aXNlLiBJZiB0aGVcbnNlbGVjdGlvbiBpcyBlbXB0eSwgdGhpcyBhcHBsaWVzIHRvIHRoZSBbc3RvcmVkXG5tYXJrc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKSBpbnN0ZWFkIG9mIGEgcmFuZ2Ugb2YgdGhlXG5kb2N1bWVudC5cbiovXG5mdW5jdGlvbiB0b2dnbGVNYXJrKG1hcmtUeXBlLCBhdHRycyA9IG51bGwsIG9wdGlvbnMpIHtcbiAgICBsZXQgcmVtb3ZlV2hlblByZXNlbnQgPSAob3B0aW9ucyAmJiBvcHRpb25zLnJlbW92ZVdoZW5QcmVzZW50KSAhPT0gZmFsc2U7XG4gICAgbGV0IGVudGVyQXRvbXMgPSAob3B0aW9ucyAmJiBvcHRpb25zLmVudGVySW5saW5lQXRvbXMpICE9PSBmYWxzZTtcbiAgICBsZXQgZHJvcFNwYWNlID0gIShvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZVdoaXRlc3BhY2UpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7IGVtcHR5LCAkY3Vyc29yLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKChlbXB0eSAmJiAhJGN1cnNvcikgfHwgIW1hcmtBcHBsaWVzKHN0YXRlLmRvYywgcmFuZ2VzLCBtYXJrVHlwZSwgZW50ZXJBdG9tcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUuaXNJblNldChzdGF0ZS5zdG9yZWRNYXJrcyB8fCAkY3Vyc29yLm1hcmtzKCkpKVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5hZGRTdG9yZWRNYXJrKG1hcmtUeXBlLmNyZWF0ZShhdHRycykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBhZGQsIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICAgICAgaWYgKCFlbnRlckF0b21zKVxuICAgICAgICAgICAgICAgICAgICByYW5nZXMgPSByZW1vdmVJbmxpbmVBdG9tcyhyYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVXaGVuUHJlc2VudCkge1xuICAgICAgICAgICAgICAgICAgICBhZGQgPSAhcmFuZ2VzLnNvbWUociA9PiBzdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKHIuJGZyb20ucG9zLCByLiR0by5wb3MsIG1hcmtUeXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGQgPSAhcmFuZ2VzLmV2ZXJ5KHIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1pc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oci4kZnJvbS5wb3MsIHIuJHRvLnBvcywgKG5vZGUsIHBvcywgcGFyZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pc3NpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nID0gIW1hcmtUeXBlLmlzSW5TZXQobm9kZS5tYXJrcykgJiYgISFwYXJlbnQgJiYgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobWFya1R5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEobm9kZS5pc1RleHQgJiYgL15cXHMqJC8udGVzdChub2RlLnRleHRCZXR3ZWVuKE1hdGgubWF4KDAsIHIuJGZyb20ucG9zIC0gcG9zKSwgTWF0aC5taW4obm9kZS5ub2RlU2l6ZSwgci4kdG8ucG9zIC0gcG9zKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFtaXNzaW5nO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIucmVtb3ZlTWFyaygkZnJvbS5wb3MsICR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gJGZyb20ucG9zLCB0byA9ICR0by5wb3MsIHN0YXJ0ID0gJGZyb20ubm9kZUFmdGVyLCBlbmQgPSAkdG8ubm9kZUJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZVN0YXJ0ID0gZHJvcFNwYWNlICYmIHN0YXJ0ICYmIHN0YXJ0LmlzVGV4dCA/IC9eXFxzKi8uZXhlYyhzdGFydC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRW5kID0gZHJvcFNwYWNlICYmIGVuZCAmJiBlbmQuaXNUZXh0ID8gL1xccyokLy5leGVjKGVuZC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gKyBzcGFjZVN0YXJ0IDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHNwYWNlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gLT0gc3BhY2VFbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCBtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgaXNKb2luYWJsZSkge1xuICAgIHJldHVybiAodHIpID0+IHtcbiAgICAgICAgaWYgKCF0ci5pc0dlbmVyaWMpXG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2godHIpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHIubWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gdHIubWFwcGluZy5tYXBzW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYW5nZXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgcmFuZ2VzW2pdID0gbWFwLm1hcChyYW5nZXNbal0pO1xuICAgICAgICAgICAgbWFwLmZvckVhY2goKF9zLCBfZSwgZnJvbSwgdG8pID0+IHJhbmdlcy5wdXNoKGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBqb2luYWJsZSBwb2ludHMgZXhpc3QgaW5zaWRlIHRob3NlIHJhbmdlcyxcbiAgICAgICAgLy8gYnkgY2hlY2tpbmcgYWxsIG5vZGUgYm91bmRhcmllcyBpbiB0aGVpciBwYXJlbnQgbm9kZXMuXG4gICAgICAgIGxldCBqb2luYWJsZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaV0sIHRvID0gcmFuZ2VzW2kgKyAxXTtcbiAgICAgICAgICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCBkZXB0aCA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKSwgcGFyZW50ID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9ICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpLCBwb3MgPSAkZnJvbS5hZnRlcihkZXB0aCArIDEpOyBwb3MgPD0gdG87ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICYmIGpvaW5hYmxlLmluZGV4T2YocG9zKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUudHlwZSA9PSBhZnRlci50eXBlICYmIGlzSm9pbmFibGUoYmVmb3JlLCBhZnRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luYWJsZS5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBhZnRlci5ub2RlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKb2luIHRoZSBqb2luYWJsZSBwb2ludHNcbiAgICAgICAgam9pbmFibGUuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICBmb3IgKGxldCBpID0gam9pbmFibGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChjYW5Kb2luKHRyLmRvYywgam9pbmFibGVbaV0pKVxuICAgICAgICAgICAgICAgIHRyLmpvaW4oam9pbmFibGVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9O1xufVxuLyoqXG5XcmFwIGEgY29tbWFuZCBzbyB0aGF0LCB3aGVuIGl0IHByb2R1Y2VzIGEgdHJhbnNmb3JtIHRoYXQgY2F1c2VzXG50d28gam9pbmFibGUgbm9kZXMgdG8gZW5kIHVwIG5leHQgdG8gZWFjaCBvdGhlciwgdGhvc2UgYXJlIGpvaW5lZC5cbk5vZGVzIGFyZSBjb25zaWRlcmVkIGpvaW5hYmxlIHdoZW4gdGhleSBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmRcbndoZW4gdGhlIGBpc0pvaW5hYmxlYCBwcmVkaWNhdGUgcmV0dXJucyB0cnVlIGZvciB0aGVtIG9yLCBpZiBhblxuYXJyYXkgb2Ygc3RyaW5ncyB3YXMgcGFzc2VkLCBpZiB0aGVpciBub2RlIHR5cGUgbmFtZSBpcyBpbiB0aGF0XG5hcnJheS5cbiovXG5mdW5jdGlvbiBhdXRvSm9pbihjb21tYW5kLCBpc0pvaW5hYmxlKSB7XG4gICAgbGV0IGNhbkpvaW4gPSBBcnJheS5pc0FycmF5KGlzSm9pbmFibGUpID8gKG5vZGUpID0+IGlzSm9pbmFibGUuaW5kZXhPZihub2RlLnR5cGUubmFtZSkgPiAtMVxuICAgICAgICA6IGlzSm9pbmFibGU7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IGNvbW1hbmQoc3RhdGUsIGRpc3BhdGNoICYmIHdyYXBEaXNwYXRjaEZvckpvaW4oZGlzcGF0Y2gsIGNhbkpvaW4pLCB2aWV3KTtcbn1cbi8qKlxuQ29tYmluZSBhIG51bWJlciBvZiBjb21tYW5kIGZ1bmN0aW9ucyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uICh3aGljaFxuY2FsbHMgdGhlbSBvbmUgYnkgb25lIHVudGlsIG9uZSByZXR1cm5zIHRydWUpLlxuKi9cbmZ1bmN0aW9uIGNoYWluQ29tbWFuZHMoLi4uY29tbWFuZHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNvbW1hbmRzW2ldKHN0YXRlLCBkaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxubGV0IGJhY2tzcGFjZSA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luQmFja3dhcmQsIHNlbGVjdE5vZGVCYWNrd2FyZCk7XG5sZXQgZGVsID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5Gb3J3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCk7XG4vKipcbkEgYmFzaWMga2V5bWFwIGNvbnRhaW5pbmcgYmluZGluZ3Mgbm90IHNwZWNpZmljIHRvIGFueSBzY2hlbWEuXG5CaW5kcyB0aGUgZm9sbG93aW5nIGtleXMgKHdoZW4gbXVsdGlwbGUgY29tbWFuZHMgYXJlIGxpc3RlZCwgdGhleVxuYXJlIGNoYWluZWQgd2l0aCBbYGNoYWluQ29tbWFuZHNgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuY2hhaW5Db21tYW5kcykpOlxuXG4qICoqRW50ZXIqKiB0byBgbmV3bGluZUluQ29kZWAsIGBjcmVhdGVQYXJhZ3JhcGhOZWFyYCwgYGxpZnRFbXB0eUJsb2NrYCwgYHNwbGl0QmxvY2tgXG4qICoqTW9kLUVudGVyKiogdG8gYGV4aXRDb2RlYFxuKiAqKkJhY2tzcGFjZSoqIGFuZCAqKk1vZC1CYWNrc3BhY2UqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5CYWNrd2FyZGAsIGBzZWxlY3ROb2RlQmFja3dhcmRgXG4qICoqRGVsZXRlKiogYW5kICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLWEqKiB0byBgc2VsZWN0QWxsYFxuKi9cbmNvbnN0IHBjQmFzZUtleW1hcCA9IHtcbiAgICBcIkVudGVyXCI6IGNoYWluQ29tbWFuZHMobmV3bGluZUluQ29kZSwgY3JlYXRlUGFyYWdyYXBoTmVhciwgbGlmdEVtcHR5QmxvY2ssIHNwbGl0QmxvY2spLFxuICAgIFwiTW9kLUVudGVyXCI6IGV4aXRDb2RlLFxuICAgIFwiQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIk1vZC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiU2hpZnQtQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIkRlbGV0ZVwiOiBkZWwsXG4gICAgXCJNb2QtRGVsZXRlXCI6IGRlbCxcbiAgICBcIk1vZC1hXCI6IHNlbGVjdEFsbFxufTtcbi8qKlxuQSBjb3B5IG9mIGBwY0Jhc2VLZXltYXBgIHRoYXQgYWxzbyBiaW5kcyAqKkN0cmwtaCoqIGxpa2UgQmFja3NwYWNlLFxuKipDdHJsLWQqKiBsaWtlIERlbGV0ZSwgKipBbHQtQmFja3NwYWNlKiogbGlrZSBDdHJsLUJhY2tzcGFjZSwgYW5kXG4qKkN0cmwtQWx0LUJhY2tzcGFjZSoqLCAqKkFsdC1EZWxldGUqKiwgYW5kICoqQWx0LWQqKiBsaWtlXG5DdHJsLURlbGV0ZS5cbiovXG5jb25zdCBtYWNCYXNlS2V5bWFwID0ge1xuICAgIFwiQ3RybC1oXCI6IHBjQmFzZUtleW1hcFtcIkJhY2tzcGFjZVwiXSxcbiAgICBcIkFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLUJhY2tzcGFjZVwiXSxcbiAgICBcIkN0cmwtZFwiOiBwY0Jhc2VLZXltYXBbXCJEZWxldGVcIl0sXG4gICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1EZWxldGVcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1kXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJDdHJsLWFcIjogc2VsZWN0VGV4dGJsb2NrU3RhcnQsXG4gICAgXCJDdHJsLWVcIjogc2VsZWN0VGV4dGJsb2NrRW5kXG59O1xuZm9yIChsZXQga2V5IGluIHBjQmFzZUtleW1hcClcbiAgICBtYWNCYXNlS2V5bWFwW2tleV0gPSBwY0Jhc2VLZXltYXBba2V5XTtcbmNvbnN0IG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IC9NYWN8aVAoaG9uZXxbb2FdZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICA6IHR5cGVvZiBvcyAhPSBcInVuZGVmaW5lZFwiICYmIG9zLnBsYXRmb3JtID8gb3MucGxhdGZvcm0oKSA9PSBcImRhcndpblwiIDogZmFsc2U7XG4vKipcbkRlcGVuZGluZyBvbiB0aGUgZGV0ZWN0ZWQgcGxhdGZvcm0sIHRoaXMgd2lsbCBob2xkXG5bYHBjQmFzZWtleW1hcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5wY0Jhc2VLZXltYXApIG9yXG5bYG1hY0Jhc2VLZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMubWFjQmFzZUtleW1hcCkuXG4qL1xuY29uc3QgYmFzZUtleW1hcCA9IG1hYyA/IG1hY0Jhc2VLZXltYXAgOiBwY0Jhc2VLZXltYXA7XG5cbmV4cG9ydCB7IGF1dG9Kb2luLCBiYXNlS2V5bWFwLCBjaGFpbkNvbW1hbmRzLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBkZWxldGVTZWxlY3Rpb24sIGV4aXRDb2RlLCBqb2luQmFja3dhcmQsIGpvaW5Eb3duLCBqb2luRm9yd2FyZCwgam9pblRleHRibG9ja0JhY2t3YXJkLCBqb2luVGV4dGJsb2NrRm9yd2FyZCwgam9pblVwLCBsaWZ0LCBsaWZ0RW1wdHlCbG9jaywgbWFjQmFzZUtleW1hcCwgbmV3bGluZUluQ29kZSwgcGNCYXNlS2V5bWFwLCBzZWxlY3RBbGwsIHNlbGVjdE5vZGVCYWNrd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQsIHNlbGVjdFBhcmVudE5vZGUsIHNlbGVjdFRleHRibG9ja0VuZCwgc2VsZWN0VGV4dGJsb2NrU3RhcnQsIHNldEJsb2NrVHlwZSwgc3BsaXRCbG9jaywgc3BsaXRCbG9ja0FzLCBzcGxpdEJsb2NrS2VlcE1hcmtzLCB0b2dnbGVNYXJrLCB3cmFwSW4gfTtcbiJdLCJuYW1lcyI6WyJsaWZ0VGFyZ2V0IiwicmVwbGFjZVN0ZXAiLCJSZXBsYWNlU3RlcCIsImNhbkpvaW4iLCJqb2luUG9pbnQiLCJjYW5TcGxpdCIsIlJlcGxhY2VBcm91bmRTdGVwIiwiZmluZFdyYXBwaW5nIiwiU2xpY2UiLCJGcmFnbWVudCIsIk5vZGVTZWxlY3Rpb24iLCJTZWxlY3Rpb24iLCJUZXh0U2VsZWN0aW9uIiwiQWxsU2VsZWN0aW9uIiwiU2VsZWN0aW9uUmFuZ2UiLCJkZWxldGVTZWxlY3Rpb24iLCJzdGF0ZSIsImRpc3BhdGNoIiwic2VsZWN0aW9uIiwiZW1wdHkiLCJ0ciIsInNjcm9sbEludG9WaWV3IiwiYXRCbG9ja1N0YXJ0IiwidmlldyIsIiRjdXJzb3IiLCJlbmRPZlRleHRibG9jayIsInBhcmVudE9mZnNldCIsImpvaW5CYWNrd2FyZCIsIiRjdXQiLCJmaW5kQ3V0QmVmb3JlIiwicmFuZ2UiLCJibG9ja1JhbmdlIiwidGFyZ2V0IiwibGlmdCIsImJlZm9yZSIsIm5vZGVCZWZvcmUiLCJkZWxldGVCYXJyaWVyIiwicGFyZW50IiwiY29udGVudCIsInNpemUiLCJ0ZXh0YmxvY2tBdCIsImlzU2VsZWN0YWJsZSIsImRlcHRoIiwiZGVsU3RlcCIsImRvYyIsImFmdGVyIiwic2xpY2UiLCJ0byIsImZyb20iLCJzdGVwIiwic2V0U2VsZWN0aW9uIiwiZmluZEZyb20iLCJyZXNvbHZlIiwibWFwcGluZyIsIm1hcCIsInBvcyIsImNyZWF0ZSIsIm5vZGVTaXplIiwibm9kZSIsImNoaWxkQ291bnQiLCJpc0F0b20iLCJkZWxldGUiLCJqb2luVGV4dGJsb2NrQmFja3dhcmQiLCJqb2luVGV4dGJsb2Nrc0Fyb3VuZCIsImpvaW5UZXh0YmxvY2tGb3J3YXJkIiwiYXRCbG9ja0VuZCIsImZpbmRDdXRBZnRlciIsImJlZm9yZVRleHQiLCJiZWZvcmVQb3MiLCJpc1RleHRibG9jayIsInR5cGUiLCJzcGVjIiwiaXNvbGF0aW5nIiwiY2hpbGQiLCJsYXN0Q2hpbGQiLCJub2RlQWZ0ZXIiLCJhZnRlclRleHQiLCJhZnRlclBvcyIsImZpcnN0Q2hpbGQiLCJzaWRlIiwib25seSIsInNjYW4iLCJzZWxlY3ROb2RlQmFja3dhcmQiLCIkaGVhZCIsIiRwb3MiLCJpIiwiaW5kZXgiLCJqb2luRm9yd2FyZCIsInNlbGVjdE5vZGVGb3J3YXJkIiwiam9pblVwIiwic2VsIiwibm9kZVNlbCIsInBvaW50Iiwiam9pbiIsImpvaW5Eb3duIiwiJGZyb20iLCIkdG8iLCJuZXdsaW5lSW5Db2RlIiwiJGFuY2hvciIsImNvZGUiLCJzYW1lUGFyZW50IiwiaW5zZXJ0VGV4dCIsImRlZmF1bHRCbG9ja0F0IiwibWF0Y2giLCJlZGdlQ291bnQiLCJlZGdlIiwiaGFzUmVxdWlyZWRBdHRycyIsImV4aXRDb2RlIiwiYWJvdmUiLCJpbmRleEFmdGVyIiwiY29udGVudE1hdGNoQXQiLCJjYW5SZXBsYWNlV2l0aCIsInJlcGxhY2VXaXRoIiwiY3JlYXRlQW5kRmlsbCIsIm5lYXIiLCJjcmVhdGVQYXJhZ3JhcGhOZWFyIiwiaW5saW5lQ29udGVudCIsImluc2VydCIsImxpZnRFbXB0eUJsb2NrIiwiZW5kIiwic3BsaXQiLCJzcGxpdEJsb2NrQXMiLCJzcGxpdE5vZGUiLCJpc0Jsb2NrIiwidHlwZXMiLCJzcGxpdERlcHRoIiwiZGVmbHQiLCJhdEVuZCIsImF0U3RhcnQiLCJkIiwic3RhcnQiLCJzcGxpdFR5cGUiLCJ1bnNoaWZ0Iiwic3BsaXRQb3MiLCJjYW4iLCJsZW5ndGgiLCJmaXJzdCIsIiRmaXJzdCIsInNldE5vZGVNYXJrdXAiLCJzcGxpdEJsb2NrIiwic3BsaXRCbG9ja0tlZXBNYXJrcyIsIm1hcmtzIiwic3RvcmVkTWFya3MiLCJlbnN1cmVNYXJrcyIsInNlbGVjdFBhcmVudE5vZGUiLCJzYW1lIiwic2hhcmVkRGVwdGgiLCJzZWxlY3RBbGwiLCJqb2luTWF5YmVDbGVhciIsImNvbXBhdGlibGVDb250ZW50IiwiY2FuUmVwbGFjZSIsImRpciIsImNvbm4iLCJpc29sYXRlZCIsImNhbkRlbEFmdGVyIiwibWF0Y2hUeXBlIiwidmFsaWRFbmQiLCJ3cmFwIiwiY29weSIsIiRqb2luQXQiLCJzZWxBZnRlciIsImF0IiwicHVzaCIsImFmdGVyRGVwdGgiLCJzZWxlY3RUZXh0YmxvY2tTaWRlIiwiaXNJbmxpbmUiLCJzZWxlY3RUZXh0YmxvY2tTdGFydCIsInNlbGVjdFRleHRibG9ja0VuZCIsIndyYXBJbiIsIm5vZGVUeXBlIiwiYXR0cnMiLCJ3cmFwcGluZyIsInNldEJsb2NrVHlwZSIsImFwcGxpY2FibGUiLCJyYW5nZXMiLCJub2Rlc0JldHdlZW4iLCJoYXNNYXJrdXAiLCJtYXJrQXBwbGllcyIsImVudGVyQXRvbXMiLCJhbGxvd3NNYXJrVHlwZSIsInJlbW92ZUlubGluZUF0b21zIiwicmVzdWx0IiwidG9nZ2xlTWFyayIsIm1hcmtUeXBlIiwib3B0aW9ucyIsInJlbW92ZVdoZW5QcmVzZW50IiwiZW50ZXJJbmxpbmVBdG9tcyIsImRyb3BTcGFjZSIsImluY2x1ZGVXaGl0ZXNwYWNlIiwiaXNJblNldCIsInJlbW92ZVN0b3JlZE1hcmsiLCJhZGRTdG9yZWRNYXJrIiwiYWRkIiwic29tZSIsInIiLCJyYW5nZUhhc01hcmsiLCJldmVyeSIsIm1pc3NpbmciLCJpc1RleHQiLCJ0ZXN0IiwidGV4dEJldHdlZW4iLCJNYXRoIiwibWF4IiwibWluIiwicmVtb3ZlTWFyayIsInNwYWNlU3RhcnQiLCJleGVjIiwidGV4dCIsInNwYWNlRW5kIiwiYWRkTWFyayIsIndyYXBEaXNwYXRjaEZvckpvaW4iLCJpc0pvaW5hYmxlIiwiaXNHZW5lcmljIiwibWFwcyIsImoiLCJmb3JFYWNoIiwiX3MiLCJfZSIsImpvaW5hYmxlIiwibWF5YmVDaGlsZCIsImluZGV4T2YiLCJzb3J0IiwiYSIsImIiLCJhdXRvSm9pbiIsImNvbW1hbmQiLCJBcnJheSIsImlzQXJyYXkiLCJuYW1lIiwiY2hhaW5Db21tYW5kcyIsImNvbW1hbmRzIiwiYmFja3NwYWNlIiwiZGVsIiwicGNCYXNlS2V5bWFwIiwibWFjQmFzZUtleW1hcCIsImtleSIsIm1hYyIsIm5hdmlnYXRvciIsInBsYXRmb3JtIiwib3MiLCJiYXNlS2V5bWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-commands/dist/index.js\n");

/***/ })

};
;