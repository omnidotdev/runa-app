"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tippy.js";
exports.ids = ["vendor-chunks/tippy.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/tippy.js/dist/tippy.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tippy.js/dist/tippy.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   animateFill: () => (/* binding */ animateFill),\n/* harmony export */   createSingleton: () => (/* binding */ createSingleton),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   delegate: () => (/* binding */ delegate),\n/* harmony export */   followCursor: () => (/* binding */ followCursor),\n/* harmony export */   hideAll: () => (/* binding */ hideAll),\n/* harmony export */   inlinePositioning: () => (/* binding */ inlinePositioning),\n/* harmony export */   roundArrow: () => (/* binding */ ROUND_ARROW),\n/* harmony export */   sticky: () => (/* binding */ sticky)\n/* harmony export */ });\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ \"(ssr)/./node_modules/@popperjs/core/lib/popper.js\");\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popperjs/core */ \"(ssr)/./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\");\n/**!\n* tippy.js v6.3.7\n* (c) 2017-2021 atomiks\n* MIT License\n*/ \nvar ROUND_ARROW = '<svg width=\"16\" height=\"6\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z\"></svg>';\nvar BOX_CLASS = \"tippy-box\";\nvar CONTENT_CLASS = \"tippy-content\";\nvar BACKDROP_CLASS = \"tippy-backdrop\";\nvar ARROW_CLASS = \"tippy-arrow\";\nvar SVG_ARROW_CLASS = \"tippy-svg-arrow\";\nvar TOUCH_OPTIONS = {\n    passive: true,\n    capture: true\n};\nvar TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {\n    return document.body;\n};\nfunction hasOwnProperty(obj, key) {\n    return ({}).hasOwnProperty.call(obj, key);\n}\nfunction getValueAtIndexOrReturn(value, index, defaultValue) {\n    if (Array.isArray(value)) {\n        var v = value[index];\n        return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;\n    }\n    return value;\n}\nfunction isType(value, type) {\n    var str = ({}).toString.call(value);\n    return str.indexOf(\"[object\") === 0 && str.indexOf(type + \"]\") > -1;\n}\nfunction invokeWithArgsOrReturn(value, args) {\n    return typeof value === \"function\" ? value.apply(void 0, args) : value;\n}\nfunction debounce(fn, ms) {\n    // Avoid wrapping in `setTimeout` if ms is 0 anyway\n    if (ms === 0) {\n        return fn;\n    }\n    var timeout;\n    return function(arg) {\n        clearTimeout(timeout);\n        timeout = setTimeout(function() {\n            fn(arg);\n        }, ms);\n    };\n}\nfunction removeProperties(obj, keys) {\n    var clone = Object.assign({}, obj);\n    keys.forEach(function(key) {\n        delete clone[key];\n    });\n    return clone;\n}\nfunction splitBySpaces(value) {\n    return value.split(/\\s+/).filter(Boolean);\n}\nfunction normalizeToArray(value) {\n    return [].concat(value);\n}\nfunction pushIfUnique(arr, value) {\n    if (arr.indexOf(value) === -1) {\n        arr.push(value);\n    }\n}\nfunction unique(arr) {\n    return arr.filter(function(item, index) {\n        return arr.indexOf(item) === index;\n    });\n}\nfunction getBasePlacement(placement) {\n    return placement.split(\"-\")[0];\n}\nfunction arrayFrom(value) {\n    return [].slice.call(value);\n}\nfunction removeUndefinedProps(obj) {\n    return Object.keys(obj).reduce(function(acc, key) {\n        if (obj[key] !== undefined) {\n            acc[key] = obj[key];\n        }\n        return acc;\n    }, {});\n}\nfunction div() {\n    return document.createElement(\"div\");\n}\nfunction isElement(value) {\n    return [\n        \"Element\",\n        \"Fragment\"\n    ].some(function(type) {\n        return isType(value, type);\n    });\n}\nfunction isNodeList(value) {\n    return isType(value, \"NodeList\");\n}\nfunction isMouseEvent(value) {\n    return isType(value, \"MouseEvent\");\n}\nfunction isReferenceElement(value) {\n    return !!(value && value._tippy && value._tippy.reference === value);\n}\nfunction getArrayOfElements(value) {\n    if (isElement(value)) {\n        return [\n            value\n        ];\n    }\n    if (isNodeList(value)) {\n        return arrayFrom(value);\n    }\n    if (Array.isArray(value)) {\n        return value;\n    }\n    return arrayFrom(document.querySelectorAll(value));\n}\nfunction setTransitionDuration(els, value) {\n    els.forEach(function(el) {\n        if (el) {\n            el.style.transitionDuration = value + \"ms\";\n        }\n    });\n}\nfunction setVisibilityState(els, state) {\n    els.forEach(function(el) {\n        if (el) {\n            el.setAttribute(\"data-state\", state);\n        }\n    });\n}\nfunction getOwnerDocument(elementOrElements) {\n    var _element$ownerDocumen;\n    var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body\n    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;\n}\nfunction isCursorOutsideInteractiveBorder(popperTreeData, event) {\n    var clientX = event.clientX, clientY = event.clientY;\n    return popperTreeData.every(function(_ref) {\n        var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;\n        var interactiveBorder = props.interactiveBorder;\n        var basePlacement = getBasePlacement(popperState.placement);\n        var offsetData = popperState.modifiersData.offset;\n        if (!offsetData) {\n            return true;\n        }\n        var topDistance = basePlacement === \"bottom\" ? offsetData.top.y : 0;\n        var bottomDistance = basePlacement === \"top\" ? offsetData.bottom.y : 0;\n        var leftDistance = basePlacement === \"right\" ? offsetData.left.x : 0;\n        var rightDistance = basePlacement === \"left\" ? offsetData.right.x : 0;\n        var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;\n        var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;\n        var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;\n        var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;\n        return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;\n    });\n}\nfunction updateTransitionEndListener(box, action, listener) {\n    var method = action + \"EventListener\"; // some browsers apparently support `transition` (unprefixed) but only fire\n    // `webkitTransitionEnd`...\n    [\n        \"transitionend\",\n        \"webkitTransitionEnd\"\n    ].forEach(function(event) {\n        box[method](event, listener);\n    });\n}\n/**\n * Compared to xxx.contains, this function works for dom structures with shadow\n * dom\n */ function actualContains(parent, child) {\n    var target = child;\n    while(target){\n        var _target$getRootNode;\n        if (parent.contains(target)) {\n            return true;\n        }\n        target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;\n    }\n    return false;\n}\nvar currentInput = {\n    isTouch: false\n};\nvar lastMouseMoveTime = 0;\n/**\n * When a `touchstart` event is fired, it's assumed the user is using touch\n * input. We'll bind a `mousemove` event listener to listen for mouse input in\n * the future. This way, the `isTouch` property is fully dynamic and will handle\n * hybrid devices that use a mix of touch + mouse input.\n */ function onDocumentTouchStart() {\n    if (currentInput.isTouch) {\n        return;\n    }\n    currentInput.isTouch = true;\n    if (window.performance) {\n        document.addEventListener(\"mousemove\", onDocumentMouseMove);\n    }\n}\n/**\n * When two `mousemove` event are fired consecutively within 20ms, it's assumed\n * the user is using mouse input again. `mousemove` can fire on touch devices as\n * well, but very rarely that quickly.\n */ function onDocumentMouseMove() {\n    var now = performance.now();\n    if (now - lastMouseMoveTime < 20) {\n        currentInput.isTouch = false;\n        document.removeEventListener(\"mousemove\", onDocumentMouseMove);\n    }\n    lastMouseMoveTime = now;\n}\n/**\n * When an element is in focus and has a tippy, leaving the tab/window and\n * returning causes it to show again. For mouse users this is unexpected, but\n * for keyboard use it makes sense.\n * TODO: find a better technique to solve this problem\n */ function onWindowBlur() {\n    var activeElement = document.activeElement;\n    if (isReferenceElement(activeElement)) {\n        var instance = activeElement._tippy;\n        if (activeElement.blur && !instance.state.isVisible) {\n            activeElement.blur();\n        }\n    }\n}\nfunction bindGlobalEventListeners() {\n    document.addEventListener(\"touchstart\", onDocumentTouchStart, TOUCH_OPTIONS);\n    window.addEventListener(\"blur\", onWindowBlur);\n}\nvar isBrowser =  false && 0;\nvar isIE11 = isBrowser ? !!window.msCrypto : false;\nfunction createMemoryLeakWarning(method) {\n    var txt = method === \"destroy\" ? \"n already-\" : \" \";\n    return [\n        method + \"() was called on a\" + txt + \"destroyed instance. This is a no-op but\",\n        \"indicates a potential memory leak.\"\n    ].join(\" \");\n}\nfunction clean(value) {\n    var spacesAndTabs = /[ \\t]{2,}/g;\n    var lineStartWithSpaces = /^[ \\t]*/gm;\n    return value.replace(spacesAndTabs, \" \").replace(lineStartWithSpaces, \"\").trim();\n}\nfunction getDevMessage(message) {\n    return clean(\"\\n  %ctippy.js\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\uD83D\\uDC77â€ This is a development-only message. It will be removed in production.\\n  \");\n}\nfunction getFormattedMessage(message) {\n    return [\n        getDevMessage(message),\n        \"color: #00C584; font-size: 1.3em; font-weight: bold;\",\n        \"line-height: 1.5\",\n        \"color: #a6a095;\"\n    ];\n} // Assume warnings and errors never have the same message\nvar visitedMessages;\nif (true) {\n    resetVisitedMessages();\n}\nfunction resetVisitedMessages() {\n    visitedMessages = new Set();\n}\nfunction warnWhen(condition, message) {\n    if (condition && !visitedMessages.has(message)) {\n        var _console;\n        visitedMessages.add(message);\n        (_console = console).warn.apply(_console, getFormattedMessage(message));\n    }\n}\nfunction errorWhen(condition, message) {\n    if (condition && !visitedMessages.has(message)) {\n        var _console2;\n        visitedMessages.add(message);\n        (_console2 = console).error.apply(_console2, getFormattedMessage(message));\n    }\n}\nfunction validateTargets(targets) {\n    var didPassFalsyValue = !targets;\n    var didPassPlainObject = Object.prototype.toString.call(targets) === \"[object Object]\" && !targets.addEventListener;\n    errorWhen(didPassFalsyValue, [\n        \"tippy() was passed\",\n        \"`\" + String(targets) + \"`\",\n        \"as its targets (first) argument. Valid types are: String, Element,\",\n        \"Element[], or NodeList.\"\n    ].join(\" \"));\n    errorWhen(didPassPlainObject, [\n        \"tippy() was passed a plain object which is not supported as an argument\",\n        \"for virtual positioning. Use props.getReferenceClientRect instead.\"\n    ].join(\" \"));\n}\nvar pluginProps = {\n    animateFill: false,\n    followCursor: false,\n    inlinePositioning: false,\n    sticky: false\n};\nvar renderProps = {\n    allowHTML: false,\n    animation: \"fade\",\n    arrow: true,\n    content: \"\",\n    inertia: false,\n    maxWidth: 350,\n    role: \"tooltip\",\n    theme: \"\",\n    zIndex: 9999\n};\nvar defaultProps = Object.assign({\n    appendTo: TIPPY_DEFAULT_APPEND_TO,\n    aria: {\n        content: \"auto\",\n        expanded: \"auto\"\n    },\n    delay: 0,\n    duration: [\n        300,\n        250\n    ],\n    getReferenceClientRect: null,\n    hideOnClick: true,\n    ignoreAttributes: false,\n    interactive: false,\n    interactiveBorder: 2,\n    interactiveDebounce: 0,\n    moveTransition: \"\",\n    offset: [\n        0,\n        10\n    ],\n    onAfterUpdate: function onAfterUpdate() {},\n    onBeforeUpdate: function onBeforeUpdate() {},\n    onCreate: function onCreate() {},\n    onDestroy: function onDestroy() {},\n    onHidden: function onHidden() {},\n    onHide: function onHide() {},\n    onMount: function onMount() {},\n    onShow: function onShow() {},\n    onShown: function onShown() {},\n    onTrigger: function onTrigger() {},\n    onUntrigger: function onUntrigger() {},\n    onClickOutside: function onClickOutside() {},\n    placement: \"top\",\n    plugins: [],\n    popperOptions: {},\n    render: null,\n    showOnCreate: false,\n    touch: true,\n    trigger: \"mouseenter focus\",\n    triggerTarget: null\n}, pluginProps, renderProps);\nvar defaultKeys = Object.keys(defaultProps);\nvar setDefaultProps = function setDefaultProps(partialProps) {\n    /* istanbul ignore else */ if (true) {\n        validateProps(partialProps, []);\n    }\n    var keys = Object.keys(partialProps);\n    keys.forEach(function(key) {\n        defaultProps[key] = partialProps[key];\n    });\n};\nfunction getExtendedPassedProps(passedProps) {\n    var plugins = passedProps.plugins || [];\n    var pluginProps = plugins.reduce(function(acc, plugin) {\n        var name = plugin.name, defaultValue = plugin.defaultValue;\n        if (name) {\n            var _name;\n            acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;\n        }\n        return acc;\n    }, {});\n    return Object.assign({}, passedProps, pluginProps);\n}\nfunction getDataAttributeProps(reference, plugins) {\n    var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {\n        plugins: plugins\n    }))) : defaultKeys;\n    var props = propKeys.reduce(function(acc, key) {\n        var valueAsString = (reference.getAttribute(\"data-tippy-\" + key) || \"\").trim();\n        if (!valueAsString) {\n            return acc;\n        }\n        if (key === \"content\") {\n            acc[key] = valueAsString;\n        } else {\n            try {\n                acc[key] = JSON.parse(valueAsString);\n            } catch (e) {\n                acc[key] = valueAsString;\n            }\n        }\n        return acc;\n    }, {});\n    return props;\n}\nfunction evaluateProps(reference, props) {\n    var out = Object.assign({}, props, {\n        content: invokeWithArgsOrReturn(props.content, [\n            reference\n        ])\n    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));\n    out.aria = Object.assign({}, defaultProps.aria, out.aria);\n    out.aria = {\n        expanded: out.aria.expanded === \"auto\" ? props.interactive : out.aria.expanded,\n        content: out.aria.content === \"auto\" ? props.interactive ? null : \"describedby\" : out.aria.content\n    };\n    return out;\n}\nfunction validateProps(partialProps, plugins) {\n    if (partialProps === void 0) {\n        partialProps = {};\n    }\n    if (plugins === void 0) {\n        plugins = [];\n    }\n    var keys = Object.keys(partialProps);\n    keys.forEach(function(prop) {\n        var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));\n        var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`\n        if (didPassUnknownProp) {\n            didPassUnknownProp = plugins.filter(function(plugin) {\n                return plugin.name === prop;\n            }).length === 0;\n        }\n        warnWhen(didPassUnknownProp, [\n            \"`\" + prop + \"`\",\n            \"is not a valid prop. You may have spelled it incorrectly, or if it's\",\n            \"a plugin, forgot to pass it in an array as props.plugins.\",\n            \"\\n\\n\",\n            \"All props: https://atomiks.github.io/tippyjs/v6/all-props/\\n\",\n            \"Plugins: https://atomiks.github.io/tippyjs/v6/plugins/\"\n        ].join(\" \"));\n    });\n}\nvar innerHTML = function innerHTML() {\n    return \"innerHTML\";\n};\nfunction dangerouslySetInnerHTML(element, html) {\n    element[innerHTML()] = html;\n}\nfunction createArrowElement(value) {\n    var arrow = div();\n    if (value === true) {\n        arrow.className = ARROW_CLASS;\n    } else {\n        arrow.className = SVG_ARROW_CLASS;\n        if (isElement(value)) {\n            arrow.appendChild(value);\n        } else {\n            dangerouslySetInnerHTML(arrow, value);\n        }\n    }\n    return arrow;\n}\nfunction setContent(content, props) {\n    if (isElement(props.content)) {\n        dangerouslySetInnerHTML(content, \"\");\n        content.appendChild(props.content);\n    } else if (typeof props.content !== \"function\") {\n        if (props.allowHTML) {\n            dangerouslySetInnerHTML(content, props.content);\n        } else {\n            content.textContent = props.content;\n        }\n    }\n}\nfunction getChildren(popper) {\n    var box = popper.firstElementChild;\n    var boxChildren = arrayFrom(box.children);\n    return {\n        box: box,\n        content: boxChildren.find(function(node) {\n            return node.classList.contains(CONTENT_CLASS);\n        }),\n        arrow: boxChildren.find(function(node) {\n            return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);\n        }),\n        backdrop: boxChildren.find(function(node) {\n            return node.classList.contains(BACKDROP_CLASS);\n        })\n    };\n}\nfunction render(instance) {\n    var popper = div();\n    var box = div();\n    box.className = BOX_CLASS;\n    box.setAttribute(\"data-state\", \"hidden\");\n    box.setAttribute(\"tabindex\", \"-1\");\n    var content = div();\n    content.className = CONTENT_CLASS;\n    content.setAttribute(\"data-state\", \"hidden\");\n    setContent(content, instance.props);\n    popper.appendChild(box);\n    box.appendChild(content);\n    onUpdate(instance.props, instance.props);\n    function onUpdate(prevProps, nextProps) {\n        var _getChildren = getChildren(popper), box = _getChildren.box, content = _getChildren.content, arrow = _getChildren.arrow;\n        if (nextProps.theme) {\n            box.setAttribute(\"data-theme\", nextProps.theme);\n        } else {\n            box.removeAttribute(\"data-theme\");\n        }\n        if (typeof nextProps.animation === \"string\") {\n            box.setAttribute(\"data-animation\", nextProps.animation);\n        } else {\n            box.removeAttribute(\"data-animation\");\n        }\n        if (nextProps.inertia) {\n            box.setAttribute(\"data-inertia\", \"\");\n        } else {\n            box.removeAttribute(\"data-inertia\");\n        }\n        box.style.maxWidth = typeof nextProps.maxWidth === \"number\" ? nextProps.maxWidth + \"px\" : nextProps.maxWidth;\n        if (nextProps.role) {\n            box.setAttribute(\"role\", nextProps.role);\n        } else {\n            box.removeAttribute(\"role\");\n        }\n        if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {\n            setContent(content, instance.props);\n        }\n        if (nextProps.arrow) {\n            if (!arrow) {\n                box.appendChild(createArrowElement(nextProps.arrow));\n            } else if (prevProps.arrow !== nextProps.arrow) {\n                box.removeChild(arrow);\n                box.appendChild(createArrowElement(nextProps.arrow));\n            }\n        } else if (arrow) {\n            box.removeChild(arrow);\n        }\n    }\n    return {\n        popper: popper,\n        onUpdate: onUpdate\n    };\n} // Runtime check to identify if the render function is the default one; this\n// way we can apply default CSS transitions logic and it can be tree-shaken away\nrender.$$tippy = true;\nvar idCounter = 1;\nvar mouseMoveListeners = []; // Used by `hideAll()`\nvar mountedInstances = [];\nfunction createTippy(reference, passedProps) {\n    var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================\n    // ðŸ”’ Private members\n    // ===========================================================================\n    var showTimeout;\n    var hideTimeout;\n    var scheduleHideAnimationFrame;\n    var isVisibleFromClick = false;\n    var didHideDueToDocumentMouseDown = false;\n    var didTouchMove = false;\n    var ignoreOnFirstUpdate = false;\n    var lastTriggerEvent;\n    var currentTransitionEndListener;\n    var onFirstUpdate;\n    var listeners = [];\n    var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);\n    var currentTarget; // ===========================================================================\n    // ðŸ”‘ Public members\n    // ===========================================================================\n    var id = idCounter++;\n    var popperInstance = null;\n    var plugins = unique(props.plugins);\n    var state = {\n        // Is the instance currently enabled?\n        isEnabled: true,\n        // Is the tippy currently showing and not transitioning out?\n        isVisible: false,\n        // Has the instance been destroyed?\n        isDestroyed: false,\n        // Is the tippy currently mounted to the DOM?\n        isMounted: false,\n        // Has the tippy finished transitioning in?\n        isShown: false\n    };\n    var instance = {\n        // properties\n        id: id,\n        reference: reference,\n        popper: div(),\n        popperInstance: popperInstance,\n        props: props,\n        state: state,\n        plugins: plugins,\n        // methods\n        clearDelayTimeouts: clearDelayTimeouts,\n        setProps: setProps,\n        setContent: setContent,\n        show: show,\n        hide: hide,\n        hideWithInteractivity: hideWithInteractivity,\n        enable: enable,\n        disable: disable,\n        unmount: unmount,\n        destroy: destroy\n    }; // TODO: Investigate why this early return causes a TDZ error in the tests â€”\n    // it doesn't seem to happen in the browser\n    /* istanbul ignore if */ if (!props.render) {\n        if (true) {\n            errorWhen(true, \"render() function has not been supplied.\");\n        }\n        return instance;\n    } // ===========================================================================\n    // Initial mutations\n    // ===========================================================================\n    var _props$render = props.render(instance), popper = _props$render.popper, onUpdate = _props$render.onUpdate;\n    popper.setAttribute(\"data-tippy-root\", \"\");\n    popper.id = \"tippy-\" + instance.id;\n    instance.popper = popper;\n    reference._tippy = instance;\n    popper._tippy = instance;\n    var pluginsHooks = plugins.map(function(plugin) {\n        return plugin.fn(instance);\n    });\n    var hasAriaExpanded = reference.hasAttribute(\"aria-expanded\");\n    addListeners();\n    handleAriaExpandedAttribute();\n    handleStyles();\n    invokeHook(\"onCreate\", [\n        instance\n    ]);\n    if (props.showOnCreate) {\n        scheduleShow();\n    } // Prevent a tippy with a delay from hiding if the cursor left then returned\n    // before it started hiding\n    popper.addEventListener(\"mouseenter\", function() {\n        if (instance.props.interactive && instance.state.isVisible) {\n            instance.clearDelayTimeouts();\n        }\n    });\n    popper.addEventListener(\"mouseleave\", function() {\n        if (instance.props.interactive && instance.props.trigger.indexOf(\"mouseenter\") >= 0) {\n            getDocument().addEventListener(\"mousemove\", debouncedOnMouseMove);\n        }\n    });\n    return instance; // ===========================================================================\n    // ðŸ”’ Private methods\n    // ===========================================================================\n    function getNormalizedTouchSettings() {\n        var touch = instance.props.touch;\n        return Array.isArray(touch) ? touch : [\n            touch,\n            0\n        ];\n    }\n    function getIsCustomTouchBehavior() {\n        return getNormalizedTouchSettings()[0] === \"hold\";\n    }\n    function getIsDefaultRenderFn() {\n        var _instance$props$rende;\n        // @ts-ignore\n        return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);\n    }\n    function getCurrentTarget() {\n        return currentTarget || reference;\n    }\n    function getDocument() {\n        var parent = getCurrentTarget().parentNode;\n        return parent ? getOwnerDocument(parent) : document;\n    }\n    function getDefaultTemplateChildren() {\n        return getChildren(popper);\n    }\n    function getDelay(isShow) {\n        // For touch or keyboard input, force `0` delay for UX reasons\n        // Also if the instance is mounted but not visible (transitioning out),\n        // ignore delay\n        if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === \"focus\") {\n            return 0;\n        }\n        return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);\n    }\n    function handleStyles(fromHide) {\n        if (fromHide === void 0) {\n            fromHide = false;\n        }\n        popper.style.pointerEvents = instance.props.interactive && !fromHide ? \"\" : \"none\";\n        popper.style.zIndex = \"\" + instance.props.zIndex;\n    }\n    function invokeHook(hook, args, shouldInvokePropsHook) {\n        if (shouldInvokePropsHook === void 0) {\n            shouldInvokePropsHook = true;\n        }\n        pluginsHooks.forEach(function(pluginHooks) {\n            if (pluginHooks[hook]) {\n                pluginHooks[hook].apply(pluginHooks, args);\n            }\n        });\n        if (shouldInvokePropsHook) {\n            var _instance$props;\n            (_instance$props = instance.props)[hook].apply(_instance$props, args);\n        }\n    }\n    function handleAriaContentAttribute() {\n        var aria = instance.props.aria;\n        if (!aria.content) {\n            return;\n        }\n        var attr = \"aria-\" + aria.content;\n        var id = popper.id;\n        var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n        nodes.forEach(function(node) {\n            var currentValue = node.getAttribute(attr);\n            if (instance.state.isVisible) {\n                node.setAttribute(attr, currentValue ? currentValue + \" \" + id : id);\n            } else {\n                var nextValue = currentValue && currentValue.replace(id, \"\").trim();\n                if (nextValue) {\n                    node.setAttribute(attr, nextValue);\n                } else {\n                    node.removeAttribute(attr);\n                }\n            }\n        });\n    }\n    function handleAriaExpandedAttribute() {\n        if (hasAriaExpanded || !instance.props.aria.expanded) {\n            return;\n        }\n        var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n        nodes.forEach(function(node) {\n            if (instance.props.interactive) {\n                node.setAttribute(\"aria-expanded\", instance.state.isVisible && node === getCurrentTarget() ? \"true\" : \"false\");\n            } else {\n                node.removeAttribute(\"aria-expanded\");\n            }\n        });\n    }\n    function cleanupInteractiveMouseListeners() {\n        getDocument().removeEventListener(\"mousemove\", debouncedOnMouseMove);\n        mouseMoveListeners = mouseMoveListeners.filter(function(listener) {\n            return listener !== debouncedOnMouseMove;\n        });\n    }\n    function onDocumentPress(event) {\n        // Moved finger to scroll instead of an intentional tap outside\n        if (currentInput.isTouch) {\n            if (didTouchMove || event.type === \"mousedown\") {\n                return;\n            }\n        }\n        var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper\n        if (instance.props.interactive && actualContains(popper, actualTarget)) {\n            return;\n        } // Clicked on the event listeners target\n        if (normalizeToArray(instance.props.triggerTarget || reference).some(function(el) {\n            return actualContains(el, actualTarget);\n        })) {\n            if (currentInput.isTouch) {\n                return;\n            }\n            if (instance.state.isVisible && instance.props.trigger.indexOf(\"click\") >= 0) {\n                return;\n            }\n        } else {\n            invokeHook(\"onClickOutside\", [\n                instance,\n                event\n            ]);\n        }\n        if (instance.props.hideOnClick === true) {\n            instance.clearDelayTimeouts();\n            instance.hide(); // `mousedown` event is fired right before `focus` if pressing the\n            // currentTarget. This lets a tippy with `focus` trigger know that it\n            // should not show\n            didHideDueToDocumentMouseDown = true;\n            setTimeout(function() {\n                didHideDueToDocumentMouseDown = false;\n            }); // The listener gets added in `scheduleShow()`, but this may be hiding it\n            // before it shows, and hide()'s early bail-out behavior can prevent it\n            // from being cleaned up\n            if (!instance.state.isMounted) {\n                removeDocumentPress();\n            }\n        }\n    }\n    function onTouchMove() {\n        didTouchMove = true;\n    }\n    function onTouchStart() {\n        didTouchMove = false;\n    }\n    function addDocumentPress() {\n        var doc = getDocument();\n        doc.addEventListener(\"mousedown\", onDocumentPress, true);\n        doc.addEventListener(\"touchend\", onDocumentPress, TOUCH_OPTIONS);\n        doc.addEventListener(\"touchstart\", onTouchStart, TOUCH_OPTIONS);\n        doc.addEventListener(\"touchmove\", onTouchMove, TOUCH_OPTIONS);\n    }\n    function removeDocumentPress() {\n        var doc = getDocument();\n        doc.removeEventListener(\"mousedown\", onDocumentPress, true);\n        doc.removeEventListener(\"touchend\", onDocumentPress, TOUCH_OPTIONS);\n        doc.removeEventListener(\"touchstart\", onTouchStart, TOUCH_OPTIONS);\n        doc.removeEventListener(\"touchmove\", onTouchMove, TOUCH_OPTIONS);\n    }\n    function onTransitionedOut(duration, callback) {\n        onTransitionEnd(duration, function() {\n            if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {\n                callback();\n            }\n        });\n    }\n    function onTransitionedIn(duration, callback) {\n        onTransitionEnd(duration, callback);\n    }\n    function onTransitionEnd(duration, callback) {\n        var box = getDefaultTemplateChildren().box;\n        function listener(event) {\n            if (event.target === box) {\n                updateTransitionEndListener(box, \"remove\", listener);\n                callback();\n            }\n        } // Make callback synchronous if duration is 0\n        // `transitionend` won't fire otherwise\n        if (duration === 0) {\n            return callback();\n        }\n        updateTransitionEndListener(box, \"remove\", currentTransitionEndListener);\n        updateTransitionEndListener(box, \"add\", listener);\n        currentTransitionEndListener = listener;\n    }\n    function on(eventType, handler, options) {\n        if (options === void 0) {\n            options = false;\n        }\n        var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n        nodes.forEach(function(node) {\n            node.addEventListener(eventType, handler, options);\n            listeners.push({\n                node: node,\n                eventType: eventType,\n                handler: handler,\n                options: options\n            });\n        });\n    }\n    function addListeners() {\n        if (getIsCustomTouchBehavior()) {\n            on(\"touchstart\", onTrigger, {\n                passive: true\n            });\n            on(\"touchend\", onMouseLeave, {\n                passive: true\n            });\n        }\n        splitBySpaces(instance.props.trigger).forEach(function(eventType) {\n            if (eventType === \"manual\") {\n                return;\n            }\n            on(eventType, onTrigger);\n            switch(eventType){\n                case \"mouseenter\":\n                    on(\"mouseleave\", onMouseLeave);\n                    break;\n                case \"focus\":\n                    on(isIE11 ? \"focusout\" : \"blur\", onBlurOrFocusOut);\n                    break;\n                case \"focusin\":\n                    on(\"focusout\", onBlurOrFocusOut);\n                    break;\n            }\n        });\n    }\n    function removeListeners() {\n        listeners.forEach(function(_ref) {\n            var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;\n            node.removeEventListener(eventType, handler, options);\n        });\n        listeners = [];\n    }\n    function onTrigger(event) {\n        var _lastTriggerEvent;\n        var shouldScheduleClickHide = false;\n        if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {\n            return;\n        }\n        var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === \"focus\";\n        lastTriggerEvent = event;\n        currentTarget = event.currentTarget;\n        handleAriaExpandedAttribute();\n        if (!instance.state.isVisible && isMouseEvent(event)) {\n            // If scrolling, `mouseenter` events can be fired if the cursor lands\n            // over a new target, but `mousemove` events don't get fired. This\n            // causes interactive tooltips to get stuck open until the cursor is\n            // moved\n            mouseMoveListeners.forEach(function(listener) {\n                return listener(event);\n            });\n        } // Toggle show/hide when clicking click-triggered tooltips\n        if (event.type === \"click\" && (instance.props.trigger.indexOf(\"mouseenter\") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {\n            shouldScheduleClickHide = true;\n        } else {\n            scheduleShow(event);\n        }\n        if (event.type === \"click\") {\n            isVisibleFromClick = !shouldScheduleClickHide;\n        }\n        if (shouldScheduleClickHide && !wasFocused) {\n            scheduleHide(event);\n        }\n    }\n    function onMouseMove(event) {\n        var target = event.target;\n        var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);\n        if (event.type === \"mousemove\" && isCursorOverReferenceOrPopper) {\n            return;\n        }\n        var popperTreeData = getNestedPopperTree().concat(popper).map(function(popper) {\n            var _instance$popperInsta;\n            var instance = popper._tippy;\n            var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;\n            if (state) {\n                return {\n                    popperRect: popper.getBoundingClientRect(),\n                    popperState: state,\n                    props: props\n                };\n            }\n            return null;\n        }).filter(Boolean);\n        if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {\n            cleanupInteractiveMouseListeners();\n            scheduleHide(event);\n        }\n    }\n    function onMouseLeave(event) {\n        var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf(\"click\") >= 0 && isVisibleFromClick;\n        if (shouldBail) {\n            return;\n        }\n        if (instance.props.interactive) {\n            instance.hideWithInteractivity(event);\n            return;\n        }\n        scheduleHide(event);\n    }\n    function onBlurOrFocusOut(event) {\n        if (instance.props.trigger.indexOf(\"focusin\") < 0 && event.target !== getCurrentTarget()) {\n            return;\n        } // If focus was moved to within the popper\n        if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {\n            return;\n        }\n        scheduleHide(event);\n    }\n    function isEventListenerStopped(event) {\n        return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf(\"touch\") >= 0 : false;\n    }\n    function createPopperInstance() {\n        destroyPopperInstance();\n        var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;\n        var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;\n        var computedReference = getReferenceClientRect ? {\n            getBoundingClientRect: getReferenceClientRect,\n            contextElement: getReferenceClientRect.contextElement || getCurrentTarget()\n        } : reference;\n        var tippyModifier = {\n            name: \"$$tippy\",\n            enabled: true,\n            phase: \"beforeWrite\",\n            requires: [\n                \"computeStyles\"\n            ],\n            fn: function fn(_ref2) {\n                var state = _ref2.state;\n                if (getIsDefaultRenderFn()) {\n                    var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;\n                    [\n                        \"placement\",\n                        \"reference-hidden\",\n                        \"escaped\"\n                    ].forEach(function(attr) {\n                        if (attr === \"placement\") {\n                            box.setAttribute(\"data-placement\", state.placement);\n                        } else {\n                            if (state.attributes.popper[\"data-popper-\" + attr]) {\n                                box.setAttribute(\"data-\" + attr, \"\");\n                            } else {\n                                box.removeAttribute(\"data-\" + attr);\n                            }\n                        }\n                    });\n                    state.attributes.popper = {};\n                }\n            }\n        };\n        var modifiers = [\n            {\n                name: \"offset\",\n                options: {\n                    offset: offset\n                }\n            },\n            {\n                name: \"preventOverflow\",\n                options: {\n                    padding: {\n                        top: 2,\n                        bottom: 2,\n                        left: 5,\n                        right: 5\n                    }\n                }\n            },\n            {\n                name: \"flip\",\n                options: {\n                    padding: 5\n                }\n            },\n            {\n                name: \"computeStyles\",\n                options: {\n                    adaptive: !moveTransition\n                }\n            },\n            tippyModifier\n        ];\n        if (getIsDefaultRenderFn() && arrow) {\n            modifiers.push({\n                name: \"arrow\",\n                options: {\n                    element: arrow,\n                    padding: 3\n                }\n            });\n        }\n        modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);\n        instance.popperInstance = (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_0__.createPopper)(computedReference, popper, Object.assign({}, popperOptions, {\n            placement: placement,\n            onFirstUpdate: onFirstUpdate,\n            modifiers: modifiers\n        }));\n    }\n    function destroyPopperInstance() {\n        if (instance.popperInstance) {\n            instance.popperInstance.destroy();\n            instance.popperInstance = null;\n        }\n    }\n    function mount() {\n        var appendTo = instance.props.appendTo;\n        var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so\n        // it's directly after the reference element so the elements inside the\n        // tippy can be tabbed to\n        // If there are clipping issues, the user can specify a different appendTo\n        // and ensure focus management is handled correctly manually\n        var node = getCurrentTarget();\n        if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === \"parent\") {\n            parentNode = node.parentNode;\n        } else {\n            parentNode = invokeWithArgsOrReturn(appendTo, [\n                node\n            ]);\n        } // The popper element needs to exist on the DOM before its position can be\n        // updated as Popper needs to read its dimensions\n        if (!parentNode.contains(popper)) {\n            parentNode.appendChild(popper);\n        }\n        instance.state.isMounted = true;\n        createPopperInstance();\n        /* istanbul ignore else */ if (true) {\n            // Accessibility check\n            warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, [\n                \"Interactive tippy element may not be accessible via keyboard\",\n                \"navigation because it is not directly after the reference element\",\n                \"in the DOM source order.\",\n                \"\\n\\n\",\n                \"Using a wrapper <div> or <span> tag around the reference element\",\n                \"solves this by creating a new parentNode context.\",\n                \"\\n\\n\",\n                \"Specifying `appendTo: document.body` silences this warning, but it\",\n                \"assumes you are using a focus management solution to handle\",\n                \"keyboard navigation.\",\n                \"\\n\\n\",\n                \"See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity\"\n            ].join(\" \"));\n        }\n    }\n    function getNestedPopperTree() {\n        return arrayFrom(popper.querySelectorAll(\"[data-tippy-root]\"));\n    }\n    function scheduleShow(event) {\n        instance.clearDelayTimeouts();\n        if (event) {\n            invokeHook(\"onTrigger\", [\n                instance,\n                event\n            ]);\n        }\n        addDocumentPress();\n        var delay = getDelay(true);\n        var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];\n        if (currentInput.isTouch && touchValue === \"hold\" && touchDelay) {\n            delay = touchDelay;\n        }\n        if (delay) {\n            showTimeout = setTimeout(function() {\n                instance.show();\n            }, delay);\n        } else {\n            instance.show();\n        }\n    }\n    function scheduleHide(event) {\n        instance.clearDelayTimeouts();\n        invokeHook(\"onUntrigger\", [\n            instance,\n            event\n        ]);\n        if (!instance.state.isVisible) {\n            removeDocumentPress();\n            return;\n        } // For interactive tippies, scheduleHide is added to a document.body handler\n        // from onMouseLeave so must intercept scheduled hides from mousemove/leave\n        // events when trigger contains mouseenter and click, and the tip is\n        // currently shown as a result of a click.\n        if (instance.props.trigger.indexOf(\"mouseenter\") >= 0 && instance.props.trigger.indexOf(\"click\") >= 0 && [\n            \"mouseleave\",\n            \"mousemove\"\n        ].indexOf(event.type) >= 0 && isVisibleFromClick) {\n            return;\n        }\n        var delay = getDelay(false);\n        if (delay) {\n            hideTimeout = setTimeout(function() {\n                if (instance.state.isVisible) {\n                    instance.hide();\n                }\n            }, delay);\n        } else {\n            // Fixes a `transitionend` problem when it fires 1 frame too\n            // late sometimes, we don't want hide() to be called.\n            scheduleHideAnimationFrame = requestAnimationFrame(function() {\n                instance.hide();\n            });\n        }\n    } // ===========================================================================\n    // ðŸ”‘ Public methods\n    // ===========================================================================\n    function enable() {\n        instance.state.isEnabled = true;\n    }\n    function disable() {\n        // Disabling the instance should also hide it\n        // https://github.com/atomiks/tippy.js-react/issues/106\n        instance.hide();\n        instance.state.isEnabled = false;\n    }\n    function clearDelayTimeouts() {\n        clearTimeout(showTimeout);\n        clearTimeout(hideTimeout);\n        cancelAnimationFrame(scheduleHideAnimationFrame);\n    }\n    function setProps(partialProps) {\n        /* istanbul ignore else */ if (true) {\n            warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"setProps\"));\n        }\n        if (instance.state.isDestroyed) {\n            return;\n        }\n        invokeHook(\"onBeforeUpdate\", [\n            instance,\n            partialProps\n        ]);\n        removeListeners();\n        var prevProps = instance.props;\n        var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {\n            ignoreAttributes: true\n        }));\n        instance.props = nextProps;\n        addListeners();\n        if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {\n            cleanupInteractiveMouseListeners();\n            debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);\n        } // Ensure stale aria-expanded attributes are removed\n        if (prevProps.triggerTarget && !nextProps.triggerTarget) {\n            normalizeToArray(prevProps.triggerTarget).forEach(function(node) {\n                node.removeAttribute(\"aria-expanded\");\n            });\n        } else if (nextProps.triggerTarget) {\n            reference.removeAttribute(\"aria-expanded\");\n        }\n        handleAriaExpandedAttribute();\n        handleStyles();\n        if (onUpdate) {\n            onUpdate(prevProps, nextProps);\n        }\n        if (instance.popperInstance) {\n            createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,\n            // and the nested ones get re-rendered first.\n            // https://github.com/atomiks/tippyjs-react/issues/177\n            // TODO: find a cleaner / more efficient solution(!)\n            getNestedPopperTree().forEach(function(nestedPopper) {\n                // React (and other UI libs likely) requires a rAF wrapper as it flushes\n                // its work in one\n                requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);\n            });\n        }\n        invokeHook(\"onAfterUpdate\", [\n            instance,\n            partialProps\n        ]);\n    }\n    function setContent(content) {\n        instance.setProps({\n            content: content\n        });\n    }\n    function show() {\n        /* istanbul ignore else */ if (true) {\n            warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"show\"));\n        } // Early bail-out\n        var isAlreadyVisible = instance.state.isVisible;\n        var isDestroyed = instance.state.isDestroyed;\n        var isDisabled = !instance.state.isEnabled;\n        var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;\n        var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);\n        if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {\n            return;\n        } // Normalize `disabled` behavior across browsers.\n        // Firefox allows events on disabled elements, but Chrome doesn't.\n        // Using a wrapper element (i.e. <span>) is recommended.\n        if (getCurrentTarget().hasAttribute(\"disabled\")) {\n            return;\n        }\n        invokeHook(\"onShow\", [\n            instance\n        ], false);\n        if (instance.props.onShow(instance) === false) {\n            return;\n        }\n        instance.state.isVisible = true;\n        if (getIsDefaultRenderFn()) {\n            popper.style.visibility = \"visible\";\n        }\n        handleStyles();\n        addDocumentPress();\n        if (!instance.state.isMounted) {\n            popper.style.transition = \"none\";\n        } // If flipping to the opposite side after hiding at least once, the\n        // animation will use the wrong placement without resetting the duration\n        if (getIsDefaultRenderFn()) {\n            var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;\n            setTransitionDuration([\n                box,\n                content\n            ], 0);\n        }\n        onFirstUpdate = function onFirstUpdate() {\n            var _instance$popperInsta2;\n            if (!instance.state.isVisible || ignoreOnFirstUpdate) {\n                return;\n            }\n            ignoreOnFirstUpdate = true; // reflow\n            void popper.offsetHeight;\n            popper.style.transition = instance.props.moveTransition;\n            if (getIsDefaultRenderFn() && instance.props.animation) {\n                var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;\n                setTransitionDuration([\n                    _box,\n                    _content\n                ], duration);\n                setVisibilityState([\n                    _box,\n                    _content\n                ], \"visible\");\n            }\n            handleAriaContentAttribute();\n            handleAriaExpandedAttribute();\n            pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the\n            // popper has been positioned for the first time\n            (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();\n            invokeHook(\"onMount\", [\n                instance\n            ]);\n            if (instance.props.animation && getIsDefaultRenderFn()) {\n                onTransitionedIn(duration, function() {\n                    instance.state.isShown = true;\n                    invokeHook(\"onShown\", [\n                        instance\n                    ]);\n                });\n            }\n        };\n        mount();\n    }\n    function hide() {\n        /* istanbul ignore else */ if (true) {\n            warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"hide\"));\n        } // Early bail-out\n        var isAlreadyHidden = !instance.state.isVisible;\n        var isDestroyed = instance.state.isDestroyed;\n        var isDisabled = !instance.state.isEnabled;\n        var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);\n        if (isAlreadyHidden || isDestroyed || isDisabled) {\n            return;\n        }\n        invokeHook(\"onHide\", [\n            instance\n        ], false);\n        if (instance.props.onHide(instance) === false) {\n            return;\n        }\n        instance.state.isVisible = false;\n        instance.state.isShown = false;\n        ignoreOnFirstUpdate = false;\n        isVisibleFromClick = false;\n        if (getIsDefaultRenderFn()) {\n            popper.style.visibility = \"hidden\";\n        }\n        cleanupInteractiveMouseListeners();\n        removeDocumentPress();\n        handleStyles(true);\n        if (getIsDefaultRenderFn()) {\n            var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;\n            if (instance.props.animation) {\n                setTransitionDuration([\n                    box,\n                    content\n                ], duration);\n                setVisibilityState([\n                    box,\n                    content\n                ], \"hidden\");\n            }\n        }\n        handleAriaContentAttribute();\n        handleAriaExpandedAttribute();\n        if (instance.props.animation) {\n            if (getIsDefaultRenderFn()) {\n                onTransitionedOut(duration, instance.unmount);\n            }\n        } else {\n            instance.unmount();\n        }\n    }\n    function hideWithInteractivity(event) {\n        /* istanbul ignore else */ if (true) {\n            warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"hideWithInteractivity\"));\n        }\n        getDocument().addEventListener(\"mousemove\", debouncedOnMouseMove);\n        pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);\n        debouncedOnMouseMove(event);\n    }\n    function unmount() {\n        /* istanbul ignore else */ if (true) {\n            warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"unmount\"));\n        }\n        if (instance.state.isVisible) {\n            instance.hide();\n        }\n        if (!instance.state.isMounted) {\n            return;\n        }\n        destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper\n        // tree by default. This seems mainly for interactive tippies, but we should\n        // find a workaround if possible\n        getNestedPopperTree().forEach(function(nestedPopper) {\n            nestedPopper._tippy.unmount();\n        });\n        if (popper.parentNode) {\n            popper.parentNode.removeChild(popper);\n        }\n        mountedInstances = mountedInstances.filter(function(i) {\n            return i !== instance;\n        });\n        instance.state.isMounted = false;\n        invokeHook(\"onHidden\", [\n            instance\n        ]);\n    }\n    function destroy() {\n        /* istanbul ignore else */ if (true) {\n            warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"destroy\"));\n        }\n        if (instance.state.isDestroyed) {\n            return;\n        }\n        instance.clearDelayTimeouts();\n        instance.unmount();\n        removeListeners();\n        delete reference._tippy;\n        instance.state.isDestroyed = true;\n        invokeHook(\"onDestroy\", [\n            instance\n        ]);\n    }\n}\nfunction tippy(targets, optionalProps) {\n    if (optionalProps === void 0) {\n        optionalProps = {};\n    }\n    var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);\n    /* istanbul ignore else */ if (true) {\n        validateTargets(targets);\n        validateProps(optionalProps, plugins);\n    }\n    bindGlobalEventListeners();\n    var passedProps = Object.assign({}, optionalProps, {\n        plugins: plugins\n    });\n    var elements = getArrayOfElements(targets);\n    /* istanbul ignore else */ if (true) {\n        var isSingleContentElement = isElement(passedProps.content);\n        var isMoreThanOneReferenceElement = elements.length > 1;\n        warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, [\n            \"tippy() was passed an Element as the `content` prop, but more than\",\n            \"one tippy instance was created by this invocation. This means the\",\n            \"content element will only be appended to the last tippy instance.\",\n            \"\\n\\n\",\n            \"Instead, pass the .innerHTML of the element, or use a function that\",\n            \"returns a cloned version of the element instead.\",\n            \"\\n\\n\",\n            \"1) content: element.innerHTML\\n\",\n            \"2) content: () => element.cloneNode(true)\"\n        ].join(\" \"));\n    }\n    var instances = elements.reduce(function(acc, reference) {\n        var instance = reference && createTippy(reference, passedProps);\n        if (instance) {\n            acc.push(instance);\n        }\n        return acc;\n    }, []);\n    return isElement(targets) ? instances[0] : instances;\n}\ntippy.defaultProps = defaultProps;\ntippy.setDefaultProps = setDefaultProps;\ntippy.currentInput = currentInput;\nvar hideAll = function hideAll(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, excludedReferenceOrInstance = _ref.exclude, duration = _ref.duration;\n    mountedInstances.forEach(function(instance) {\n        var isExcluded = false;\n        if (excludedReferenceOrInstance) {\n            isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;\n        }\n        if (!isExcluded) {\n            var originalDuration = instance.props.duration;\n            instance.setProps({\n                duration: duration\n            });\n            instance.hide();\n            if (!instance.state.isDestroyed) {\n                instance.setProps({\n                    duration: originalDuration\n                });\n            }\n        }\n    });\n};\n// every time the popper is destroyed (i.e. a new target), removing the styles\n// and causing transitions to break for singletons when the console is open, but\n// most notably for non-transform styles being used, `gpuAcceleration: false`.\nvar applyStylesModifier = Object.assign({}, _popperjs_core__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n    effect: function effect(_ref) {\n        var state = _ref.state;\n        var initialStyles = {\n            popper: {\n                position: state.options.strategy,\n                left: \"0\",\n                top: \"0\",\n                margin: \"0\"\n            },\n            arrow: {\n                position: \"absolute\"\n            },\n            reference: {}\n        };\n        Object.assign(state.elements.popper.style, initialStyles.popper);\n        state.styles = initialStyles;\n        if (state.elements.arrow) {\n            Object.assign(state.elements.arrow.style, initialStyles.arrow);\n        } // intentionally return no cleanup function\n    // return () => { ... }\n    }\n});\nvar createSingleton = function createSingleton(tippyInstances, optionalProps) {\n    var _optionalProps$popper;\n    if (optionalProps === void 0) {\n        optionalProps = {};\n    }\n    /* istanbul ignore else */ if (true) {\n        errorWhen(!Array.isArray(tippyInstances), [\n            \"The first argument passed to createSingleton() must be an array of\",\n            \"tippy instances. The passed value was\",\n            String(tippyInstances)\n        ].join(\" \"));\n    }\n    var individualInstances = tippyInstances;\n    var references = [];\n    var triggerTargets = [];\n    var currentTarget;\n    var overrides = optionalProps.overrides;\n    var interceptSetPropsCleanups = [];\n    var shownOnCreate = false;\n    function setTriggerTargets() {\n        triggerTargets = individualInstances.map(function(instance) {\n            return normalizeToArray(instance.props.triggerTarget || instance.reference);\n        }).reduce(function(acc, item) {\n            return acc.concat(item);\n        }, []);\n    }\n    function setReferences() {\n        references = individualInstances.map(function(instance) {\n            return instance.reference;\n        });\n    }\n    function enableInstances(isEnabled) {\n        individualInstances.forEach(function(instance) {\n            if (isEnabled) {\n                instance.enable();\n            } else {\n                instance.disable();\n            }\n        });\n    }\n    function interceptSetProps(singleton) {\n        return individualInstances.map(function(instance) {\n            var originalSetProps = instance.setProps;\n            instance.setProps = function(props) {\n                originalSetProps(props);\n                if (instance.reference === currentTarget) {\n                    singleton.setProps(props);\n                }\n            };\n            return function() {\n                instance.setProps = originalSetProps;\n            };\n        });\n    } // have to pass singleton, as it maybe undefined on first call\n    function prepareInstance(singleton, target) {\n        var index = triggerTargets.indexOf(target); // bail-out\n        if (target === currentTarget) {\n            return;\n        }\n        currentTarget = target;\n        var overrideProps = (overrides || []).concat(\"content\").reduce(function(acc, prop) {\n            acc[prop] = individualInstances[index].props[prop];\n            return acc;\n        }, {});\n        singleton.setProps(Object.assign({}, overrideProps, {\n            getReferenceClientRect: typeof overrideProps.getReferenceClientRect === \"function\" ? overrideProps.getReferenceClientRect : function() {\n                var _references$index;\n                return (_references$index = references[index]) == null ? void 0 : _references$index.getBoundingClientRect();\n            }\n        }));\n    }\n    enableInstances(false);\n    setReferences();\n    setTriggerTargets();\n    var plugin = {\n        fn: function fn() {\n            return {\n                onDestroy: function onDestroy() {\n                    enableInstances(true);\n                },\n                onHidden: function onHidden() {\n                    currentTarget = null;\n                },\n                onClickOutside: function onClickOutside(instance) {\n                    if (instance.props.showOnCreate && !shownOnCreate) {\n                        shownOnCreate = true;\n                        currentTarget = null;\n                    }\n                },\n                onShow: function onShow(instance) {\n                    if (instance.props.showOnCreate && !shownOnCreate) {\n                        shownOnCreate = true;\n                        prepareInstance(instance, references[0]);\n                    }\n                },\n                onTrigger: function onTrigger(instance, event) {\n                    prepareInstance(instance, event.currentTarget);\n                }\n            };\n        }\n    };\n    var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, [\n        \"overrides\"\n    ]), {\n        plugins: [\n            plugin\n        ].concat(optionalProps.plugins || []),\n        triggerTarget: triggerTargets,\n        popperOptions: Object.assign({}, optionalProps.popperOptions, {\n            modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [\n                applyStylesModifier\n            ])\n        })\n    }));\n    var originalShow = singleton.show;\n    singleton.show = function(target) {\n        originalShow(); // first time, showOnCreate or programmatic call with no params\n        // default to showing first instance\n        if (!currentTarget && target == null) {\n            return prepareInstance(singleton, references[0]);\n        } // triggered from event (do nothing as prepareInstance already called by onTrigger)\n        // programmatic call with no params when already visible (do nothing again)\n        if (currentTarget && target == null) {\n            return;\n        } // target is index of instance\n        if (typeof target === \"number\") {\n            return references[target] && prepareInstance(singleton, references[target]);\n        } // target is a child tippy instance\n        if (individualInstances.indexOf(target) >= 0) {\n            var ref = target.reference;\n            return prepareInstance(singleton, ref);\n        } // target is a ReferenceElement\n        if (references.indexOf(target) >= 0) {\n            return prepareInstance(singleton, target);\n        }\n    };\n    singleton.showNext = function() {\n        var first = references[0];\n        if (!currentTarget) {\n            return singleton.show(0);\n        }\n        var index = references.indexOf(currentTarget);\n        singleton.show(references[index + 1] || first);\n    };\n    singleton.showPrevious = function() {\n        var last = references[references.length - 1];\n        if (!currentTarget) {\n            return singleton.show(last);\n        }\n        var index = references.indexOf(currentTarget);\n        var target = references[index - 1] || last;\n        singleton.show(target);\n    };\n    var originalSetProps = singleton.setProps;\n    singleton.setProps = function(props) {\n        overrides = props.overrides || overrides;\n        originalSetProps(props);\n    };\n    singleton.setInstances = function(nextInstances) {\n        enableInstances(true);\n        interceptSetPropsCleanups.forEach(function(fn) {\n            return fn();\n        });\n        individualInstances = nextInstances;\n        enableInstances(false);\n        setReferences();\n        setTriggerTargets();\n        interceptSetPropsCleanups = interceptSetProps(singleton);\n        singleton.setProps({\n            triggerTarget: triggerTargets\n        });\n    };\n    interceptSetPropsCleanups = interceptSetProps(singleton);\n    return singleton;\n};\nvar BUBBLING_EVENTS_MAP = {\n    mouseover: \"mouseenter\",\n    focusin: \"focus\",\n    click: \"click\"\n};\n/**\n * Creates a delegate instance that controls the creation of tippy instances\n * for child elements (`target` CSS selector).\n */ function delegate(targets, props) {\n    /* istanbul ignore else */ if (true) {\n        errorWhen(!(props && props.target), [\n            \"You must specity a `target` prop indicating a CSS selector string matching\",\n            \"the target elements that should receive a tippy.\"\n        ].join(\" \"));\n    }\n    var listeners = [];\n    var childTippyInstances = [];\n    var disabled = false;\n    var target = props.target;\n    var nativeProps = removeProperties(props, [\n        \"target\"\n    ]);\n    var parentProps = Object.assign({}, nativeProps, {\n        trigger: \"manual\",\n        touch: false\n    });\n    var childProps = Object.assign({\n        touch: defaultProps.touch\n    }, nativeProps, {\n        showOnCreate: true\n    });\n    var returnValue = tippy(targets, parentProps);\n    var normalizedReturnValue = normalizeToArray(returnValue);\n    function onTrigger(event) {\n        if (!event.target || disabled) {\n            return;\n        }\n        var targetNode = event.target.closest(target);\n        if (!targetNode) {\n            return;\n        } // Get relevant trigger with fallbacks:\n        // 1. Check `data-tippy-trigger` attribute on target node\n        // 2. Fallback to `trigger` passed to `delegate()`\n        // 3. Fallback to `defaultProps.trigger`\n        var trigger = targetNode.getAttribute(\"data-tippy-trigger\") || props.trigger || defaultProps.trigger; // @ts-ignore\n        if (targetNode._tippy) {\n            return;\n        }\n        if (event.type === \"touchstart\" && typeof childProps.touch === \"boolean\") {\n            return;\n        }\n        if (event.type !== \"touchstart\" && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) {\n            return;\n        }\n        var instance = tippy(targetNode, childProps);\n        if (instance) {\n            childTippyInstances = childTippyInstances.concat(instance);\n        }\n    }\n    function on(node, eventType, handler, options) {\n        if (options === void 0) {\n            options = false;\n        }\n        node.addEventListener(eventType, handler, options);\n        listeners.push({\n            node: node,\n            eventType: eventType,\n            handler: handler,\n            options: options\n        });\n    }\n    function addEventListeners(instance) {\n        var reference = instance.reference;\n        on(reference, \"touchstart\", onTrigger, TOUCH_OPTIONS);\n        on(reference, \"mouseover\", onTrigger);\n        on(reference, \"focusin\", onTrigger);\n        on(reference, \"click\", onTrigger);\n    }\n    function removeEventListeners() {\n        listeners.forEach(function(_ref) {\n            var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;\n            node.removeEventListener(eventType, handler, options);\n        });\n        listeners = [];\n    }\n    function applyMutations(instance) {\n        var originalDestroy = instance.destroy;\n        var originalEnable = instance.enable;\n        var originalDisable = instance.disable;\n        instance.destroy = function(shouldDestroyChildInstances) {\n            if (shouldDestroyChildInstances === void 0) {\n                shouldDestroyChildInstances = true;\n            }\n            if (shouldDestroyChildInstances) {\n                childTippyInstances.forEach(function(instance) {\n                    instance.destroy();\n                });\n            }\n            childTippyInstances = [];\n            removeEventListeners();\n            originalDestroy();\n        };\n        instance.enable = function() {\n            originalEnable();\n            childTippyInstances.forEach(function(instance) {\n                return instance.enable();\n            });\n            disabled = false;\n        };\n        instance.disable = function() {\n            originalDisable();\n            childTippyInstances.forEach(function(instance) {\n                return instance.disable();\n            });\n            disabled = true;\n        };\n        addEventListeners(instance);\n    }\n    normalizedReturnValue.forEach(applyMutations);\n    return returnValue;\n}\nvar animateFill = {\n    name: \"animateFill\",\n    defaultValue: false,\n    fn: function fn(instance) {\n        var _instance$props$rende;\n        // @ts-ignore\n        if (!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy)) {\n            if (true) {\n                errorWhen(instance.props.animateFill, \"The `animateFill` plugin requires the default render function.\");\n            }\n            return {};\n        }\n        var _getChildren = getChildren(instance.popper), box = _getChildren.box, content = _getChildren.content;\n        var backdrop = instance.props.animateFill ? createBackdropElement() : null;\n        return {\n            onCreate: function onCreate() {\n                if (backdrop) {\n                    box.insertBefore(backdrop, box.firstElementChild);\n                    box.setAttribute(\"data-animatefill\", \"\");\n                    box.style.overflow = \"hidden\";\n                    instance.setProps({\n                        arrow: false,\n                        animation: \"shift-away\"\n                    });\n                }\n            },\n            onMount: function onMount() {\n                if (backdrop) {\n                    var transitionDuration = box.style.transitionDuration;\n                    var duration = Number(transitionDuration.replace(\"ms\", \"\")); // The content should fade in after the backdrop has mostly filled the\n                    // tooltip element. `clip-path` is the other alternative but is not\n                    // well-supported and is buggy on some devices.\n                    content.style.transitionDelay = Math.round(duration / 10) + \"ms\";\n                    backdrop.style.transitionDuration = transitionDuration;\n                    setVisibilityState([\n                        backdrop\n                    ], \"visible\");\n                }\n            },\n            onShow: function onShow() {\n                if (backdrop) {\n                    backdrop.style.transitionDuration = \"0ms\";\n                }\n            },\n            onHide: function onHide() {\n                if (backdrop) {\n                    setVisibilityState([\n                        backdrop\n                    ], \"hidden\");\n                }\n            }\n        };\n    }\n};\nfunction createBackdropElement() {\n    var backdrop = div();\n    backdrop.className = BACKDROP_CLASS;\n    setVisibilityState([\n        backdrop\n    ], \"hidden\");\n    return backdrop;\n}\nvar mouseCoords = {\n    clientX: 0,\n    clientY: 0\n};\nvar activeInstances = [];\nfunction storeMouseCoords(_ref) {\n    var clientX = _ref.clientX, clientY = _ref.clientY;\n    mouseCoords = {\n        clientX: clientX,\n        clientY: clientY\n    };\n}\nfunction addMouseCoordsListener(doc) {\n    doc.addEventListener(\"mousemove\", storeMouseCoords);\n}\nfunction removeMouseCoordsListener(doc) {\n    doc.removeEventListener(\"mousemove\", storeMouseCoords);\n}\nvar followCursor = {\n    name: \"followCursor\",\n    defaultValue: false,\n    fn: function fn(instance) {\n        var reference = instance.reference;\n        var doc = getOwnerDocument(instance.props.triggerTarget || reference);\n        var isInternalUpdate = false;\n        var wasFocusEvent = false;\n        var isUnmounted = true;\n        var prevProps = instance.props;\n        function getIsInitialBehavior() {\n            return instance.props.followCursor === \"initial\" && instance.state.isVisible;\n        }\n        function addListener() {\n            doc.addEventListener(\"mousemove\", onMouseMove);\n        }\n        function removeListener() {\n            doc.removeEventListener(\"mousemove\", onMouseMove);\n        }\n        function unsetGetReferenceClientRect() {\n            isInternalUpdate = true;\n            instance.setProps({\n                getReferenceClientRect: null\n            });\n            isInternalUpdate = false;\n        }\n        function onMouseMove(event) {\n            // If the instance is interactive, avoid updating the position unless it's\n            // over the reference element\n            var isCursorOverReference = event.target ? reference.contains(event.target) : true;\n            var followCursor = instance.props.followCursor;\n            var clientX = event.clientX, clientY = event.clientY;\n            var rect = reference.getBoundingClientRect();\n            var relativeX = clientX - rect.left;\n            var relativeY = clientY - rect.top;\n            if (isCursorOverReference || !instance.props.interactive) {\n                instance.setProps({\n                    // @ts-ignore - unneeded DOMRect properties\n                    getReferenceClientRect: function getReferenceClientRect() {\n                        var rect = reference.getBoundingClientRect();\n                        var x = clientX;\n                        var y = clientY;\n                        if (followCursor === \"initial\") {\n                            x = rect.left + relativeX;\n                            y = rect.top + relativeY;\n                        }\n                        var top = followCursor === \"horizontal\" ? rect.top : y;\n                        var right = followCursor === \"vertical\" ? rect.right : x;\n                        var bottom = followCursor === \"horizontal\" ? rect.bottom : y;\n                        var left = followCursor === \"vertical\" ? rect.left : x;\n                        return {\n                            width: right - left,\n                            height: bottom - top,\n                            top: top,\n                            right: right,\n                            bottom: bottom,\n                            left: left\n                        };\n                    }\n                });\n            }\n        }\n        function create() {\n            if (instance.props.followCursor) {\n                activeInstances.push({\n                    instance: instance,\n                    doc: doc\n                });\n                addMouseCoordsListener(doc);\n            }\n        }\n        function destroy() {\n            activeInstances = activeInstances.filter(function(data) {\n                return data.instance !== instance;\n            });\n            if (activeInstances.filter(function(data) {\n                return data.doc === doc;\n            }).length === 0) {\n                removeMouseCoordsListener(doc);\n            }\n        }\n        return {\n            onCreate: create,\n            onDestroy: destroy,\n            onBeforeUpdate: function onBeforeUpdate() {\n                prevProps = instance.props;\n            },\n            onAfterUpdate: function onAfterUpdate(_, _ref2) {\n                var followCursor = _ref2.followCursor;\n                if (isInternalUpdate) {\n                    return;\n                }\n                if (followCursor !== undefined && prevProps.followCursor !== followCursor) {\n                    destroy();\n                    if (followCursor) {\n                        create();\n                        if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {\n                            addListener();\n                        }\n                    } else {\n                        removeListener();\n                        unsetGetReferenceClientRect();\n                    }\n                }\n            },\n            onMount: function onMount() {\n                if (instance.props.followCursor && !wasFocusEvent) {\n                    if (isUnmounted) {\n                        onMouseMove(mouseCoords);\n                        isUnmounted = false;\n                    }\n                    if (!getIsInitialBehavior()) {\n                        addListener();\n                    }\n                }\n            },\n            onTrigger: function onTrigger(_, event) {\n                if (isMouseEvent(event)) {\n                    mouseCoords = {\n                        clientX: event.clientX,\n                        clientY: event.clientY\n                    };\n                }\n                wasFocusEvent = event.type === \"focus\";\n            },\n            onHidden: function onHidden() {\n                if (instance.props.followCursor) {\n                    unsetGetReferenceClientRect();\n                    removeListener();\n                    isUnmounted = true;\n                }\n            }\n        };\n    }\n};\nfunction getProps(props, modifier) {\n    var _props$popperOptions;\n    return {\n        popperOptions: Object.assign({}, props.popperOptions, {\n            modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function(_ref) {\n                var name = _ref.name;\n                return name !== modifier.name;\n            }), [\n                modifier\n            ])\n        })\n    };\n}\nvar inlinePositioning = {\n    name: \"inlinePositioning\",\n    defaultValue: false,\n    fn: function fn(instance) {\n        var reference = instance.reference;\n        function isEnabled() {\n            return !!instance.props.inlinePositioning;\n        }\n        var placement;\n        var cursorRectIndex = -1;\n        var isInternalUpdate = false;\n        var triedPlacements = [];\n        var modifier = {\n            name: \"tippyInlinePositioning\",\n            enabled: true,\n            phase: \"afterWrite\",\n            fn: function fn(_ref2) {\n                var state = _ref2.state;\n                if (isEnabled()) {\n                    if (triedPlacements.indexOf(state.placement) !== -1) {\n                        triedPlacements = [];\n                    }\n                    if (placement !== state.placement && triedPlacements.indexOf(state.placement) === -1) {\n                        triedPlacements.push(state.placement);\n                        instance.setProps({\n                            // @ts-ignore - unneeded DOMRect properties\n                            getReferenceClientRect: function getReferenceClientRect() {\n                                return _getReferenceClientRect(state.placement);\n                            }\n                        });\n                    }\n                    placement = state.placement;\n                }\n            }\n        };\n        function _getReferenceClientRect(placement) {\n            return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);\n        }\n        function setInternalProps(partialProps) {\n            isInternalUpdate = true;\n            instance.setProps(partialProps);\n            isInternalUpdate = false;\n        }\n        function addModifier() {\n            if (!isInternalUpdate) {\n                setInternalProps(getProps(instance.props, modifier));\n            }\n        }\n        return {\n            onCreate: addModifier,\n            onAfterUpdate: addModifier,\n            onTrigger: function onTrigger(_, event) {\n                if (isMouseEvent(event)) {\n                    var rects = arrayFrom(instance.reference.getClientRects());\n                    var cursorRect = rects.find(function(rect) {\n                        return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;\n                    });\n                    var index = rects.indexOf(cursorRect);\n                    cursorRectIndex = index > -1 ? index : cursorRectIndex;\n                }\n            },\n            onHidden: function onHidden() {\n                cursorRectIndex = -1;\n            }\n        };\n    }\n};\nfunction getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {\n    // Not an inline element, or placement is not yet known\n    if (clientRects.length < 2 || currentBasePlacement === null) {\n        return boundingRect;\n    } // There are two rects and they are disjoined\n    if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {\n        return clientRects[cursorRectIndex] || boundingRect;\n    }\n    switch(currentBasePlacement){\n        case \"top\":\n        case \"bottom\":\n            {\n                var firstRect = clientRects[0];\n                var lastRect = clientRects[clientRects.length - 1];\n                var isTop = currentBasePlacement === \"top\";\n                var top = firstRect.top;\n                var bottom = lastRect.bottom;\n                var left = isTop ? firstRect.left : lastRect.left;\n                var right = isTop ? firstRect.right : lastRect.right;\n                var width = right - left;\n                var height = bottom - top;\n                return {\n                    top: top,\n                    bottom: bottom,\n                    left: left,\n                    right: right,\n                    width: width,\n                    height: height\n                };\n            }\n        case \"left\":\n        case \"right\":\n            {\n                var minLeft = Math.min.apply(Math, clientRects.map(function(rects) {\n                    return rects.left;\n                }));\n                var maxRight = Math.max.apply(Math, clientRects.map(function(rects) {\n                    return rects.right;\n                }));\n                var measureRects = clientRects.filter(function(rect) {\n                    return currentBasePlacement === \"left\" ? rect.left === minLeft : rect.right === maxRight;\n                });\n                var _top = measureRects[0].top;\n                var _bottom = measureRects[measureRects.length - 1].bottom;\n                var _left = minLeft;\n                var _right = maxRight;\n                var _width = _right - _left;\n                var _height = _bottom - _top;\n                return {\n                    top: _top,\n                    bottom: _bottom,\n                    left: _left,\n                    right: _right,\n                    width: _width,\n                    height: _height\n                };\n            }\n        default:\n            {\n                return boundingRect;\n            }\n    }\n}\nvar sticky = {\n    name: \"sticky\",\n    defaultValue: false,\n    fn: function fn(instance) {\n        var reference = instance.reference, popper = instance.popper;\n        function getReference() {\n            return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;\n        }\n        function shouldCheck(value) {\n            return instance.props.sticky === true || instance.props.sticky === value;\n        }\n        var prevRefRect = null;\n        var prevPopRect = null;\n        function updatePosition() {\n            var currentRefRect = shouldCheck(\"reference\") ? getReference().getBoundingClientRect() : null;\n            var currentPopRect = shouldCheck(\"popper\") ? popper.getBoundingClientRect() : null;\n            if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {\n                if (instance.popperInstance) {\n                    instance.popperInstance.update();\n                }\n            }\n            prevRefRect = currentRefRect;\n            prevPopRect = currentPopRect;\n            if (instance.state.isMounted) {\n                requestAnimationFrame(updatePosition);\n            }\n        }\n        return {\n            onMount: function onMount() {\n                if (instance.props.sticky) {\n                    updatePosition();\n                }\n            }\n        };\n    }\n};\nfunction areRectsDifferent(rectA, rectB) {\n    if (rectA && rectB) {\n        return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;\n    }\n    return true;\n}\ntippy.setDefaultProps({\n    render: render\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (tippy);\n //# sourceMappingURL=tippy.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvZGlzdC90aXBweS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUlBLEdBQzJEO0FBRTNELElBQUlFLGNBQWM7QUFDbEIsSUFBSUMsWUFBWTtBQUNoQixJQUFJQyxnQkFBZ0I7QUFDcEIsSUFBSUMsaUJBQWlCO0FBQ3JCLElBQUlDLGNBQWM7QUFDbEIsSUFBSUMsa0JBQWtCO0FBQ3RCLElBQUlDLGdCQUFnQjtJQUNsQkMsU0FBUztJQUNUQyxTQUFTO0FBQ1g7QUFDQSxJQUFJQywwQkFBMEIsU0FBU0E7SUFDckMsT0FBT0MsU0FBU0MsSUFBSTtBQUN0QjtBQUVBLFNBQVNDLGVBQWVDLEdBQUcsRUFBRUMsR0FBRztJQUM5QixPQUFPLEVBQUMsR0FBRUYsY0FBYyxDQUFDRyxJQUFJLENBQUNGLEtBQUtDO0FBQ3JDO0FBQ0EsU0FBU0Usd0JBQXdCQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsWUFBWTtJQUN6RCxJQUFJQyxNQUFNQyxPQUFPLENBQUNKLFFBQVE7UUFDeEIsSUFBSUssSUFBSUwsS0FBSyxDQUFDQyxNQUFNO1FBQ3BCLE9BQU9JLEtBQUssT0FBT0YsTUFBTUMsT0FBTyxDQUFDRixnQkFBZ0JBLFlBQVksQ0FBQ0QsTUFBTSxHQUFHQyxlQUFlRztJQUN4RjtJQUVBLE9BQU9MO0FBQ1Q7QUFDQSxTQUFTTSxPQUFPTixLQUFLLEVBQUVPLElBQUk7SUFDekIsSUFBSUMsTUFBTSxFQUFDLEdBQUVDLFFBQVEsQ0FBQ1gsSUFBSSxDQUFDRTtJQUMzQixPQUFPUSxJQUFJRSxPQUFPLENBQUMsZUFBZSxLQUFLRixJQUFJRSxPQUFPLENBQUNILE9BQU8sT0FBTyxDQUFDO0FBQ3BFO0FBQ0EsU0FBU0ksdUJBQXVCWCxLQUFLLEVBQUVZLElBQUk7SUFDekMsT0FBTyxPQUFPWixVQUFVLGFBQWFBLE1BQU1hLEtBQUssQ0FBQyxLQUFLLEdBQUdELFFBQVFaO0FBQ25FO0FBQ0EsU0FBU2MsU0FB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QUFNNWEsSUFBSSxLQUFLNmEsTUFBTTdhLElBQUk7SUFDN0g7SUFFQSxPQUFPO0FBQ1Q7QUFFQXdTLE1BQU1sTCxlQUFlLENBQUM7SUFDcEJOLFFBQVFBO0FBQ1Y7QUFFQSxpRUFBZXdMLEtBQUtBLEVBQUM7QUFDMEcsQ0FDL0gscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy90aXBweS5qcy9kaXN0L3RpcHB5LmVzbS5qcz8xY2IyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiFcbiogdGlwcHkuanMgdjYuMy43XG4qIChjKSAyMDE3LTIwMjEgYXRvbWlrc1xuKiBNSVQgTGljZW5zZVxuKi9cbmltcG9ydCB7IGNyZWF0ZVBvcHBlciwgYXBwbHlTdHlsZXMgfSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5cbnZhciBST1VORF9BUlJPVyA9ICc8c3ZnIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMCA2czEuNzk2LS4wMTMgNC42Ny0zLjYxNUM1Ljg1MS45IDYuOTMuMDA2IDggMGMxLjA3LS4wMDYgMi4xNDguODg3IDMuMzQzIDIuMzg1QzE0LjIzMyA2LjAwNSAxNiA2IDE2IDZIMHpcIj48L3N2Zz4nO1xudmFyIEJPWF9DTEFTUyA9IFwidGlwcHktYm94XCI7XG52YXIgQ09OVEVOVF9DTEFTUyA9IFwidGlwcHktY29udGVudFwiO1xudmFyIEJBQ0tEUk9QX0NMQVNTID0gXCJ0aXBweS1iYWNrZHJvcFwiO1xudmFyIEFSUk9XX0NMQVNTID0gXCJ0aXBweS1hcnJvd1wiO1xudmFyIFNWR19BUlJPV19DTEFTUyA9IFwidGlwcHktc3ZnLWFycm93XCI7XG52YXIgVE9VQ0hfT1BUSU9OUyA9IHtcbiAgcGFzc2l2ZTogdHJ1ZSxcbiAgY2FwdHVyZTogdHJ1ZVxufTtcbnZhciBUSVBQWV9ERUZBVUxUX0FQUEVORF9UTyA9IGZ1bmN0aW9uIFRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPKCkge1xuICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwga2V5KSB7XG4gIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKHZhbHVlLCBpbmRleCwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciB2ID0gdmFsdWVbaW5kZXhdO1xuICAgIHJldHVybiB2ID09IG51bGwgPyBBcnJheS5pc0FycmF5KGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWVbaW5kZXhdIDogZGVmYXVsdFZhbHVlIDogdjtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzVHlwZSh2YWx1ZSwgdHlwZSkge1xuICB2YXIgc3RyID0ge30udG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIHJldHVybiBzdHIuaW5kZXhPZignW29iamVjdCcpID09PSAwICYmIHN0ci5pbmRleE9mKHR5cGUgKyBcIl1cIikgPiAtMTtcbn1cbmZ1bmN0aW9uIGludm9rZVdpdGhBcmdzT3JSZXR1cm4odmFsdWUsIGFyZ3MpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLmFwcGx5KHZvaWQgMCwgYXJncykgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCBtcykge1xuICAvLyBBdm9pZCB3cmFwcGluZyBpbiBgc2V0VGltZW91dGAgaWYgbXMgaXMgMCBhbnl3YXlcbiAgaWYgKG1zID09PSAwKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuKGFyZyk7XG4gICAgfSwgbXMpO1xuICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlUHJvcGVydGllcyhvYmosIGtleXMpIHtcbiAgdmFyIGNsb25lID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWxldGUgY2xvbmVba2V5XTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZTtcbn1cbmZ1bmN0aW9uIHNwbGl0QnlTcGFjZXModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gW10uY29uY2F0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHB1c2hJZlVuaXF1ZShhcnIsIHZhbHVlKSB7XG4gIGlmIChhcnIuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgYXJyLnB1c2godmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiB1bmlxdWUoYXJyKSB7XG4gIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiBhcnIuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXg7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gYXJyYXlGcm9tKHZhbHVlKSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZFByb3BzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgaWYgKG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFjY1trZXldID0gb2JqW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBkaXYoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gWydFbGVtZW50JywgJ0ZyYWdtZW50J10uc29tZShmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiBpc1R5cGUodmFsdWUsIHR5cGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzTm9kZUxpc3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ05vZGVMaXN0Jyk7XG59XG5mdW5jdGlvbiBpc01vdXNlRXZlbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ01vdXNlRXZlbnQnKTtcbn1cbmZ1bmN0aW9uIGlzUmVmZXJlbmNlRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX3RpcHB5ICYmIHZhbHVlLl90aXBweS5yZWZlcmVuY2UgPT09IHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldEFycmF5T2ZFbGVtZW50cyh2YWx1ZSkge1xuICBpZiAoaXNFbGVtZW50KHZhbHVlKSkge1xuICAgIHJldHVybiBbdmFsdWVdO1xuICB9XG5cbiAgaWYgKGlzTm9kZUxpc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGFycmF5RnJvbSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gYXJyYXlGcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25EdXJhdGlvbihlbHMsIHZhbHVlKSB7XG4gIGVscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdmFsdWUgKyBcIm1zXCI7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHNldFZpc2liaWxpdHlTdGF0ZShlbHMsIHN0YXRlKSB7XG4gIGVscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgc3RhdGUpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50KGVsZW1lbnRPckVsZW1lbnRzKSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgdmFyIF9ub3JtYWxpemVUb0FycmF5ID0gbm9ybWFsaXplVG9BcnJheShlbGVtZW50T3JFbGVtZW50cyksXG4gICAgICBlbGVtZW50ID0gX25vcm1hbGl6ZVRvQXJyYXlbMF07IC8vIEVsZW1lbnRzIGNyZWF0ZWQgdmlhIGEgPHRlbXBsYXRlPiBoYXZlIGFuIG93bmVyRG9jdW1lbnQgd2l0aCBubyByZWZlcmVuY2UgdG8gdGhlIGJvZHlcblxuXG4gIHJldHVybiBlbGVtZW50ICE9IG51bGwgJiYgKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgIT0gbnVsbCAmJiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IGRvY3VtZW50O1xufVxuZnVuY3Rpb24gaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIocG9wcGVyVHJlZURhdGEsIGV2ZW50KSB7XG4gIHZhciBjbGllbnRYID0gZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFkgPSBldmVudC5jbGllbnRZO1xuICByZXR1cm4gcG9wcGVyVHJlZURhdGEuZXZlcnkoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgcG9wcGVyUmVjdCA9IF9yZWYucG9wcGVyUmVjdCxcbiAgICAgICAgcG9wcGVyU3RhdGUgPSBfcmVmLnBvcHBlclN0YXRlLFxuICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgdmFyIGludGVyYWN0aXZlQm9yZGVyID0gcHJvcHMuaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBvcHBlclN0YXRlLnBsYWNlbWVudCk7XG4gICAgdmFyIG9mZnNldERhdGEgPSBwb3BwZXJTdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDtcblxuICAgIGlmICghb2Zmc2V0RGF0YSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHRvcERpc3RhbmNlID0gYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScgPyBvZmZzZXREYXRhLnRvcC55IDogMDtcbiAgICB2YXIgYm90dG9tRGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAndG9wJyA/IG9mZnNldERhdGEuYm90dG9tLnkgOiAwO1xuICAgIHZhciBsZWZ0RGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnID8gb2Zmc2V0RGF0YS5sZWZ0LnggOiAwO1xuICAgIHZhciByaWdodERpc3RhbmNlID0gYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnID8gb2Zmc2V0RGF0YS5yaWdodC54IDogMDtcbiAgICB2YXIgZXhjZWVkc1RvcCA9IHBvcHBlclJlY3QudG9wIC0gY2xpZW50WSArIHRvcERpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgdmFyIGV4Y2VlZHNCb3R0b20gPSBjbGllbnRZIC0gcG9wcGVyUmVjdC5ib3R0b20gLSBib3R0b21EaXN0YW5jZSA+IGludGVyYWN0aXZlQm9yZGVyO1xuICAgIHZhciBleGNlZWRzTGVmdCA9IHBvcHBlclJlY3QubGVmdCAtIGNsaWVudFggKyBsZWZ0RGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICB2YXIgZXhjZWVkc1JpZ2h0ID0gY2xpZW50WCAtIHBvcHBlclJlY3QucmlnaHQgLSByaWdodERpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgcmV0dXJuIGV4Y2VlZHNUb3AgfHwgZXhjZWVkc0JvdHRvbSB8fCBleGNlZWRzTGVmdCB8fCBleGNlZWRzUmlnaHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKGJveCwgYWN0aW9uLCBsaXN0ZW5lcikge1xuICB2YXIgbWV0aG9kID0gYWN0aW9uICsgXCJFdmVudExpc3RlbmVyXCI7IC8vIHNvbWUgYnJvd3NlcnMgYXBwYXJlbnRseSBzdXBwb3J0IGB0cmFuc2l0aW9uYCAodW5wcmVmaXhlZCkgYnV0IG9ubHkgZmlyZVxuICAvLyBgd2Via2l0VHJhbnNpdGlvbkVuZGAuLi5cblxuICBbJ3RyYW5zaXRpb25lbmQnLCAnd2Via2l0VHJhbnNpdGlvbkVuZCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgYm94W21ldGhvZF0oZXZlbnQsIGxpc3RlbmVyKTtcbiAgfSk7XG59XG4vKipcbiAqIENvbXBhcmVkIHRvIHh4eC5jb250YWlucywgdGhpcyBmdW5jdGlvbiB3b3JrcyBmb3IgZG9tIHN0cnVjdHVyZXMgd2l0aCBzaGFkb3dcbiAqIGRvbVxuICovXG5cbmZ1bmN0aW9uIGFjdHVhbENvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHRhcmdldCA9IGNoaWxkO1xuXG4gIHdoaWxlICh0YXJnZXQpIHtcbiAgICB2YXIgX3RhcmdldCRnZXRSb290Tm9kZTtcblxuICAgIGlmIChwYXJlbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmdldFJvb3ROb2RlID09IG51bGwgPyB2b2lkIDAgOiAoX3RhcmdldCRnZXRSb290Tm9kZSA9IHRhcmdldC5nZXRSb290Tm9kZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldCRnZXRSb290Tm9kZS5ob3N0O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgY3VycmVudElucHV0ID0ge1xuICBpc1RvdWNoOiBmYWxzZVxufTtcbnZhciBsYXN0TW91c2VNb3ZlVGltZSA9IDA7XG4vKipcbiAqIFdoZW4gYSBgdG91Y2hzdGFydGAgZXZlbnQgaXMgZmlyZWQsIGl0J3MgYXNzdW1lZCB0aGUgdXNlciBpcyB1c2luZyB0b3VjaFxuICogaW5wdXQuIFdlJ2xsIGJpbmQgYSBgbW91c2Vtb3ZlYCBldmVudCBsaXN0ZW5lciB0byBsaXN0ZW4gZm9yIG1vdXNlIGlucHV0IGluXG4gKiB0aGUgZnV0dXJlLiBUaGlzIHdheSwgdGhlIGBpc1RvdWNoYCBwcm9wZXJ0eSBpcyBmdWxseSBkeW5hbWljIGFuZCB3aWxsIGhhbmRsZVxuICogaHlicmlkIGRldmljZXMgdGhhdCB1c2UgYSBtaXggb2YgdG91Y2ggKyBtb3VzZSBpbnB1dC5cbiAqL1xuXG5mdW5jdGlvbiBvbkRvY3VtZW50VG91Y2hTdGFydCgpIHtcbiAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3VycmVudElucHV0LmlzVG91Y2ggPSB0cnVlO1xuXG4gIGlmICh3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbkRvY3VtZW50TW91c2VNb3ZlKTtcbiAgfVxufVxuLyoqXG4gKiBXaGVuIHR3byBgbW91c2Vtb3ZlYCBldmVudCBhcmUgZmlyZWQgY29uc2VjdXRpdmVseSB3aXRoaW4gMjBtcywgaXQncyBhc3N1bWVkXG4gKiB0aGUgdXNlciBpcyB1c2luZyBtb3VzZSBpbnB1dCBhZ2Fpbi4gYG1vdXNlbW92ZWAgY2FuIGZpcmUgb24gdG91Y2ggZGV2aWNlcyBhc1xuICogd2VsbCwgYnV0IHZlcnkgcmFyZWx5IHRoYXQgcXVpY2tseS5cbiAqL1xuXG5mdW5jdGlvbiBvbkRvY3VtZW50TW91c2VNb3ZlKCkge1xuICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgaWYgKG5vdyAtIGxhc3RNb3VzZU1vdmVUaW1lIDwgMjApIHtcbiAgICBjdXJyZW50SW5wdXQuaXNUb3VjaCA9IGZhbHNlO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uRG9jdW1lbnRNb3VzZU1vdmUpO1xuICB9XG5cbiAgbGFzdE1vdXNlTW92ZVRpbWUgPSBub3c7XG59XG4vKipcbiAqIFdoZW4gYW4gZWxlbWVudCBpcyBpbiBmb2N1cyBhbmQgaGFzIGEgdGlwcHksIGxlYXZpbmcgdGhlIHRhYi93aW5kb3cgYW5kXG4gKiByZXR1cm5pbmcgY2F1c2VzIGl0IHRvIHNob3cgYWdhaW4uIEZvciBtb3VzZSB1c2VycyB0aGlzIGlzIHVuZXhwZWN0ZWQsIGJ1dFxuICogZm9yIGtleWJvYXJkIHVzZSBpdCBtYWtlcyBzZW5zZS5cbiAqIFRPRE86IGZpbmQgYSBiZXR0ZXIgdGVjaG5pcXVlIHRvIHNvbHZlIHRoaXMgcHJvYmxlbVxuICovXG5cbmZ1bmN0aW9uIG9uV2luZG93Qmx1cigpIHtcbiAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gIGlmIChpc1JlZmVyZW5jZUVsZW1lbnQoYWN0aXZlRWxlbWVudCkpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBhY3RpdmVFbGVtZW50Ll90aXBweTtcblxuICAgIGlmIChhY3RpdmVFbGVtZW50LmJsdXIgJiYgIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBiaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvbkRvY3VtZW50VG91Y2hTdGFydCwgVE9VQ0hfT1BUSU9OUyk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgb25XaW5kb3dCbHVyKTtcbn1cblxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaXNJRTExID0gaXNCcm93c2VyID8gLy8gQHRzLWlnbm9yZVxuISF3aW5kb3cubXNDcnlwdG8gOiBmYWxzZTtcblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcobWV0aG9kKSB7XG4gIHZhciB0eHQgPSBtZXRob2QgPT09ICdkZXN0cm95JyA/ICduIGFscmVhZHktJyA6ICcgJztcbiAgcmV0dXJuIFttZXRob2QgKyBcIigpIHdhcyBjYWxsZWQgb24gYVwiICsgdHh0ICsgXCJkZXN0cm95ZWQgaW5zdGFuY2UuIFRoaXMgaXMgYSBuby1vcCBidXRcIiwgJ2luZGljYXRlcyBhIHBvdGVudGlhbCBtZW1vcnkgbGVhay4nXS5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBjbGVhbih2YWx1ZSkge1xuICB2YXIgc3BhY2VzQW5kVGFicyA9IC9bIFxcdF17Mix9L2c7XG4gIHZhciBsaW5lU3RhcnRXaXRoU3BhY2VzID0gL15bIFxcdF0qL2dtO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShzcGFjZXNBbmRUYWJzLCAnICcpLnJlcGxhY2UobGluZVN0YXJ0V2l0aFNwYWNlcywgJycpLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGV2TWVzc2FnZShtZXNzYWdlKSB7XG4gIHJldHVybiBjbGVhbihcIlxcbiAgJWN0aXBweS5qc1xcblxcbiAgJWNcIiArIGNsZWFuKG1lc3NhZ2UpICsgXCJcXG5cXG4gICVjXFx1RDgzRFxcdURDNzdcXHUyMDBEIFRoaXMgaXMgYSBkZXZlbG9wbWVudC1vbmx5IG1lc3NhZ2UuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uLlxcbiAgXCIpO1xufVxuXG5mdW5jdGlvbiBnZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIFtnZXREZXZNZXNzYWdlKG1lc3NhZ2UpLCAvLyB0aXRsZVxuICAnY29sb3I6ICMwMEM1ODQ7IGZvbnQtc2l6ZTogMS4zZW07IGZvbnQtd2VpZ2h0OiBib2xkOycsIC8vIG1lc3NhZ2VcbiAgJ2xpbmUtaGVpZ2h0OiAxLjUnLCAvLyBmb290ZXJcbiAgJ2NvbG9yOiAjYTZhMDk1OyddO1xufSAvLyBBc3N1bWUgd2FybmluZ3MgYW5kIGVycm9ycyBuZXZlciBoYXZlIHRoZSBzYW1lIG1lc3NhZ2VcblxudmFyIHZpc2l0ZWRNZXNzYWdlcztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICByZXNldFZpc2l0ZWRNZXNzYWdlcygpO1xufVxuXG5mdW5jdGlvbiByZXNldFZpc2l0ZWRNZXNzYWdlcygpIHtcbiAgdmlzaXRlZE1lc3NhZ2VzID0gbmV3IFNldCgpO1xufVxuZnVuY3Rpb24gd2FybldoZW4oY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChjb25kaXRpb24gJiYgIXZpc2l0ZWRNZXNzYWdlcy5oYXMobWVzc2FnZSkpIHtcbiAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICB2aXNpdGVkTWVzc2FnZXMuYWRkKG1lc3NhZ2UpO1xuXG4gICAgKF9jb25zb2xlID0gY29uc29sZSkud2Fybi5hcHBseShfY29uc29sZSwgZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yV2hlbihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKGNvbmRpdGlvbiAmJiAhdmlzaXRlZE1lc3NhZ2VzLmhhcyhtZXNzYWdlKSkge1xuICAgIHZhciBfY29uc29sZTI7XG5cbiAgICB2aXNpdGVkTWVzc2FnZXMuYWRkKG1lc3NhZ2UpO1xuXG4gICAgKF9jb25zb2xlMiA9IGNvbnNvbGUpLmVycm9yLmFwcGx5KF9jb25zb2xlMiwgZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVGFyZ2V0cyh0YXJnZXRzKSB7XG4gIHZhciBkaWRQYXNzRmFsc3lWYWx1ZSA9ICF0YXJnZXRzO1xuICB2YXIgZGlkUGFzc1BsYWluT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhcmdldHMpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiAhdGFyZ2V0cy5hZGRFdmVudExpc3RlbmVyO1xuICBlcnJvcldoZW4oZGlkUGFzc0ZhbHN5VmFsdWUsIFsndGlwcHkoKSB3YXMgcGFzc2VkJywgJ2AnICsgU3RyaW5nKHRhcmdldHMpICsgJ2AnLCAnYXMgaXRzIHRhcmdldHMgKGZpcnN0KSBhcmd1bWVudC4gVmFsaWQgdHlwZXMgYXJlOiBTdHJpbmcsIEVsZW1lbnQsJywgJ0VsZW1lbnRbXSwgb3IgTm9kZUxpc3QuJ10uam9pbignICcpKTtcbiAgZXJyb3JXaGVuKGRpZFBhc3NQbGFpbk9iamVjdCwgWyd0aXBweSgpIHdhcyBwYXNzZWQgYSBwbGFpbiBvYmplY3Qgd2hpY2ggaXMgbm90IHN1cHBvcnRlZCBhcyBhbiBhcmd1bWVudCcsICdmb3IgdmlydHVhbCBwb3NpdGlvbmluZy4gVXNlIHByb3BzLmdldFJlZmVyZW5jZUNsaWVudFJlY3QgaW5zdGVhZC4nXS5qb2luKCcgJykpO1xufVxuXG52YXIgcGx1Z2luUHJvcHMgPSB7XG4gIGFuaW1hdGVGaWxsOiBmYWxzZSxcbiAgZm9sbG93Q3Vyc29yOiBmYWxzZSxcbiAgaW5saW5lUG9zaXRpb25pbmc6IGZhbHNlLFxuICBzdGlja3k6IGZhbHNlXG59O1xudmFyIHJlbmRlclByb3BzID0ge1xuICBhbGxvd0hUTUw6IGZhbHNlLFxuICBhbmltYXRpb246ICdmYWRlJyxcbiAgYXJyb3c6IHRydWUsXG4gIGNvbnRlbnQ6ICcnLFxuICBpbmVydGlhOiBmYWxzZSxcbiAgbWF4V2lkdGg6IDM1MCxcbiAgcm9sZTogJ3Rvb2x0aXAnLFxuICB0aGVtZTogJycsXG4gIHpJbmRleDogOTk5OVxufTtcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHtcbiAgYXBwZW5kVG86IFRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPLFxuICBhcmlhOiB7XG4gICAgY29udGVudDogJ2F1dG8nLFxuICAgIGV4cGFuZGVkOiAnYXV0bydcbiAgfSxcbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiBbMzAwLCAyNTBdLFxuICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBudWxsLFxuICBoaWRlT25DbGljazogdHJ1ZSxcbiAgaWdub3JlQXR0cmlidXRlczogZmFsc2UsXG4gIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgaW50ZXJhY3RpdmVCb3JkZXI6IDIsXG4gIGludGVyYWN0aXZlRGVib3VuY2U6IDAsXG4gIG1vdmVUcmFuc2l0aW9uOiAnJyxcbiAgb2Zmc2V0OiBbMCwgMTBdLFxuICBvbkFmdGVyVXBkYXRlOiBmdW5jdGlvbiBvbkFmdGVyVXBkYXRlKCkge30sXG4gIG9uQmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBvbkJlZm9yZVVwZGF0ZSgpIHt9LFxuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcbiAgb25EZXN0cm95OiBmdW5jdGlvbiBvbkRlc3Ryb3koKSB7fSxcbiAgb25IaWRkZW46IGZ1bmN0aW9uIG9uSGlkZGVuKCkge30sXG4gIG9uSGlkZTogZnVuY3Rpb24gb25IaWRlKCkge30sXG4gIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7fSxcbiAgb25TaG93OiBmdW5jdGlvbiBvblNob3coKSB7fSxcbiAgb25TaG93bjogZnVuY3Rpb24gb25TaG93bigpIHt9LFxuICBvblRyaWdnZXI6IGZ1bmN0aW9uIG9uVHJpZ2dlcigpIHt9LFxuICBvblVudHJpZ2dlcjogZnVuY3Rpb24gb25VbnRyaWdnZXIoKSB7fSxcbiAgb25DbGlja091dHNpZGU6IGZ1bmN0aW9uIG9uQ2xpY2tPdXRzaWRlKCkge30sXG4gIHBsYWNlbWVudDogJ3RvcCcsXG4gIHBsdWdpbnM6IFtdLFxuICBwb3BwZXJPcHRpb25zOiB7fSxcbiAgcmVuZGVyOiBudWxsLFxuICBzaG93T25DcmVhdGU6IGZhbHNlLFxuICB0b3VjaDogdHJ1ZSxcbiAgdHJpZ2dlcjogJ21vdXNlZW50ZXIgZm9jdXMnLFxuICB0cmlnZ2VyVGFyZ2V0OiBudWxsXG59LCBwbHVnaW5Qcm9wcywgcmVuZGVyUHJvcHMpO1xudmFyIGRlZmF1bHRLZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdFByb3BzKTtcbnZhciBzZXREZWZhdWx0UHJvcHMgPSBmdW5jdGlvbiBzZXREZWZhdWx0UHJvcHMocGFydGlhbFByb3BzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVByb3BzKHBhcnRpYWxQcm9wcywgW10pO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwYXJ0aWFsUHJvcHMpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGRlZmF1bHRQcm9wc1trZXldID0gcGFydGlhbFByb3BzW2tleV07XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGdldEV4dGVuZGVkUGFzc2VkUHJvcHMocGFzc2VkUHJvcHMpIHtcbiAgdmFyIHBsdWdpbnMgPSBwYXNzZWRQcm9wcy5wbHVnaW5zIHx8IFtdO1xuICB2YXIgcGx1Z2luUHJvcHMgPSBwbHVnaW5zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbHVnaW4pIHtcbiAgICB2YXIgbmFtZSA9IHBsdWdpbi5uYW1lLFxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBwbHVnaW4uZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHZhciBfbmFtZTtcblxuICAgICAgYWNjW25hbWVdID0gcGFzc2VkUHJvcHNbbmFtZV0gIT09IHVuZGVmaW5lZCA/IHBhc3NlZFByb3BzW25hbWVdIDogKF9uYW1lID0gZGVmYXVsdFByb3BzW25hbWVdKSAhPSBudWxsID8gX25hbWUgOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcGFzc2VkUHJvcHMsIHBsdWdpblByb3BzKTtcbn1cbmZ1bmN0aW9uIGdldERhdGFBdHRyaWJ1dGVQcm9wcyhyZWZlcmVuY2UsIHBsdWdpbnMpIHtcbiAgdmFyIHByb3BLZXlzID0gcGx1Z2lucyA/IE9iamVjdC5rZXlzKGdldEV4dGVuZGVkUGFzc2VkUHJvcHMoT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzLCB7XG4gICAgcGx1Z2luczogcGx1Z2luc1xuICB9KSkpIDogZGVmYXVsdEtleXM7XG4gIHZhciBwcm9wcyA9IHByb3BLZXlzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICB2YXIgdmFsdWVBc1N0cmluZyA9IChyZWZlcmVuY2UuZ2V0QXR0cmlidXRlKFwiZGF0YS10aXBweS1cIiArIGtleSkgfHwgJycpLnRyaW0oKTtcblxuICAgIGlmICghdmFsdWVBc1N0cmluZykge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnY29udGVudCcpIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWVBc1N0cmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWNjW2tleV0gPSBKU09OLnBhcnNlKHZhbHVlQXNTdHJpbmcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhY2Nba2V5XSA9IHZhbHVlQXNTdHJpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBldmFsdWF0ZVByb3BzKHJlZmVyZW5jZSwgcHJvcHMpIHtcbiAgdmFyIG91dCA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgY29udGVudDogaW52b2tlV2l0aEFyZ3NPclJldHVybihwcm9wcy5jb250ZW50LCBbcmVmZXJlbmNlXSlcbiAgfSwgcHJvcHMuaWdub3JlQXR0cmlidXRlcyA/IHt9IDogZ2V0RGF0YUF0dHJpYnV0ZVByb3BzKHJlZmVyZW5jZSwgcHJvcHMucGx1Z2lucykpO1xuICBvdXQuYXJpYSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcy5hcmlhLCBvdXQuYXJpYSk7XG4gIG91dC5hcmlhID0ge1xuICAgIGV4cGFuZGVkOiBvdXQuYXJpYS5leHBhbmRlZCA9PT0gJ2F1dG8nID8gcHJvcHMuaW50ZXJhY3RpdmUgOiBvdXQuYXJpYS5leHBhbmRlZCxcbiAgICBjb250ZW50OiBvdXQuYXJpYS5jb250ZW50ID09PSAnYXV0bycgPyBwcm9wcy5pbnRlcmFjdGl2ZSA/IG51bGwgOiAnZGVzY3JpYmVkYnknIDogb3V0LmFyaWEuY29udGVudFxuICB9O1xuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhwYXJ0aWFsUHJvcHMsIHBsdWdpbnMpIHtcbiAgaWYgKHBhcnRpYWxQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcGFydGlhbFByb3BzID0ge307XG4gIH1cblxuICBpZiAocGx1Z2lucyA9PT0gdm9pZCAwKSB7XG4gICAgcGx1Z2lucyA9IFtdO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwYXJ0aWFsUHJvcHMpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgbm9uUGx1Z2luUHJvcHMgPSByZW1vdmVQcm9wZXJ0aWVzKGRlZmF1bHRQcm9wcywgT2JqZWN0LmtleXMocGx1Z2luUHJvcHMpKTtcbiAgICB2YXIgZGlkUGFzc1Vua25vd25Qcm9wID0gIWhhc093blByb3BlcnR5KG5vblBsdWdpblByb3BzLCBwcm9wKTsgLy8gQ2hlY2sgaWYgdGhlIHByb3AgZXhpc3RzIGluIGBwbHVnaW5zYFxuXG4gICAgaWYgKGRpZFBhc3NVbmtub3duUHJvcCkge1xuICAgICAgZGlkUGFzc1Vua25vd25Qcm9wID0gcGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luLm5hbWUgPT09IHByb3A7XG4gICAgICB9KS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgd2FybldoZW4oZGlkUGFzc1Vua25vd25Qcm9wLCBbXCJgXCIgKyBwcm9wICsgXCJgXCIsIFwiaXMgbm90IGEgdmFsaWQgcHJvcC4gWW91IG1heSBoYXZlIHNwZWxsZWQgaXQgaW5jb3JyZWN0bHksIG9yIGlmIGl0J3NcIiwgJ2EgcGx1Z2luLCBmb3Jnb3QgdG8gcGFzcyBpdCBpbiBhbiBhcnJheSBhcyBwcm9wcy5wbHVnaW5zLicsICdcXG5cXG4nLCAnQWxsIHByb3BzOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvdjYvYWxsLXByb3BzL1xcbicsICdQbHVnaW5zOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvdjYvcGx1Z2lucy8nXS5qb2luKCcgJykpO1xuICB9KTtcbn1cblxudmFyIGlubmVySFRNTCA9IGZ1bmN0aW9uIGlubmVySFRNTCgpIHtcbiAgcmV0dXJuICdpbm5lckhUTUwnO1xufTtcblxuZnVuY3Rpb24gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoZWxlbWVudCwgaHRtbCkge1xuICBlbGVtZW50W2lubmVySFRNTCgpXSA9IGh0bWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycm93RWxlbWVudCh2YWx1ZSkge1xuICB2YXIgYXJyb3cgPSBkaXYoKTtcblxuICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICBhcnJvdy5jbGFzc05hbWUgPSBBUlJPV19DTEFTUztcbiAgfSBlbHNlIHtcbiAgICBhcnJvdy5jbGFzc05hbWUgPSBTVkdfQVJST1dfQ0xBU1M7XG5cbiAgICBpZiAoaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAgYXJyb3cuYXBwZW5kQ2hpbGQodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTChhcnJvdywgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcnJvdztcbn1cblxuZnVuY3Rpb24gc2V0Q29udGVudChjb250ZW50LCBwcm9wcykge1xuICBpZiAoaXNFbGVtZW50KHByb3BzLmNvbnRlbnQpKSB7XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoY29udGVudCwgJycpO1xuICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQocHJvcHMuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmNvbnRlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvcHMuYWxsb3dIVE1MKSB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTChjb250ZW50LCBwcm9wcy5jb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudC50ZXh0Q29udGVudCA9IHByb3BzLmNvbnRlbnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihwb3BwZXIpIHtcbiAgdmFyIGJveCA9IHBvcHBlci5maXJzdEVsZW1lbnRDaGlsZDtcbiAgdmFyIGJveENoaWxkcmVuID0gYXJyYXlGcm9tKGJveC5jaGlsZHJlbik7XG4gIHJldHVybiB7XG4gICAgYm94OiBib3gsXG4gICAgY29udGVudDogYm94Q2hpbGRyZW4uZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKENPTlRFTlRfQ0xBU1MpO1xuICAgIH0pLFxuICAgIGFycm93OiBib3hDaGlsZHJlbi5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQVJST1dfQ0xBU1MpIHx8IG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFNWR19BUlJPV19DTEFTUyk7XG4gICAgfSksXG4gICAgYmFja2Ryb3A6IGJveENoaWxkcmVuLmZpbmQoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhCQUNLRFJPUF9DTEFTUyk7XG4gICAgfSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihpbnN0YW5jZSkge1xuICB2YXIgcG9wcGVyID0gZGl2KCk7XG4gIHZhciBib3ggPSBkaXYoKTtcbiAgYm94LmNsYXNzTmFtZSA9IEJPWF9DTEFTUztcbiAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdoaWRkZW4nKTtcbiAgYm94LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgdmFyIGNvbnRlbnQgPSBkaXYoKTtcbiAgY29udGVudC5jbGFzc05hbWUgPSBDT05URU5UX0NMQVNTO1xuICBjb250ZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdoaWRkZW4nKTtcbiAgc2V0Q29udGVudChjb250ZW50LCBpbnN0YW5jZS5wcm9wcyk7XG4gIHBvcHBlci5hcHBlbmRDaGlsZChib3gpO1xuICBib3guYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gIG9uVXBkYXRlKGluc3RhbmNlLnByb3BzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgZnVuY3Rpb24gb25VcGRhdGUocHJldlByb3BzLCBuZXh0UHJvcHMpIHtcbiAgICB2YXIgX2dldENoaWxkcmVuID0gZ2V0Q2hpbGRyZW4ocG9wcGVyKSxcbiAgICAgICAgYm94ID0gX2dldENoaWxkcmVuLmJveCxcbiAgICAgICAgY29udGVudCA9IF9nZXRDaGlsZHJlbi5jb250ZW50LFxuICAgICAgICBhcnJvdyA9IF9nZXRDaGlsZHJlbi5hcnJvdztcblxuICAgIGlmIChuZXh0UHJvcHMudGhlbWUpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnLCBuZXh0UHJvcHMudGhlbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXRoZW1lJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXh0UHJvcHMuYW5pbWF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nLCBuZXh0UHJvcHMuYW5pbWF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dFByb3BzLmluZXJ0aWEpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5lcnRpYScsICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1pbmVydGlhJyk7XG4gICAgfVxuXG4gICAgYm94LnN0eWxlLm1heFdpZHRoID0gdHlwZW9mIG5leHRQcm9wcy5tYXhXaWR0aCA9PT0gJ251bWJlcicgPyBuZXh0UHJvcHMubWF4V2lkdGggKyBcInB4XCIgOiBuZXh0UHJvcHMubWF4V2lkdGg7XG5cbiAgICBpZiAobmV4dFByb3BzLnJvbGUpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCBuZXh0UHJvcHMucm9sZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICB9XG5cbiAgICBpZiAocHJldlByb3BzLmNvbnRlbnQgIT09IG5leHRQcm9wcy5jb250ZW50IHx8IHByZXZQcm9wcy5hbGxvd0hUTUwgIT09IG5leHRQcm9wcy5hbGxvd0hUTUwpIHtcbiAgICAgIHNldENvbnRlbnQoY29udGVudCwgaW5zdGFuY2UucHJvcHMpO1xuICAgIH1cblxuICAgIGlmIChuZXh0UHJvcHMuYXJyb3cpIHtcbiAgICAgIGlmICghYXJyb3cpIHtcbiAgICAgICAgYm94LmFwcGVuZENoaWxkKGNyZWF0ZUFycm93RWxlbWVudChuZXh0UHJvcHMuYXJyb3cpKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldlByb3BzLmFycm93ICE9PSBuZXh0UHJvcHMuYXJyb3cpIHtcbiAgICAgICAgYm94LnJlbW92ZUNoaWxkKGFycm93KTtcbiAgICAgICAgYm94LmFwcGVuZENoaWxkKGNyZWF0ZUFycm93RWxlbWVudChuZXh0UHJvcHMuYXJyb3cpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFycm93KSB7XG4gICAgICBib3gucmVtb3ZlQ2hpbGQoYXJyb3cpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9wcGVyOiBwb3BwZXIsXG4gICAgb25VcGRhdGU6IG9uVXBkYXRlXG4gIH07XG59IC8vIFJ1bnRpbWUgY2hlY2sgdG8gaWRlbnRpZnkgaWYgdGhlIHJlbmRlciBmdW5jdGlvbiBpcyB0aGUgZGVmYXVsdCBvbmU7IHRoaXNcbi8vIHdheSB3ZSBjYW4gYXBwbHkgZGVmYXVsdCBDU1MgdHJhbnNpdGlvbnMgbG9naWMgYW5kIGl0IGNhbiBiZSB0cmVlLXNoYWtlbiBhd2F5XG5cbnJlbmRlci4kJHRpcHB5ID0gdHJ1ZTtcblxudmFyIGlkQ291bnRlciA9IDE7XG52YXIgbW91c2VNb3ZlTGlzdGVuZXJzID0gW107IC8vIFVzZWQgYnkgYGhpZGVBbGwoKWBcblxudmFyIG1vdW50ZWRJbnN0YW5jZXMgPSBbXTtcbmZ1bmN0aW9uIGNyZWF0ZVRpcHB5KHJlZmVyZW5jZSwgcGFzc2VkUHJvcHMpIHtcbiAgdmFyIHByb3BzID0gZXZhbHVhdGVQcm9wcyhyZWZlcmVuY2UsIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcywgZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyhyZW1vdmVVbmRlZmluZWRQcm9wcyhwYXNzZWRQcm9wcykpKSk7IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn5SSIFByaXZhdGUgbWVtYmVyc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgc2hvd1RpbWVvdXQ7XG4gIHZhciBoaWRlVGltZW91dDtcbiAgdmFyIHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lO1xuICB2YXIgaXNWaXNpYmxlRnJvbUNsaWNrID0gZmFsc2U7XG4gIHZhciBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IGZhbHNlO1xuICB2YXIgZGlkVG91Y2hNb3ZlID0gZmFsc2U7XG4gIHZhciBpZ25vcmVPbkZpcnN0VXBkYXRlID0gZmFsc2U7XG4gIHZhciBsYXN0VHJpZ2dlckV2ZW50O1xuICB2YXIgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lcjtcbiAgdmFyIG9uRmlyc3RVcGRhdGU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGRlYm91bmNlZE9uTW91c2VNb3ZlID0gZGVib3VuY2Uob25Nb3VzZU1vdmUsIHByb3BzLmludGVyYWN0aXZlRGVib3VuY2UpO1xuICB2YXIgY3VycmVudFRhcmdldDsgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJEgUHVibGljIG1lbWJlcnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGlkID0gaWRDb3VudGVyKys7XG4gIHZhciBwb3BwZXJJbnN0YW5jZSA9IG51bGw7XG4gIHZhciBwbHVnaW5zID0gdW5pcXVlKHByb3BzLnBsdWdpbnMpO1xuICB2YXIgc3RhdGUgPSB7XG4gICAgLy8gSXMgdGhlIGluc3RhbmNlIGN1cnJlbnRseSBlbmFibGVkP1xuICAgIGlzRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyBJcyB0aGUgdGlwcHkgY3VycmVudGx5IHNob3dpbmcgYW5kIG5vdCB0cmFuc2l0aW9uaW5nIG91dD9cbiAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgIC8vIEhhcyB0aGUgaW5zdGFuY2UgYmVlbiBkZXN0cm95ZWQ/XG4gICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgIC8vIElzIHRoZSB0aXBweSBjdXJyZW50bHkgbW91bnRlZCB0byB0aGUgRE9NP1xuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgLy8gSGFzIHRoZSB0aXBweSBmaW5pc2hlZCB0cmFuc2l0aW9uaW5nIGluP1xuICAgIGlzU2hvd246IGZhbHNlXG4gIH07XG4gIHZhciBpbnN0YW5jZSA9IHtcbiAgICAvLyBwcm9wZXJ0aWVzXG4gICAgaWQ6IGlkLFxuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgIHBvcHBlcjogZGl2KCksXG4gICAgcG9wcGVySW5zdGFuY2U6IHBvcHBlckluc3RhbmNlLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgcGx1Z2luczogcGx1Z2lucyxcbiAgICAvLyBtZXRob2RzXG4gICAgY2xlYXJEZWxheVRpbWVvdXRzOiBjbGVhckRlbGF5VGltZW91dHMsXG4gICAgc2V0UHJvcHM6IHNldFByb3BzLFxuICAgIHNldENvbnRlbnQ6IHNldENvbnRlbnQsXG4gICAgc2hvdzogc2hvdyxcbiAgICBoaWRlOiBoaWRlLFxuICAgIGhpZGVXaXRoSW50ZXJhY3Rpdml0eTogaGlkZVdpdGhJbnRlcmFjdGl2aXR5LFxuICAgIGVuYWJsZTogZW5hYmxlLFxuICAgIGRpc2FibGU6IGRpc2FibGUsXG4gICAgdW5tb3VudDogdW5tb3VudCxcbiAgICBkZXN0cm95OiBkZXN0cm95XG4gIH07IC8vIFRPRE86IEludmVzdGlnYXRlIHdoeSB0aGlzIGVhcmx5IHJldHVybiBjYXVzZXMgYSBURFogZXJyb3IgaW4gdGhlIHRlc3RzIOKAlFxuICAvLyBpdCBkb2Vzbid0IHNlZW0gdG8gaGFwcGVuIGluIHRoZSBicm93c2VyXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cbiAgaWYgKCFwcm9wcy5yZW5kZXIpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBlcnJvcldoZW4odHJ1ZSwgJ3JlbmRlcigpIGZ1bmN0aW9uIGhhcyBub3QgYmVlbiBzdXBwbGllZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEluaXRpYWwgbXV0YXRpb25zXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgdmFyIF9wcm9wcyRyZW5kZXIgPSBwcm9wcy5yZW5kZXIoaW5zdGFuY2UpLFxuICAgICAgcG9wcGVyID0gX3Byb3BzJHJlbmRlci5wb3BwZXIsXG4gICAgICBvblVwZGF0ZSA9IF9wcm9wcyRyZW5kZXIub25VcGRhdGU7XG5cbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgnZGF0YS10aXBweS1yb290JywgJycpO1xuICBwb3BwZXIuaWQgPSBcInRpcHB5LVwiICsgaW5zdGFuY2UuaWQ7XG4gIGluc3RhbmNlLnBvcHBlciA9IHBvcHBlcjtcbiAgcmVmZXJlbmNlLl90aXBweSA9IGluc3RhbmNlO1xuICBwb3BwZXIuX3RpcHB5ID0gaW5zdGFuY2U7XG4gIHZhciBwbHVnaW5zSG9va3MgPSBwbHVnaW5zLm1hcChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgcmV0dXJuIHBsdWdpbi5mbihpbnN0YW5jZSk7XG4gIH0pO1xuICB2YXIgaGFzQXJpYUV4cGFuZGVkID0gcmVmZXJlbmNlLmhhc0F0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICBhZGRMaXN0ZW5lcnMoKTtcbiAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG4gIGhhbmRsZVN0eWxlcygpO1xuICBpbnZva2VIb29rKCdvbkNyZWF0ZScsIFtpbnN0YW5jZV0pO1xuXG4gIGlmIChwcm9wcy5zaG93T25DcmVhdGUpIHtcbiAgICBzY2hlZHVsZVNob3coKTtcbiAgfSAvLyBQcmV2ZW50IGEgdGlwcHkgd2l0aCBhIGRlbGF5IGZyb20gaGlkaW5nIGlmIHRoZSBjdXJzb3IgbGVmdCB0aGVuIHJldHVybmVkXG4gIC8vIGJlZm9yZSBpdCBzdGFydGVkIGhpZGluZ1xuXG5cbiAgcG9wcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgfVxuICB9KTtcbiAgcG9wcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignbW91c2VlbnRlcicpID49IDApIHtcbiAgICAgIGdldERvY3VtZW50KCkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbnN0YW5jZTsgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJIgUHJpdmF0ZSBtZXRob2RzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKCkge1xuICAgIHZhciB0b3VjaCA9IGluc3RhbmNlLnByb3BzLnRvdWNoO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRvdWNoKSA/IHRvdWNoIDogW3RvdWNoLCAwXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpIHtcbiAgICByZXR1cm4gZ2V0Tm9ybWFsaXplZFRvdWNoU2V0dGluZ3MoKVswXSA9PT0gJ2hvbGQnO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRwcm9wcyRyZW5kZTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gISEoKF9pbnN0YW5jZSRwcm9wcyRyZW5kZSA9IGluc3RhbmNlLnByb3BzLnJlbmRlcikgIT0gbnVsbCAmJiBfaW5zdGFuY2UkcHJvcHMkcmVuZGUuJCR0aXBweSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXJyZW50VGFyZ2V0KCkge1xuICAgIHJldHVybiBjdXJyZW50VGFyZ2V0IHx8IHJlZmVyZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgIHZhciBwYXJlbnQgPSBnZXRDdXJyZW50VGFyZ2V0KCkucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gcGFyZW50ID8gZ2V0T3duZXJEb2N1bWVudChwYXJlbnQpIDogZG9jdW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpIHtcbiAgICByZXR1cm4gZ2V0Q2hpbGRyZW4ocG9wcGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlbGF5KGlzU2hvdykge1xuICAgIC8vIEZvciB0b3VjaCBvciBrZXlib2FyZCBpbnB1dCwgZm9yY2UgYDBgIGRlbGF5IGZvciBVWCByZWFzb25zXG4gICAgLy8gQWxzbyBpZiB0aGUgaW5zdGFuY2UgaXMgbW91bnRlZCBidXQgbm90IHZpc2libGUgKHRyYW5zaXRpb25pbmcgb3V0KSxcbiAgICAvLyBpZ25vcmUgZGVsYXlcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkICYmICFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgfHwgY3VycmVudElucHV0LmlzVG91Y2ggfHwgbGFzdFRyaWdnZXJFdmVudCAmJiBsYXN0VHJpZ2dlckV2ZW50LnR5cGUgPT09ICdmb2N1cycpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRWYWx1ZUF0SW5kZXhPclJldHVybihpbnN0YW5jZS5wcm9wcy5kZWxheSwgaXNTaG93ID8gMCA6IDEsIGRlZmF1bHRQcm9wcy5kZWxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdHlsZXMoZnJvbUhpZGUpIHtcbiAgICBpZiAoZnJvbUhpZGUgPT09IHZvaWQgMCkge1xuICAgICAgZnJvbUhpZGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwb3BwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmICFmcm9tSGlkZSA/ICcnIDogJ25vbmUnO1xuICAgIHBvcHBlci5zdHlsZS56SW5kZXggPSBcIlwiICsgaW5zdGFuY2UucHJvcHMuekluZGV4O1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSG9vayhob29rLCBhcmdzLCBzaG91bGRJbnZva2VQcm9wc0hvb2spIHtcbiAgICBpZiAoc2hvdWxkSW52b2tlUHJvcHNIb29rID09PSB2b2lkIDApIHtcbiAgICAgIHNob3VsZEludm9rZVByb3BzSG9vayA9IHRydWU7XG4gICAgfVxuXG4gICAgcGx1Z2luc0hvb2tzLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbkhvb2tzKSB7XG4gICAgICBpZiAocGx1Z2luSG9va3NbaG9va10pIHtcbiAgICAgICAgcGx1Z2luSG9va3NbaG9va10uYXBwbHkocGx1Z2luSG9va3MsIGFyZ3MpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHNob3VsZEludm9rZVByb3BzSG9vaykge1xuICAgICAgdmFyIF9pbnN0YW5jZSRwcm9wcztcblxuICAgICAgKF9pbnN0YW5jZSRwcm9wcyA9IGluc3RhbmNlLnByb3BzKVtob29rXS5hcHBseShfaW5zdGFuY2UkcHJvcHMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlKCkge1xuICAgIHZhciBhcmlhID0gaW5zdGFuY2UucHJvcHMuYXJpYTtcblxuICAgIGlmICghYXJpYS5jb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0dHIgPSBcImFyaWEtXCIgKyBhcmlhLmNvbnRlbnQ7XG4gICAgdmFyIGlkID0gcG9wcGVyLmlkO1xuICAgIHZhciBub2RlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyKTtcblxuICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCBjdXJyZW50VmFsdWUgPyBjdXJyZW50VmFsdWUgKyBcIiBcIiArIGlkIDogaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9IGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUucmVwbGFjZShpZCwgJycpLnRyaW0oKTtcblxuICAgICAgICBpZiAobmV4dFZhbHVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgbmV4dFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCkge1xuICAgIGlmIChoYXNBcmlhRXhwYW5kZWQgfHwgIWluc3RhbmNlLnByb3BzLmFyaWEuZXhwYW5kZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiYgbm9kZSA9PT0gZ2V0Q3VycmVudFRhcmdldCgpID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKSB7XG4gICAgZ2V0RG9jdW1lbnQoKS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgbW91c2VNb3ZlTGlzdGVuZXJzID0gbW91c2VNb3ZlTGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lciAhPT0gZGVib3VuY2VkT25Nb3VzZU1vdmU7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkRvY3VtZW50UHJlc3MoZXZlbnQpIHtcbiAgICAvLyBNb3ZlZCBmaW5nZXIgdG8gc2Nyb2xsIGluc3RlYWQgb2YgYW4gaW50ZW50aW9uYWwgdGFwIG91dHNpZGVcbiAgICBpZiAoY3VycmVudElucHV0LmlzVG91Y2gpIHtcbiAgICAgIGlmIChkaWRUb3VjaE1vdmUgfHwgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhY3R1YWxUYXJnZXQgPSBldmVudC5jb21wb3NlZFBhdGggJiYgZXZlbnQuY29tcG9zZWRQYXRoKClbMF0gfHwgZXZlbnQudGFyZ2V0OyAvLyBDbGlja2VkIG9uIGludGVyYWN0aXZlIHBvcHBlclxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGFjdHVhbENvbnRhaW5zKHBvcHBlciwgYWN0dWFsVGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2xpY2tlZCBvbiB0aGUgZXZlbnQgbGlzdGVuZXJzIHRhcmdldFxuXG5cbiAgICBpZiAobm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSkuc29tZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBhY3R1YWxDb250YWlucyhlbCwgYWN0dWFsVGFyZ2V0KTtcbiAgICB9KSkge1xuICAgICAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJiBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2NsaWNrJykgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGludm9rZUhvb2soJ29uQ2xpY2tPdXRzaWRlJywgW2luc3RhbmNlLCBldmVudF0pO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5oaWRlT25DbGljayA9PT0gdHJ1ZSkge1xuICAgICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgICBpbnN0YW5jZS5oaWRlKCk7IC8vIGBtb3VzZWRvd25gIGV2ZW50IGlzIGZpcmVkIHJpZ2h0IGJlZm9yZSBgZm9jdXNgIGlmIHByZXNzaW5nIHRoZVxuICAgICAgLy8gY3VycmVudFRhcmdldC4gVGhpcyBsZXRzIGEgdGlwcHkgd2l0aCBgZm9jdXNgIHRyaWdnZXIga25vdyB0aGF0IGl0XG4gICAgICAvLyBzaG91bGQgbm90IHNob3dcblxuICAgICAgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24gPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duID0gZmFsc2U7XG4gICAgICB9KTsgLy8gVGhlIGxpc3RlbmVyIGdldHMgYWRkZWQgaW4gYHNjaGVkdWxlU2hvdygpYCwgYnV0IHRoaXMgbWF5IGJlIGhpZGluZyBpdFxuICAgICAgLy8gYmVmb3JlIGl0IHNob3dzLCBhbmQgaGlkZSgpJ3MgZWFybHkgYmFpbC1vdXQgYmVoYXZpb3IgY2FuIHByZXZlbnQgaXRcbiAgICAgIC8vIGZyb20gYmVpbmcgY2xlYW5lZCB1cFxuXG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICByZW1vdmVEb2N1bWVudFByZXNzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaE1vdmUoKSB7XG4gICAgZGlkVG91Y2hNb3ZlID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hTdGFydCgpIHtcbiAgICBkaWRUb3VjaE1vdmUgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZERvY3VtZW50UHJlc3MoKSB7XG4gICAgdmFyIGRvYyA9IGdldERvY3VtZW50KCk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uRG9jdW1lbnRQcmVzcywgdHJ1ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Eb2N1bWVudFByZXNzLCBUT1VDSF9PUFRJT05TKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgVE9VQ0hfT1BUSU9OUyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBUT1VDSF9PUFRJT05TKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZURvY3VtZW50UHJlc3MoKSB7XG4gICAgdmFyIGRvYyA9IGdldERvY3VtZW50KCk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uRG9jdW1lbnRQcmVzcywgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Eb2N1bWVudFByZXNzLCBUT1VDSF9PUFRJT05TKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgVE9VQ0hfT1BUSU9OUyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBUT1VDSF9PUFRJT05TKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbmVkT3V0KGR1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiYgcG9wcGVyLnBhcmVudE5vZGUgJiYgcG9wcGVyLnBhcmVudE5vZGUuY29udGFpbnMocG9wcGVyKSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uZWRJbihkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBvblRyYW5zaXRpb25FbmQoZHVyYXRpb24sIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgYm94ID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKS5ib3g7XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW5lcihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gYm94KSB7XG4gICAgICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcihib3gsICdyZW1vdmUnLCBsaXN0ZW5lcik7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSAvLyBNYWtlIGNhbGxiYWNrIHN5bmNocm9ub3VzIGlmIGR1cmF0aW9uIGlzIDBcbiAgICAvLyBgdHJhbnNpdGlvbmVuZGAgd29uJ3QgZmlyZSBvdGhlcndpc2VcblxuXG4gICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoYm94LCAncmVtb3ZlJywgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lcik7XG4gICAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKGJveCwgJ2FkZCcsIGxpc3RlbmVyKTtcbiAgICBjdXJyZW50VHJhbnNpdGlvbkVuZExpc3RlbmVyID0gbGlzdGVuZXI7XG4gIH1cblxuICBmdW5jdGlvbiBvbihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzID0gbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICBsaXN0ZW5lcnMucHVzaCh7XG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIGV2ZW50VHlwZTogZXZlbnRUeXBlLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVycygpIHtcbiAgICBpZiAoZ2V0SXNDdXN0b21Ub3VjaEJlaGF2aW9yKCkpIHtcbiAgICAgIG9uKCd0b3VjaHN0YXJ0Jywgb25UcmlnZ2VyLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgb24oJ3RvdWNoZW5kJywgb25Nb3VzZUxlYXZlLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNwbGl0QnlTcGFjZXMoaW5zdGFuY2UucHJvcHMudHJpZ2dlcikuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICBpZiAoZXZlbnRUeXBlID09PSAnbWFudWFsJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9uKGV2ZW50VHlwZSwgb25UcmlnZ2VyKTtcblxuICAgICAgc3dpdGNoIChldmVudFR5cGUpIHtcbiAgICAgICAgY2FzZSAnbW91c2VlbnRlcic6XG4gICAgICAgICAgb24oJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICBvbihpc0lFMTEgPyAnZm9jdXNvdXQnIDogJ2JsdXInLCBvbkJsdXJPckZvY3VzT3V0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgICAgICBvbignZm9jdXNvdXQnLCBvbkJsdXJPckZvY3VzT3V0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIG5vZGUgPSBfcmVmLm5vZGUsXG4gICAgICAgICAgZXZlbnRUeXBlID0gX3JlZi5ldmVudFR5cGUsXG4gICAgICAgICAgaGFuZGxlciA9IF9yZWYuaGFuZGxlcixcbiAgICAgICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgbGlzdGVuZXJzID0gW107XG4gIH1cblxuICBmdW5jdGlvbiBvblRyaWdnZXIoZXZlbnQpIHtcbiAgICB2YXIgX2xhc3RUcmlnZ2VyRXZlbnQ7XG5cbiAgICB2YXIgc2hvdWxkU2NoZWR1bGVDbGlja0hpZGUgPSBmYWxzZTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkIHx8IGlzRXZlbnRMaXN0ZW5lclN0b3BwZWQoZXZlbnQpIHx8IGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhc0ZvY3VzZWQgPSAoKF9sYXN0VHJpZ2dlckV2ZW50ID0gbGFzdFRyaWdnZXJFdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sYXN0VHJpZ2dlckV2ZW50LnR5cGUpID09PSAnZm9jdXMnO1xuICAgIGxhc3RUcmlnZ2VyRXZlbnQgPSBldmVudDtcbiAgICBjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgIC8vIElmIHNjcm9sbGluZywgYG1vdXNlZW50ZXJgIGV2ZW50cyBjYW4gYmUgZmlyZWQgaWYgdGhlIGN1cnNvciBsYW5kc1xuICAgICAgLy8gb3ZlciBhIG5ldyB0YXJnZXQsIGJ1dCBgbW91c2Vtb3ZlYCBldmVudHMgZG9uJ3QgZ2V0IGZpcmVkLiBUaGlzXG4gICAgICAvLyBjYXVzZXMgaW50ZXJhY3RpdmUgdG9vbHRpcHMgdG8gZ2V0IHN0dWNrIG9wZW4gdW50aWwgdGhlIGN1cnNvciBpc1xuICAgICAgLy8gbW92ZWRcbiAgICAgIG1vdXNlTW92ZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSAvLyBUb2dnbGUgc2hvdy9oaWRlIHdoZW4gY2xpY2tpbmcgY2xpY2stdHJpZ2dlcmVkIHRvb2x0aXBzXG5cblxuICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snICYmIChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ21vdXNlZW50ZXInKSA8IDAgfHwgaXNWaXNpYmxlRnJvbUNsaWNrKSAmJiBpbnN0YW5jZS5wcm9wcy5oaWRlT25DbGljayAhPT0gZmFsc2UgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlU2hvdyhldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgIGlzVmlzaWJsZUZyb21DbGljayA9ICFzaG91bGRTY2hlZHVsZUNsaWNrSGlkZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkU2NoZWR1bGVDbGlja0hpZGUgJiYgIXdhc0ZvY3VzZWQpIHtcbiAgICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHZhciBpc0N1cnNvck92ZXJSZWZlcmVuY2VPclBvcHBlciA9IGdldEN1cnJlbnRUYXJnZXQoKS5jb250YWlucyh0YXJnZXQpIHx8IHBvcHBlci5jb250YWlucyh0YXJnZXQpO1xuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZW1vdmUnICYmIGlzQ3Vyc29yT3ZlclJlZmVyZW5jZU9yUG9wcGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvcHBlclRyZWVEYXRhID0gZ2V0TmVzdGVkUG9wcGVyVHJlZSgpLmNvbmNhdChwb3BwZXIpLm1hcChmdW5jdGlvbiAocG9wcGVyKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJHBvcHBlckluc3RhO1xuXG4gICAgICB2YXIgaW5zdGFuY2UgPSBwb3BwZXIuX3RpcHB5O1xuICAgICAgdmFyIHN0YXRlID0gKF9pbnN0YW5jZSRwb3BwZXJJbnN0YSA9IGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJHBvcHBlckluc3RhLnN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb3BwZXJSZWN0OiBwb3BwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgcG9wcGVyU3RhdGU6IHN0YXRlLFxuICAgICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICBpZiAoaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIocG9wcGVyVHJlZURhdGEsIGV2ZW50KSkge1xuICAgICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTtcbiAgICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgdmFyIHNob3VsZEJhaWwgPSBpc0V2ZW50TGlzdGVuZXJTdG9wcGVkKGV2ZW50KSB8fCBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2NsaWNrJykgPj0gMCAmJiBpc1Zpc2libGVGcm9tQ2xpY2s7XG5cbiAgICBpZiAoc2hvdWxkQmFpbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgaW5zdGFuY2UuaGlkZVdpdGhJbnRlcmFjdGl2aXR5KGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25CbHVyT3JGb2N1c091dChldmVudCkge1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2ZvY3VzaW4nKSA8IDAgJiYgZXZlbnQudGFyZ2V0ICE9PSBnZXRDdXJyZW50VGFyZ2V0KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIGZvY3VzIHdhcyBtb3ZlZCB0byB3aXRoaW4gdGhlIHBvcHBlclxuXG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgZXZlbnQucmVsYXRlZFRhcmdldCAmJiBwb3BwZXIuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudCkge1xuICAgIHJldHVybiBjdXJyZW50SW5wdXQuaXNUb3VjaCA/IGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpICE9PSBldmVudC50eXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMCA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUG9wcGVySW5zdGFuY2UoKSB7XG4gICAgZGVzdHJveVBvcHBlckluc3RhbmNlKCk7XG4gICAgdmFyIF9pbnN0YW5jZSRwcm9wczIgPSBpbnN0YW5jZS5wcm9wcyxcbiAgICAgICAgcG9wcGVyT3B0aW9ucyA9IF9pbnN0YW5jZSRwcm9wczIucG9wcGVyT3B0aW9ucyxcbiAgICAgICAgcGxhY2VtZW50ID0gX2luc3RhbmNlJHByb3BzMi5wbGFjZW1lbnQsXG4gICAgICAgIG9mZnNldCA9IF9pbnN0YW5jZSRwcm9wczIub2Zmc2V0LFxuICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0ID0gX2luc3RhbmNlJHByb3BzMi5nZXRSZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgICAgICBtb3ZlVHJhbnNpdGlvbiA9IF9pbnN0YW5jZSRwcm9wczIubW92ZVRyYW5zaXRpb247XG4gICAgdmFyIGFycm93ID0gZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSA/IGdldENoaWxkcmVuKHBvcHBlcikuYXJyb3cgOiBudWxsO1xuICAgIHZhciBjb21wdXRlZFJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZUNsaWVudFJlY3QgPyB7XG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGdldFJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgICBjb250ZXh0RWxlbWVudDogZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdC5jb250ZXh0RWxlbWVudCB8fCBnZXRDdXJyZW50VGFyZ2V0KClcbiAgICB9IDogcmVmZXJlbmNlO1xuICAgIHZhciB0aXBweU1vZGlmaWVyID0ge1xuICAgICAgbmFtZTogJyQkdGlwcHknLFxuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICAgICAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddLFxuICAgICAgZm46IGZ1bmN0aW9uIGZuKF9yZWYyKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuXG4gICAgICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICAgICAgdmFyIF9nZXREZWZhdWx0VGVtcGxhdGVDaCA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCksXG4gICAgICAgICAgICAgIGJveCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaC5ib3g7XG5cbiAgICAgICAgICBbJ3BsYWNlbWVudCcsICdyZWZlcmVuY2UtaGlkZGVuJywgJ2VzY2FwZWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ciA9PT0gJ3BsYWNlbWVudCcpIHtcbiAgICAgICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZW1lbnQnLCBzdGF0ZS5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyW1wiZGF0YS1wb3BwZXItXCIgKyBhdHRyXSkge1xuICAgICAgICAgICAgICAgIGJveC5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsgYXR0ciwgJycpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLVwiICsgYXR0cik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgbW9kaWZpZXJzID0gW3tcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgdG9wOiAyLFxuICAgICAgICAgIGJvdHRvbTogMixcbiAgICAgICAgICBsZWZ0OiA1LFxuICAgICAgICAgIHJpZ2h0OiA1XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZmxpcCcsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHBhZGRpbmc6IDVcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGFkYXB0aXZlOiAhbW92ZVRyYW5zaXRpb25cbiAgICAgIH1cbiAgICB9LCB0aXBweU1vZGlmaWVyXTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpICYmIGFycm93KSB7XG4gICAgICBtb2RpZmllcnMucHVzaCh7XG4gICAgICAgIG5hbWU6ICdhcnJvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBlbGVtZW50OiBhcnJvdyxcbiAgICAgICAgICBwYWRkaW5nOiAzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZGlmaWVycy5wdXNoLmFwcGx5KG1vZGlmaWVycywgKHBvcHBlck9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcHBlck9wdGlvbnMubW9kaWZpZXJzKSB8fCBbXSk7XG4gICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UgPSBjcmVhdGVQb3BwZXIoY29tcHV0ZWRSZWZlcmVuY2UsIHBvcHBlciwgT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyT3B0aW9ucywge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBvbkZpcnN0VXBkYXRlOiBvbkZpcnN0VXBkYXRlLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbiAgICB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95UG9wcGVySW5zdGFuY2UoKSB7XG4gICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgdmFyIGFwcGVuZFRvID0gaW5zdGFuY2UucHJvcHMuYXBwZW5kVG87XG4gICAgdmFyIHBhcmVudE5vZGU7IC8vIEJ5IGRlZmF1bHQsIHdlJ2xsIGFwcGVuZCB0aGUgcG9wcGVyIHRvIHRoZSB0cmlnZ2VyVGFyZ2V0cydzIHBhcmVudE5vZGUgc29cbiAgICAvLyBpdCdzIGRpcmVjdGx5IGFmdGVyIHRoZSByZWZlcmVuY2UgZWxlbWVudCBzbyB0aGUgZWxlbWVudHMgaW5zaWRlIHRoZVxuICAgIC8vIHRpcHB5IGNhbiBiZSB0YWJiZWQgdG9cbiAgICAvLyBJZiB0aGVyZSBhcmUgY2xpcHBpbmcgaXNzdWVzLCB0aGUgdXNlciBjYW4gc3BlY2lmeSBhIGRpZmZlcmVudCBhcHBlbmRUb1xuICAgIC8vIGFuZCBlbnN1cmUgZm9jdXMgbWFuYWdlbWVudCBpcyBoYW5kbGVkIGNvcnJlY3RseSBtYW51YWxseVxuXG4gICAgdmFyIG5vZGUgPSBnZXRDdXJyZW50VGFyZ2V0KCk7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgYXBwZW5kVG8gPT09IFRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPIHx8IGFwcGVuZFRvID09PSAncGFyZW50Jykge1xuICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZSA9IGludm9rZVdpdGhBcmdzT3JSZXR1cm4oYXBwZW5kVG8sIFtub2RlXSk7XG4gICAgfSAvLyBUaGUgcG9wcGVyIGVsZW1lbnQgbmVlZHMgdG8gZXhpc3Qgb24gdGhlIERPTSBiZWZvcmUgaXRzIHBvc2l0aW9uIGNhbiBiZVxuICAgIC8vIHVwZGF0ZWQgYXMgUG9wcGVyIG5lZWRzIHRvIHJlYWQgaXRzIGRpbWVuc2lvbnNcblxuXG4gICAgaWYgKCFwYXJlbnROb2RlLmNvbnRhaW5zKHBvcHBlcikpIHtcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocG9wcGVyKTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNyZWF0ZVBvcHBlckluc3RhbmNlKCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIC8vIEFjY2Vzc2liaWxpdHkgY2hlY2tcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGFwcGVuZFRvID09PSBkZWZhdWx0UHJvcHMuYXBwZW5kVG8gJiYgbm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgIT09IHBvcHBlciwgWydJbnRlcmFjdGl2ZSB0aXBweSBlbGVtZW50IG1heSBub3QgYmUgYWNjZXNzaWJsZSB2aWEga2V5Ym9hcmQnLCAnbmF2aWdhdGlvbiBiZWNhdXNlIGl0IGlzIG5vdCBkaXJlY3RseSBhZnRlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQnLCAnaW4gdGhlIERPTSBzb3VyY2Ugb3JkZXIuJywgJ1xcblxcbicsICdVc2luZyBhIHdyYXBwZXIgPGRpdj4gb3IgPHNwYW4+IHRhZyBhcm91bmQgdGhlIHJlZmVyZW5jZSBlbGVtZW50JywgJ3NvbHZlcyB0aGlzIGJ5IGNyZWF0aW5nIGEgbmV3IHBhcmVudE5vZGUgY29udGV4dC4nLCAnXFxuXFxuJywgJ1NwZWNpZnlpbmcgYGFwcGVuZFRvOiBkb2N1bWVudC5ib2R5YCBzaWxlbmNlcyB0aGlzIHdhcm5pbmcsIGJ1dCBpdCcsICdhc3N1bWVzIHlvdSBhcmUgdXNpbmcgYSBmb2N1cyBtYW5hZ2VtZW50IHNvbHV0aW9uIHRvIGhhbmRsZScsICdrZXlib2FyZCBuYXZpZ2F0aW9uLicsICdcXG5cXG4nLCAnU2VlOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvdjYvYWNjZXNzaWJpbGl0eS8jaW50ZXJhY3Rpdml0eSddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmVzdGVkUG9wcGVyVHJlZSgpIHtcbiAgICByZXR1cm4gYXJyYXlGcm9tKHBvcHBlci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10aXBweS1yb290XScpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlU2hvdyhldmVudCkge1xuICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBpbnZva2VIb29rKCdvblRyaWdnZXInLCBbaW5zdGFuY2UsIGV2ZW50XSk7XG4gICAgfVxuXG4gICAgYWRkRG9jdW1lbnRQcmVzcygpO1xuICAgIHZhciBkZWxheSA9IGdldERlbGF5KHRydWUpO1xuXG4gICAgdmFyIF9nZXROb3JtYWxpemVkVG91Y2hTZSA9IGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKCksXG4gICAgICAgIHRvdWNoVmFsdWUgPSBfZ2V0Tm9ybWFsaXplZFRvdWNoU2VbMF0sXG4gICAgICAgIHRvdWNoRGVsYXkgPSBfZ2V0Tm9ybWFsaXplZFRvdWNoU2VbMV07XG5cbiAgICBpZiAoY3VycmVudElucHV0LmlzVG91Y2ggJiYgdG91Y2hWYWx1ZSA9PT0gJ2hvbGQnICYmIHRvdWNoRGVsYXkpIHtcbiAgICAgIGRlbGF5ID0gdG91Y2hEZWxheTtcbiAgICB9XG5cbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIHNob3dUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlLnNob3coKTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2Uuc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlSGlkZShldmVudCkge1xuICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgIGludm9rZUhvb2soJ29uVW50cmlnZ2VyJywgW2luc3RhbmNlLCBldmVudF0pO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIHJlbW92ZURvY3VtZW50UHJlc3MoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZvciBpbnRlcmFjdGl2ZSB0aXBwaWVzLCBzY2hlZHVsZUhpZGUgaXMgYWRkZWQgdG8gYSBkb2N1bWVudC5ib2R5IGhhbmRsZXJcbiAgICAvLyBmcm9tIG9uTW91c2VMZWF2ZSBzbyBtdXN0IGludGVyY2VwdCBzY2hlZHVsZWQgaGlkZXMgZnJvbSBtb3VzZW1vdmUvbGVhdmVcbiAgICAvLyBldmVudHMgd2hlbiB0cmlnZ2VyIGNvbnRhaW5zIG1vdXNlZW50ZXIgYW5kIGNsaWNrLCBhbmQgdGhlIHRpcCBpc1xuICAgIC8vIGN1cnJlbnRseSBzaG93biBhcyBhIHJlc3VsdCBvZiBhIGNsaWNrLlxuXG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdtb3VzZWVudGVyJykgPj0gMCAmJiBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2NsaWNrJykgPj0gMCAmJiBbJ21vdXNlbGVhdmUnLCAnbW91c2Vtb3ZlJ10uaW5kZXhPZihldmVudC50eXBlKSA+PSAwICYmIGlzVmlzaWJsZUZyb21DbGljaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkZWxheSA9IGdldERlbGF5KGZhbHNlKTtcblxuICAgIGlmIChkZWxheSkge1xuICAgICAgaGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaXhlcyBhIGB0cmFuc2l0aW9uZW5kYCBwcm9ibGVtIHdoZW4gaXQgZmlyZXMgMSBmcmFtZSB0b29cbiAgICAgIC8vIGxhdGUgc29tZXRpbWVzLCB3ZSBkb24ndCB3YW50IGhpZGUoKSB0byBiZSBjYWxsZWQuXG4gICAgICBzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+UkSBQdWJsaWMgbWV0aG9kc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAvLyBEaXNhYmxpbmcgdGhlIGluc3RhbmNlIHNob3VsZCBhbHNvIGhpZGUgaXRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXRvbWlrcy90aXBweS5qcy1yZWFjdC9pc3N1ZXMvMTA2XG4gICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgIGluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJEZWxheVRpbWVvdXRzKCkge1xuICAgIGNsZWFyVGltZW91dChzaG93VGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KGhpZGVUaW1lb3V0KTtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcm9wcyhwYXJ0aWFsUHJvcHMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnc2V0UHJvcHMnKSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25CZWZvcmVVcGRhdGUnLCBbaW5zdGFuY2UsIHBhcnRpYWxQcm9wc10pO1xuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgIHZhciBwcmV2UHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gZXZhbHVhdGVQcm9wcyhyZWZlcmVuY2UsIE9iamVjdC5hc3NpZ24oe30sIHByZXZQcm9wcywgcmVtb3ZlVW5kZWZpbmVkUHJvcHMocGFydGlhbFByb3BzKSwge1xuICAgICAgaWdub3JlQXR0cmlidXRlczogdHJ1ZVxuICAgIH0pKTtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBhZGRMaXN0ZW5lcnMoKTtcblxuICAgIGlmIChwcmV2UHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSAhPT0gbmV4dFByb3BzLmludGVyYWN0aXZlRGVib3VuY2UpIHtcbiAgICAgIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCk7XG4gICAgICBkZWJvdW5jZWRPbk1vdXNlTW92ZSA9IGRlYm91bmNlKG9uTW91c2VNb3ZlLCBuZXh0UHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSk7XG4gICAgfSAvLyBFbnN1cmUgc3RhbGUgYXJpYS1leHBhbmRlZCBhdHRyaWJ1dGVzIGFyZSByZW1vdmVkXG5cblxuICAgIGlmIChwcmV2UHJvcHMudHJpZ2dlclRhcmdldCAmJiAhbmV4dFByb3BzLnRyaWdnZXJUYXJnZXQpIHtcbiAgICAgIG5vcm1hbGl6ZVRvQXJyYXkocHJldlByb3BzLnRyaWdnZXJUYXJnZXQpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobmV4dFByb3BzLnRyaWdnZXJUYXJnZXQpIHtcbiAgICAgIHJlZmVyZW5jZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICB9XG5cbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcbiAgICBoYW5kbGVTdHlsZXMoKTtcblxuICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgb25VcGRhdGUocHJldlByb3BzLCBuZXh0UHJvcHMpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgY3JlYXRlUG9wcGVySW5zdGFuY2UoKTsgLy8gRml4ZXMgYW4gaXNzdWUgd2l0aCBuZXN0ZWQgdGlwcGllcyBpZiB0aGV5IGFyZSBhbGwgZ2V0dGluZyByZS1yZW5kZXJlZCxcbiAgICAgIC8vIGFuZCB0aGUgbmVzdGVkIG9uZXMgZ2V0IHJlLXJlbmRlcmVkIGZpcnN0LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F0b21pa3MvdGlwcHlqcy1yZWFjdC9pc3N1ZXMvMTc3XG4gICAgICAvLyBUT0RPOiBmaW5kIGEgY2xlYW5lciAvIG1vcmUgZWZmaWNpZW50IHNvbHV0aW9uKCEpXG5cbiAgICAgIGdldE5lc3RlZFBvcHBlclRyZWUoKS5mb3JFYWNoKGZ1bmN0aW9uIChuZXN0ZWRQb3BwZXIpIHtcbiAgICAgICAgLy8gUmVhY3QgKGFuZCBvdGhlciBVSSBsaWJzIGxpa2VseSkgcmVxdWlyZXMgYSByQUYgd3JhcHBlciBhcyBpdCBmbHVzaGVzXG4gICAgICAgIC8vIGl0cyB3b3JrIGluIG9uZVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobmVzdGVkUG9wcGVyLl90aXBweS5wb3BwZXJJbnN0YW5jZS5mb3JjZVVwZGF0ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvbkFmdGVyVXBkYXRlJywgW2luc3RhbmNlLCBwYXJ0aWFsUHJvcHNdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbnRlbnQoY29udGVudCkge1xuICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3coKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ3Nob3cnKSk7XG4gICAgfSAvLyBFYXJseSBiYWlsLW91dFxuXG5cbiAgICB2YXIgaXNBbHJlYWR5VmlzaWJsZSA9IGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZDtcbiAgICB2YXIgaXNEaXNhYmxlZCA9ICFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQ7XG4gICAgdmFyIGlzVG91Y2hBbmRUb3VjaERpc2FibGVkID0gY3VycmVudElucHV0LmlzVG91Y2ggJiYgIWluc3RhbmNlLnByb3BzLnRvdWNoO1xuICAgIHZhciBkdXJhdGlvbiA9IGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKGluc3RhbmNlLnByb3BzLmR1cmF0aW9uLCAwLCBkZWZhdWx0UHJvcHMuZHVyYXRpb24pO1xuXG4gICAgaWYgKGlzQWxyZWFkeVZpc2libGUgfHwgaXNEZXN0cm95ZWQgfHwgaXNEaXNhYmxlZCB8fCBpc1RvdWNoQW5kVG91Y2hEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gTm9ybWFsaXplIGBkaXNhYmxlZGAgYmVoYXZpb3IgYWNyb3NzIGJyb3dzZXJzLlxuICAgIC8vIEZpcmVmb3ggYWxsb3dzIGV2ZW50cyBvbiBkaXNhYmxlZCBlbGVtZW50cywgYnV0IENocm9tZSBkb2Vzbid0LlxuICAgIC8vIFVzaW5nIGEgd3JhcHBlciBlbGVtZW50IChpLmUuIDxzcGFuPikgaXMgcmVjb21tZW5kZWQuXG5cblxuICAgIGlmIChnZXRDdXJyZW50VGFyZ2V0KCkuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25TaG93JywgW2luc3RhbmNlXSwgZmFsc2UpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLm9uU2hvdyhpbnN0YW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlID0gdHJ1ZTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICBwb3BwZXIuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICB9XG5cbiAgICBoYW5kbGVTdHlsZXMoKTtcbiAgICBhZGREb2N1bWVudFByZXNzKCk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgcG9wcGVyLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XG4gICAgfSAvLyBJZiBmbGlwcGluZyB0byB0aGUgb3Bwb3NpdGUgc2lkZSBhZnRlciBoaWRpbmcgYXQgbGVhc3Qgb25jZSwgdGhlXG4gICAgLy8gYW5pbWF0aW9uIHdpbGwgdXNlIHRoZSB3cm9uZyBwbGFjZW1lbnQgd2l0aG91dCByZXNldHRpbmcgdGhlIGR1cmF0aW9uXG5cblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICB2YXIgX2dldERlZmF1bHRUZW1wbGF0ZUNoMiA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCksXG4gICAgICAgICAgYm94ID0gX2dldERlZmF1bHRUZW1wbGF0ZUNoMi5ib3gsXG4gICAgICAgICAgY29udGVudCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDIuY29udGVudDtcblxuICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtib3gsIGNvbnRlbnRdLCAwKTtcbiAgICB9XG5cbiAgICBvbkZpcnN0VXBkYXRlID0gZnVuY3Rpb24gb25GaXJzdFVwZGF0ZSgpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkcG9wcGVySW5zdGEyO1xuXG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSB8fCBpZ25vcmVPbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWdub3JlT25GaXJzdFVwZGF0ZSA9IHRydWU7IC8vIHJlZmxvd1xuXG4gICAgICB2b2lkIHBvcHBlci5vZmZzZXRIZWlnaHQ7XG4gICAgICBwb3BwZXIuc3R5bGUudHJhbnNpdGlvbiA9IGluc3RhbmNlLnByb3BzLm1vdmVUcmFuc2l0aW9uO1xuXG4gICAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSAmJiBpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24pIHtcbiAgICAgICAgdmFyIF9nZXREZWZhdWx0VGVtcGxhdGVDaDMgPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpLFxuICAgICAgICAgICAgX2JveCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDMuYm94LFxuICAgICAgICAgICAgX2NvbnRlbnQgPSBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2gzLmNvbnRlbnQ7XG5cbiAgICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtfYm94LCBfY29udGVudF0sIGR1cmF0aW9uKTtcbiAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtfYm94LCBfY29udGVudF0sICd2aXNpYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlKCk7XG4gICAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcbiAgICAgIHB1c2hJZlVuaXF1ZShtb3VudGVkSW5zdGFuY2VzLCBpbnN0YW5jZSk7IC8vIGNlcnRhaW4gbW9kaWZpZXJzIChlLmcuIGBtYXhTaXplYCkgcmVxdWlyZSBhIHNlY29uZCB1cGRhdGUgYWZ0ZXIgdGhlXG4gICAgICAvLyBwb3BwZXIgaGFzIGJlZW4gcG9zaXRpb25lZCBmb3IgdGhlIGZpcnN0IHRpbWVcblxuICAgICAgKF9pbnN0YW5jZSRwb3BwZXJJbnN0YTIgPSBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRwb3BwZXJJbnN0YTIuZm9yY2VVcGRhdGUoKTtcbiAgICAgIGludm9rZUhvb2soJ29uTW91bnQnLCBbaW5zdGFuY2VdKTtcblxuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmFuaW1hdGlvbiAmJiBnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICAgIG9uVHJhbnNpdGlvbmVkSW4oZHVyYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZS5pc1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICBpbnZva2VIb29rKCdvblNob3duJywgW2luc3RhbmNlXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBtb3VudCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnaGlkZScpKTtcbiAgICB9IC8vIEVhcmx5IGJhaWwtb3V0XG5cblxuICAgIHZhciBpc0FscmVhZHlIaWRkZW4gPSAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkO1xuICAgIHZhciBpc0Rpc2FibGVkID0gIWluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZDtcbiAgICB2YXIgZHVyYXRpb24gPSBnZXRWYWx1ZUF0SW5kZXhPclJldHVybihpbnN0YW5jZS5wcm9wcy5kdXJhdGlvbiwgMSwgZGVmYXVsdFByb3BzLmR1cmF0aW9uKTtcblxuICAgIGlmIChpc0FscmVhZHlIaWRkZW4gfHwgaXNEZXN0cm95ZWQgfHwgaXNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludm9rZUhvb2soJ29uSGlkZScsIFtpbnN0YW5jZV0sIGZhbHNlKTtcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5vbkhpZGUoaW5zdGFuY2UpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgIGluc3RhbmNlLnN0YXRlLmlzU2hvd24gPSBmYWxzZTtcbiAgICBpZ25vcmVPbkZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgaXNWaXNpYmxlRnJvbUNsaWNrID0gZmFsc2U7XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgcG9wcGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICB9XG5cbiAgICBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpO1xuICAgIHJlbW92ZURvY3VtZW50UHJlc3MoKTtcbiAgICBoYW5kbGVTdHlsZXModHJ1ZSk7XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgdmFyIF9nZXREZWZhdWx0VGVtcGxhdGVDaDQgPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpLFxuICAgICAgICAgIGJveCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDQuYm94LFxuICAgICAgICAgIGNvbnRlbnQgPSBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2g0LmNvbnRlbnQ7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24pIHtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtib3gsIGNvbnRlbnRdLCBkdXJhdGlvbik7XG4gICAgICAgIHNldFZpc2liaWxpdHlTdGF0ZShbYm94LCBjb250ZW50XSwgJ2hpZGRlbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlKCk7XG4gICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgICBvblRyYW5zaXRpb25lZE91dChkdXJhdGlvbiwgaW5zdGFuY2UudW5tb3VudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnVubW91bnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlV2l0aEludGVyYWN0aXZpdHkoZXZlbnQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnaGlkZVdpdGhJbnRlcmFjdGl2aXR5JykpO1xuICAgIH1cblxuICAgIGdldERvY3VtZW50KCkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIHB1c2hJZlVuaXF1ZShtb3VzZU1vdmVMaXN0ZW5lcnMsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICBkZWJvdW5jZWRPbk1vdXNlTW92ZShldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCd1bm1vdW50JykpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlc3Ryb3lQb3BwZXJJbnN0YW5jZSgpOyAvLyBJZiBhIHBvcHBlciBpcyBub3QgaW50ZXJhY3RpdmUsIGl0IHdpbGwgYmUgYXBwZW5kZWQgb3V0c2lkZSB0aGUgcG9wcGVyXG4gICAgLy8gdHJlZSBieSBkZWZhdWx0LiBUaGlzIHNlZW1zIG1haW5seSBmb3IgaW50ZXJhY3RpdmUgdGlwcGllcywgYnV0IHdlIHNob3VsZFxuICAgIC8vIGZpbmQgYSB3b3JrYXJvdW5kIGlmIHBvc3NpYmxlXG5cbiAgICBnZXROZXN0ZWRQb3BwZXJUcmVlKCkuZm9yRWFjaChmdW5jdGlvbiAobmVzdGVkUG9wcGVyKSB7XG4gICAgICBuZXN0ZWRQb3BwZXIuX3RpcHB5LnVubW91bnQoKTtcbiAgICB9KTtcblxuICAgIGlmIChwb3BwZXIucGFyZW50Tm9kZSkge1xuICAgICAgcG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocG9wcGVyKTtcbiAgICB9XG5cbiAgICBtb3VudGVkSW5zdGFuY2VzID0gbW91bnRlZEluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBpICE9PSBpbnN0YW5jZTtcbiAgICB9KTtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICBpbnZva2VIb29rKCdvbkhpZGRlbicsIFtpbnN0YW5jZV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnZGVzdHJveScpKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICBpbnN0YW5jZS51bm1vdW50KCk7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgZGVsZXRlIHJlZmVyZW5jZS5fdGlwcHk7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIGludm9rZUhvb2soJ29uRGVzdHJveScsIFtpbnN0YW5jZV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRpcHB5KHRhcmdldHMsIG9wdGlvbmFsUHJvcHMpIHtcbiAgaWYgKG9wdGlvbmFsUHJvcHMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbmFsUHJvcHMgPSB7fTtcbiAgfVxuXG4gIHZhciBwbHVnaW5zID0gZGVmYXVsdFByb3BzLnBsdWdpbnMuY29uY2F0KG9wdGlvbmFsUHJvcHMucGx1Z2lucyB8fCBbXSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgICB2YWxpZGF0ZVByb3BzKG9wdGlvbmFsUHJvcHMsIHBsdWdpbnMpO1xuICB9XG5cbiAgYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzKCk7XG4gIHZhciBwYXNzZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbmFsUHJvcHMsIHtcbiAgICBwbHVnaW5zOiBwbHVnaW5zXG4gIH0pO1xuICB2YXIgZWxlbWVudHMgPSBnZXRBcnJheU9mRWxlbWVudHModGFyZ2V0cyk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciBpc1NpbmdsZUNvbnRlbnRFbGVtZW50ID0gaXNFbGVtZW50KHBhc3NlZFByb3BzLmNvbnRlbnQpO1xuICAgIHZhciBpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCA9IGVsZW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgd2FybldoZW4oaXNTaW5nbGVDb250ZW50RWxlbWVudCAmJiBpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCwgWyd0aXBweSgpIHdhcyBwYXNzZWQgYW4gRWxlbWVudCBhcyB0aGUgYGNvbnRlbnRgIHByb3AsIGJ1dCBtb3JlIHRoYW4nLCAnb25lIHRpcHB5IGluc3RhbmNlIHdhcyBjcmVhdGVkIGJ5IHRoaXMgaW52b2NhdGlvbi4gVGhpcyBtZWFucyB0aGUnLCAnY29udGVudCBlbGVtZW50IHdpbGwgb25seSBiZSBhcHBlbmRlZCB0byB0aGUgbGFzdCB0aXBweSBpbnN0YW5jZS4nLCAnXFxuXFxuJywgJ0luc3RlYWQsIHBhc3MgdGhlIC5pbm5lckhUTUwgb2YgdGhlIGVsZW1lbnQsIG9yIHVzZSBhIGZ1bmN0aW9uIHRoYXQnLCAncmV0dXJucyBhIGNsb25lZCB2ZXJzaW9uIG9mIHRoZSBlbGVtZW50IGluc3RlYWQuJywgJ1xcblxcbicsICcxKSBjb250ZW50OiBlbGVtZW50LmlubmVySFRNTFxcbicsICcyKSBjb250ZW50OiAoKSA9PiBlbGVtZW50LmNsb25lTm9kZSh0cnVlKSddLmpvaW4oJyAnKSk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2VzID0gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHJlZmVyZW5jZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHJlZmVyZW5jZSAmJiBjcmVhdGVUaXBweShyZWZlcmVuY2UsIHBhc3NlZFByb3BzKTtcblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgYWNjLnB1c2goaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlzRWxlbWVudCh0YXJnZXRzKSA/IGluc3RhbmNlc1swXSA6IGluc3RhbmNlcztcbn1cblxudGlwcHkuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xudGlwcHkuc2V0RGVmYXVsdFByb3BzID0gc2V0RGVmYXVsdFByb3BzO1xudGlwcHkuY3VycmVudElucHV0ID0gY3VycmVudElucHV0O1xudmFyIGhpZGVBbGwgPSBmdW5jdGlvbiBoaWRlQWxsKF90ZW1wKSB7XG4gIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICBleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UgPSBfcmVmLmV4Y2x1ZGUsXG4gICAgICBkdXJhdGlvbiA9IF9yZWYuZHVyYXRpb247XG5cbiAgbW91bnRlZEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHZhciBpc0V4Y2x1ZGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlKSB7XG4gICAgICBpc0V4Y2x1ZGVkID0gaXNSZWZlcmVuY2VFbGVtZW50KGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSkgPyBpbnN0YW5jZS5yZWZlcmVuY2UgPT09IGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSA6IGluc3RhbmNlLnBvcHBlciA9PT0gZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlLnBvcHBlcjtcbiAgICB9XG5cbiAgICBpZiAoIWlzRXhjbHVkZWQpIHtcbiAgICAgIHZhciBvcmlnaW5hbER1cmF0aW9uID0gaW5zdGFuY2UucHJvcHMuZHVyYXRpb247XG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgICAgfSk7XG4gICAgICBpbnN0YW5jZS5oaWRlKCk7XG5cbiAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICAgIGR1cmF0aW9uOiBvcmlnaW5hbER1cmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBldmVyeSB0aW1lIHRoZSBwb3BwZXIgaXMgZGVzdHJveWVkIChpLmUuIGEgbmV3IHRhcmdldCksIHJlbW92aW5nIHRoZSBzdHlsZXNcbi8vIGFuZCBjYXVzaW5nIHRyYW5zaXRpb25zIHRvIGJyZWFrIGZvciBzaW5nbGV0b25zIHdoZW4gdGhlIGNvbnNvbGUgaXMgb3BlbiwgYnV0XG4vLyBtb3N0IG5vdGFibHkgZm9yIG5vbi10cmFuc2Zvcm0gc3R5bGVzIGJlaW5nIHVzZWQsIGBncHVBY2NlbGVyYXRpb246IGZhbHNlYC5cblxudmFyIGFwcGx5U3R5bGVzTW9kaWZpZXIgPSBPYmplY3QuYXNzaWduKHt9LCBhcHBseVN0eWxlcywge1xuICBlZmZlY3Q6IGZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICAgIHBvcHBlcjoge1xuICAgICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgICAgbGVmdDogJzAnLFxuICAgICAgICB0b3A6ICcwJyxcbiAgICAgICAgbWFyZ2luOiAnMCdcbiAgICAgIH0sXG4gICAgICBhcnJvdzoge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgfSxcbiAgICAgIHJlZmVyZW5jZToge31cbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gICAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICAgIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gICAgfSAvLyBpbnRlbnRpb25hbGx5IHJldHVybiBubyBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgLy8gcmV0dXJuICgpID0+IHsgLi4uIH1cblxuICB9XG59KTtcblxudmFyIGNyZWF0ZVNpbmdsZXRvbiA9IGZ1bmN0aW9uIGNyZWF0ZVNpbmdsZXRvbih0aXBweUluc3RhbmNlcywgb3B0aW9uYWxQcm9wcykge1xuICB2YXIgX29wdGlvbmFsUHJvcHMkcG9wcGVyO1xuXG4gIGlmIChvcHRpb25hbFByb3BzID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25hbFByb3BzID0ge307XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZXJyb3JXaGVuKCFBcnJheS5pc0FycmF5KHRpcHB5SW5zdGFuY2VzKSwgWydUaGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVNpbmdsZXRvbigpIG11c3QgYmUgYW4gYXJyYXkgb2YnLCAndGlwcHkgaW5zdGFuY2VzLiBUaGUgcGFzc2VkIHZhbHVlIHdhcycsIFN0cmluZyh0aXBweUluc3RhbmNlcyldLmpvaW4oJyAnKSk7XG4gIH1cblxuICB2YXIgaW5kaXZpZHVhbEluc3RhbmNlcyA9IHRpcHB5SW5zdGFuY2VzO1xuICB2YXIgcmVmZXJlbmNlcyA9IFtdO1xuICB2YXIgdHJpZ2dlclRhcmdldHMgPSBbXTtcbiAgdmFyIGN1cnJlbnRUYXJnZXQ7XG4gIHZhciBvdmVycmlkZXMgPSBvcHRpb25hbFByb3BzLm92ZXJyaWRlcztcbiAgdmFyIGludGVyY2VwdFNldFByb3BzQ2xlYW51cHMgPSBbXTtcbiAgdmFyIHNob3duT25DcmVhdGUgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzZXRUcmlnZ2VyVGFyZ2V0cygpIHtcbiAgICB0cmlnZ2VyVGFyZ2V0cyA9IGluZGl2aWR1YWxJbnN0YW5jZXMubWFwKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCBpbnN0YW5jZS5yZWZlcmVuY2UpO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpdGVtKSB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChpdGVtKTtcbiAgICB9LCBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRSZWZlcmVuY2VzKCkge1xuICAgIHJlZmVyZW5jZXMgPSBpbmRpdmlkdWFsSW5zdGFuY2VzLm1hcChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5yZWZlcmVuY2U7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmFibGVJbnN0YW5jZXMoaXNFbmFibGVkKSB7XG4gICAgaW5kaXZpZHVhbEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgaWYgKGlzRW5hYmxlZCkge1xuICAgICAgICBpbnN0YW5jZS5lbmFibGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVyY2VwdFNldFByb3BzKHNpbmdsZXRvbikge1xuICAgIHJldHVybiBpbmRpdmlkdWFsSW5zdGFuY2VzLm1hcChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIHZhciBvcmlnaW5hbFNldFByb3BzID0gaW5zdGFuY2Uuc2V0UHJvcHM7XG5cbiAgICAgIGluc3RhbmNlLnNldFByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIG9yaWdpbmFsU2V0UHJvcHMocHJvcHMpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZS5yZWZlcmVuY2UgPT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICBzaW5nbGV0b24uc2V0UHJvcHMocHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyA9IG9yaWdpbmFsU2V0UHJvcHM7XG4gICAgICB9O1xuICAgIH0pO1xuICB9IC8vIGhhdmUgdG8gcGFzcyBzaW5nbGV0b24sIGFzIGl0IG1heWJlIHVuZGVmaW5lZCBvbiBmaXJzdCBjYWxsXG5cblxuICBmdW5jdGlvbiBwcmVwYXJlSW5zdGFuY2Uoc2luZ2xldG9uLCB0YXJnZXQpIHtcbiAgICB2YXIgaW5kZXggPSB0cmlnZ2VyVGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7IC8vIGJhaWwtb3V0XG5cbiAgICBpZiAodGFyZ2V0ID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgICB2YXIgb3ZlcnJpZGVQcm9wcyA9IChvdmVycmlkZXMgfHwgW10pLmNvbmNhdCgnY29udGVudCcpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwcm9wKSB7XG4gICAgICBhY2NbcHJvcF0gPSBpbmRpdmlkdWFsSW5zdGFuY2VzW2luZGV4XS5wcm9wc1twcm9wXTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHNpbmdsZXRvbi5zZXRQcm9wcyhPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZVByb3BzLCB7XG4gICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiB0eXBlb2Ygb3ZlcnJpZGVQcm9wcy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nID8gb3ZlcnJpZGVQcm9wcy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZmVyZW5jZXMkaW5kZXg7XG5cbiAgICAgICAgcmV0dXJuIChfcmVmZXJlbmNlcyRpbmRleCA9IHJlZmVyZW5jZXNbaW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX3JlZmVyZW5jZXMkaW5kZXguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgZW5hYmxlSW5zdGFuY2VzKGZhbHNlKTtcbiAgc2V0UmVmZXJlbmNlcygpO1xuICBzZXRUcmlnZ2VyVGFyZ2V0cygpO1xuICB2YXIgcGx1Z2luID0ge1xuICAgIGZuOiBmdW5jdGlvbiBmbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9uRGVzdHJveTogZnVuY3Rpb24gb25EZXN0cm95KCkge1xuICAgICAgICAgIGVuYWJsZUluc3RhbmNlcyh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25IaWRkZW46IGZ1bmN0aW9uIG9uSGlkZGVuKCkge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrT3V0c2lkZTogZnVuY3Rpb24gb25DbGlja091dHNpZGUoaW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuc2hvd09uQ3JlYXRlICYmICFzaG93bk9uQ3JlYXRlKSB7XG4gICAgICAgICAgICBzaG93bk9uQ3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25TaG93OiBmdW5jdGlvbiBvblNob3coaW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuc2hvd09uQ3JlYXRlICYmICFzaG93bk9uQ3JlYXRlKSB7XG4gICAgICAgICAgICBzaG93bk9uQ3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHByZXBhcmVJbnN0YW5jZShpbnN0YW5jZSwgcmVmZXJlbmNlc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblRyaWdnZXI6IGZ1bmN0aW9uIG9uVHJpZ2dlcihpbnN0YW5jZSwgZXZlbnQpIHtcbiAgICAgICAgICBwcmVwYXJlSW5zdGFuY2UoaW5zdGFuY2UsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdmFyIHNpbmdsZXRvbiA9IHRpcHB5KGRpdigpLCBPYmplY3QuYXNzaWduKHt9LCByZW1vdmVQcm9wZXJ0aWVzKG9wdGlvbmFsUHJvcHMsIFsnb3ZlcnJpZGVzJ10pLCB7XG4gICAgcGx1Z2luczogW3BsdWdpbl0uY29uY2F0KG9wdGlvbmFsUHJvcHMucGx1Z2lucyB8fCBbXSksXG4gICAgdHJpZ2dlclRhcmdldDogdHJpZ2dlclRhcmdldHMsXG4gICAgcG9wcGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9uYWxQcm9wcy5wb3BwZXJPcHRpb25zLCB7XG4gICAgICBtb2RpZmllcnM6IFtdLmNvbmNhdCgoKF9vcHRpb25hbFByb3BzJHBvcHBlciA9IG9wdGlvbmFsUHJvcHMucG9wcGVyT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRpb25hbFByb3BzJHBvcHBlci5tb2RpZmllcnMpIHx8IFtdLCBbYXBwbHlTdHlsZXNNb2RpZmllcl0pXG4gICAgfSlcbiAgfSkpO1xuICB2YXIgb3JpZ2luYWxTaG93ID0gc2luZ2xldG9uLnNob3c7XG5cbiAgc2luZ2xldG9uLnNob3cgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgb3JpZ2luYWxTaG93KCk7IC8vIGZpcnN0IHRpbWUsIHNob3dPbkNyZWF0ZSBvciBwcm9ncmFtbWF0aWMgY2FsbCB3aXRoIG5vIHBhcmFtc1xuICAgIC8vIGRlZmF1bHQgdG8gc2hvd2luZyBmaXJzdCBpbnN0YW5jZVxuXG4gICAgaWYgKCFjdXJyZW50VGFyZ2V0ICYmIHRhcmdldCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcHJlcGFyZUluc3RhbmNlKHNpbmdsZXRvbiwgcmVmZXJlbmNlc1swXSk7XG4gICAgfSAvLyB0cmlnZ2VyZWQgZnJvbSBldmVudCAoZG8gbm90aGluZyBhcyBwcmVwYXJlSW5zdGFuY2UgYWxyZWFkeSBjYWxsZWQgYnkgb25UcmlnZ2VyKVxuICAgIC8vIHByb2dyYW1tYXRpYyBjYWxsIHdpdGggbm8gcGFyYW1zIHdoZW4gYWxyZWFkeSB2aXNpYmxlIChkbyBub3RoaW5nIGFnYWluKVxuXG5cbiAgICBpZiAoY3VycmVudFRhcmdldCAmJiB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gdGFyZ2V0IGlzIGluZGV4IG9mIGluc3RhbmNlXG5cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHJlZmVyZW5jZXNbdGFyZ2V0XSAmJiBwcmVwYXJlSW5zdGFuY2Uoc2luZ2xldG9uLCByZWZlcmVuY2VzW3RhcmdldF0pO1xuICAgIH0gLy8gdGFyZ2V0IGlzIGEgY2hpbGQgdGlwcHkgaW5zdGFuY2VcblxuXG4gICAgaWYgKGluZGl2aWR1YWxJbnN0YW5jZXMuaW5kZXhPZih0YXJnZXQpID49IDApIHtcbiAgICAgIHZhciByZWYgPSB0YXJnZXQucmVmZXJlbmNlO1xuICAgICAgcmV0dXJuIHByZXBhcmVJbnN0YW5jZShzaW5nbGV0b24sIHJlZik7XG4gICAgfSAvLyB0YXJnZXQgaXMgYSBSZWZlcmVuY2VFbGVtZW50XG5cblxuICAgIGlmIChyZWZlcmVuY2VzLmluZGV4T2YodGFyZ2V0KSA+PSAwKSB7XG4gICAgICByZXR1cm4gcHJlcGFyZUluc3RhbmNlKHNpbmdsZXRvbiwgdGFyZ2V0KTtcbiAgICB9XG4gIH07XG5cbiAgc2luZ2xldG9uLnNob3dOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaXJzdCA9IHJlZmVyZW5jZXNbMF07XG5cbiAgICBpZiAoIWN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBzaW5nbGV0b24uc2hvdygwKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSByZWZlcmVuY2VzLmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgc2luZ2xldG9uLnNob3cocmVmZXJlbmNlc1tpbmRleCArIDFdIHx8IGZpcnN0KTtcbiAgfTtcblxuICBzaW5nbGV0b24uc2hvd1ByZXZpb3VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYXN0ID0gcmVmZXJlbmNlc1tyZWZlcmVuY2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKCFjdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc2luZ2xldG9uLnNob3cobGFzdCk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gcmVmZXJlbmNlcy5pbmRleE9mKGN1cnJlbnRUYXJnZXQpO1xuICAgIHZhciB0YXJnZXQgPSByZWZlcmVuY2VzW2luZGV4IC0gMV0gfHwgbGFzdDtcbiAgICBzaW5nbGV0b24uc2hvdyh0YXJnZXQpO1xuICB9O1xuXG4gIHZhciBvcmlnaW5hbFNldFByb3BzID0gc2luZ2xldG9uLnNldFByb3BzO1xuXG4gIHNpbmdsZXRvbi5zZXRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIG92ZXJyaWRlcyA9IHByb3BzLm92ZXJyaWRlcyB8fCBvdmVycmlkZXM7XG4gICAgb3JpZ2luYWxTZXRQcm9wcyhwcm9wcyk7XG4gIH07XG5cbiAgc2luZ2xldG9uLnNldEluc3RhbmNlcyA9IGZ1bmN0aW9uIChuZXh0SW5zdGFuY2VzKSB7XG4gICAgZW5hYmxlSW5zdGFuY2VzKHRydWUpO1xuICAgIGludGVyY2VwdFNldFByb3BzQ2xlYW51cHMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0pO1xuICAgIGluZGl2aWR1YWxJbnN0YW5jZXMgPSBuZXh0SW5zdGFuY2VzO1xuICAgIGVuYWJsZUluc3RhbmNlcyhmYWxzZSk7XG4gICAgc2V0UmVmZXJlbmNlcygpO1xuICAgIHNldFRyaWdnZXJUYXJnZXRzKCk7XG4gICAgaW50ZXJjZXB0U2V0UHJvcHNDbGVhbnVwcyA9IGludGVyY2VwdFNldFByb3BzKHNpbmdsZXRvbik7XG4gICAgc2luZ2xldG9uLnNldFByb3BzKHtcbiAgICAgIHRyaWdnZXJUYXJnZXQ6IHRyaWdnZXJUYXJnZXRzXG4gICAgfSk7XG4gIH07XG5cbiAgaW50ZXJjZXB0U2V0UHJvcHNDbGVhbnVwcyA9IGludGVyY2VwdFNldFByb3BzKHNpbmdsZXRvbik7XG4gIHJldHVybiBzaW5nbGV0b247XG59O1xuXG52YXIgQlVCQkxJTkdfRVZFTlRTX01BUCA9IHtcbiAgbW91c2VvdmVyOiAnbW91c2VlbnRlcicsXG4gIGZvY3VzaW46ICdmb2N1cycsXG4gIGNsaWNrOiAnY2xpY2snXG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgZGVsZWdhdGUgaW5zdGFuY2UgdGhhdCBjb250cm9scyB0aGUgY3JlYXRpb24gb2YgdGlwcHkgaW5zdGFuY2VzXG4gKiBmb3IgY2hpbGQgZWxlbWVudHMgKGB0YXJnZXRgIENTUyBzZWxlY3RvcikuXG4gKi9cblxuZnVuY3Rpb24gZGVsZWdhdGUodGFyZ2V0cywgcHJvcHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGVycm9yV2hlbighKHByb3BzICYmIHByb3BzLnRhcmdldCksIFsnWW91IG11c3Qgc3BlY2l0eSBhIGB0YXJnZXRgIHByb3AgaW5kaWNhdGluZyBhIENTUyBzZWxlY3RvciBzdHJpbmcgbWF0Y2hpbmcnLCAndGhlIHRhcmdldCBlbGVtZW50cyB0aGF0IHNob3VsZCByZWNlaXZlIGEgdGlwcHkuJ10uam9pbignICcpKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGNoaWxkVGlwcHlJbnN0YW5jZXMgPSBbXTtcbiAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG4gIHZhciB0YXJnZXQgPSBwcm9wcy50YXJnZXQ7XG4gIHZhciBuYXRpdmVQcm9wcyA9IHJlbW92ZVByb3BlcnRpZXMocHJvcHMsIFsndGFyZ2V0J10pO1xuICB2YXIgcGFyZW50UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBuYXRpdmVQcm9wcywge1xuICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgIHRvdWNoOiBmYWxzZVxuICB9KTtcbiAgdmFyIGNoaWxkUHJvcHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICB0b3VjaDogZGVmYXVsdFByb3BzLnRvdWNoXG4gIH0sIG5hdGl2ZVByb3BzLCB7XG4gICAgc2hvd09uQ3JlYXRlOiB0cnVlXG4gIH0pO1xuICB2YXIgcmV0dXJuVmFsdWUgPSB0aXBweSh0YXJnZXRzLCBwYXJlbnRQcm9wcyk7XG4gIHZhciBub3JtYWxpemVkUmV0dXJuVmFsdWUgPSBub3JtYWxpemVUb0FycmF5KHJldHVyblZhbHVlKTtcblxuICBmdW5jdGlvbiBvblRyaWdnZXIoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LnRhcmdldCB8fCBkaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QodGFyZ2V0KTtcblxuICAgIGlmICghdGFyZ2V0Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gR2V0IHJlbGV2YW50IHRyaWdnZXIgd2l0aCBmYWxsYmFja3M6XG4gICAgLy8gMS4gQ2hlY2sgYGRhdGEtdGlwcHktdHJpZ2dlcmAgYXR0cmlidXRlIG9uIHRhcmdldCBub2RlXG4gICAgLy8gMi4gRmFsbGJhY2sgdG8gYHRyaWdnZXJgIHBhc3NlZCB0byBgZGVsZWdhdGUoKWBcbiAgICAvLyAzLiBGYWxsYmFjayB0byBgZGVmYXVsdFByb3BzLnRyaWdnZXJgXG5cblxuICAgIHZhciB0cmlnZ2VyID0gdGFyZ2V0Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGlwcHktdHJpZ2dlcicpIHx8IHByb3BzLnRyaWdnZXIgfHwgZGVmYXVsdFByb3BzLnRyaWdnZXI7IC8vIEB0cy1pZ25vcmVcblxuICAgIGlmICh0YXJnZXROb2RlLl90aXBweSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlID09PSAndG91Y2hzdGFydCcgJiYgdHlwZW9mIGNoaWxkUHJvcHMudG91Y2ggPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlICE9PSAndG91Y2hzdGFydCcgJiYgdHJpZ2dlci5pbmRleE9mKEJVQkJMSU5HX0VWRU5UU19NQVBbZXZlbnQudHlwZV0pIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHRpcHB5KHRhcmdldE5vZGUsIGNoaWxkUHJvcHMpO1xuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzID0gY2hpbGRUaXBweUluc3RhbmNlcy5jb25jYXQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKG5vZGUsIGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICBsaXN0ZW5lcnMucHVzaCh7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoaW5zdGFuY2UpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlO1xuICAgIG9uKHJlZmVyZW5jZSwgJ3RvdWNoc3RhcnQnLCBvblRyaWdnZXIsIFRPVUNIX09QVElPTlMpO1xuICAgIG9uKHJlZmVyZW5jZSwgJ21vdXNlb3ZlcicsIG9uVHJpZ2dlcik7XG4gICAgb24ocmVmZXJlbmNlLCAnZm9jdXNpbicsIG9uVHJpZ2dlcik7XG4gICAgb24ocmVmZXJlbmNlLCAnY2xpY2snLCBvblRyaWdnZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBub2RlID0gX3JlZi5ub2RlLFxuICAgICAgICAgIGV2ZW50VHlwZSA9IF9yZWYuZXZlbnRUeXBlLFxuICAgICAgICAgIGhhbmRsZXIgPSBfcmVmLmhhbmRsZXIsXG4gICAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIGxpc3RlbmVycyA9IFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvbnMoaW5zdGFuY2UpIHtcbiAgICB2YXIgb3JpZ2luYWxEZXN0cm95ID0gaW5zdGFuY2UuZGVzdHJveTtcbiAgICB2YXIgb3JpZ2luYWxFbmFibGUgPSBpbnN0YW5jZS5lbmFibGU7XG4gICAgdmFyIG9yaWdpbmFsRGlzYWJsZSA9IGluc3RhbmNlLmRpc2FibGU7XG5cbiAgICBpbnN0YW5jZS5kZXN0cm95ID0gZnVuY3Rpb24gKHNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcykge1xuICAgICAgaWYgKHNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGREZXN0cm95Q2hpbGRJbnN0YW5jZXMpIHtcbiAgICAgICAgY2hpbGRUaXBweUluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIGluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMgPSBbXTtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICBvcmlnaW5hbERlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgaW5zdGFuY2UuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgb3JpZ2luYWxFbmFibGUoKTtcbiAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmVuYWJsZSgpO1xuICAgICAgfSk7XG4gICAgICBkaXNhYmxlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBpbnN0YW5jZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgb3JpZ2luYWxEaXNhYmxlKCk7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5kaXNhYmxlKCk7XG4gICAgICB9KTtcbiAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoaW5zdGFuY2UpO1xuICB9XG5cbiAgbm9ybWFsaXplZFJldHVyblZhbHVlLmZvckVhY2goYXBwbHlNdXRhdGlvbnMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbnZhciBhbmltYXRlRmlsbCA9IHtcbiAgbmFtZTogJ2FuaW1hdGVGaWxsJyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm46IGZ1bmN0aW9uIGZuKGluc3RhbmNlKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRwcm9wcyRyZW5kZTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoISgoX2luc3RhbmNlJHByb3BzJHJlbmRlID0gaW5zdGFuY2UucHJvcHMucmVuZGVyKSAhPSBudWxsICYmIF9pbnN0YW5jZSRwcm9wcyRyZW5kZS4kJHRpcHB5KSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBlcnJvcldoZW4oaW5zdGFuY2UucHJvcHMuYW5pbWF0ZUZpbGwsICdUaGUgYGFuaW1hdGVGaWxsYCBwbHVnaW4gcmVxdWlyZXMgdGhlIGRlZmF1bHQgcmVuZGVyIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgdmFyIF9nZXRDaGlsZHJlbiA9IGdldENoaWxkcmVuKGluc3RhbmNlLnBvcHBlciksXG4gICAgICAgIGJveCA9IF9nZXRDaGlsZHJlbi5ib3gsXG4gICAgICAgIGNvbnRlbnQgPSBfZ2V0Q2hpbGRyZW4uY29udGVudDtcblxuICAgIHZhciBiYWNrZHJvcCA9IGluc3RhbmNlLnByb3BzLmFuaW1hdGVGaWxsID8gY3JlYXRlQmFja2Ryb3BFbGVtZW50KCkgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIGJveC5pbnNlcnRCZWZvcmUoYmFja2Ryb3AsIGJveC5maXJzdEVsZW1lbnRDaGlsZCk7XG4gICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRlZmlsbCcsICcnKTtcbiAgICAgICAgICBib3guc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgICAgICBhcnJvdzogZmFsc2UsXG4gICAgICAgICAgICBhbmltYXRpb246ICdzaGlmdC1hd2F5J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudCgpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IGJveC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gTnVtYmVyKHRyYW5zaXRpb25EdXJhdGlvbi5yZXBsYWNlKCdtcycsICcnKSk7IC8vIFRoZSBjb250ZW50IHNob3VsZCBmYWRlIGluIGFmdGVyIHRoZSBiYWNrZHJvcCBoYXMgbW9zdGx5IGZpbGxlZCB0aGVcbiAgICAgICAgICAvLyB0b29sdGlwIGVsZW1lbnQuIGBjbGlwLXBhdGhgIGlzIHRoZSBvdGhlciBhbHRlcm5hdGl2ZSBidXQgaXMgbm90XG4gICAgICAgICAgLy8gd2VsbC1zdXBwb3J0ZWQgYW5kIGlzIGJ1Z2d5IG9uIHNvbWUgZGV2aWNlcy5cblxuICAgICAgICAgIGNvbnRlbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gTWF0aC5yb3VuZChkdXJhdGlvbiAvIDEwKSArIFwibXNcIjtcbiAgICAgICAgICBiYWNrZHJvcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICd2aXNpYmxlJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdygpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgYmFja2Ryb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBtcyc7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkhpZGU6IGZ1bmN0aW9uIG9uSGlkZSgpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICdoaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhY2tkcm9wRWxlbWVudCgpIHtcbiAgdmFyIGJhY2tkcm9wID0gZGl2KCk7XG4gIGJhY2tkcm9wLmNsYXNzTmFtZSA9IEJBQ0tEUk9QX0NMQVNTO1xuICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JhY2tkcm9wXSwgJ2hpZGRlbicpO1xuICByZXR1cm4gYmFja2Ryb3A7XG59XG5cbnZhciBtb3VzZUNvb3JkcyA9IHtcbiAgY2xpZW50WDogMCxcbiAgY2xpZW50WTogMFxufTtcbnZhciBhY3RpdmVJbnN0YW5jZXMgPSBbXTtcblxuZnVuY3Rpb24gc3RvcmVNb3VzZUNvb3JkcyhfcmVmKSB7XG4gIHZhciBjbGllbnRYID0gX3JlZi5jbGllbnRYLFxuICAgICAgY2xpZW50WSA9IF9yZWYuY2xpZW50WTtcbiAgbW91c2VDb29yZHMgPSB7XG4gICAgY2xpZW50WDogY2xpZW50WCxcbiAgICBjbGllbnRZOiBjbGllbnRZXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZE1vdXNlQ29vcmRzTGlzdGVuZXIoZG9jKSB7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzdG9yZU1vdXNlQ29vcmRzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTW91c2VDb29yZHNMaXN0ZW5lcihkb2MpIHtcbiAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHN0b3JlTW91c2VDb29yZHMpO1xufVxuXG52YXIgZm9sbG93Q3Vyc29yID0ge1xuICBuYW1lOiAnZm9sbG93Q3Vyc29yJyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm46IGZ1bmN0aW9uIGZuKGluc3RhbmNlKSB7XG4gICAgdmFyIHJlZmVyZW5jZSA9IGluc3RhbmNlLnJlZmVyZW5jZTtcbiAgICB2YXIgZG9jID0gZ2V0T3duZXJEb2N1bWVudChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG4gICAgdmFyIGlzSW50ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgICB2YXIgd2FzRm9jdXNFdmVudCA9IGZhbHNlO1xuICAgIHZhciBpc1VubW91bnRlZCA9IHRydWU7XG4gICAgdmFyIHByZXZQcm9wcyA9IGluc3RhbmNlLnByb3BzO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNJbml0aWFsQmVoYXZpb3IoKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yID09PSAnaW5pdGlhbCcgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKCkge1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5zZXRHZXRSZWZlcmVuY2VDbGllbnRSZWN0KCkge1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IHRydWU7XG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGxcbiAgICAgIH0pO1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAvLyBJZiB0aGUgaW5zdGFuY2UgaXMgaW50ZXJhY3RpdmUsIGF2b2lkIHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB1bmxlc3MgaXQnc1xuICAgICAgLy8gb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICAgIHZhciBpc0N1cnNvck92ZXJSZWZlcmVuY2UgPSBldmVudC50YXJnZXQgPyByZWZlcmVuY2UuY29udGFpbnMoZXZlbnQudGFyZ2V0KSA6IHRydWU7XG4gICAgICB2YXIgZm9sbG93Q3Vyc29yID0gaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yO1xuICAgICAgdmFyIGNsaWVudFggPSBldmVudC5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFkgPSBldmVudC5jbGllbnRZO1xuICAgICAgdmFyIHJlY3QgPSByZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgcmVsYXRpdmVYID0gY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgIHZhciByZWxhdGl2ZVkgPSBjbGllbnRZIC0gcmVjdC50b3A7XG5cbiAgICAgIGlmIChpc0N1cnNvck92ZXJSZWZlcmVuY2UgfHwgIWluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gdW5uZWVkZWQgRE9NUmVjdCBwcm9wZXJ0aWVzXG4gICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogZnVuY3Rpb24gZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHggPSBjbGllbnRYO1xuICAgICAgICAgICAgdmFyIHkgPSBjbGllbnRZO1xuXG4gICAgICAgICAgICBpZiAoZm9sbG93Q3Vyc29yID09PSAnaW5pdGlhbCcpIHtcbiAgICAgICAgICAgICAgeCA9IHJlY3QubGVmdCArIHJlbGF0aXZlWDtcbiAgICAgICAgICAgICAgeSA9IHJlY3QudG9wICsgcmVsYXRpdmVZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG9wID0gZm9sbG93Q3Vyc29yID09PSAnaG9yaXpvbnRhbCcgPyByZWN0LnRvcCA6IHk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBmb2xsb3dDdXJzb3IgPT09ICd2ZXJ0aWNhbCcgPyByZWN0LnJpZ2h0IDogeDtcbiAgICAgICAgICAgIHZhciBib3R0b20gPSBmb2xsb3dDdXJzb3IgPT09ICdob3Jpem9udGFsJyA/IHJlY3QuYm90dG9tIDogeTtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gZm9sbG93Q3Vyc29yID09PSAndmVydGljYWwnID8gcmVjdC5sZWZ0IDogeDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHdpZHRoOiByaWdodCAtIGxlZnQsXG4gICAgICAgICAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wLFxuICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdDogbGVmdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICBkb2M6IGRvY1xuICAgICAgICB9KTtcbiAgICAgICAgYWRkTW91c2VDb29yZHNMaXN0ZW5lcihkb2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBhY3RpdmVJbnN0YW5jZXMgPSBhY3RpdmVJbnN0YW5jZXMuZmlsdGVyKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmluc3RhbmNlICE9PSBpbnN0YW5jZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYWN0aXZlSW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS5kb2MgPT09IGRvYztcbiAgICAgIH0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW1vdmVNb3VzZUNvb3Jkc0xpc3RlbmVyKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ3JlYXRlOiBjcmVhdGUsXG4gICAgICBvbkRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICBvbkJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gb25CZWZvcmVVcGRhdGUoKSB7XG4gICAgICAgIHByZXZQcm9wcyA9IGluc3RhbmNlLnByb3BzO1xuICAgICAgfSxcbiAgICAgIG9uQWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uIG9uQWZ0ZXJVcGRhdGUoXywgX3JlZjIpIHtcbiAgICAgICAgdmFyIGZvbGxvd0N1cnNvciA9IF9yZWYyLmZvbGxvd0N1cnNvcjtcblxuICAgICAgICBpZiAoaXNJbnRlcm5hbFVwZGF0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb2xsb3dDdXJzb3IgIT09IHVuZGVmaW5lZCAmJiBwcmV2UHJvcHMuZm9sbG93Q3Vyc29yICE9PSBmb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgICBkZXN0cm95KCk7XG5cbiAgICAgICAgICBpZiAoZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgICAgICBjcmVhdGUoKTtcblxuICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCAmJiAhd2FzRm9jdXNFdmVudCAmJiAhZ2V0SXNJbml0aWFsQmVoYXZpb3IoKSkge1xuICAgICAgICAgICAgICBhZGRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgdW5zZXRHZXRSZWZlcmVuY2VDbGllbnRSZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudCgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvciAmJiAhd2FzRm9jdXNFdmVudCkge1xuICAgICAgICAgIGlmIChpc1VubW91bnRlZCkge1xuICAgICAgICAgICAgb25Nb3VzZU1vdmUobW91c2VDb29yZHMpO1xuICAgICAgICAgICAgaXNVbm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWdldElzSW5pdGlhbEJlaGF2aW9yKCkpIHtcbiAgICAgICAgICAgIGFkZExpc3RlbmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25UcmlnZ2VyOiBmdW5jdGlvbiBvblRyaWdnZXIoXywgZXZlbnQpIHtcbiAgICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgICAgICBtb3VzZUNvb3JkcyA9IHtcbiAgICAgICAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhc0ZvY3VzRXZlbnQgPSBldmVudC50eXBlID09PSAnZm9jdXMnO1xuICAgICAgfSxcbiAgICAgIG9uSGlkZGVuOiBmdW5jdGlvbiBvbkhpZGRlbigpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvcikge1xuICAgICAgICAgIHVuc2V0R2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0UHJvcHMocHJvcHMsIG1vZGlmaWVyKSB7XG4gIHZhciBfcHJvcHMkcG9wcGVyT3B0aW9ucztcblxuICByZXR1cm4ge1xuICAgIHBvcHBlck9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLnBvcHBlck9wdGlvbnMsIHtcbiAgICAgIG1vZGlmaWVyczogW10uY29uY2F0KCgoKF9wcm9wcyRwb3BwZXJPcHRpb25zID0gcHJvcHMucG9wcGVyT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRwb3BwZXJPcHRpb25zLm1vZGlmaWVycykgfHwgW10pLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICAgICAgcmV0dXJuIG5hbWUgIT09IG1vZGlmaWVyLm5hbWU7XG4gICAgICB9KSwgW21vZGlmaWVyXSlcbiAgICB9KVxuICB9O1xufVxuXG52YXIgaW5saW5lUG9zaXRpb25pbmcgPSB7XG4gIG5hbWU6ICdpbmxpbmVQb3NpdGlvbmluZycsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuOiBmdW5jdGlvbiBmbihpbnN0YW5jZSkge1xuICAgIHZhciByZWZlcmVuY2UgPSBpbnN0YW5jZS5yZWZlcmVuY2U7XG5cbiAgICBmdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gISFpbnN0YW5jZS5wcm9wcy5pbmxpbmVQb3NpdGlvbmluZztcbiAgICB9XG5cbiAgICB2YXIgcGxhY2VtZW50O1xuICAgIHZhciBjdXJzb3JSZWN0SW5kZXggPSAtMTtcbiAgICB2YXIgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIHZhciB0cmllZFBsYWNlbWVudHMgPSBbXTtcbiAgICB2YXIgbW9kaWZpZXIgPSB7XG4gICAgICBuYW1lOiAndGlwcHlJbmxpbmVQb3NpdGlvbmluZycsXG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgcGhhc2U6ICdhZnRlcldyaXRlJyxcbiAgICAgIGZuOiBmdW5jdGlvbiBmbihfcmVmMikge1xuICAgICAgICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcblxuICAgICAgICBpZiAoaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICBpZiAodHJpZWRQbGFjZW1lbnRzLmluZGV4T2Yoc3RhdGUucGxhY2VtZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRyaWVkUGxhY2VtZW50cyA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwbGFjZW1lbnQgIT09IHN0YXRlLnBsYWNlbWVudCAmJiB0cmllZFBsYWNlbWVudHMuaW5kZXhPZihzdGF0ZS5wbGFjZW1lbnQpID09PSAtMSkge1xuICAgICAgICAgICAgdHJpZWRQbGFjZW1lbnRzLnB1c2goc3RhdGUucGxhY2VtZW50KTtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIHVubmVlZGVkIERPTVJlY3QgcHJvcGVydGllc1xuICAgICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBmdW5jdGlvbiBnZXRSZWZlcmVuY2VDbGllbnRSZWN0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdChzdGF0ZS5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwbGFjZW1lbnQgPSBzdGF0ZS5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2dldFJlZmVyZW5jZUNsaWVudFJlY3QocGxhY2VtZW50KSB7XG4gICAgICByZXR1cm4gZ2V0SW5saW5lQm91bmRpbmdDbGllbnRSZWN0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSwgcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBhcnJheUZyb20ocmVmZXJlbmNlLmdldENsaWVudFJlY3RzKCkpLCBjdXJzb3JSZWN0SW5kZXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEludGVybmFsUHJvcHMocGFydGlhbFByb3BzKSB7XG4gICAgICBpc0ludGVybmFsVXBkYXRlID0gdHJ1ZTtcbiAgICAgIGluc3RhbmNlLnNldFByb3BzKHBhcnRpYWxQcm9wcyk7XG4gICAgICBpc0ludGVybmFsVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTW9kaWZpZXIoKSB7XG4gICAgICBpZiAoIWlzSW50ZXJuYWxVcGRhdGUpIHtcbiAgICAgICAgc2V0SW50ZXJuYWxQcm9wcyhnZXRQcm9wcyhpbnN0YW5jZS5wcm9wcywgbW9kaWZpZXIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb25DcmVhdGU6IGFkZE1vZGlmaWVyLFxuICAgICAgb25BZnRlclVwZGF0ZTogYWRkTW9kaWZpZXIsXG4gICAgICBvblRyaWdnZXI6IGZ1bmN0aW9uIG9uVHJpZ2dlcihfLCBldmVudCkge1xuICAgICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgIHZhciByZWN0cyA9IGFycmF5RnJvbShpbnN0YW5jZS5yZWZlcmVuY2UuZ2V0Q2xpZW50UmVjdHMoKSk7XG4gICAgICAgICAgdmFyIGN1cnNvclJlY3QgPSByZWN0cy5maW5kKGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdC5sZWZ0IC0gMiA8PSBldmVudC5jbGllbnRYICYmIHJlY3QucmlnaHQgKyAyID49IGV2ZW50LmNsaWVudFggJiYgcmVjdC50b3AgLSAyIDw9IGV2ZW50LmNsaWVudFkgJiYgcmVjdC5ib3R0b20gKyAyID49IGV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcmVjdHMuaW5kZXhPZihjdXJzb3JSZWN0KTtcbiAgICAgICAgICBjdXJzb3JSZWN0SW5kZXggPSBpbmRleCA+IC0xID8gaW5kZXggOiBjdXJzb3JSZWN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkhpZGRlbjogZnVuY3Rpb24gb25IaWRkZW4oKSB7XG4gICAgICAgIGN1cnNvclJlY3RJbmRleCA9IC0xO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRJbmxpbmVCb3VuZGluZ0NsaWVudFJlY3QoY3VycmVudEJhc2VQbGFjZW1lbnQsIGJvdW5kaW5nUmVjdCwgY2xpZW50UmVjdHMsIGN1cnNvclJlY3RJbmRleCkge1xuICAvLyBOb3QgYW4gaW5saW5lIGVsZW1lbnQsIG9yIHBsYWNlbWVudCBpcyBub3QgeWV0IGtub3duXG4gIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPCAyIHx8IGN1cnJlbnRCYXNlUGxhY2VtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGJvdW5kaW5nUmVjdDtcbiAgfSAvLyBUaGVyZSBhcmUgdHdvIHJlY3RzIGFuZCB0aGV5IGFyZSBkaXNqb2luZWRcblxuXG4gIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPT09IDIgJiYgY3Vyc29yUmVjdEluZGV4ID49IDAgJiYgY2xpZW50UmVjdHNbMF0ubGVmdCA+IGNsaWVudFJlY3RzWzFdLnJpZ2h0KSB7XG4gICAgcmV0dXJuIGNsaWVudFJlY3RzW2N1cnNvclJlY3RJbmRleF0gfHwgYm91bmRpbmdSZWN0O1xuICB9XG5cbiAgc3dpdGNoIChjdXJyZW50QmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgICB2YXIgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGlzVG9wID0gY3VycmVudEJhc2VQbGFjZW1lbnQgPT09ICd0b3AnO1xuICAgICAgICB2YXIgdG9wID0gZmlyc3RSZWN0LnRvcDtcbiAgICAgICAgdmFyIGJvdHRvbSA9IGxhc3RSZWN0LmJvdHRvbTtcbiAgICAgICAgdmFyIGxlZnQgPSBpc1RvcCA/IGZpcnN0UmVjdC5sZWZ0IDogbGFzdFJlY3QubGVmdDtcbiAgICAgICAgdmFyIHJpZ2h0ID0gaXNUb3AgPyBmaXJzdFJlY3QucmlnaHQgOiBsYXN0UmVjdC5yaWdodDtcbiAgICAgICAgdmFyIHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSAnbGVmdCc6XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAge1xuICAgICAgICB2YXIgbWluTGVmdCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIGNsaWVudFJlY3RzLm1hcChmdW5jdGlvbiAocmVjdHMpIHtcbiAgICAgICAgICByZXR1cm4gcmVjdHMubGVmdDtcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgbWF4UmlnaHQgPSBNYXRoLm1heC5hcHBseShNYXRoLCBjbGllbnRSZWN0cy5tYXAoZnVuY3Rpb24gKHJlY3RzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlY3RzLnJpZ2h0O1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBtZWFzdXJlUmVjdHMgPSBjbGllbnRSZWN0cy5maWx0ZXIoZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudEJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0JyA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF90b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICB2YXIgX2JvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICB2YXIgX2xlZnQgPSBtaW5MZWZ0O1xuICAgICAgICB2YXIgX3JpZ2h0ID0gbWF4UmlnaHQ7XG5cbiAgICAgICAgdmFyIF93aWR0aCA9IF9yaWdodCAtIF9sZWZ0O1xuXG4gICAgICAgIHZhciBfaGVpZ2h0ID0gX2JvdHRvbSAtIF90b3A7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6IF90b3AsXG4gICAgICAgICAgYm90dG9tOiBfYm90dG9tLFxuICAgICAgICAgIGxlZnQ6IF9sZWZ0LFxuICAgICAgICAgIHJpZ2h0OiBfcmlnaHQsXG4gICAgICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IF9oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBib3VuZGluZ1JlY3Q7XG4gICAgICB9XG4gIH1cbn1cblxudmFyIHN0aWNreSA9IHtcbiAgbmFtZTogJ3N0aWNreScsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuOiBmdW5jdGlvbiBmbihpbnN0YW5jZSkge1xuICAgIHZhciByZWZlcmVuY2UgPSBpbnN0YW5jZS5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IGluc3RhbmNlLnBvcHBlcjtcblxuICAgIGZ1bmN0aW9uIGdldFJlZmVyZW5jZSgpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSA/IGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSA6IHJlZmVyZW5jZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRDaGVjayh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3BzLnN0aWNreSA9PT0gdHJ1ZSB8fCBpbnN0YW5jZS5wcm9wcy5zdGlja3kgPT09IHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBwcmV2UmVmUmVjdCA9IG51bGw7XG4gICAgdmFyIHByZXZQb3BSZWN0ID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgdmFyIGN1cnJlbnRSZWZSZWN0ID0gc2hvdWxkQ2hlY2soJ3JlZmVyZW5jZScpID8gZ2V0UmVmZXJlbmNlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBudWxsO1xuICAgICAgdmFyIGN1cnJlbnRQb3BSZWN0ID0gc2hvdWxkQ2hlY2soJ3BvcHBlcicpID8gcG9wcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogbnVsbDtcblxuICAgICAgaWYgKGN1cnJlbnRSZWZSZWN0ICYmIGFyZVJlY3RzRGlmZmVyZW50KHByZXZSZWZSZWN0LCBjdXJyZW50UmVmUmVjdCkgfHwgY3VycmVudFBvcFJlY3QgJiYgYXJlUmVjdHNEaWZmZXJlbnQocHJldlBvcFJlY3QsIGN1cnJlbnRQb3BSZWN0KSkge1xuICAgICAgICBpZiAoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2UmVmUmVjdCA9IGN1cnJlbnRSZWZSZWN0O1xuICAgICAgcHJldlBvcFJlY3QgPSBjdXJyZW50UG9wUmVjdDtcblxuICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlUG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbk1vdW50OiBmdW5jdGlvbiBvbk1vdW50KCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuc3RpY2t5KSB7XG4gICAgICAgICAgdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFyZVJlY3RzRGlmZmVyZW50KHJlY3RBLCByZWN0Qikge1xuICBpZiAocmVjdEEgJiYgcmVjdEIpIHtcbiAgICByZXR1cm4gcmVjdEEudG9wICE9PSByZWN0Qi50b3AgfHwgcmVjdEEucmlnaHQgIT09IHJlY3RCLnJpZ2h0IHx8IHJlY3RBLmJvdHRvbSAhPT0gcmVjdEIuYm90dG9tIHx8IHJlY3RBLmxlZnQgIT09IHJlY3RCLmxlZnQ7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudGlwcHkuc2V0RGVmYXVsdFByb3BzKHtcbiAgcmVuZGVyOiByZW5kZXJcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB0aXBweTtcbmV4cG9ydCB7IGFuaW1hdGVGaWxsLCBjcmVhdGVTaW5nbGV0b24sIGRlbGVnYXRlLCBmb2xsb3dDdXJzb3IsIGhpZGVBbGwsIGlubGluZVBvc2l0aW9uaW5nLCBST1VORF9BUlJPVyBhcyByb3VuZEFycm93LCBzdGlja3kgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpcHB5LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjcmVhdGVQb3BwZXIiLCJhcHBseVN0eWxlcyIsIlJPVU5EX0FSUk9XIiwiQk9YX0NMQVNTIiwiQ09OVEVOVF9DTEFTUyIsIkJBQ0tEUk9QX0NMQVNTIiwiQVJST1dfQ0xBU1MiLCJTVkdfQVJST1dfQ0xBU1MiLCJUT1VDSF9PUFRJT05TIiwicGFzc2l2ZSIsImNhcHR1cmUiLCJUSVBQWV9ERUZBVUxUX0FQUEVORF9UTyIsImRvY3VtZW50IiwiYm9keSIsImhhc093blByb3BlcnR5Iiwib2JqIiwia2V5IiwiY2FsbCIsImdldFZhbHVlQXRJbmRleE9yUmV0dXJuIiwidmFsdWUiLCJpbmRleCIsImRlZmF1bHRWYWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsInYiLCJpc1R5cGUiLCJ0eXBlIiwic3RyIiwidG9TdHJpbmciLCJpbmRleE9mIiwiaW52b2tlV2l0aEFyZ3NPclJldHVybiIsImFyZ3MiLCJhcHBseSIsImRlYm91bmNlIiwiZm4iLCJtcyIsInRpbWVvdXQiLCJhcmciLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwicmVtb3ZlUHJvcGVydGllcyIsImtleXMiLCJjbG9uZSIsIk9iamVjdCIsImFzc2lnbiIsImZvckVhY2giLCJzcGxpdEJ5U3BhY2VzIiwic3BsaXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwibm9ybWFsaXplVG9BcnJheSIsImNvbmNhdCIsInB1c2hJZlVuaXF1ZSIsImFyciIsInB1c2giLCJ1bmlxdWUiLCJpdGVtIiwiZ2V0QmFzZVBsYWNlbWVudCIsInBsYWNlbWVudCIsImFycmF5RnJvbSIsInNsaWNlIiwicmVtb3ZlVW5kZWZpbmVkUHJvcHMiLCJyZWR1Y2UiLCJhY2MiLCJ1bmRlZmluZWQiLCJkaXYiLCJjcmVhdGVFbGVtZW50IiwiaXNFbGVtZW50Iiwic29tZSIsImlzTm9kZUxpc3QiLCJpc01vdXNlRXZlbnQiLCJpc1JlZmVyZW5jZUVsZW1lbnQiLCJfdGlwcHkiLCJyZWZlcmVuY2UiLCJnZXRBcnJheU9mRWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwic2V0VHJhbnNpdGlvbkR1cmF0aW9uIiwiZWxzIiwiZWwiLCJzdHlsZSIsInRyYW5zaXRpb25EdXJhdGlvbiIsInNldFZpc2liaWxpdHlTdGF0ZSIsInN0YXRlIiwic2V0QXR0cmlidXRlIiwiZ2V0T3duZXJEb2N1bWVudCIsImVsZW1lbnRPckVsZW1lbnRzIiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwiX25vcm1hbGl6ZVRvQXJyYXkiLCJlbGVtZW50Iiwib3duZXJEb2N1bWVudCIsImlzQ3Vyc29yT3V0c2lkZUludGVyYWN0aXZlQm9yZGVyIiwicG9wcGVyVHJlZURhdGEiLCJldmVudCIsImNsaWVudFgiLCJjbGllbnRZIiwiZXZlcnkiLCJfcmVmIiwicG9wcGVyUmVjdCIsInBvcHBlclN0YXRlIiwicHJvcHMiLCJpbnRlcmFjdGl2ZUJvcmRlciIsImJhc2VQbGFjZW1lbnQiLCJvZmZzZXREYXRhIiwibW9kaWZpZXJzRGF0YSIsIm9mZnNldCIsInRvcERpc3RhbmNlIiwidG9wIiwieSIsImJvdHRvbURpc3RhbmNlIiwiYm90dG9tIiwibGVmdERpc3RhbmNlIiwibGVmdCIsIngiLCJyaWdodERpc3RhbmNlIiwicmlnaHQiLCJleGNlZWRzVG9wIiwiZXhjZWVkc0JvdHRvbSIsImV4Y2VlZHNMZWZ0IiwiZXhjZWVkc1JpZ2h0IiwidXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyIiwiYm94IiwiYWN0aW9uIiwibGlzdGVuZXIiLCJtZXRob2QiLCJhY3R1YWxDb250YWlucyIsInBhcmVudCIsImNoaWxkIiwidGFyZ2V0IiwiX3RhcmdldCRnZXRSb290Tm9kZSIsImNvbnRhaW5zIiwiZ2V0Um9vdE5vZGUiLCJob3N0IiwiY3VycmVudElucHV0IiwiaXNUb3VjaCIsImxhc3RNb3VzZU1vdmVUaW1lIiwib25Eb2N1bWVudFRvdWNoU3RhcnQiLCJ3aW5kb3ciLCJwZXJmb3JtYW5jZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbkRvY3VtZW50TW91c2VNb3ZlIiwibm93IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uV2luZG93Qmx1ciIsImFjdGl2ZUVsZW1lbnQiLCJpbnN0YW5jZSIsImJsdXIiLCJpc1Zpc2libGUiLCJiaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMiLCJpc0Jyb3dzZXIiLCJpc0lFMTEiLCJtc0NyeXB0byIsImNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nIiwidHh0Iiwiam9pbiIsImNsZWFuIiwic3BhY2VzQW5kVGFicyIsImxpbmVTdGFydFdpdGhTcGFjZXMiLCJyZXBsYWNlIiwidHJpbSIsImdldERldk1lc3NhZ2UiLCJtZXNzYWdlIiwiZ2V0Rm9ybWF0dGVkTWVzc2FnZSIsInZpc2l0ZWRNZXNzYWdlcyIsInByb2Nlc3MiLCJyZXNldFZpc2l0ZWRNZXNzYWdlcyIsIlNldCIsIndhcm5XaGVuIiwiY29uZGl0aW9uIiwiaGFzIiwiX2NvbnNvbGUiLCJhZGQiLCJjb25zb2xlIiwid2FybiIsImVycm9yV2hlbiIsIl9jb25zb2xlMiIsImVycm9yIiwidmFsaWRhdGVUYXJnZXRzIiwidGFyZ2V0cyIsImRpZFBhc3NGYWxzeVZhbHVlIiwiZGlkUGFzc1BsYWluT2JqZWN0IiwicHJvdG90eXBlIiwiU3RyaW5nIiwicGx1Z2luUHJvcHMiLCJhbmltYXRlRmlsbCIsImZvbGxvd0N1cnNvciIsImlubGluZVBvc2l0aW9uaW5nIiwic3RpY2t5IiwicmVuZGVyUHJvcHMiLCJhbGxvd0hUTUwiLCJhbmltYXRpb24iLCJhcnJvdyIsImNvbnRlbnQiLCJpbmVydGlhIiwibWF4V2lkdGgiLCJyb2xlIiwidGhlbWUiLCJ6SW5kZXgiLCJkZWZhdWx0UHJvcHMiLCJhcHBlbmRUbyIsImFyaWEiLCJleHBhbmRlZCIsImRlbGF5IiwiZHVyYXRpb24iLCJnZXRSZWZlcmVuY2VDbGllbnRSZWN0IiwiaGlkZU9uQ2xpY2siLCJpZ25vcmVBdHRyaWJ1dGVzIiwiaW50ZXJhY3RpdmUiLCJpbnRlcmFjdGl2ZURlYm91bmNlIiwibW92ZVRyYW5zaXRpb24iLCJvbkFmdGVyVXBkYXRlIiwib25CZWZvcmVVcGRhdGUiLCJvbkNyZWF0ZSIsIm9uRGVzdHJveSIsIm9uSGlkZGVuIiwib25IaWRlIiwib25Nb3VudCIsIm9uU2hvdyIsIm9uU2hvd24iLCJvblRyaWdnZXIiLCJvblVudHJpZ2dlciIsIm9uQ2xpY2tPdXRzaWRlIiwicGx1Z2lucyIsInBvcHBlck9wdGlvbnMiLCJyZW5kZXIiLCJzaG93T25DcmVhdGUiLCJ0b3VjaCIsInRyaWdnZXIiLCJ0cmlnZ2VyVGFyZ2V0IiwiZGVmYXVsdEtleXMiLCJzZXREZWZhdWx0UHJvcHMiLCJwYXJ0aWFsUHJvcHMiLCJ2YWxpZGF0ZVByb3BzIiwiZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyIsInBhc3NlZFByb3BzIiwicGx1Z2luIiwibmFtZSIsIl9uYW1lIiwiZ2V0RGF0YUF0dHJpYnV0ZVByb3BzIiwicHJvcEtleXMiLCJ2YWx1ZUFzU3RyaW5nIiwiZ2V0QXR0cmlidXRlIiwiSlNPTiIsInBhcnNlIiwiZSIsImV2YWx1YXRlUHJvcHMiLCJvdXQiLCJwcm9wIiwibm9uUGx1Z2luUHJvcHMiLCJkaWRQYXNzVW5rbm93blByb3AiLCJsZW5ndGgiLCJpbm5lckhUTUwiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImh0bWwiLCJjcmVhdGVBcnJvd0VsZW1lbnQiLCJjbGFzc05hbWUiLCJhcHBlbmRDaGlsZCIsInNldENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsImdldENoaWxkcmVuIiwicG9wcGVyIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJib3hDaGlsZHJlbiIsImNoaWxkcmVuIiwiZmluZCIsIm5vZGUiLCJjbGFzc0xpc3QiLCJiYWNrZHJvcCIsIm9uVXBkYXRlIiwicHJldlByb3BzIiwibmV4dFByb3BzIiwiX2dldENoaWxkcmVuIiwicmVtb3ZlQXR0cmlidXRlIiwicmVtb3ZlQ2hpbGQiLCIkJHRpcHB5IiwiaWRDb3VudGVyIiwibW91c2VNb3ZlTGlzdGVuZXJzIiwibW91bnRlZEluc3RhbmNlcyIsImNyZWF0ZVRpcHB5Iiwic2hvd1RpbWVvdXQiLCJoaWRlVGltZW91dCIsInNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lIiwiaXNWaXNpYmxlRnJvbUNsaWNrIiwiZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24iLCJkaWRUb3VjaE1vdmUiLCJpZ25vcmVPbkZpcnN0VXBkYXRlIiwibGFzdFRyaWdnZXJFdmVudCIsImN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXIiLCJvbkZpcnN0VXBkYXRlIiwibGlzdGVuZXJzIiwiZGVib3VuY2VkT25Nb3VzZU1vdmUiLCJvbk1vdXNlTW92ZSIsImN1cnJlbnRUYXJnZXQiLCJpZCIsInBvcHBlckluc3RhbmNlIiwiaXNFbmFibGVkIiwiaXNEZXN0cm95ZWQiLCJpc01vdW50ZWQiLCJpc1Nob3duIiwiY2xlYXJEZWxheVRpbWVvdXRzIiwic2V0UHJvcHMiLCJzaG93IiwiaGlkZSIsImhpZGVXaXRoSW50ZXJhY3Rpdml0eSIsImVuYWJsZSIsImRpc2FibGUiLCJ1bm1vdW50IiwiZGVzdHJveSIsIl9wcm9wcyRyZW5kZXIiLCJwbHVnaW5zSG9va3MiLCJtYXAiLCJoYXNBcmlhRXhwYW5kZWQiLCJoYXNBdHRyaWJ1dGUiLCJhZGRMaXN0ZW5lcnMiLCJoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUiLCJoYW5kbGVTdHlsZXMiLCJpbnZva2VIb29rIiwic2NoZWR1bGVTaG93IiwiZ2V0RG9jdW1lbnQiLCJnZXROb3JtYWxpemVkVG91Y2hTZXR0aW5ncyIsImdldElzQ3VzdG9tVG91Y2hCZWhhdmlvciIsImdldElzRGVmYXVsdFJlbmRlckZuIiwiX2luc3RhbmNlJHByb3BzJHJlbmRlIiwiZ2V0Q3VycmVudFRhcmdldCIsInBhcmVudE5vZGUiLCJnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbiIsImdldERlbGF5IiwiaXNTaG93IiwiZnJvbUhpZGUiLCJwb2ludGVyRXZlbnRzIiwiaG9vayIsInNob3VsZEludm9rZVByb3BzSG9vayIsInBsdWdpbkhvb2tzIiwiX2luc3RhbmNlJHByb3BzIiwiaGFuZGxlQXJpYUNvbnRlbnRBdHRyaWJ1dGUiLCJhdHRyIiwibm9kZXMiLCJjdXJyZW50VmFsdWUiLCJuZXh0VmFsdWUiLCJjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycyIsIm9uRG9jdW1lbnRQcmVzcyIsImFjdHVhbFRhcmdldCIsImNvbXBvc2VkUGF0aCIsInJlbW92ZURvY3VtZW50UHJlc3MiLCJvblRvdWNoTW92ZSIsIm9uVG91Y2hTdGFydCIsImFkZERvY3VtZW50UHJlc3MiLCJkb2MiLCJvblRyYW5zaXRpb25lZE91dCIsImNhbGxiYWNrIiwib25UcmFuc2l0aW9uRW5kIiwib25UcmFuc2l0aW9uZWRJbiIsIm9uIiwiZXZlbnRUeXBlIiwiaGFuZGxlciIsIm9wdGlvbnMiLCJvbk1vdXNlTGVhdmUiLCJvbkJsdXJPckZvY3VzT3V0IiwicmVtb3ZlTGlzdGVuZXJzIiwiX2xhc3RUcmlnZ2VyRXZlbnQiLCJzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSIsImlzRXZlbnRMaXN0ZW5lclN0b3BwZWQiLCJ3YXNGb2N1c2VkIiwic2NoZWR1bGVIaWRlIiwiaXNDdXJzb3JPdmVyUmVmZXJlbmNlT3JQb3BwZXIiLCJnZXROZXN0ZWRQb3BwZXJUcmVlIiwiX2luc3RhbmNlJHBvcHBlckluc3RhIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2hvdWxkQmFpbCIsInJlbGF0ZWRUYXJnZXQiLCJjcmVhdGVQb3BwZXJJbnN0YW5jZSIsImRlc3Ryb3lQb3BwZXJJbnN0YW5jZSIsIl9pbnN0YW5jZSRwcm9wczIiLCJjb21wdXRlZFJlZmVyZW5jZSIsImNvbnRleHRFbGVtZW50IiwidGlwcHlNb2RpZmllciIsImVuYWJsZWQiLCJwaGFzZSIsInJlcXVpcmVzIiwiX3JlZjIiLCJfZ2V0RGVmYXVsdFRlbXBsYXRlQ2giLCJhdHRyaWJ1dGVzIiwibW9kaWZpZXJzIiwicGFkZGluZyIsImFkYXB0aXZlIiwibW91bnQiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJfZ2V0Tm9ybWFsaXplZFRvdWNoU2UiLCJ0b3VjaFZhbHVlIiwidG91Y2hEZWxheSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwibmVzdGVkUG9wcGVyIiwiZm9yY2VVcGRhdGUiLCJpc0FscmVhZHlWaXNpYmxlIiwiaXNEaXNhYmxlZCIsImlzVG91Y2hBbmRUb3VjaERpc2FibGVkIiwidmlzaWJpbGl0eSIsInRyYW5zaXRpb24iLCJfZ2V0RGVmYXVsdFRlbXBsYXRlQ2gyIiwiX2luc3RhbmNlJHBvcHBlckluc3RhMiIsIm9mZnNldEhlaWdodCIsIl9nZXREZWZhdWx0VGVtcGxhdGVDaDMiLCJfYm94IiwiX2NvbnRlbnQiLCJpc0FscmVhZHlIaWRkZW4iLCJfZ2V0RGVmYXVsdFRlbXBsYXRlQ2g0IiwiaSIsInRpcHB5Iiwib3B0aW9uYWxQcm9wcyIsImVsZW1lbnRzIiwiaXNTaW5nbGVDb250ZW50RWxlbWVudCIsImlzTW9yZVRoYW5PbmVSZWZlcmVuY2VFbGVtZW50IiwiaW5zdGFuY2VzIiwiaGlkZUFsbCIsIl90ZW1wIiwiZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlIiwiZXhjbHVkZSIsImlzRXhjbHVkZWQiLCJvcmlnaW5hbER1cmF0aW9uIiwiYXBwbHlTdHlsZXNNb2RpZmllciIsImVmZmVjdCIsImluaXRpYWxTdHlsZXMiLCJwb3NpdGlvbiIsInN0cmF0ZWd5IiwibWFyZ2luIiwic3R5bGVzIiwiY3JlYXRlU2luZ2xldG9uIiwidGlwcHlJbnN0YW5jZXMiLCJfb3B0aW9uYWxQcm9wcyRwb3BwZXIiLCJpbmRpdmlkdWFsSW5zdGFuY2VzIiwicmVmZXJlbmNlcyIsInRyaWdnZXJUYXJnZXRzIiwib3ZlcnJpZGVzIiwiaW50ZXJjZXB0U2V0UHJvcHNDbGVhbnVwcyIsInNob3duT25DcmVhdGUiLCJzZXRUcmlnZ2VyVGFyZ2V0cyIsInNldFJlZmVyZW5jZXMiLCJlbmFibGVJbnN0YW5jZXMiLCJpbnRlcmNlcHRTZXRQcm9wcyIsInNpbmdsZXRvbiIsIm9yaWdpbmFsU2V0UHJvcHMiLCJwcmVwYXJlSW5zdGFuY2UiLCJvdmVycmlkZVByb3BzIiwiX3JlZmVyZW5jZXMkaW5kZXgiLCJvcmlnaW5hbFNob3ciLCJyZWYiLCJzaG93TmV4dCIsImZpcnN0Iiwic2hvd1ByZXZpb3VzIiwibGFzdCIsInNldEluc3RhbmNlcyIsIm5leHRJbnN0YW5jZXMiLCJCVUJCTElOR19FVkVOVFNfTUFQIiwibW91c2VvdmVyIiwiZm9jdXNpbiIsImNsaWNrIiwiZGVsZWdhdGUiLCJjaGlsZFRpcHB5SW5zdGFuY2VzIiwiZGlzYWJsZWQiLCJuYXRpdmVQcm9wcyIsInBhcmVudFByb3BzIiwiY2hpbGRQcm9wcyIsInJldHVyblZhbHVlIiwibm9ybWFsaXplZFJldHVyblZhbHVlIiwidGFyZ2V0Tm9kZSIsImNsb3Nlc3QiLCJhZGRFdmVudExpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXJzIiwiYXBwbHlNdXRhdGlvbnMiLCJvcmlnaW5hbERlc3Ryb3kiLCJvcmlnaW5hbEVuYWJsZSIsIm9yaWdpbmFsRGlzYWJsZSIsInNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcyIsImNyZWF0ZUJhY2tkcm9wRWxlbWVudCIsImluc2VydEJlZm9yZSIsIm92ZXJmbG93IiwiTnVtYmVyIiwidHJhbnNpdGlvbkRlbGF5IiwiTWF0aCIsInJvdW5kIiwibW91c2VDb29yZHMiLCJhY3RpdmVJbnN0YW5jZXMiLCJzdG9yZU1vdXNlQ29vcmRzIiwiYWRkTW91c2VDb29yZHNMaXN0ZW5lciIsInJlbW92ZU1vdXNlQ29vcmRzTGlzdGVuZXIiLCJpc0ludGVybmFsVXBkYXRlIiwid2FzRm9jdXNFdmVudCIsImlzVW5tb3VudGVkIiwiZ2V0SXNJbml0aWFsQmVoYXZpb3IiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwidW5zZXRHZXRSZWZlcmVuY2VDbGllbnRSZWN0IiwiaXNDdXJzb3JPdmVyUmVmZXJlbmNlIiwicmVjdCIsInJlbGF0aXZlWCIsInJlbGF0aXZlWSIsIndpZHRoIiwiaGVpZ2h0IiwiY3JlYXRlIiwiZGF0YSIsIl8iLCJnZXRQcm9wcyIsIm1vZGlmaWVyIiwiX3Byb3BzJHBvcHBlck9wdGlvbnMiLCJjdXJzb3JSZWN0SW5kZXgiLCJ0cmllZFBsYWNlbWVudHMiLCJfZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCIsImdldElubGluZUJvdW5kaW5nQ2xpZW50UmVjdCIsImdldENsaWVudFJlY3RzIiwic2V0SW50ZXJuYWxQcm9wcyIsImFkZE1vZGlmaWVyIiwicmVjdHMiLCJjdXJzb3JSZWN0IiwiY3VycmVudEJhc2VQbGFjZW1lbnQiLCJib3VuZGluZ1JlY3QiLCJjbGllbnRSZWN0cyIsImZpcnN0UmVjdCIsImxhc3RSZWN0IiwiaXNUb3AiLCJtaW5MZWZ0IiwibWluIiwibWF4UmlnaHQiLCJtYXgiLCJtZWFzdXJlUmVjdHMiLCJfdG9wIiwiX2JvdHRvbSIsIl9sZWZ0IiwiX3JpZ2h0IiwiX3dpZHRoIiwiX2hlaWdodCIsImdldFJlZmVyZW5jZSIsInNob3VsZENoZWNrIiwicHJldlJlZlJlY3QiLCJwcmV2UG9wUmVjdCIsInVwZGF0ZVBvc2l0aW9uIiwiY3VycmVudFJlZlJlY3QiLCJjdXJyZW50UG9wUmVjdCIsImFyZVJlY3RzRGlmZmVyZW50IiwidXBkYXRlIiwicmVjdEEiLCJyZWN0QiIsInJvdW5kQXJyb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tippy.js/dist/tippy.esm.js\n");

/***/ })

};
;