"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-view";
exports.ids = ["vendor-chunks/prosemirror-view"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   DecorationSet: () => (/* binding */ DecorationSet),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   __endComposition: () => (/* binding */ __endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* binding */ __parseFromClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n\n\n\nconst domIndex = function(node) {\n    for(var index = 0;; index++){\n        node = node.previousSibling;\n        if (!node) return index;\n    }\n};\nconst parentNode = function(node) {\n    let parent = node.assignedSlot || node.parentNode;\n    return parent && parent.nodeType == 11 ? parent.host : parent;\n};\nlet reusedRange = null;\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nconst textRange = function(node, from, to) {\n    let range = reusedRange || (reusedRange = document.createRange());\n    range.setEnd(node, to == null ? node.nodeValue.length : to);\n    range.setStart(node, from || 0);\n    return range;\n};\nconst clearReusedRange = function() {\n    reusedRange = null;\n};\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nconst isEquivalentPosition = function(node, off, targetNode, targetOff) {\n    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));\n};\nconst atomElements = /^(img|br|input|textarea|hr)$/i;\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for(;;){\n        if (node == targetNode && off == targetOff) return true;\n        if (off == (dir < 0 ? 0 : nodeSize(node))) {\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\") return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        } else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (node.contentEditable == \"false\") return false;\n            off = dir < 0 ? nodeSize(node) : 0;\n        } else {\n            return false;\n        }\n    }\n}\nfunction nodeSize(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction textNodeBefore$1(node, offset) {\n    for(;;){\n        if (node.nodeType == 3 && offset) return node;\n        if (node.nodeType == 1 && offset > 0) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset - 1];\n            offset = nodeSize(node);\n        } else if (node.parentNode && !hasBlockDesc(node)) {\n            offset = domIndex(node);\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nfunction textNodeAfter$1(node, offset) {\n    for(;;){\n        if (node.nodeType == 3 && offset < node.nodeValue.length) return node;\n        if (node.nodeType == 1 && offset < node.childNodes.length) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset];\n            offset = 0;\n        } else if (node.parentNode && !hasBlockDesc(node)) {\n            offset = domIndex(node) + 1;\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nfunction isOnEdge(node, offset, parent) {\n    for(let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;){\n        if (node == parent) return true;\n        let index = domIndex(node);\n        node = node.parentNode;\n        if (!node) return false;\n        atStart = atStart && index == 0;\n        atEnd = atEnd && index == nodeSize(node);\n    }\n}\nfunction hasBlockDesc(dom) {\n    let desc;\n    for(let cur = dom; cur; cur = cur.parentNode)if (desc = cur.pmViewDesc) break;\n    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n}\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nconst selectionCollapsed = function(domSel) {\n    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n};\nfunction keyEvent(keyCode, key) {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"keydown\", true, true);\n    event.keyCode = keyCode;\n    event.key = event.code = key;\n    return event;\n}\nfunction deepActiveElement(doc) {\n    let elt = doc.activeElement;\n    while(elt && elt.shadowRoot)elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction caretFromPoint(doc, x, y) {\n    if (doc.caretPositionFromPoint) {\n        try {\n            let pos = doc.caretPositionFromPoint(x, y);\n            // Clip the offset, because Chrome will return a text offset\n            // into <input> nodes, which can't be treated as a regular DOM\n            // offset\n            if (pos) return {\n                node: pos.offsetNode,\n                offset: Math.min(nodeSize(pos.offsetNode), pos.offset)\n            };\n        } catch (_) {}\n    }\n    if (doc.caretRangeFromPoint) {\n        let range = doc.caretRangeFromPoint(x, y);\n        if (range) return {\n            node: range.startContainer,\n            offset: Math.min(nodeSize(range.startContainer), range.startOffset)\n        };\n    }\n}\nconst nav = typeof navigator != \"undefined\" ? navigator : null;\nconst doc = typeof document != \"undefined\" ? document : null;\nconst agent = nav && nav.userAgent || \"\";\nconst ie_edge = /Edge\\/(\\d+)/.exec(agent);\nconst ie_upto10 = /MSIE \\d/.exec(agent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\ngecko && +(/Firefox\\/(\\d+)/.exec(agent) || [\n    0,\n    0\n])[1];\nconst _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\nconst chrome = !!_chrome;\nconst chrome_version = _chrome ? +_chrome[1] : 0;\nconst safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\n// Is true for both iOS and iPadOS for convenience\nconst ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\nconst mac = ios || (nav ? /Mac/.test(nav.platform) : false);\nconst windows = nav ? /Win/.test(nav.platform) : false;\nconst android = /Android \\d/.test(agent);\nconst webkit = !!doc && \"webkitFontSmoothing\" in doc.documentElement.style;\nconst webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [\n    0,\n    0\n])[1] : 0;\nfunction windowRect(doc) {\n    let vp = doc.defaultView && doc.defaultView.visualViewport;\n    if (vp) return {\n        left: 0,\n        right: vp.width,\n        top: 0,\n        bottom: vp.height\n    };\n    return {\n        left: 0,\n        right: doc.documentElement.clientWidth,\n        top: 0,\n        bottom: doc.documentElement.clientHeight\n    };\n}\nfunction getSide(value, side) {\n    return typeof value == \"number\" ? value : value[side];\n}\nfunction clientRect(node) {\n    let rect = node.getBoundingClientRect();\n    // Adjust for elements with style \"transform: scale()\"\n    let scaleX = rect.width / node.offsetWidth || 1;\n    let scaleY = rect.height / node.offsetHeight || 1;\n    // Make sure scrollbar width isn't included in the rectangle\n    return {\n        left: rect.left,\n        right: rect.left + node.clientWidth * scaleX,\n        top: rect.top,\n        bottom: rect.top + node.clientHeight * scaleY\n    };\n}\nfunction scrollRectIntoView(view, rect, startDOM) {\n    let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n    let doc = view.dom.ownerDocument;\n    for(let parent = startDOM || view.dom;;){\n        if (!parent) break;\n        if (parent.nodeType != 1) {\n            parent = parentNode(parent);\n            continue;\n        }\n        let elt = parent;\n        let atTop = elt == doc.body;\n        let bounding = atTop ? windowRect(doc) : clientRect(elt);\n        let moveX = 0, moveY = 0;\n        if (rect.top < bounding.top + getSide(scrollThreshold, \"top\")) moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"));\n        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\")) moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, \"top\") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\");\n        if (rect.left < bounding.left + getSide(scrollThreshold, \"left\")) moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"));\n        else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\")) moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\");\n        if (moveX || moveY) {\n            if (atTop) {\n                doc.defaultView.scrollBy(moveX, moveY);\n            } else {\n                let startX = elt.scrollLeft, startY = elt.scrollTop;\n                if (moveY) elt.scrollTop += moveY;\n                if (moveX) elt.scrollLeft += moveX;\n                let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;\n                rect = {\n                    left: rect.left - dX,\n                    top: rect.top - dY,\n                    right: rect.right - dX,\n                    bottom: rect.bottom - dY\n                };\n            }\n        }\n        let pos = atTop ? \"fixed\" : getComputedStyle(parent).position;\n        if (/^(fixed|sticky)$/.test(pos)) break;\n        parent = pos == \"absolute\" ? parent.offsetParent : parentNode(parent);\n    }\n}\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nfunction storeScrollPos(view) {\n    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n    let refDOM, refTop;\n    for(let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5){\n        let dom = view.root.elementFromPoint(x, y);\n        if (!dom || dom == view.dom || !view.dom.contains(dom)) continue;\n        let localRect = dom.getBoundingClientRect();\n        if (localRect.top >= startY - 20) {\n            refDOM = dom;\n            refTop = localRect.top;\n            break;\n        }\n    }\n    return {\n        refDOM: refDOM,\n        refTop: refTop,\n        stack: scrollStack(view.dom)\n    };\n}\nfunction scrollStack(dom) {\n    let stack = [], doc = dom.ownerDocument;\n    for(let cur = dom; cur; cur = parentNode(cur)){\n        stack.push({\n            dom: cur,\n            top: cur.scrollTop,\n            left: cur.scrollLeft\n        });\n        if (dom == doc) break;\n    }\n    return stack;\n}\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nfunction resetScrollPos({ refDOM, refTop, stack }) {\n    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\nfunction restoreScrollStack(stack, dTop) {\n    for(let i = 0; i < stack.length; i++){\n        let { dom, top, left } = stack[i];\n        if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop;\n        if (dom.scrollLeft != left) dom.scrollLeft = left;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive) return dom.setActive(); // in IE\n    if (preventScrollSupported) return dom.focus(preventScrollSupported);\n    let stored = scrollStack(dom);\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll () {\n            preventScrollSupported = {\n                preventScroll: true\n            };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        restoreScrollStack(stored, 0);\n    }\n}\nfunction findOffsetInNode(node, coords) {\n    let closest, dxClosest = 2e8, coordsClosest, offset = 0;\n    let rowBot = coords.top, rowTop = coords.top;\n    let firstBelow, coordsBelow;\n    for(let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++){\n        let rects;\n        if (child.nodeType == 1) rects = child.getClientRects();\n        else if (child.nodeType == 3) rects = textRange(child).getClientRects();\n        else continue;\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (rect.top <= rowBot && rect.bottom >= rowTop) {\n                rowBot = Math.max(rect.bottom, rowBot);\n                rowTop = Math.min(rect.top, rowTop);\n                let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;\n                if (dx < dxClosest) {\n                    closest = child;\n                    dxClosest = dx;\n                    coordsClosest = dx && closest.nodeType == 3 ? {\n                        left: rect.right < coords.left ? rect.right : rect.left,\n                        top: coords.top\n                    } : coords;\n                    if (child.nodeType == 1 && dx) offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n                    continue;\n                }\n            } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {\n                firstBelow = child;\n                coordsBelow = {\n                    left: Math.max(rect.left, Math.min(rect.right, coords.left)),\n                    top: rect.top\n                };\n            }\n            if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) offset = childIndex + 1;\n        }\n    }\n    if (!closest && firstBelow) {\n        closest = firstBelow;\n        coordsClosest = coordsBelow;\n        dxClosest = 0;\n    }\n    if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);\n    if (!closest || dxClosest && closest.nodeType == 1) return {\n        node,\n        offset\n    };\n    return findOffsetInNode(closest, coordsClosest);\n}\nfunction findOffsetInText(node, coords) {\n    let len = node.nodeValue.length;\n    let range = document.createRange();\n    for(let i = 0; i < len; i++){\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rect = singleRect(range, 1);\n        if (rect.top == rect.bottom) continue;\n        if (inRect(coords, rect)) return {\n            node,\n            offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)\n        };\n    }\n    return {\n        node,\n        offset: 0\n    };\n}\nfunction inRect(coords, rect) {\n    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n}\nfunction targetKludge(dom, coords) {\n    let parent = dom.parentNode;\n    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) return parent;\n    return dom;\n}\nfunction posFromElement(view, elt, coords) {\n    let { node, offset } = findOffsetInNode(elt, coords), bias = -1;\n    if (node.nodeType == 1 && !node.firstChild) {\n        let rect = node.getBoundingClientRect();\n        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n    }\n    return view.docView.posFromDOM(node, offset, bias);\n}\nfunction posFromCaret(view, node, offset, coords) {\n    // Browser (in caretPosition/RangeFromPoint) will agressively\n    // normalize towards nearby inline nodes. Since we are interested in\n    // positions between block nodes too, we first walk up the hierarchy\n    // of nodes to see if there are block nodes that the coordinates\n    // fall outside of. If so, we take the position before/after that\n    // block. If not, we call `posFromDOM` on the raw node/offset.\n    let outsideBlock = -1;\n    for(let cur = node, sawBlock = false;;){\n        if (cur == view.dom) break;\n        let desc = view.docView.nearestDesc(cur, true), rect;\n        if (!desc) return null;\n        if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles\n        ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {\n            if (desc.node.isBlock && desc.parent) {\n                // Only apply the horizontal test to the innermost block. Vertical for any parent.\n                if (!sawBlock && rect.left > coords.left || rect.top > coords.top) outsideBlock = desc.posBefore;\n                else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top) outsideBlock = desc.posAfter;\n                sawBlock = true;\n            }\n            if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {\n                // If we are inside a leaf, return the side of the leaf closer to the coords\n                let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;\n                return before ? desc.posBefore : desc.posAfter;\n            }\n        }\n        cur = desc.dom.parentNode;\n    }\n    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);\n}\nfunction elementFromPoint(element, coords, box) {\n    let len = element.childNodes.length;\n    if (len && box.top < box.bottom) {\n        for(let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;){\n            let child = element.childNodes[i];\n            if (child.nodeType == 1) {\n                let rects = child.getClientRects();\n                for(let j = 0; j < rects.length; j++){\n                    let rect = rects[j];\n                    if (inRect(coords, rect)) return elementFromPoint(child, coords, rect);\n                }\n            }\n            if ((i = (i + 1) % len) == startI) break;\n        }\n    }\n    return element;\n}\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(view, coords) {\n    let doc = view.dom.ownerDocument, node, offset = 0;\n    let caret = caretFromPoint(doc, coords.left, coords.top);\n    if (caret) ({ node, offset } = caret);\n    let elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top);\n    let pos;\n    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n        let box = view.dom.getBoundingClientRect();\n        if (!inRect(coords, box)) return null;\n        elt = elementFromPoint(view.dom, coords, box);\n        if (!elt) return null;\n    }\n    // Safari's caretRangeFromPoint returns nonsense when on a draggable element\n    if (safari) {\n        for(let p = elt; node && p; p = parentNode(p))if (p.draggable) node = undefined;\n    }\n    elt = targetKludge(elt, coords);\n    if (node) {\n        if (gecko && node.nodeType == 1) {\n            // Firefox will sometimes return offsets into <input> nodes, which\n            // have no actual children, from caretPositionFromPoint (#953)\n            offset = Math.min(offset, node.childNodes.length);\n            // It'll also move the returned position before image nodes,\n            // even if those are behind it.\n            if (offset < node.childNodes.length) {\n                let next = node.childNodes[offset], box;\n                if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top) offset++;\n            }\n        }\n        let prev;\n        // When clicking above the right side of an uneditable node, Chrome will report a cursor position after that node.\n        if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == \"false\" && prev.getBoundingClientRect().top >= coords.top) offset--;\n        // Suspiciously specific kludge to work around caret*FromPoint\n        // never returning a position at the end of the document\n        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) pos = view.state.doc.content.size;\n        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\") pos = posFromCaret(view, node, offset, coords);\n    }\n    if (pos == null) pos = posFromElement(view, elt, coords);\n    let desc = view.docView.nearestDesc(elt, true);\n    return {\n        pos,\n        inside: desc ? desc.posAtStart - desc.border : -1\n    };\n}\nfunction nonZero(rect) {\n    return rect.top < rect.bottom || rect.left < rect.right;\n}\nfunction singleRect(target, bias) {\n    let rects = target.getClientRects();\n    if (rects.length) {\n        let first = rects[bias < 0 ? 0 : rects.length - 1];\n        if (nonZero(first)) return first;\n    }\n    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();\n}\nconst BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(view, pos, side) {\n    let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n    let supportEmptyRange = webkit || gecko;\n    if (node.nodeType == 3) {\n        // These browsers support querying empty text ranges. Prefer that in\n        // bidi context or when at the end of a node.\n        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n            let rect = singleRect(textRange(node, offset, offset), side);\n            // Firefox returns bad results (the position before the space)\n            // when querying a position directly after line-broken\n            // whitespace. Detect this situation and and kludge around it\n            if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n                let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n                if (rectBefore.top == rect.top) {\n                    let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n                    if (rectAfter.top != rect.top) return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n                }\n            }\n            return rect;\n        } else {\n            let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n            if (side < 0 && !offset) {\n                to++;\n                takeSide = -1;\n            } else if (side >= 0 && offset == node.nodeValue.length) {\n                from--;\n                takeSide = 1;\n            } else if (side < 0) {\n                from--;\n            } else {\n                to++;\n            }\n            return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);\n        }\n    }\n    let $dom = view.state.doc.resolve(pos - (atom || 0));\n    // Return a horizontal line in block context\n    if (!$dom.parent.inlineContent) {\n        if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n            let before = node.childNodes[offset - 1];\n            if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false);\n        }\n        if (atom == null && offset < nodeSize(node)) {\n            let after = node.childNodes[offset];\n            if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true);\n        }\n        return flattenH(node.getBoundingClientRect(), side >= 0);\n    }\n    // Inline, not in text node (this is not Bidi-safe)\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n        let before = node.childNodes[offset - 1];\n        let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null;\n        if (target) return flattenV(singleRect(target, 1), false);\n    }\n    if (atom == null && offset < nodeSize(node)) {\n        let after = node.childNodes[offset];\n        while(after.pmViewDesc && after.pmViewDesc.ignoreForCoords)after = after.nextSibling;\n        let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;\n        if (target) return flattenV(singleRect(target, -1), true);\n    }\n    // All else failed, just try to get a rectangle for the target node\n    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n}\nfunction flattenV(rect, left) {\n    if (rect.width == 0) return rect;\n    let x = left ? rect.left : rect.right;\n    return {\n        top: rect.top,\n        bottom: rect.bottom,\n        left: x,\n        right: x\n    };\n}\nfunction flattenH(rect, top) {\n    if (rect.height == 0) return rect;\n    let y = top ? rect.top : rect.bottom;\n    return {\n        top: y,\n        bottom: y,\n        left: rect.left,\n        right: rect.right\n    };\n}\nfunction withFlushedState(view, state, f) {\n    let viewState = view.state, active = view.root.activeElement;\n    if (viewState != state) view.updateState(state);\n    if (active != view.dom) view.focus();\n    try {\n        return f();\n    } finally{\n        if (viewState != state) view.updateState(viewState);\n        if (active != view.dom && active) active.focus();\n    }\n}\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n    let sel = state.selection;\n    let $pos = dir == \"up\" ? sel.$from : sel.$to;\n    return withFlushedState(view, state, ()=>{\n        let { node: dom } = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n        for(;;){\n            let nearest = view.docView.nearestDesc(dom, true);\n            if (!nearest) break;\n            if (nearest.node.isBlock) {\n                dom = nearest.contentDOM || nearest.dom;\n                break;\n            }\n            dom = nearest.dom.parentNode;\n        }\n        let coords = coordsAtPos(view, $pos.pos, 1);\n        for(let child = dom.firstChild; child; child = child.nextSibling){\n            let boxes;\n            if (child.nodeType == 1) boxes = child.getClientRects();\n            else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects();\n            else continue;\n            for(let i = 0; i < boxes.length; i++){\n                let box = boxes[i];\n                if (box.bottom > box.top + 1 && (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) return false;\n            }\n        }\n        return true;\n    });\n}\nconst maybeRTL = /[\\u0590-\\u08ac]/;\nfunction endOfTextblockHorizontal(view, state, dir) {\n    let { $head } = state.selection;\n    if (!$head.parent.isTextblock) return false;\n    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n    let sel = view.domSelection();\n    if (!sel) return $head.pos == $head.start() || $head.pos == $head.end();\n    // If the textblock is all LTR, or the browser doesn't support\n    // Selection.modify (Edge), fall back to a primitive approach\n    if (!maybeRTL.test($head.parent.textContent) || !sel.modify) return dir == \"left\" || dir == \"backward\" ? atStart : atEnd;\n    return withFlushedState(view, state, ()=>{\n        // This is a huge hack, but appears to be the best we can\n        // currently do: use `Selection.modify` to move the selection by\n        // one character, and see if that moves the cursor out of the\n        // textblock (or doesn't move it at all, when at the start/end of\n        // the document).\n        let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();\n        let oldBidiLevel = sel.caretBidiLevel // Only for Firefox\n        ;\n        sel.modify(\"move\", dir, \"character\");\n        let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n        let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();\n        let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;\n        // Restore the previous selection\n        try {\n            sel.collapse(anchorNode, anchorOffset);\n            if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend) sel.extend(oldNode, oldOff);\n        } catch (_) {}\n        if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel;\n        return result;\n    });\n}\nlet cachedState = null;\nlet cachedDir = null;\nlet cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n    if (cachedState == state && cachedDir == dir) return cachedResult;\n    cachedState = state;\n    cachedDir = dir;\n    return cachedResult = dir == \"up\" || dir == \"down\" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);\n}\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\nconst NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nclass ViewDesc {\n    constructor(parent, children, dom, // This is the node that holds the child views. It may be null for\n    // descs that don't have children.\n    contentDOM){\n        this.parent = parent;\n        this.children = children;\n        this.dom = dom;\n        this.contentDOM = contentDOM;\n        this.dirty = NOT_DIRTY;\n        // An expando property on the DOM node provides a link back to its\n        // description.\n        dom.pmViewDesc = this;\n    }\n    // Used to check whether a given description corresponds to a\n    // widget/mark/node.\n    matchesWidget(widget) {\n        return false;\n    }\n    matchesMark(mark) {\n        return false;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return false;\n    }\n    matchesHack(nodeName) {\n        return false;\n    }\n    // When parsing in-editor content (in domchange.js), we allow\n    // descriptions to determine the parse rules that should be used to\n    // parse them.\n    parseRule() {\n        return null;\n    }\n    // Used by the editor's event handler to ignore events that come\n    // from certain descs.\n    stopEvent(event) {\n        return false;\n    }\n    // The size of the content represented by this desc.\n    get size() {\n        let size = 0;\n        for(let i = 0; i < this.children.length; i++)size += this.children[i].size;\n        return size;\n    }\n    // For block nodes, this represents the space taken up by their\n    // start/end tokens.\n    get border() {\n        return 0;\n    }\n    destroy() {\n        this.parent = undefined;\n        if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = undefined;\n        for(let i = 0; i < this.children.length; i++)this.children[i].destroy();\n    }\n    posBeforeChild(child) {\n        for(let i = 0, pos = this.posAtStart;; i++){\n            let cur = this.children[i];\n            if (cur == child) return pos;\n            pos += cur.size;\n        }\n    }\n    get posBefore() {\n        return this.parent.posBeforeChild(this);\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n    }\n    get posAfter() {\n        return this.posBefore + this.size;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.size - 2 * this.border;\n    }\n    localPosFromDOM(dom, offset, bias) {\n        // If the DOM position is in the content, use the child desc after\n        // it to figure out a position.\n        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n            if (bias < 0) {\n                let domBefore, desc;\n                if (dom == this.contentDOM) {\n                    domBefore = dom.childNodes[offset - 1];\n                } else {\n                    while(dom.parentNode != this.contentDOM)dom = dom.parentNode;\n                    domBefore = dom.previousSibling;\n                }\n                while(domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))domBefore = domBefore.previousSibling;\n                return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n            } else {\n                let domAfter, desc;\n                if (dom == this.contentDOM) {\n                    domAfter = dom.childNodes[offset];\n                } else {\n                    while(dom.parentNode != this.contentDOM)dom = dom.parentNode;\n                    domAfter = dom.nextSibling;\n                }\n                while(domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))domAfter = domAfter.nextSibling;\n                return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;\n            }\n        }\n        // Otherwise, use various heuristics, falling back on the bias\n        // parameter, to determine whether to return the position at the\n        // start or at the end of this view desc.\n        let atEnd;\n        if (dom == this.dom && this.contentDOM) {\n            atEnd = offset > domIndex(this.contentDOM);\n        } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n            atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n        } else if (this.dom.firstChild) {\n            if (offset == 0) for(let search = dom;; search = search.parentNode){\n                if (search == this.dom) {\n                    atEnd = false;\n                    break;\n                }\n                if (search.previousSibling) break;\n            }\n            if (atEnd == null && offset == dom.childNodes.length) for(let search = dom;; search = search.parentNode){\n                if (search == this.dom) {\n                    atEnd = true;\n                    break;\n                }\n                if (search.nextSibling) break;\n            }\n        }\n        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n    }\n    nearestDesc(dom, onlyNodes = false) {\n        for(let first = true, cur = dom; cur; cur = cur.parentNode){\n            let desc = this.getDesc(cur), nodeDOM;\n            if (desc && (!onlyNodes || desc.node)) {\n                // If dom is outside of this desc's nodeDOM, don't count it.\n                if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom)) first = false;\n                else return desc;\n            }\n        }\n    }\n    getDesc(dom) {\n        let desc = dom.pmViewDesc;\n        for(let cur = desc; cur; cur = cur.parent)if (cur == this) return desc;\n    }\n    posFromDOM(dom, offset, bias) {\n        for(let scan = dom; scan; scan = scan.parentNode){\n            let desc = this.getDesc(scan);\n            if (desc) return desc.localPosFromDOM(dom, offset, bias);\n        }\n        return -1;\n    }\n    // Find the desc for the node after the given pos, if any. (When a\n    // parent node overrode rendering, there might not be one.)\n    descAt(pos) {\n        for(let i = 0, offset = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (offset == pos && end != offset) {\n                while(!child.border && child.children.length){\n                    for(let i = 0; i < child.children.length; i++){\n                        let inner = child.children[i];\n                        if (inner.size) {\n                            child = inner;\n                            break;\n                        }\n                    }\n                }\n                return child;\n            }\n            if (pos < end) return child.descAt(pos - offset - child.border);\n            offset = end;\n        }\n    }\n    domFromPos(pos, side) {\n        if (!this.contentDOM) return {\n            node: this.dom,\n            offset: 0,\n            atom: pos + 1\n        };\n        // First find the position in the child array\n        let i = 0, offset = 0;\n        for(let curPos = 0; i < this.children.length; i++){\n            let child = this.children[i], end = curPos + child.size;\n            if (end > pos || child instanceof TrailingHackViewDesc) {\n                offset = pos - curPos;\n                break;\n            }\n            curPos = end;\n        }\n        // If this points into the middle of a child, call through\n        if (offset) return this.children[i].domFromPos(offset - this.children[i].border, side);\n        // Go back if there were any zero-length widgets with side >= 0 before this point\n        for(let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--){}\n        // Scan towards the first useable node\n        if (side <= 0) {\n            let prev, enter = true;\n            for(;; i--, enter = false){\n                prev = i ? this.children[i - 1] : null;\n                if (!prev || prev.dom.parentNode == this.contentDOM) break;\n            }\n            if (prev && side && enter && !prev.border && !prev.domAtom) return prev.domFromPos(prev.size, side);\n            return {\n                node: this.contentDOM,\n                offset: prev ? domIndex(prev.dom) + 1 : 0\n            };\n        } else {\n            let next, enter = true;\n            for(;; i++, enter = false){\n                next = i < this.children.length ? this.children[i] : null;\n                if (!next || next.dom.parentNode == this.contentDOM) break;\n            }\n            if (next && enter && !next.border && !next.domAtom) return next.domFromPos(0, side);\n            return {\n                node: this.contentDOM,\n                offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length\n            };\n        }\n    }\n    // Used to find a DOM range in a single parent for a given changed\n    // range.\n    parseRange(from, to, base = 0) {\n        if (this.children.length == 0) return {\n            node: this.contentDOM,\n            from,\n            to,\n            fromOffset: 0,\n            toOffset: this.contentDOM.childNodes.length\n        };\n        let fromOffset = -1, toOffset = -1;\n        for(let offset = base, i = 0;; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (fromOffset == -1 && from <= end) {\n                let childBase = offset + child.border;\n                // FIXME maybe descend mark views to parse a narrower range?\n                if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) return child.parseRange(from, to, childBase);\n                from = offset;\n                for(let j = i; j > 0; j--){\n                    let prev = this.children[j - 1];\n                    if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n                        fromOffset = domIndex(prev.dom) + 1;\n                        break;\n                    }\n                    from -= prev.size;\n                }\n                if (fromOffset == -1) fromOffset = 0;\n            }\n            if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n                to = end;\n                for(let j = i + 1; j < this.children.length; j++){\n                    let next = this.children[j];\n                    if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n                        toOffset = domIndex(next.dom);\n                        break;\n                    }\n                    to += next.size;\n                }\n                if (toOffset == -1) toOffset = this.contentDOM.childNodes.length;\n                break;\n            }\n            offset = end;\n        }\n        return {\n            node: this.contentDOM,\n            from,\n            to,\n            fromOffset,\n            toOffset\n        };\n    }\n    emptyChildAt(side) {\n        if (this.border || !this.contentDOM || !this.children.length) return false;\n        let child = this.children[side < 0 ? 0 : this.children.length - 1];\n        return child.size == 0 || child.emptyChildAt(side);\n    }\n    domAfterPos(pos) {\n        let { node, offset } = this.domFromPos(pos, 0);\n        if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError(\"No node after pos \" + pos);\n        return node.childNodes[offset];\n    }\n    // View descs are responsible for setting any selection that falls\n    // entirely inside of them, so that custom implementations can do\n    // custom things with the selection. Note that this falls apart when\n    // a selection starts in such a node and ends in another, in which\n    // case we just use whatever domFromPos produces as a best effort.\n    setSelection(anchor, head, view, force = false) {\n        // If the selection falls entirely in a child, give it to that child\n        let from = Math.min(anchor, head), to = Math.max(anchor, head);\n        for(let i = 0, offset = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (from > offset && to < end) return child.setSelection(anchor - offset - child.border, head - offset - child.border, view, force);\n            offset = end;\n        }\n        let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n        let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n        let domSel = view.root.getSelection();\n        let selRange = view.domSelectionRange();\n        let brKludge = false;\n        // On Firefox, using Selection.collapse to put the cursor after a\n        // BR node for some reason doesn't always work (#1073). On Safari,\n        // the cursor sometimes inexplicable visually lags behind its\n        // reported position in such situations (#1092).\n        if ((gecko || safari) && anchor == head) {\n            let { node, offset } = anchorDOM;\n            if (node.nodeType == 3) {\n                brKludge = !!(offset && node.nodeValue[offset - 1] == \"\\n\");\n                // Issue #1128\n                if (brKludge && offset == node.nodeValue.length) {\n                    for(let scan = node, after; scan; scan = scan.parentNode){\n                        if (after = scan.nextSibling) {\n                            if (after.nodeName == \"BR\") anchorDOM = headDOM = {\n                                node: after.parentNode,\n                                offset: domIndex(after) + 1\n                            };\n                            break;\n                        }\n                        let desc = scan.pmViewDesc;\n                        if (desc && desc.node && desc.node.isBlock) break;\n                    }\n                }\n            } else {\n                let prev = node.childNodes[offset - 1];\n                brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n            }\n        }\n        // Firefox can act strangely when the selection is in front of an\n        // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536\n        if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {\n            let after = selRange.focusNode.childNodes[selRange.focusOffset];\n            if (after && after.contentEditable == \"false\") force = true;\n        }\n        if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset)) return;\n        // Selection.extend can be used to create an 'inverted' selection\n        // (one where the focus is before the anchor), but not all\n        // browsers support it yet.\n        let domSelExtended = false;\n        if ((domSel.extend || anchor == head) && !brKludge) {\n            domSel.collapse(anchorDOM.node, anchorDOM.offset);\n            try {\n                if (anchor != head) domSel.extend(headDOM.node, headDOM.offset);\n                domSelExtended = true;\n            } catch (_) {\n            // In some cases with Chrome the selection is empty after calling\n            // collapse, even when it should be valid. This appears to be a bug, but\n            // it is difficult to isolate. If this happens fallback to the old path\n            // without using extend.\n            // Similarly, this could crash on Safari if the editor is hidden, and\n            // there was no selection.\n            }\n        }\n        if (!domSelExtended) {\n            if (anchor > head) {\n                let tmp = anchorDOM;\n                anchorDOM = headDOM;\n                headDOM = tmp;\n            }\n            let range = document.createRange();\n            range.setEnd(headDOM.node, headDOM.offset);\n            range.setStart(anchorDOM.node, anchorDOM.offset);\n            domSel.removeAllRanges();\n            domSel.addRange(range);\n        }\n    }\n    ignoreMutation(mutation) {\n        return !this.contentDOM && mutation.type != \"selection\";\n    }\n    get contentLost() {\n        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n    }\n    // Remove a subtree of the element tree that has been touched\n    // by a DOM change, so that the next update will redraw it.\n    markDirty(from, to) {\n        for(let offset = 0, i = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n                let startInside = offset + child.border, endInside = end - child.border;\n                if (from >= startInside && to <= endInside) {\n                    this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n                    if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY;\n                    else child.markDirty(from - startInside, to - startInside);\n                    return;\n                } else {\n                    child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;\n                }\n            }\n            offset = end;\n        }\n        this.dirty = CONTENT_DIRTY;\n    }\n    markParentsDirty() {\n        let level = 1;\n        for(let node = this.parent; node; node = node.parent, level++){\n            let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n            if (node.dirty < dirty) node.dirty = dirty;\n        }\n    }\n    get domAtom() {\n        return false;\n    }\n    get ignoreForCoords() {\n        return false;\n    }\n    isText(text) {\n        return false;\n    }\n}\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nclass WidgetViewDesc extends ViewDesc {\n    constructor(parent, widget, view, pos){\n        let self, dom = widget.type.toDOM;\n        if (typeof dom == \"function\") dom = dom(view, ()=>{\n            if (!self) return pos;\n            if (self.parent) return self.parent.posBeforeChild(self);\n        });\n        if (!widget.type.spec.raw) {\n            if (dom.nodeType != 1) {\n                let wrap = document.createElement(\"span\");\n                wrap.appendChild(dom);\n                dom = wrap;\n            }\n            dom.contentEditable = \"false\";\n            dom.classList.add(\"ProseMirror-widget\");\n        }\n        super(parent, [], dom, null);\n        this.widget = widget;\n        this.widget = widget;\n        self = this;\n    }\n    matchesWidget(widget) {\n        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n    }\n    parseRule() {\n        return {\n            ignore: true\n        };\n    }\n    stopEvent(event) {\n        let stop = this.widget.spec.stopEvent;\n        return stop ? stop(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"selection\" || this.widget.spec.ignoreSelection;\n    }\n    destroy() {\n        this.widget.type.destroy(this.dom);\n        super.destroy();\n    }\n    get domAtom() {\n        return true;\n    }\n    get side() {\n        return this.widget.type.side;\n    }\n}\nclass CompositionViewDesc extends ViewDesc {\n    constructor(parent, dom, textDOM, text){\n        super(parent, [], dom, null);\n        this.textDOM = textDOM;\n        this.text = text;\n    }\n    get size() {\n        return this.text.length;\n    }\n    localPosFromDOM(dom, offset) {\n        if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0);\n        return this.posAtStart + offset;\n    }\n    domFromPos(pos) {\n        return {\n            node: this.textDOM,\n            offset: pos\n        };\n    }\n    ignoreMutation(mut) {\n        return mut.type === \"characterData\" && mut.target.nodeValue == mut.oldValue;\n    }\n}\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nclass MarkViewDesc extends ViewDesc {\n    constructor(parent, mark, dom, contentDOM, spec){\n        super(parent, [], dom, contentDOM);\n        this.mark = mark;\n        this.spec = spec;\n    }\n    static create(parent, mark, inline, view) {\n        let custom = view.nodeViews[mark.type.name];\n        let spec = custom && custom(mark, view, inline);\n        if (!spec || !spec.dom) spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);\n        return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);\n    }\n    parseRule() {\n        if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) return null;\n        return {\n            mark: this.mark.type.name,\n            attrs: this.mark.attrs,\n            contentElement: this.contentDOM\n        };\n    }\n    matchesMark(mark) {\n        return this.dirty != NODE_DIRTY && this.mark.eq(mark);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        // Move dirty info to nearest node view\n        if (this.dirty != NOT_DIRTY) {\n            let parent = this.parent;\n            while(!parent.node)parent = parent.parent;\n            if (parent.dirty < this.dirty) parent.dirty = this.dirty;\n            this.dirty = NOT_DIRTY;\n        }\n    }\n    slice(from, to, view) {\n        let copy = MarkViewDesc.create(this.parent, this.mark, true, view);\n        let nodes = this.children, size = this.size;\n        if (to < size) nodes = replaceNodes(nodes, to, size, view);\n        if (from > 0) nodes = replaceNodes(nodes, 0, from, view);\n        for(let i = 0; i < nodes.length; i++)nodes[i].parent = copy;\n        copy.children = nodes;\n        return copy;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n    destroy() {\n        if (this.spec.destroy) this.spec.destroy();\n        super.destroy();\n    }\n}\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nclass NodeViewDesc extends ViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos){\n        super(parent, [], dom, contentDOM);\n        this.node = node;\n        this.outerDeco = outerDeco;\n        this.innerDeco = innerDeco;\n        this.nodeDOM = nodeDOM;\n    }\n    // By default, a node is rendered using the `toDOM` method from the\n    // node type spec. But client code can use the `nodeViews` spec to\n    // supply a custom node view, which can influence various aspects of\n    // the way the node works.\n    //\n    // (Using subclassing for this was intentionally decided against,\n    // since it'd require exposing a whole slew of finicky\n    // implementation details to the user code that they probably will\n    // never need.)\n    static create(parent, node, outerDeco, innerDeco, view, pos) {\n        let custom = view.nodeViews[node.type.name], descObj;\n        let spec = custom && custom(node, view, ()=>{\n            // (This is a function that allows the custom view to find its\n            // own position)\n            if (!descObj) return pos;\n            if (descObj.parent) return descObj.parent.posBeforeChild(descObj);\n        }, outerDeco, innerDeco);\n        let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n        if (node.isText) {\n            if (!dom) dom = document.createTextNode(node.text);\n            else if (dom.nodeType != 3) throw new RangeError(\"Text must be rendered as a DOM text node\");\n        } else if (!dom) {\n            let spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);\n            ({ dom, contentDOM } = spec);\n        }\n        if (!contentDOM && !node.isText && dom.nodeName != \"BR\") {\n            if (!dom.hasAttribute(\"contenteditable\")) dom.contentEditable = \"false\";\n            if (node.type.spec.draggable) dom.draggable = true;\n        }\n        let nodeDOM = dom;\n        dom = applyOuterDeco(dom, outerDeco, node);\n        if (spec) return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);\n        else if (node.isText) return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);\n        else return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n    }\n    parseRule() {\n        // Experimental kludge to allow opt-in re-parsing of nodes\n        if (this.node.type.spec.reparseInView) return null;\n        // FIXME the assumption that this can always return the current\n        // attrs means that if the user somehow manages to change the\n        // attrs in the dom, that won't be picked up. Not entirely sure\n        // whether this is a problem\n        let rule = {\n            node: this.node.type.name,\n            attrs: this.node.attrs\n        };\n        if (this.node.type.whitespace == \"pre\") rule.preserveWhitespace = \"full\";\n        if (!this.contentDOM) {\n            rule.getContent = ()=>this.node.content;\n        } else if (!this.contentLost) {\n            rule.contentElement = this.contentDOM;\n        } else {\n            // Chrome likes to randomly recreate parent nodes when\n            // backspacing things. When that happens, this tries to find the\n            // new parent.\n            for(let i = this.children.length - 1; i >= 0; i--){\n                let child = this.children[i];\n                if (this.dom.contains(child.dom.parentNode)) {\n                    rule.contentElement = child.dom.parentNode;\n                    break;\n                }\n            }\n            if (!rule.contentElement) rule.getContent = ()=>prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        }\n        return rule;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n    }\n    get size() {\n        return this.node.nodeSize;\n    }\n    get border() {\n        return this.node.isLeaf ? 0 : 1;\n    }\n    // Syncs `this.children` to match `this.node.content` and the local\n    // decorations, possibly introducing nesting for marks. Then, in a\n    // separate step, syncs the DOM inside `this.contentDOM` to\n    // `this.children`.\n    updateChildren(view, pos) {\n        let inline = this.node.inlineContent, off = pos;\n        let composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n        let localComposition = composition && composition.pos > -1 ? composition : null;\n        let compositionInChild = composition && composition.pos < 0;\n        let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n        iterDeco(this.node, this.innerDeco, (widget, i, insideNode)=>{\n            if (widget.spec.marks) updater.syncToMarks(widget.spec.marks, inline, view);\n            else if (widget.type.side >= 0 && !insideNode) updater.syncToMarks(i == this.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none : this.node.child(i).marks, inline, view);\n            // If the next node is a desc matching this widget, reuse it,\n            // otherwise insert the widget as a new view desc.\n            updater.placeWidget(widget, view, off);\n        }, (child, outerDeco, innerDeco, i)=>{\n            // Make sure the wrapping mark descs match the node's marks.\n            updater.syncToMarks(child.marks, inline, view);\n            // Try several strategies for drawing this node\n            let compIndex;\n            if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;\n            else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;\n            else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;\n            else {\n                // Add it as a new view\n                updater.addNode(child, outerDeco, innerDeco, view, off);\n            }\n            off += child.nodeSize;\n        });\n        // Drop all remaining descs after the current position.\n        updater.syncToMarks([], inline, view);\n        if (this.node.isTextblock) updater.addTextblockHacks();\n        updater.destroyRest();\n        // Sync the DOM if anything changed\n        if (updater.changed || this.dirty == CONTENT_DIRTY) {\n            // May have to protect focused DOM from being changed if a composition is active\n            if (localComposition) this.protectLocalComposition(view, localComposition);\n            renderDescs(this.contentDOM, this.children, view);\n            if (ios) iosHacks(this.dom);\n        }\n    }\n    localCompositionInfo(view, pos) {\n        // Only do something if both the selection and a focused text node\n        // are inside of this node\n        let { from, to } = view.state.selection;\n        if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || from < pos || to > pos + this.node.content.size) return null;\n        let textNode = view.input.compositionNode;\n        if (!textNode || !this.dom.contains(textNode.parentNode)) return null;\n        if (this.node.inlineContent) {\n            // Find the text in the focused node in the node, stop if it's not\n            // there (may have been modified through other means, in which\n            // case it should overwritten)\n            let text = textNode.nodeValue;\n            let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n            return textPos < 0 ? null : {\n                node: textNode,\n                pos: textPos,\n                text\n            };\n        } else {\n            return {\n                node: textNode,\n                pos: -1,\n                text: \"\"\n            };\n        }\n    }\n    protectLocalComposition(view, { node, pos, text }) {\n        // The node is already part of a local view desc, leave it there\n        if (this.getDesc(node)) return;\n        // Create a composition view for the orphaned nodes\n        let topNode = node;\n        for(;; topNode = topNode.parentNode){\n            if (topNode.parentNode == this.contentDOM) break;\n            while(topNode.previousSibling)topNode.parentNode.removeChild(topNode.previousSibling);\n            while(topNode.nextSibling)topNode.parentNode.removeChild(topNode.nextSibling);\n            if (topNode.pmViewDesc) topNode.pmViewDesc = undefined;\n        }\n        let desc = new CompositionViewDesc(this, topNode, node, text);\n        view.input.compositionNodes.push(desc);\n        // Patch up this.children to contain the composition view\n        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n    }\n    // If this desc must be updated to match the given node decoration,\n    // do so and return true.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) return false;\n        this.updateInner(node, outerDeco, innerDeco, view);\n        return true;\n    }\n    updateInner(node, outerDeco, innerDeco, view) {\n        this.updateOuterDeco(outerDeco);\n        this.node = node;\n        this.innerDeco = innerDeco;\n        if (this.contentDOM) this.updateChildren(view, this.posAtStart);\n        this.dirty = NOT_DIRTY;\n    }\n    updateOuterDeco(outerDeco) {\n        if (sameOuterDeco(outerDeco, this.outerDeco)) return;\n        let needsWrap = this.nodeDOM.nodeType != 1;\n        let oldDOM = this.dom;\n        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n        if (this.dom != oldDOM) {\n            oldDOM.pmViewDesc = undefined;\n            this.dom.pmViewDesc = this;\n        }\n        this.outerDeco = outerDeco;\n    }\n    // Mark this node as being the selected node.\n    selectNode() {\n        if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n        if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = true;\n    }\n    // Remove selected node marking from this node.\n    deselectNode() {\n        if (this.nodeDOM.nodeType == 1) {\n            this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n            if (this.contentDOM || !this.node.type.spec.draggable) this.dom.removeAttribute(\"draggable\");\n        }\n    }\n    get domAtom() {\n        return this.node.isAtom;\n    }\n}\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n    applyOuterDeco(dom, outerDeco, doc);\n    let docView = new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);\n    if (docView.contentDOM) docView.updateChildren(view, 0);\n    return docView;\n}\nclass TextViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view){\n        super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n    }\n    parseRule() {\n        let skip = this.nodeDOM.parentNode;\n        while(skip && skip != this.dom && !skip.pmIsDeco)skip = skip.parentNode;\n        return {\n            skip: skip || true\n        };\n    }\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) return false;\n        this.updateOuterDeco(outerDeco);\n        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n            this.nodeDOM.nodeValue = node.text;\n            if (view.trackWrites == this.nodeDOM) view.trackWrites = null;\n        }\n        this.node = node;\n        this.dirty = NOT_DIRTY;\n        return true;\n    }\n    inParent() {\n        let parentDOM = this.parent.contentDOM;\n        for(let n = this.nodeDOM; n; n = n.parentNode)if (n == parentDOM) return true;\n        return false;\n    }\n    domFromPos(pos) {\n        return {\n            node: this.nodeDOM,\n            offset: pos\n        };\n    }\n    localPosFromDOM(dom, offset, bias) {\n        if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length);\n        return super.localPosFromDOM(dom, offset, bias);\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"characterData\" && mutation.type != \"selection\";\n    }\n    slice(from, to, view) {\n        let node = this.node.cut(from, to), dom = document.createTextNode(node.text);\n        return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length)) this.dirty = NODE_DIRTY;\n    }\n    get domAtom() {\n        return false;\n    }\n    isText(text) {\n        return this.node.text == text;\n    }\n}\n// A dummy desc used to tag trailing BR or IMG nodes created to work\n// around contentEditable terribleness.\nclass TrailingHackViewDesc extends ViewDesc {\n    parseRule() {\n        return {\n            ignore: true\n        };\n    }\n    matchesHack(nodeName) {\n        return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;\n    }\n    get domAtom() {\n        return true;\n    }\n    get ignoreForCoords() {\n        return this.dom.nodeName == \"IMG\";\n    }\n}\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nclass CustomNodeViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos){\n        super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n        this.spec = spec;\n    }\n    // A custom `update` method gets to decide whether the update goes\n    // through. If it does, and there's a `contentDOM` node, our logic\n    // updates the children.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY) return false;\n        if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {\n            let result = this.spec.update(node, outerDeco, innerDeco);\n            if (result) this.updateInner(node, outerDeco, innerDeco, view);\n            return result;\n        } else if (!this.contentDOM && !node.isLeaf) {\n            return false;\n        } else {\n            return super.update(node, outerDeco, innerDeco, view);\n        }\n    }\n    selectNode() {\n        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();\n    }\n    deselectNode() {\n        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();\n    }\n    setSelection(anchor, head, view, force) {\n        this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);\n    }\n    destroy() {\n        if (this.spec.destroy) this.spec.destroy();\n        super.destroy();\n    }\n    stopEvent(event) {\n        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n}\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n    let dom = parentDOM.firstChild, written = false;\n    for(let i = 0; i < descs.length; i++){\n        let desc = descs[i], childDOM = desc.dom;\n        if (childDOM.parentNode == parentDOM) {\n            while(childDOM != dom){\n                dom = rm(dom);\n                written = true;\n            }\n            dom = dom.nextSibling;\n        } else {\n            written = true;\n            parentDOM.insertBefore(childDOM, dom);\n        }\n        if (desc instanceof MarkViewDesc) {\n            let pos = dom ? dom.previousSibling : parentDOM.lastChild;\n            renderDescs(desc.contentDOM, desc.children, view);\n            dom = pos ? pos.nextSibling : parentDOM.firstChild;\n        }\n    }\n    while(dom){\n        dom = rm(dom);\n        written = true;\n    }\n    if (written && view.trackWrites == parentDOM) view.trackWrites = null;\n}\nconst OuterDecoLevel = function(nodeName) {\n    if (nodeName) this.nodeName = nodeName;\n};\nOuterDecoLevel.prototype = Object.create(null);\nconst noDeco = [\n    new OuterDecoLevel\n];\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n    if (outerDeco.length == 0) return noDeco;\n    let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [\n        top\n    ];\n    for(let i = 0; i < outerDeco.length; i++){\n        let attrs = outerDeco[i].type.attrs;\n        if (!attrs) continue;\n        if (attrs.nodeName) result.push(top = new OuterDecoLevel(attrs.nodeName));\n        for(let name in attrs){\n            let val = attrs[name];\n            if (val == null) continue;\n            if (needsWrap && result.length == 1) result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"));\n            if (name == \"class\") top.class = (top.class ? top.class + \" \" : \"\") + val;\n            else if (name == \"style\") top.style = (top.style ? top.style + \";\" : \"\") + val;\n            else if (name != \"nodeName\") top[name] = val;\n        }\n    }\n    return result;\n}\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n    // Shortcut for trivial case\n    if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM;\n    let curDOM = nodeDOM;\n    for(let i = 0; i < curComputed.length; i++){\n        let deco = curComputed[i], prev = prevComputed[i];\n        if (i) {\n            let parent;\n            if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n                curDOM = parent;\n            } else {\n                parent = document.createElement(deco.nodeName);\n                parent.pmIsDeco = true;\n                parent.appendChild(curDOM);\n                prev = noDeco[0];\n                curDOM = parent;\n            }\n        }\n        patchAttributes(curDOM, prev || noDeco[0], deco);\n    }\n    return curDOM;\n}\nfunction patchAttributes(dom, prev, cur) {\n    for(let name in prev)if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur)) dom.removeAttribute(name);\n    for(let name in cur)if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name]) dom.setAttribute(name, cur[name]);\n    if (prev.class != cur.class) {\n        let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : [];\n        let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : [];\n        for(let i = 0; i < prevList.length; i++)if (curList.indexOf(prevList[i]) == -1) dom.classList.remove(prevList[i]);\n        for(let i = 0; i < curList.length; i++)if (prevList.indexOf(curList[i]) == -1) dom.classList.add(curList[i]);\n        if (dom.classList.length == 0) dom.removeAttribute(\"class\");\n    }\n    if (prev.style != cur.style) {\n        if (prev.style) {\n            let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n            while(m = prop.exec(prev.style))dom.style.removeProperty(m[1]);\n        }\n        if (cur.style) dom.style.cssText += cur.style;\n    }\n}\nfunction applyOuterDeco(dom, deco, node) {\n    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n}\nfunction sameOuterDeco(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!a[i].type.eq(b[i].type)) return false;\n    return true;\n}\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nclass ViewTreeUpdater {\n    constructor(top, lock, view){\n        this.lock = lock;\n        this.view = view;\n        // Index into `this.top`'s child array, represents the current\n        // update position.\n        this.index = 0;\n        // When entering a mark, the current top and index are pushed\n        // onto this.\n        this.stack = [];\n        // Tracks whether anything was changed\n        this.changed = false;\n        this.top = top;\n        this.preMatch = preMatch(top.node.content, top);\n    }\n    // Destroy and remove the children between the given indices in\n    // `this.top`.\n    destroyBetween(start, end) {\n        if (start == end) return;\n        for(let i = start; i < end; i++)this.top.children[i].destroy();\n        this.top.children.splice(start, end - start);\n        this.changed = true;\n    }\n    // Destroy all remaining children in `this.top`.\n    destroyRest() {\n        this.destroyBetween(this.index, this.top.children.length);\n    }\n    // Sync the current stack of mark descs with the given array of\n    // marks, reusing existing mark descs when possible.\n    syncToMarks(marks, inline, view) {\n        let keep = 0, depth = this.stack.length >> 1;\n        let maxKeep = Math.min(depth, marks.length);\n        while(keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)keep++;\n        while(keep < depth){\n            this.destroyRest();\n            this.top.dirty = NOT_DIRTY;\n            this.index = this.stack.pop();\n            this.top = this.stack.pop();\n            depth--;\n        }\n        while(depth < marks.length){\n            this.stack.push(this.top, this.index + 1);\n            let found = -1;\n            for(let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++){\n                let next = this.top.children[i];\n                if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {\n                    found = i;\n                    break;\n                }\n            }\n            if (found > -1) {\n                if (found > this.index) {\n                    this.changed = true;\n                    this.destroyBetween(this.index, found);\n                }\n                this.top = this.top.children[this.index];\n            } else {\n                let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n                this.top.children.splice(this.index, 0, markDesc);\n                this.top = markDesc;\n                this.changed = true;\n            }\n            this.index = 0;\n            depth++;\n        }\n    }\n    // Try to find a node desc matching the given data. Skip over it and\n    // return true when successful.\n    findNodeMatch(node, outerDeco, innerDeco, index) {\n        let found = -1, targetDesc;\n        if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n            found = this.top.children.indexOf(targetDesc, this.index);\n        } else {\n            for(let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++){\n                let child = this.top.children[i];\n                if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n                    found = i;\n                    break;\n                }\n            }\n        }\n        if (found < 0) return false;\n        this.destroyBetween(this.index, found);\n        this.index++;\n        return true;\n    }\n    updateNodeAt(node, outerDeco, innerDeco, index, view) {\n        let child = this.top.children[index];\n        if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM) child.dirty = CONTENT_DIRTY;\n        if (!child.update(node, outerDeco, innerDeco, view)) return false;\n        this.destroyBetween(this.index, index);\n        this.index++;\n        return true;\n    }\n    findIndexWithChild(domNode) {\n        for(;;){\n            let parent = domNode.parentNode;\n            if (!parent) return -1;\n            if (parent == this.top.contentDOM) {\n                let desc = domNode.pmViewDesc;\n                if (desc) for(let i = this.index; i < this.top.children.length; i++){\n                    if (this.top.children[i] == desc) return i;\n                }\n                return -1;\n            }\n            domNode = parent;\n        }\n    }\n    // Try to update the next node, if any, to the given data. Checks\n    // pre-matches to avoid overwriting nodes that could still be used.\n    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {\n        for(let i = this.index; i < this.top.children.length; i++){\n            let next = this.top.children[i];\n            if (next instanceof NodeViewDesc) {\n                let preMatch = this.preMatch.matched.get(next);\n                if (preMatch != null && preMatch != index) return false;\n                let nextDOM = next.dom, updated;\n                // Can't update if nextDOM is or contains this.lock, except if\n                // it's a text node whose content already matches the new text\n                // and whose decorations match the new ones.\n                let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n                if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n                    this.destroyBetween(this.index, i);\n                    if (next.dom != nextDOM) this.changed = true;\n                    this.index++;\n                    return true;\n                } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {\n                    this.destroyBetween(this.index, i);\n                    this.top.children[this.index] = updated;\n                    if (updated.contentDOM) {\n                        updated.dirty = CONTENT_DIRTY;\n                        updated.updateChildren(view, pos + 1);\n                        updated.dirty = NOT_DIRTY;\n                    }\n                    this.changed = true;\n                    this.index++;\n                    return true;\n                }\n                break;\n            }\n        }\n        return false;\n    }\n    // When a node with content is replaced by a different node with\n    // identical content, move over its children.\n    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {\n        if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco)) return null;\n        let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (wrapper.contentDOM) {\n            wrapper.children = next.children;\n            next.children = [];\n            for (let ch of wrapper.children)ch.parent = wrapper;\n        }\n        next.destroy();\n        return wrapper;\n    }\n    // Insert the node as a newly created node desc.\n    addNode(node, outerDeco, innerDeco, view, pos) {\n        let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (desc.contentDOM) desc.updateChildren(view, pos + 1);\n        this.top.children.splice(this.index++, 0, desc);\n        this.changed = true;\n    }\n    placeWidget(widget, view, pos) {\n        let next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n        if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n            this.index++;\n        } else {\n            let desc = new WidgetViewDesc(this.top, widget, view, pos);\n            this.top.children.splice(this.index++, 0, desc);\n            this.changed = true;\n        }\n    }\n    // Make sure a textblock looks and behaves correctly in\n    // contentEditable.\n    addTextblockHacks() {\n        let lastChild = this.top.children[this.index - 1], parent = this.top;\n        while(lastChild instanceof MarkViewDesc){\n            parent = lastChild;\n            lastChild = parent.children[parent.children.length - 1];\n        }\n        if (!lastChild || // Empty textblock\n        !(lastChild instanceof TextViewDesc) || /\\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text)) {\n            // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)\n            if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == \"false\") this.addHackNode(\"IMG\", parent);\n            this.addHackNode(\"BR\", this.top);\n        }\n    }\n    addHackNode(nodeName, parent) {\n        if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n            this.index++;\n        } else {\n            let dom = document.createElement(nodeName);\n            if (nodeName == \"IMG\") {\n                dom.className = \"ProseMirror-separator\";\n                dom.alt = \"\";\n            }\n            if (nodeName == \"BR\") dom.className = \"ProseMirror-trailingBreak\";\n            let hack = new TrailingHackViewDesc(this.top, [], dom, null);\n            if (parent != this.top) parent.children.push(hack);\n            else parent.children.splice(this.index++, 0, hack);\n            this.changed = true;\n        }\n    }\n    isLocked(node) {\n        return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));\n    }\n}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes. Returns the fragment index of the first node that\n// is part of the sequence of matched nodes at the end of the\n// fragment.\nfunction preMatch(frag, parentDesc) {\n    let curDesc = parentDesc, descI = curDesc.children.length;\n    let fI = frag.childCount, matched = new Map, matches = [];\n    outer: while(fI > 0){\n        let desc;\n        for(;;){\n            if (descI) {\n                let next = curDesc.children[descI - 1];\n                if (next instanceof MarkViewDesc) {\n                    curDesc = next;\n                    descI = next.children.length;\n                } else {\n                    desc = next;\n                    descI--;\n                    break;\n                }\n            } else if (curDesc == parentDesc) {\n                break outer;\n            } else {\n                // FIXME\n                descI = curDesc.parent.children.indexOf(curDesc);\n                curDesc = curDesc.parent;\n            }\n        }\n        let node = desc.node;\n        if (!node) continue;\n        if (node != frag.child(fI - 1)) break;\n        --fI;\n        matched.set(desc, fI);\n        matches.push(desc);\n    }\n    return {\n        index: fI,\n        matched,\n        matches: matches.reverse()\n    };\n}\nfunction compareSide(a, b) {\n    return a.type.side - b.type.side;\n}\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n    let locals = deco.locals(parent), offset = 0;\n    // Simple, cheap variant for when there are no local decorations\n    if (locals.length == 0) {\n        for(let i = 0; i < parent.childCount; i++){\n            let child = parent.child(i);\n            onNode(child, locals, deco.forChild(offset, child), i);\n            offset += child.nodeSize;\n        }\n        return;\n    }\n    let decoIndex = 0, active = [], restNode = null;\n    for(let parentIndex = 0;;){\n        let widget, widgets;\n        while(decoIndex < locals.length && locals[decoIndex].to == offset){\n            let next = locals[decoIndex++];\n            if (next.widget) {\n                if (!widget) widget = next;\n                else (widgets || (widgets = [\n                    widget\n                ])).push(next);\n            }\n        }\n        if (widget) {\n            if (widgets) {\n                widgets.sort(compareSide);\n                for(let i = 0; i < widgets.length; i++)onWidget(widgets[i], parentIndex, !!restNode);\n            } else {\n                onWidget(widget, parentIndex, !!restNode);\n            }\n        }\n        let child, index;\n        if (restNode) {\n            index = -1;\n            child = restNode;\n            restNode = null;\n        } else if (parentIndex < parent.childCount) {\n            index = parentIndex;\n            child = parent.child(parentIndex++);\n        } else {\n            break;\n        }\n        for(let i = 0; i < active.length; i++)if (active[i].to <= offset) active.splice(i--, 1);\n        while(decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)active.push(locals[decoIndex++]);\n        let end = offset + child.nodeSize;\n        if (child.isText) {\n            let cutAt = end;\n            if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from;\n            for(let i = 0; i < active.length; i++)if (active[i].to < cutAt) cutAt = active[i].to;\n            if (cutAt < end) {\n                restNode = child.cut(cutAt - offset);\n                child = child.cut(0, cutAt - offset);\n                end = cutAt;\n                index = -1;\n            }\n        } else {\n            while(decoIndex < locals.length && locals[decoIndex].to < end)decoIndex++;\n        }\n        let outerDeco = child.isInline && !child.isLeaf ? active.filter((d)=>!d.inline) : active.slice();\n        onNode(child, outerDeco, deco.forChild(offset, child), index);\n        offset = end;\n    }\n}\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n    if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n        let oldCSS = dom.style.cssText;\n        dom.style.cssText = oldCSS + \"; list-style: square !important\";\n        window.getComputedStyle(dom).listStyle;\n        dom.style.cssText = oldCSS;\n    }\n}\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n    for(let i = 0, pos = 0; i < frag.childCount && pos <= to;){\n        let child = frag.child(i++), childStart = pos;\n        pos += child.nodeSize;\n        if (!child.isText) continue;\n        let str = child.text;\n        while(i < frag.childCount){\n            let next = frag.child(i++);\n            pos += next.nodeSize;\n            if (!next.isText) break;\n            str += next.text;\n        }\n        if (pos >= from) {\n            if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text) return to - text.length;\n            let found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n            if (found >= 0 && found + text.length + childStart >= from) return childStart + found;\n            if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text) return to;\n        }\n    }\n    return -1;\n}\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n    let result = [];\n    for(let i = 0, off = 0; i < nodes.length; i++){\n        let child = nodes[i], start = off, end = off += child.size;\n        if (start >= to || end <= from) {\n            result.push(child);\n        } else {\n            if (start < from) result.push(child.slice(0, from - start, view));\n            if (replacement) {\n                result.push(replacement);\n                replacement = undefined;\n            }\n            if (end > to) result.push(child.slice(to - start, child.size, view));\n        }\n    }\n    return result;\n}\nfunction selectionFromDOM(view, origin = null) {\n    let domSel = view.domSelectionRange(), doc = view.state.doc;\n    if (!domSel.focusNode) return null;\n    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n    if (head < 0) return null;\n    let $head = doc.resolve(head), anchor, selection;\n    if (selectionCollapsed(domSel)) {\n        anchor = head;\n        while(nearestDesc && !nearestDesc.node)nearestDesc = nearestDesc.parent;\n        let nearestDescNode = nearestDesc.node;\n        if (nearestDesc && nearestDescNode.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n            let pos = nearestDesc.posBefore;\n            selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(head == pos ? $head : doc.resolve(pos));\n        }\n    } else {\n        if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {\n            let min = head, max = head;\n            for(let i = 0; i < domSel.rangeCount; i++){\n                let range = domSel.getRangeAt(i);\n                min = Math.min(min, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));\n                max = Math.max(max, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));\n            }\n            if (min < 0) return null;\n            [anchor, head] = max == view.state.selection.anchor ? [\n                max,\n                min\n            ] : [\n                min,\n                max\n            ];\n            $head = doc.resolve(head);\n        } else {\n            anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n        }\n        if (anchor < 0) return null;\n    }\n    let $anchor = doc.resolve(anchor);\n    if (!selection) {\n        let bias = origin == \"pointer\" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;\n        selection = selectionBetween(view, $anchor, $head, bias);\n    }\n    return selection;\n}\nfunction editorOwnsSelection(view) {\n    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n}\nfunction selectionToDOM(view, force = false) {\n    let sel = view.state.selection;\n    syncNodeSelection(view, sel);\n    if (!editorOwnsSelection(view)) return;\n    // The delayed drag selection causes issues with Cell Selections\n    // in Safari. And the drag selection delay is to workarond issues\n    // which only present in Chrome.\n    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n        let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;\n        if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n            view.input.mouseDown.delayedSelectionSync = true;\n            view.domObserver.setCurSelection();\n            return;\n        }\n    }\n    view.domObserver.disconnectSelection();\n    if (view.cursorWrapper) {\n        selectCursorWrapper(view);\n    } else {\n        let { anchor, head } = sel, resetEditableFrom, resetEditableTo;\n        if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) {\n            if (!sel.$from.parent.inlineContent) resetEditableFrom = temporarilyEditableNear(view, sel.from);\n            if (!sel.empty && !sel.$from.parent.inlineContent) resetEditableTo = temporarilyEditableNear(view, sel.to);\n        }\n        view.docView.setSelection(anchor, head, view, force);\n        if (brokenSelectBetweenUneditable) {\n            if (resetEditableFrom) resetEditable(resetEditableFrom);\n            if (resetEditableTo) resetEditable(resetEditableTo);\n        }\n        if (sel.visible) {\n            view.dom.classList.remove(\"ProseMirror-hideselection\");\n        } else {\n            view.dom.classList.add(\"ProseMirror-hideselection\");\n            if (\"onselectionchange\" in document) removeClassOnSelectionChange(view);\n        }\n    }\n    view.domObserver.setCurSelection();\n    view.domObserver.connectSelection();\n}\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\nconst brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\nfunction temporarilyEditableNear(view, pos) {\n    let { node, offset } = view.docView.domFromPos(pos, 0);\n    let after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n    let before = offset ? node.childNodes[offset - 1] : null;\n    if (safari && after && after.contentEditable == \"false\") return setEditable(after);\n    if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n        if (after) return setEditable(after);\n        else if (before) return setEditable(before);\n    }\n}\nfunction setEditable(element) {\n    element.contentEditable = \"true\";\n    if (safari && element.draggable) {\n        element.draggable = false;\n        element.wasDraggable = true;\n    }\n    return element;\n}\nfunction resetEditable(element) {\n    element.contentEditable = \"false\";\n    if (element.wasDraggable) {\n        element.draggable = true;\n        element.wasDraggable = null;\n    }\n}\nfunction removeClassOnSelectionChange(view) {\n    let doc = view.dom.ownerDocument;\n    doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n    let domSel = view.domSelectionRange();\n    let node = domSel.anchorNode, offset = domSel.anchorOffset;\n    doc.addEventListener(\"selectionchange\", view.input.hideSelectionGuard = ()=>{\n        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n            doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n            setTimeout(()=>{\n                if (!editorOwnsSelection(view) || view.state.selection.visible) view.dom.classList.remove(\"ProseMirror-hideselection\");\n            }, 20);\n        }\n    });\n}\nfunction selectCursorWrapper(view) {\n    let domSel = view.domSelection(), range = document.createRange();\n    if (!domSel) return;\n    let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n    if (img) range.setStart(node.parentNode, domIndex(node) + 1);\n    else range.setStart(node, 0);\n    range.collapse(true);\n    domSel.removeAllRanges();\n    domSel.addRange(range);\n    // Kludge to kill 'control selection' in IE11 when selecting an\n    // invisible cursor wrapper, since that would result in those weird\n    // resize handles and a selection that considers the absolutely\n    // positioned wrapper, rather than the root editable node, the\n    // focused element.\n    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n        node.disabled = true;\n        node.disabled = false;\n    }\n}\nfunction syncNodeSelection(view, sel) {\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        let desc = view.docView.descAt(sel.from);\n        if (desc != view.lastSelectedViewDesc) {\n            clearNodeSelection(view);\n            if (desc) desc.selectNode();\n            view.lastSelectedViewDesc = desc;\n        }\n    } else {\n        clearNodeSelection(view);\n    }\n}\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n    if (view.lastSelectedViewDesc) {\n        if (view.lastSelectedViewDesc.parent) view.lastSelectedViewDesc.deselectNode();\n        view.lastSelectedViewDesc = undefined;\n    }\n}\nfunction selectionBetween(view, $anchor, $head, bias) {\n    return view.someProp(\"createSelectionBetween\", (f)=>f(view, $anchor, $head)) || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.between($anchor, $head, bias);\n}\nfunction hasFocusAndSelection(view) {\n    if (view.editable && !view.hasFocus()) return false;\n    return hasSelection(view);\n}\nfunction hasSelection(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.anchorNode) return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n    } catch (_) {\n        return false;\n    }\n}\nfunction anchorInRightPlace(view) {\n    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n    let domSel = view.domSelectionRange();\n    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n}\nfunction moveSelectionBlock(state, dir) {\n    let { $anchor, $head } = state.selection;\n    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n    return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($start, dir);\n}\nfunction apply(view, sel) {\n    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n    return true;\n}\nfunction selectHorizontally(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (mods.indexOf(\"s\") > -1) {\n            let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;\n            if (!node || node.isText || !node.isLeaf) return false;\n            let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));\n            return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(sel.$anchor, $newHead));\n        } else if (!sel.empty) {\n            return false;\n        } else if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) {\n            let next = moveSelectionBlock(view.state, dir);\n            if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) return apply(view, next);\n            return false;\n        } else if (!(mac && mods.indexOf(\"m\") > -1)) {\n            let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n            if (!node || node.isText) return false;\n            let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n            if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false;\n            if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n            } else if (webkit) {\n                // Chrome and Safari will introduce extra pointless cursor\n                // positions around inline uneditable nodes, so we have to\n                // take over and move the cursor past them (#937)\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n            } else {\n                return false;\n            }\n        }\n    } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && sel.node.isInline) {\n        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(dir > 0 ? sel.$to : sel.$from));\n    } else {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next) return apply(view, next);\n        return false;\n    }\n}\nfunction nodeLen(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isIgnorable(dom, dir) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != \"BR\");\n}\nfunction skipIgnoredNodes(view, dir) {\n    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);\n}\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesBefore(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node) return;\n    let moveNode, moveOffset, force = false;\n    // Gecko will do odd things when the selection is directly in front\n    // of a non-editable node, so in that case, move it into the next\n    // node if possible. Issue prosemirror/prosemirror#832.\n    if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1)) force = true;\n    for(;;){\n        if (offset > 0) {\n            if (node.nodeType != 1) {\n                break;\n            } else {\n                let before = node.childNodes[offset - 1];\n                if (isIgnorable(before, -1)) {\n                    moveNode = node;\n                    moveOffset = --offset;\n                } else if (before.nodeType == 3) {\n                    node = before;\n                    offset = node.nodeValue.length;\n                } else break;\n            }\n        } else if (isBlockNode(node)) {\n            break;\n        } else {\n            let prev = node.previousSibling;\n            while(prev && isIgnorable(prev, -1)){\n                moveNode = node.parentNode;\n                moveOffset = domIndex(prev);\n                prev = prev.previousSibling;\n            }\n            if (!prev) {\n                node = node.parentNode;\n                if (node == view.dom) break;\n                offset = 0;\n            } else {\n                node = prev;\n                offset = nodeLen(node);\n            }\n        }\n    }\n    if (force) setSelFocus(view, node, offset);\n    else if (moveNode) setSelFocus(view, moveNode, moveOffset);\n}\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesAfter(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node) return;\n    let len = nodeLen(node);\n    let moveNode, moveOffset;\n    for(;;){\n        if (offset < len) {\n            if (node.nodeType != 1) break;\n            let after = node.childNodes[offset];\n            if (isIgnorable(after, 1)) {\n                moveNode = node;\n                moveOffset = ++offset;\n            } else break;\n        } else if (isBlockNode(node)) {\n            break;\n        } else {\n            let next = node.nextSibling;\n            while(next && isIgnorable(next, 1)){\n                moveNode = next.parentNode;\n                moveOffset = domIndex(next) + 1;\n                next = next.nextSibling;\n            }\n            if (!next) {\n                node = node.parentNode;\n                if (node == view.dom) break;\n                offset = len = 0;\n            } else {\n                node = next;\n                offset = 0;\n                len = nodeLen(node);\n            }\n        }\n    }\n    if (moveNode) setSelFocus(view, moveNode, moveOffset);\n}\nfunction isBlockNode(dom) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.node && desc.node.isBlock;\n}\nfunction textNodeAfter(node, offset) {\n    while(node && offset == node.childNodes.length && !hasBlockDesc(node)){\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n    while(node && offset < node.childNodes.length){\n        let next = node.childNodes[offset];\n        if (next.nodeType == 3) return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\") break;\n        node = next;\n        offset = 0;\n    }\n}\nfunction textNodeBefore(node, offset) {\n    while(node && !offset && !hasBlockDesc(node)){\n        offset = domIndex(node);\n        node = node.parentNode;\n    }\n    while(node && offset){\n        let next = node.childNodes[offset - 1];\n        if (next.nodeType == 3) return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\") break;\n        node = next;\n        offset = node.childNodes.length;\n    }\n}\nfunction setSelFocus(view, node, offset) {\n    if (node.nodeType != 3) {\n        let before, after;\n        if (after = textNodeAfter(node, offset)) {\n            node = after;\n            offset = 0;\n        } else if (before = textNodeBefore(node, offset)) {\n            node = before;\n            offset = before.nodeValue.length;\n        }\n    }\n    let sel = view.domSelection();\n    if (!sel) return;\n    if (selectionCollapsed(sel)) {\n        let range = document.createRange();\n        range.setEnd(node, offset);\n        range.setStart(node, offset);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    } else if (sel.extend) {\n        sel.extend(node, offset);\n    }\n    view.domObserver.setCurSelection();\n    let { state } = view;\n    // If no state update ends up happening, reset the selection.\n    setTimeout(()=>{\n        if (view.state == state) selectionToDOM(view);\n    }, 50);\n}\nfunction findDirection(view, pos) {\n    let $pos = view.state.doc.resolve(pos);\n    if (!(chrome || windows) && $pos.parent.inlineContent) {\n        let coords = view.coordsAtPos(pos);\n        if (pos > $pos.start()) {\n            let before = view.coordsAtPos(pos - 1);\n            let mid = (before.top + before.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1) return before.left < coords.left ? \"ltr\" : \"rtl\";\n        }\n        if (pos < $pos.end()) {\n            let after = view.coordsAtPos(pos + 1);\n            let mid = (after.top + after.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1) return after.left > coords.left ? \"ltr\" : \"rtl\";\n        }\n    }\n    let computed = getComputedStyle(view.dom).direction;\n    return computed == \"rtl\" ? \"rtl\" : \"ltr\";\n}\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty || mods.indexOf(\"s\") > -1) return false;\n    if (mac && mods.indexOf(\"m\") > -1) return false;\n    let { $from, $to } = sel;\n    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) return apply(view, next);\n    }\n    if (!$from.parent.inlineContent) {\n        let side = dir < 0 ? $from : $to;\n        let beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(side, dir);\n        return beyond ? apply(view, beyond) : false;\n    }\n    return false;\n}\nfunction stopNativeHorizontalDelete(view, dir) {\n    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) return true;\n    let { $head, $anchor, empty } = view.state.selection;\n    if (!$head.sameParent($anchor)) return true;\n    if (!empty) return false;\n    if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) return true;\n    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n    if (nextNode && !nextNode.isText) {\n        let tr = view.state.tr;\n        if (dir < 0) tr.delete($head.pos - nextNode.nodeSize, $head.pos);\n        else tr.delete($head.pos, $head.pos + nextNode.nodeSize);\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\nfunction switchEditable(view, node, state) {\n    view.domObserver.stop();\n    node.contentEditable = state;\n    view.domObserver.start();\n}\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n    if (!safari || view.state.selection.$head.parentOffset > 0) return false;\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n        let child = focusNode.firstChild;\n        switchEditable(view, child, \"true\");\n        setTimeout(()=>switchEditable(view, child, \"false\"), 20);\n    }\n    return false;\n}\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\nfunction getMods(event) {\n    let result = \"\";\n    if (event.ctrlKey) result += \"c\";\n    if (event.metaKey) result += \"m\";\n    if (event.altKey) result += \"a\";\n    if (event.shiftKey) result += \"s\";\n    return result;\n}\nfunction captureKeyDown(view, event) {\n    let code = event.keyCode, mods = getMods(event);\n    if (code == 8 || mac && code == 72 && mods == \"c\") {\n        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);\n    } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == \"c\") {\n        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);\n    } else if (code == 13 || code == 27) {\n        return true;\n    } else if (code == 37 || mac && code == 66 && mods == \"c\") {\n        let dir = code == 37 ? findDirection(view, view.state.selection.from) == \"ltr\" ? -1 : 1 : -1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 39 || mac && code == 70 && mods == \"c\") {\n        let dir = code == 39 ? findDirection(view, view.state.selection.from) == \"ltr\" ? 1 : -1 : 1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 38 || mac && code == 80 && mods == \"c\") {\n        return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);\n    } else if (code == 40 || mac && code == 78 && mods == \"c\") {\n        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);\n    } else if (mods == (mac ? \"m\" : \"c\") && (code == 66 || code == 73 || code == 89 || code == 90)) {\n        return true;\n    }\n    return false;\n}\nfunction serializeForClipboard(view, slice) {\n    view.someProp(\"transformCopied\", (f)=>{\n        slice = f(slice, view);\n    });\n    let context = [], { content, openStart, openEnd } = slice;\n    while(openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1){\n        openStart--;\n        openEnd--;\n        let node = content.firstChild;\n        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n        content = node.content;\n    }\n    let serializer = view.someProp(\"clipboardSerializer\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(view.state.schema);\n    let doc = detachedDoc(), wrap = doc.createElement(\"div\");\n    wrap.appendChild(serializer.serializeFragment(content, {\n        document: doc\n    }));\n    let firstChild = wrap.firstChild, needsWrap, wrappers = 0;\n    while(firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])){\n        for(let i = needsWrap.length - 1; i >= 0; i--){\n            let wrapper = doc.createElement(needsWrap[i]);\n            while(wrap.firstChild)wrapper.appendChild(wrap.firstChild);\n            wrap.appendChild(wrapper);\n            wrappers++;\n        }\n        firstChild = wrap.firstChild;\n    }\n    if (firstChild && firstChild.nodeType == 1) firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : \"\"} ${JSON.stringify(context)}`);\n    let text = view.someProp(\"clipboardTextSerializer\", (f)=>f(slice, view)) || slice.content.textBetween(0, slice.content.size, \"\\n\\n\");\n    return {\n        dom: wrap,\n        text,\n        slice\n    };\n}\n// Read a slice of content from the clipboard (or drop data).\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n    let inCode = $context.parent.type.spec.code;\n    let dom, slice;\n    if (!html && !text) return null;\n    let asText = text && (plainText || inCode || !html);\n    if (asText) {\n        view.someProp(\"transformPastedText\", (f)=>{\n            text = f(text, inCode || plainText, view);\n        });\n        if (inCode) return text ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0) : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;\n        let parsed = view.someProp(\"clipboardTextParser\", (f)=>f(text, $context, plainText, view));\n        if (parsed) {\n            slice = parsed;\n        } else {\n            let marks = $context.marks();\n            let { schema } = view.state, serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(schema);\n            dom = document.createElement(\"div\");\n            text.split(/(?:\\r\\n?|\\n)+/).forEach((block)=>{\n                let p = dom.appendChild(document.createElement(\"p\"));\n                if (block) p.appendChild(serializer.serializeNode(schema.text(block, marks)));\n            });\n        }\n    } else {\n        view.someProp(\"transformPastedHTML\", (f)=>{\n            html = f(html, view);\n        });\n        dom = readHTML(html);\n        if (webkit) restoreReplacedSpaces(dom);\n    }\n    let contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n    let sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\") || \"\");\n    if (sliceData && sliceData[3]) for(let i = +sliceData[3]; i > 0; i--){\n        let child = dom.firstChild;\n        while(child && child.nodeType != 1)child = child.nextSibling;\n        if (!child) break;\n        dom = child;\n    }\n    if (!slice) {\n        let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n        slice = parser.parseSlice(dom, {\n            preserveWhitespace: !!(asText || sliceData),\n            context: $context,\n            ruleFromNode (dom) {\n                if (dom.nodeName == \"BR\" && !dom.nextSibling && dom.parentNode && !inlineParents.test(dom.parentNode.nodeName)) return {\n                    ignore: true\n                };\n                return null;\n            }\n        });\n    }\n    if (sliceData) {\n        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);\n    } else {\n        slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n        if (slice.openStart || slice.openEnd) {\n            let openStart = 0, openEnd = 0;\n            for(let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild){}\n            for(let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild){}\n            slice = closeSlice(slice, openStart, openEnd);\n        }\n    }\n    view.someProp(\"transformPasted\", (f)=>{\n        slice = f(slice, view);\n    });\n    return slice;\n}\nconst inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n    if (fragment.childCount < 2) return fragment;\n    for(let d = $context.depth; d >= 0; d--){\n        let parent = $context.node(d);\n        let match = parent.contentMatchAt($context.index(d));\n        let lastWrap, result = [];\n        fragment.forEach((node)=>{\n            if (!result) return;\n            let wrap = match.findWrapping(node.type), inLast;\n            if (!wrap) return result = null;\n            if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n                result[result.length - 1] = inLast;\n            } else {\n                if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n                let wrapped = withWrappers(node, wrap);\n                result.push(wrapped);\n                match = match.matchType(wrapped.type);\n                lastWrap = wrap;\n            }\n        });\n        if (result) return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(result);\n    }\n    return fragment;\n}\nfunction withWrappers(node, wrap, from = 0) {\n    for(let i = wrap.length - 1; i >= from; i--)node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node));\n    return node;\n}\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n    if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n        let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n        if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n        let match = sibling.contentMatchAt(sibling.childCount);\n        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1])) return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(withWrappers(node, wrap, depth + 1))));\n    }\n}\nfunction closeRight(node, depth) {\n    if (depth == 0) return node;\n    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n    let fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n    return node.copy(fragment.append(fill));\n}\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n    if (fragment.childCount > 1) openEnd = 0;\n    if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd);\n    if (depth >= from) inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n}\nfunction closeSlice(slice, openStart, openEnd) {\n    if (openStart < slice.openStart) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);\n    if (openEnd < slice.openEnd) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);\n    return slice;\n}\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nconst wrapMap = {\n    thead: [\n        \"table\"\n    ],\n    tbody: [\n        \"table\"\n    ],\n    tfoot: [\n        \"table\"\n    ],\n    caption: [\n        \"table\"\n    ],\n    colgroup: [\n        \"table\"\n    ],\n    col: [\n        \"table\",\n        \"colgroup\"\n    ],\n    tr: [\n        \"table\",\n        \"tbody\"\n    ],\n    td: [\n        \"table\",\n        \"tbody\",\n        \"tr\"\n    ],\n    th: [\n        \"table\",\n        \"tbody\",\n        \"tr\"\n    ]\n};\nlet _detachedDoc = null;\nfunction detachedDoc() {\n    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n}\nlet _policy = null;\nfunction maybeWrapTrusted(html) {\n    let trustedTypes = window.trustedTypes;\n    if (!trustedTypes) return html;\n    // With the require-trusted-types-for CSP, Chrome will block\n    // innerHTML, even on a detached document. This wraps the string in\n    // a way that makes the browser allow us to use its parser again.\n    if (!_policy) _policy = trustedTypes.createPolicy(\"ProseMirrorClipboard\", {\n        createHTML: (s)=>s\n    });\n    return _policy.createHTML(html);\n}\nfunction readHTML(html) {\n    let metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n    if (metas) html = html.slice(metas[0].length);\n    let elt = detachedDoc().createElement(\"div\");\n    let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap;\n    if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) html = wrap.map((n)=>\"<\" + n + \">\").join(\"\") + html + wrap.map((n)=>\"</\" + n + \">\").reverse().join(\"\");\n    elt.innerHTML = maybeWrapTrusted(html);\n    if (wrap) for(let i = 0; i < wrap.length; i++)elt = elt.querySelector(wrap[i]) || elt;\n    return elt;\n}\n// Webkit browsers do some hard-to-predict replacement of regular\n// spaces with non-breaking spaces when putting content on the\n// clipboard. This tries to convert such non-breaking spaces (which\n// will be wrapped in a plain span on Chrome, a span with class\n// Apple-converted-space on Safari) back to regular spaces.\nfunction restoreReplacedSpaces(dom) {\n    let nodes = dom.querySelectorAll(chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n    for(let i = 0; i < nodes.length; i++){\n        let node = nodes[i];\n        if (node.childNodes.length == 1 && node.textContent == \"\\xa0\" && node.parentNode) node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node);\n    }\n}\nfunction addContext(slice, context) {\n    if (!slice.size) return slice;\n    let schema = slice.content.firstChild.type.schema, array;\n    try {\n        array = JSON.parse(context);\n    } catch (e) {\n        return slice;\n    }\n    let { content, openStart, openEnd } = slice;\n    for(let i = array.length - 2; i >= 0; i -= 2){\n        let type = schema.nodes[array[i]];\n        if (!type || type.hasRequiredAttrs()) break;\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(array[i + 1], content));\n        openStart++;\n        openEnd++;\n    }\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n}\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nconst handlers = {};\nconst editHandlers = {};\nconst passiveHandlers = {\n    touchstart: true,\n    touchmove: true\n};\nclass InputState {\n    constructor(){\n        this.shiftKey = false;\n        this.mouseDown = null;\n        this.lastKeyCode = null;\n        this.lastKeyCodeTime = 0;\n        this.lastClick = {\n            time: 0,\n            x: 0,\n            y: 0,\n            type: \"\"\n        };\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastIOSEnter = 0;\n        this.lastIOSEnterFallbackTimeout = -1;\n        this.lastFocus = 0;\n        this.lastTouch = 0;\n        this.lastChromeDelete = 0;\n        this.composing = false;\n        this.compositionNode = null;\n        this.composingTimeout = -1;\n        this.compositionNodes = [];\n        this.compositionEndedAt = -2e8;\n        this.compositionID = 1;\n        // Set to a composition ID when there are pending changes at compositionend\n        this.compositionPendingChanges = 0;\n        this.domChangeCount = 0;\n        this.eventHandlers = Object.create(null);\n        this.hideSelectionGuard = null;\n    }\n}\nfunction initInput(view) {\n    for(let event in handlers){\n        let handler = handlers[event];\n        view.dom.addEventListener(event, view.input.eventHandlers[event] = (event)=>{\n            if (eventBelongsToView(view, event) && !runCustomHandler(view, event) && (view.editable || !(event.type in editHandlers))) handler(view, event);\n        }, passiveHandlers[event] ? {\n            passive: true\n        } : undefined);\n    }\n    // On Safari, for reasons beyond my understanding, adding an input\n    // event handler makes an issue where the composition vanishes when\n    // you press enter go away.\n    if (safari) view.dom.addEventListener(\"input\", ()=>null);\n    ensureListeners(view);\n}\nfunction setSelectionOrigin(view, origin) {\n    view.input.lastSelectionOrigin = origin;\n    view.input.lastSelectionTime = Date.now();\n}\nfunction destroyInput(view) {\n    view.domObserver.stop();\n    for(let type in view.input.eventHandlers)view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n    clearTimeout(view.input.composingTimeout);\n    clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n}\nfunction ensureListeners(view) {\n    view.someProp(\"handleDOMEvents\", (currentHandlers)=>{\n        for(let type in currentHandlers)if (!view.input.eventHandlers[type]) view.dom.addEventListener(type, view.input.eventHandlers[type] = (event)=>runCustomHandler(view, event));\n    });\n}\nfunction runCustomHandler(view, event) {\n    return view.someProp(\"handleDOMEvents\", (handlers)=>{\n        let handler = handlers[event.type];\n        return handler ? handler(view, event) || event.defaultPrevented : false;\n    });\n}\nfunction eventBelongsToView(view, event) {\n    if (!event.bubbles) return true;\n    if (event.defaultPrevented) return false;\n    for(let node = event.target; node != view.dom; node = node.parentNode)if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) return false;\n    return true;\n}\nfunction dispatchEvent(view, event) {\n    if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) handlers[event.type](view, event);\n}\neditHandlers.keydown = (view, _event)=>{\n    let event = _event;\n    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n    if (inOrNearComposition(view, event)) return;\n    view.input.lastKeyCode = event.keyCode;\n    view.input.lastKeyCodeTime = Date.now();\n    // Suppress enter key events on Chrome Android, because those tend\n    // to be part of a confused sequence of composition events fired,\n    // and handling them eagerly tends to corrupt the input.\n    if (android && chrome && event.keyCode == 13) return;\n    if (event.keyCode != 229) view.domObserver.forceFlush();\n    // On iOS, if we preventDefault enter key presses, the virtual\n    // keyboard gets confused. So the hack here is to set a flag that\n    // makes the DOM change code recognize that what just happens should\n    // be replaced by whatever the Enter key handlers do.\n    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n        let now = Date.now();\n        view.input.lastIOSEnter = now;\n        view.input.lastIOSEnterFallbackTimeout = setTimeout(()=>{\n            if (view.input.lastIOSEnter == now) {\n                view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")));\n                view.input.lastIOSEnter = 0;\n            }\n        }, 200);\n    } else if (view.someProp(\"handleKeyDown\", (f)=>f(view, event)) || captureKeyDown(view, event)) {\n        event.preventDefault();\n    } else {\n        setSelectionOrigin(view, \"key\");\n    }\n};\neditHandlers.keyup = (view, event)=>{\n    if (event.keyCode == 16) view.input.shiftKey = false;\n};\neditHandlers.keypress = (view, _event)=>{\n    let event = _event;\n    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey) return;\n    if (view.someProp(\"handleKeyPress\", (f)=>f(view, event))) {\n        event.preventDefault();\n        return;\n    }\n    let sel = view.state.selection;\n    if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || !sel.$from.sameParent(sel.$to)) {\n        let text = String.fromCharCode(event.charCode);\n        if (!/[\\r\\n]/.test(text) && !view.someProp(\"handleTextInput\", (f)=>f(view, sel.$from.pos, sel.$to.pos, text))) view.dispatch(view.state.tr.insertText(text).scrollIntoView());\n        event.preventDefault();\n    }\n};\nfunction eventCoords(event) {\n    return {\n        left: event.clientX,\n        top: event.clientY\n    };\n}\nfunction isNear(event, click) {\n    let dx = click.x - event.clientX, dy = click.y - event.clientY;\n    return dx * dx + dy * dy < 100;\n}\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n    if (inside == -1) return false;\n    let $pos = view.state.doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        if (view.someProp(propName, (f)=>i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false))) return true;\n    }\n    return false;\n}\nfunction updateSelection(view, selection, origin) {\n    if (!view.focused) view.focus();\n    if (view.state.selection.eq(selection)) return;\n    let tr = view.state.tr.setSelection(selection);\n    if (origin == \"pointer\") tr.setMeta(\"pointer\", true);\n    view.dispatch(tr);\n}\nfunction selectClickedLeaf(view, inside) {\n    if (inside == -1) return false;\n    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n    if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n        updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos), \"pointer\");\n        return true;\n    }\n    return false;\n}\nfunction selectClickedNode(view, inside) {\n    if (inside == -1) return false;\n    let sel = view.state.selection, selectedNode, selectAt;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) selectedNode = sel.node;\n    let $pos = view.state.doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n            if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) selectAt = $pos.before(sel.$from.depth);\n            else selectAt = $pos.before(i);\n            break;\n        }\n    }\n    if (selectAt != null) {\n        updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n        return true;\n    } else {\n        return false;\n    }\n}\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n    return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) || view.someProp(\"handleClick\", (f)=>f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n}\nfunction handleDoubleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) || view.someProp(\"handleDoubleClick\", (f)=>f(view, pos, event));\n}\nfunction handleTripleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) || view.someProp(\"handleTripleClick\", (f)=>f(view, pos, event)) || defaultTripleClick(view, inside, event);\n}\nfunction defaultTripleClick(view, inside, event) {\n    if (event.button != 0) return false;\n    let doc = view.state.doc;\n    if (inside == -1) {\n        if (doc.inlineContent) {\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, 0, doc.content.size), \"pointer\");\n            return true;\n        }\n        return false;\n    }\n    let $pos = doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        let nodePos = $pos.before(i);\n        if (node.inlineContent) updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\");\n        else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(doc, nodePos), \"pointer\");\n        else continue;\n        return true;\n    }\n}\nfunction forceDOMFlush(view) {\n    return endComposition(view);\n}\nconst selectNodeModifier = mac ? \"metaKey\" : \"ctrlKey\";\nhandlers.mousedown = (view, _event)=>{\n    let event = _event;\n    view.input.shiftKey = event.shiftKey;\n    let flushed = forceDOMFlush(view);\n    let now = Date.now(), type = \"singleClick\";\n    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {\n        if (view.input.lastClick.type == \"singleClick\") type = \"doubleClick\";\n        else if (view.input.lastClick.type == \"doubleClick\") type = \"tripleClick\";\n    }\n    view.input.lastClick = {\n        time: now,\n        x: event.clientX,\n        y: event.clientY,\n        type\n    };\n    let pos = view.posAtCoords(eventCoords(event));\n    if (!pos) return;\n    if (type == \"singleClick\") {\n        if (view.input.mouseDown) view.input.mouseDown.done();\n        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n    } else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n        event.preventDefault();\n    } else {\n        setSelectionOrigin(view, \"pointer\");\n    }\n};\nclass MouseDown {\n    constructor(view, pos, event, flushed){\n        this.view = view;\n        this.pos = pos;\n        this.event = event;\n        this.flushed = flushed;\n        this.delayedSelectionSync = false;\n        this.mightDrag = null;\n        this.startDoc = view.state.doc;\n        this.selectNode = !!event[selectNodeModifier];\n        this.allowDefault = event.shiftKey;\n        let targetNode, targetPos;\n        if (pos.inside > -1) {\n            targetNode = view.state.doc.nodeAt(pos.inside);\n            targetPos = pos.inside;\n        } else {\n            let $pos = view.state.doc.resolve(pos.pos);\n            targetNode = $pos.parent;\n            targetPos = $pos.depth ? $pos.before() : 0;\n        }\n        const target = flushed ? null : event.target;\n        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n        this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;\n        let { selection } = view.state;\n        if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && selection.from <= targetPos && selection.to > targetPos) this.mightDrag = {\n            node: targetNode,\n            pos: targetPos,\n            addAttr: !!(this.target && !this.target.draggable),\n            setUneditable: !!(this.target && gecko && !this.target.hasAttribute(\"contentEditable\"))\n        };\n        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr) this.target.draggable = true;\n            if (this.mightDrag.setUneditable) setTimeout(()=>{\n                if (this.view.input.mouseDown == this) this.target.setAttribute(\"contentEditable\", \"false\");\n            }, 20);\n            this.view.domObserver.start();\n        }\n        view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        setSelectionOrigin(view, \"pointer\");\n    }\n    done() {\n        this.view.root.removeEventListener(\"mouseup\", this.up);\n        this.view.root.removeEventListener(\"mousemove\", this.move);\n        if (this.mightDrag && this.target) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr) this.target.removeAttribute(\"draggable\");\n            if (this.mightDrag.setUneditable) this.target.removeAttribute(\"contentEditable\");\n            this.view.domObserver.start();\n        }\n        if (this.delayedSelectionSync) setTimeout(()=>selectionToDOM(this.view));\n        this.view.input.mouseDown = null;\n    }\n    up(event) {\n        this.done();\n        if (!this.view.dom.contains(event.target)) return;\n        let pos = this.pos;\n        if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event));\n        this.updateAllowDefault(event);\n        if (this.allowDefault || !pos) {\n            setSelectionOrigin(this.view, \"pointer\");\n        } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n            event.preventDefault();\n        } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements\n        safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a\n        // cursor, but still report that the node is selected\n        // when asked through getSelection. You'll then get a\n        // situation where clicking at the point where that\n        // (hidden) cursor is doesn't change the selection, and\n        // thus doesn't get a reaction from ProseMirror. This\n        // works around that.\n        chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {\n            updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n            event.preventDefault();\n        } else {\n            setSelectionOrigin(this.view, \"pointer\");\n        }\n    }\n    move(event) {\n        this.updateAllowDefault(event);\n        setSelectionOrigin(this.view, \"pointer\");\n        if (event.buttons == 0) this.done();\n    }\n    updateAllowDefault(event) {\n        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) this.allowDefault = true;\n    }\n}\nhandlers.touchstart = (view)=>{\n    view.input.lastTouch = Date.now();\n    forceDOMFlush(view);\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.touchmove = (view)=>{\n    view.input.lastTouch = Date.now();\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.contextmenu = (view)=>forceDOMFlush(view);\nfunction inOrNearComposition(view, event) {\n    if (view.composing) return true;\n    // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n    // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n    // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n    // emitted. The keydown event triggers newline insertion, which we don't want.\n    // This method returns true if the keydown event should be ignored.\n    // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n    // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n    // This guards against the case where compositionend is triggered without the keyboard\n    // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n    // afterwards- we wouldn't want to ignore the keydown event in this case.\n    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n        view.input.compositionEndedAt = -2e8;\n        return true;\n    }\n    return false;\n}\n// Drop active composition after 5 seconds of inactivity on Android\nconst timeoutComposition = android ? 5000 : -1;\neditHandlers.compositionstart = editHandlers.compositionupdate = (view)=>{\n    if (!view.composing) {\n        view.domObserver.flush();\n        let { state } = view, $pos = state.selection.$to;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m)=>m.type.spec.inclusive === false))) {\n            // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n            view.markCursor = view.state.storedMarks || $pos.marks();\n            endComposition(view, true);\n            view.markCursor = null;\n        } else {\n            endComposition(view, !state.selection.empty);\n            // In firefox, if the cursor is after but outside a marked node,\n            // the inserted text won't inherit the marks. So this moves it\n            // inside if necessary.\n            if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n                let sel = view.domSelectionRange();\n                for(let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;){\n                    let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n                    if (!before) break;\n                    if (before.nodeType == 3) {\n                        let sel = view.domSelection();\n                        if (sel) sel.collapse(before, before.nodeValue.length);\n                        break;\n                    } else {\n                        node = before;\n                        offset = -1;\n                    }\n                }\n            }\n        }\n        view.input.composing = true;\n    }\n    scheduleComposeEnd(view, timeoutComposition);\n};\neditHandlers.compositionend = (view, event)=>{\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = event.timeStamp;\n        view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;\n        view.input.compositionNode = null;\n        if (view.input.compositionPendingChanges) Promise.resolve().then(()=>view.domObserver.flush());\n        view.input.compositionID++;\n        scheduleComposeEnd(view, 20);\n    }\n};\nfunction scheduleComposeEnd(view, delay) {\n    clearTimeout(view.input.composingTimeout);\n    if (delay > -1) view.input.composingTimeout = setTimeout(()=>endComposition(view), delay);\n}\nfunction clearComposition(view) {\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = timestampFromCustomEvent();\n    }\n    while(view.input.compositionNodes.length > 0)view.input.compositionNodes.pop().markParentsDirty();\n}\nfunction findCompositionNode(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.focusNode) return null;\n    let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);\n    let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);\n    if (textBefore && textAfter && textBefore != textAfter) {\n        let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;\n        if (textBefore == lastChanged || textAfter == lastChanged) return lastChanged;\n        if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {\n            return textAfter;\n        } else if (view.input.compositionNode == textAfter) {\n            let descBefore = textBefore.pmViewDesc;\n            if (!(!descBefore || !descBefore.isText(textBefore.nodeValue))) return textAfter;\n        }\n    }\n    return textBefore || textAfter;\n}\nfunction timestampFromCustomEvent() {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"event\", true, true);\n    return event.timeStamp;\n}\n/**\n@internal\n*/ function endComposition(view, restarting = false) {\n    if (android && view.domObserver.flushingSoon >= 0) return;\n    view.domObserver.forceFlush();\n    clearComposition(view);\n    if (restarting || view.docView && view.docView.dirty) {\n        let sel = selectionFromDOM(view);\n        if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel));\n        else if ((view.markCursor || restarting) && !view.state.selection.empty) view.dispatch(view.state.tr.deleteSelection());\n        else view.updateState(view.state);\n        return true;\n    }\n    return false;\n}\nfunction captureCopy(view, dom) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    if (!view.dom.parentNode) return;\n    let wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n    wrap.appendChild(dom);\n    wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    let sel = getSelection(), range = document.createRange();\n    range.selectNodeContents(dom);\n    // Done because IE will fire a selectionchange moving the selection\n    // to its start when removeAllRanges is called and the editor still\n    // has focus (which will mess up the editor's selection state).\n    view.dom.blur();\n    sel.removeAllRanges();\n    sel.addRange(range);\n    setTimeout(()=>{\n        if (wrap.parentNode) wrap.parentNode.removeChild(wrap);\n        view.focus();\n    }, 50);\n}\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard APIall the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;\nhandlers.copy = editHandlers.cut = (view, _event)=>{\n    let event = _event;\n    let sel = view.state.selection, cut = event.type == \"cut\";\n    if (sel.empty) return;\n    // IE and Edge's clipboard interface is completely broken\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/html\", dom.innerHTML);\n        data.setData(\"text/plain\", text);\n    } else {\n        captureCopy(view, dom);\n    }\n    if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"));\n};\nfunction sliceSingleNode(slice) {\n    return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;\n}\nfunction capturePaste(view, event) {\n    if (!view.dom.parentNode) return;\n    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n    if (!plainText) target.contentEditable = \"true\";\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    setTimeout(()=>{\n        view.focus();\n        if (target.parentNode) target.parentNode.removeChild(target);\n        if (plainText) doPaste(view, target.value, null, plain, event);\n        else doPaste(view, target.textContent, target.innerHTML, plain, event);\n    }, 50);\n}\nfunction doPaste(view, text, html, preferPlain, event) {\n    let slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);\n    if (view.someProp(\"handlePaste\", (f)=>f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty))) return true;\n    if (!slice) return false;\n    let singleNode = sliceSingleNode(slice);\n    let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice);\n    view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n    return true;\n}\nfunction getText(clipboardData) {\n    let text = clipboardData.getData(\"text/plain\") || clipboardData.getData(\"Text\");\n    if (text) return text;\n    let uris = clipboardData.getData(\"text/uri-list\");\n    return uris ? uris.replace(/\\r?\\n/g, \" \") : \"\";\n}\neditHandlers.paste = (view, _event)=>{\n    let event = _event;\n    // Handling paste from JavaScript during composition is very poorly\n    // handled by browsers, so as a dodgy but preferable kludge, we just\n    // let the browser do its native thing there, except on Android,\n    // where the editor is almost always composing.\n    if (view.composing && !android) return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    if (data && doPaste(view, getText(data), data.getData(\"text/html\"), plain, event)) event.preventDefault();\n    else capturePaste(view, event);\n};\nclass Dragging {\n    constructor(slice, move, node){\n        this.slice = slice;\n        this.move = move;\n        this.node = node;\n    }\n}\nconst dragCopyModifier = mac ? \"altKey\" : \"ctrlKey\";\nfunction dragMoves(view, event) {\n    let moves = view.someProp(\"dragCopies\", (test)=>!test(event));\n    return moves != null ? moves : !event[dragCopyModifier];\n}\nhandlers.dragstart = (view, _event)=>{\n    let event = _event;\n    let mouseDown = view.input.mouseDown;\n    if (mouseDown) mouseDown.done();\n    if (!event.dataTransfer) return;\n    let sel = view.state.selection;\n    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n    let node;\n    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection ? sel.to - 1 : sel.to)) ;\n    else if (mouseDown && mouseDown.mightDrag) {\n        node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);\n    } else if (event.target && event.target.nodeType == 1) {\n        let desc = view.docView.nearestDesc(event.target, true);\n        if (desc && desc.node.type.spec.draggable && desc != view.docView) node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, desc.posBefore);\n    }\n    let draggedSlice = (node || view.state.selection).content();\n    let { dom, text, slice } = serializeForClipboard(view, draggedSlice);\n    // Pre-120 Chrome versions clear files when calling `clearData` (#1472)\n    if (!event.dataTransfer.files.length || !chrome || chrome_version > 120) event.dataTransfer.clearData();\n    event.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n    // See https://github.com/ProseMirror/prosemirror/issues/1156\n    event.dataTransfer.effectAllowed = \"copyMove\";\n    if (!brokenClipboardAPI) event.dataTransfer.setData(\"text/plain\", text);\n    view.dragging = new Dragging(slice, dragMoves(view, event), node);\n};\nhandlers.dragend = (view)=>{\n    let dragging = view.dragging;\n    window.setTimeout(()=>{\n        if (view.dragging == dragging) view.dragging = null;\n    }, 50);\n};\neditHandlers.dragover = editHandlers.dragenter = (_, e)=>e.preventDefault();\neditHandlers.drop = (view, _event)=>{\n    let event = _event;\n    let dragging = view.dragging;\n    view.dragging = null;\n    if (!event.dataTransfer) return;\n    let eventPos = view.posAtCoords(eventCoords(event));\n    if (!eventPos) return;\n    let $mouse = view.state.doc.resolve(eventPos.pos);\n    let slice = dragging && dragging.slice;\n    if (slice) {\n        view.someProp(\"transformPasted\", (f)=>{\n            slice = f(slice, view);\n        });\n    } else {\n        slice = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData(\"text/html\"), false, $mouse);\n    }\n    let move = !!(dragging && dragMoves(view, event));\n    if (view.someProp(\"handleDrop\", (f)=>f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, move))) {\n        event.preventDefault();\n        return;\n    }\n    if (!slice) return;\n    event.preventDefault();\n    let insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n    if (insertPos == null) insertPos = $mouse.pos;\n    let tr = view.state.tr;\n    if (move) {\n        let { node } = dragging;\n        if (node) node.replace(tr);\n        else tr.deleteSelection();\n    }\n    let pos = tr.mapping.map(insertPos);\n    let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n    let beforeInsert = tr.doc;\n    if (isNode) tr.replaceRangeWith(pos, pos, slice.content.firstChild);\n    else tr.replaceRange(pos, pos, slice);\n    if (tr.doc.eq(beforeInsert)) return;\n    let $pos = tr.doc.resolve(pos);\n    if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n        tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos));\n    } else {\n        let end = tr.mapping.map(insertPos);\n        tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo)=>end = newTo);\n        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n    }\n    view.focus();\n    view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n};\nhandlers.focus = (view)=>{\n    view.input.lastFocus = Date.now();\n    if (!view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.add(\"ProseMirror-focused\");\n        view.domObserver.start();\n        view.focused = true;\n        setTimeout(()=>{\n            if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange())) selectionToDOM(view);\n        }, 20);\n    }\n};\nhandlers.blur = (view, _event)=>{\n    let event = _event;\n    if (view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.remove(\"ProseMirror-focused\");\n        view.domObserver.start();\n        if (event.relatedTarget && view.dom.contains(event.relatedTarget)) view.domObserver.currentSelection.clear();\n        view.focused = false;\n    }\n};\nhandlers.beforeinput = (view, _event)=>{\n    let event = _event;\n    // We should probably do more with beforeinput events, but support\n    // is so spotty that I'm still waiting to see where they are going.\n    // Very specific hack to deal with backspace sometimes failing on\n    // Chrome Android when after an uneditable node.\n    if (chrome && android && event.inputType == \"deleteContentBackward\") {\n        view.domObserver.flushSoon();\n        let { domChangeCount } = view.input;\n        setTimeout(()=>{\n            if (view.input.domChangeCount != domChangeCount) return; // Event already had some effect\n            // This bug tends to close the virtual keyboard, so we refocus\n            view.dom.blur();\n            view.focus();\n            if (view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(8, \"Backspace\")))) return;\n            let { $cursor } = view.state.selection;\n            // Crude approximation of backspace behavior when no command handled it\n            if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());\n        }, 50);\n    }\n};\n// Make sure all handlers get registered\nfor(let prop in editHandlers)handlers[prop] = editHandlers[prop];\nfunction compareObjs(a, b) {\n    if (a == b) return true;\n    for(let p in a)if (a[p] !== b[p]) return false;\n    for(let p in b)if (!(p in a)) return false;\n    return true;\n}\nclass WidgetType {\n    constructor(toDOM, spec){\n        this.toDOM = toDOM;\n        this.spec = spec || noSpec;\n        this.side = this.spec.side || 0;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n        return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n    }\n    valid() {\n        return true;\n    }\n    eq(other) {\n        return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));\n    }\n    destroy(node) {\n        if (this.spec.destroy) this.spec.destroy(node);\n    }\n}\nclass InlineType {\n    constructor(attrs, spec){\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n        let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n        return from >= to ? null : new Decoration(from, to, this);\n    }\n    valid(_, span) {\n        return span.from < span.to;\n    }\n    eq(other) {\n        return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    static is(span) {\n        return span.type instanceof InlineType;\n    }\n    destroy() {}\n}\nclass NodeType {\n    constructor(attrs, spec){\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.mapResult(span.from + oldOffset, 1);\n        if (from.deleted) return null;\n        let to = mapping.mapResult(span.to + oldOffset, -1);\n        if (to.deleted || to.pos <= from.pos) return null;\n        return new Decoration(from.pos - offset, to.pos - offset, this);\n    }\n    valid(node, span) {\n        let { index, offset } = node.content.findIndex(span.from), child;\n        return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n    }\n    eq(other) {\n        return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    destroy() {}\n}\n/**\nDecoration objects can be provided to the view through the\n[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in\nseveral variantssee the static members of this class for details.\n*/ class Decoration {\n    /**\n    @internal\n    */ constructor(/**\n    The start position of the decoration.\n    */ from, /**\n    The end position. Will be the same as `from` for [widget\n    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).\n    */ to, /**\n    @internal\n    */ type){\n        this.from = from;\n        this.to = to;\n        this.type = type;\n    }\n    /**\n    @internal\n    */ copy(from, to) {\n        return new Decoration(from, to, this.type);\n    }\n    /**\n    @internal\n    */ eq(other, offset = 0) {\n        return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n    }\n    /**\n    @internal\n    */ map(mapping, offset, oldOffset) {\n        return this.type.map(mapping, this, offset, oldOffset);\n    }\n    /**\n    Creates a widget decoration, which is a DOM node that's shown in\n    the document at the given position. It is recommended that you\n    delay rendering the widget by passing a function that will be\n    called when the widget is actually drawn in a view, but you can\n    also directly pass a DOM node. `getPos` can be used to find the\n    widget's current document position.\n    */ static widget(pos, toDOM, spec) {\n        return new Decoration(pos, pos, new WidgetType(toDOM, spec));\n    }\n    /**\n    Creates an inline decoration, which adds the given attributes to\n    each inline node between `from` and `to`.\n    */ static inline(from, to, attrs, spec) {\n        return new Decoration(from, to, new InlineType(attrs, spec));\n    }\n    /**\n    Creates a node decoration. `from` and `to` should point precisely\n    before and after a node in the document. That node, and only that\n    node, will receive the given attributes.\n    */ static node(from, to, attrs, spec) {\n        return new Decoration(from, to, new NodeType(attrs, spec));\n    }\n    /**\n    The spec provided when creating this decoration. Can be useful\n    if you've stored extra information in that object.\n    */ get spec() {\n        return this.type.spec;\n    }\n    /**\n    @internal\n    */ get inline() {\n        return this.type instanceof InlineType;\n    }\n    /**\n    @internal\n    */ get widget() {\n        return this.type instanceof WidgetType;\n    }\n}\nconst none = [], noSpec = {};\n/**\nA collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such\na way that the drawing algorithm can efficiently use and compare\nthem. This is a persistent data structureit is not modified,\nupdates create a new value.\n*/ class DecorationSet {\n    /**\n    @internal\n    */ constructor(local, children){\n        this.local = local.length ? local : none;\n        this.children = children.length ? children : none;\n    }\n    /**\n    Create a set of decorations, using the structure of the given\n    document. This will consume (modify) the `decorations` array, so\n    you must make a copy if you want need to preserve that.\n    */ static create(doc, decorations) {\n        return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;\n    }\n    /**\n    Find all decorations in this set which touch the given range\n    (including decorations that start or end directly at the\n    boundaries) and match the given predicate on their spec. When\n    `start` and `end` are omitted, all decorations in the set are\n    considered. When `predicate` isn't given, all decorations are\n    assumed to match.\n    */ find(start, end, predicate) {\n        let result = [];\n        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n        return result;\n    }\n    findInner(start, end, result, offset, predicate) {\n        for(let i = 0; i < this.local.length; i++){\n            let span = this.local[i];\n            if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) result.push(span.copy(span.from + offset, span.to + offset));\n        }\n        for(let i = 0; i < this.children.length; i += 3){\n            if (this.children[i] < end && this.children[i + 1] > start) {\n                let childOff = this.children[i] + 1;\n                this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n            }\n        }\n    }\n    /**\n    Map the set of decorations in response to a change in the\n    document.\n    */ map(mapping, doc, options) {\n        if (this == empty || mapping.maps.length == 0) return this;\n        return this.mapInner(mapping, doc, 0, 0, options || noSpec);\n    }\n    /**\n    @internal\n    */ mapInner(mapping, node, offset, oldOffset, options) {\n        let newLocal;\n        for(let i = 0; i < this.local.length; i++){\n            let mapped = this.local[i].map(mapping, offset, oldOffset);\n            if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped);\n            else if (options.onRemove) options.onRemove(this.local[i].spec);\n        }\n        if (this.children.length) return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);\n        else return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;\n    }\n    /**\n    Add the given array of decorations to the ones in the set,\n    producing a new set. Consumes the `decorations` array. Needs\n    access to the current document to create the appropriate tree\n    structure.\n    */ add(doc, decorations) {\n        if (!decorations.length) return this;\n        if (this == empty) return DecorationSet.create(doc, decorations);\n        return this.addInner(doc, decorations, 0);\n    }\n    addInner(doc, decorations, offset) {\n        let children, childIndex = 0;\n        doc.forEach((childNode, childOffset)=>{\n            let baseOffset = childOffset + offset, found;\n            if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return;\n            if (!children) children = this.children.slice();\n            while(childIndex < children.length && children[childIndex] < childOffset)childIndex += 3;\n            if (children[childIndex] == childOffset) children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);\n            else children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));\n            childIndex += 3;\n        });\n        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n        for(let i = 0; i < local.length; i++)if (!local[i].type.valid(doc, local[i])) local.splice(i--, 1);\n        return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n    }\n    /**\n    Create a new set that contains the decorations in this set, minus\n    the ones in the given array.\n    */ remove(decorations) {\n        if (decorations.length == 0 || this == empty) return this;\n        return this.removeInner(decorations, 0);\n    }\n    removeInner(decorations, offset) {\n        let children = this.children, local = this.local;\n        for(let i = 0; i < children.length; i += 3){\n            let found;\n            let from = children[i] + offset, to = children[i + 1] + offset;\n            for(let j = 0, span; j < decorations.length; j++)if (span = decorations[j]) {\n                if (span.from > from && span.to < to) {\n                    decorations[j] = null;\n                    (found || (found = [])).push(span);\n                }\n            }\n            if (!found) continue;\n            if (children == this.children) children = this.children.slice();\n            let removed = children[i + 2].removeInner(found, from + 1);\n            if (removed != empty) {\n                children[i + 2] = removed;\n            } else {\n                children.splice(i, 3);\n                i -= 3;\n            }\n        }\n        if (local.length) {\n            for(let i = 0, span; i < decorations.length; i++)if (span = decorations[i]) {\n                for(let j = 0; j < local.length; j++)if (local[j].eq(span, offset)) {\n                    if (local == this.local) local = this.local.slice();\n                    local.splice(j--, 1);\n                }\n            }\n        }\n        if (children == this.children && local == this.local) return this;\n        return local.length || children.length ? new DecorationSet(local, children) : empty;\n    }\n    forChild(offset, node) {\n        if (this == empty) return this;\n        if (node.isLeaf) return DecorationSet.empty;\n        let child, local;\n        for(let i = 0; i < this.children.length; i += 3)if (this.children[i] >= offset) {\n            if (this.children[i] == offset) child = this.children[i + 2];\n            break;\n        }\n        let start = offset + 1, end = start + node.content.size;\n        for(let i = 0; i < this.local.length; i++){\n            let dec = this.local[i];\n            if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {\n                let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n                if (from < to) (local || (local = [])).push(dec.copy(from, to));\n            }\n        }\n        if (local) {\n            let localSet = new DecorationSet(local.sort(byPos), none);\n            return child ? new DecorationGroup([\n                localSet,\n                child\n            ]) : localSet;\n        }\n        return child || empty;\n    }\n    /**\n    @internal\n    */ eq(other) {\n        if (this == other) return true;\n        if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) return false;\n        for(let i = 0; i < this.local.length; i++)if (!this.local[i].eq(other.local[i])) return false;\n        for(let i = 0; i < this.children.length; i += 3)if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2])) return false;\n        return true;\n    }\n    /**\n    @internal\n    */ locals(node) {\n        return removeOverlap(this.localsInner(node));\n    }\n    /**\n    @internal\n    */ localsInner(node) {\n        if (this == empty) return none;\n        if (node.inlineContent || !this.local.some(InlineType.is)) return this.local;\n        let result = [];\n        for(let i = 0; i < this.local.length; i++){\n            if (!(this.local[i].type instanceof InlineType)) result.push(this.local[i]);\n        }\n        return result;\n    }\n    forEachSet(f) {\n        f(this);\n    }\n}\n/**\nThe empty set of decorations.\n*/ DecorationSet.empty = new DecorationSet([], []);\n/**\n@internal\n*/ DecorationSet.removeOverlap = removeOverlap;\nconst empty = DecorationSet.empty;\n// An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nclass DecorationGroup {\n    constructor(members){\n        this.members = members;\n    }\n    map(mapping, doc) {\n        const mappedDecos = this.members.map((member)=>member.map(mapping, doc, noSpec));\n        return DecorationGroup.from(mappedDecos);\n    }\n    forChild(offset, child) {\n        if (child.isLeaf) return DecorationSet.empty;\n        let found = [];\n        for(let i = 0; i < this.members.length; i++){\n            let result = this.members[i].forChild(offset, child);\n            if (result == empty) continue;\n            if (result instanceof DecorationGroup) found = found.concat(result.members);\n            else found.push(result);\n        }\n        return DecorationGroup.from(found);\n    }\n    eq(other) {\n        if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) return false;\n        for(let i = 0; i < this.members.length; i++)if (!this.members[i].eq(other.members[i])) return false;\n        return true;\n    }\n    locals(node) {\n        let result, sorted = true;\n        for(let i = 0; i < this.members.length; i++){\n            let locals = this.members[i].localsInner(node);\n            if (!locals.length) continue;\n            if (!result) {\n                result = locals;\n            } else {\n                if (sorted) {\n                    result = result.slice();\n                    sorted = false;\n                }\n                for(let j = 0; j < locals.length; j++)result.push(locals[j]);\n            }\n        }\n        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n    }\n    // Create a group for the given array of decoration sets, or return\n    // a single set when possible.\n    static from(members) {\n        switch(members.length){\n            case 0:\n                return empty;\n            case 1:\n                return members[0];\n            default:\n                return new DecorationGroup(members.every((m)=>m instanceof DecorationSet) ? members : members.reduce((r, m)=>r.concat(m instanceof DecorationSet ? m : m.members), []));\n        }\n    }\n    forEachSet(f) {\n        for(let i = 0; i < this.members.length; i++)this.members[i].forEachSet(f);\n    }\n}\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n    let children = oldChildren.slice();\n    // Mark the children that are directly touched by changes, and\n    // move those that are after the changes.\n    for(let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++){\n        let moved = 0;\n        mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd)=>{\n            let dSize = newEnd - newStart - (oldEnd - oldStart);\n            for(let i = 0; i < children.length; i += 3){\n                let end = children[i + 1];\n                if (end < 0 || oldStart > end + baseOffset - moved) continue;\n                let start = children[i] + baseOffset - moved;\n                if (oldEnd >= start) {\n                    children[i + 1] = oldStart <= start ? -2 : -1;\n                } else if (oldStart >= baseOffset && dSize) {\n                    children[i] += dSize;\n                    children[i + 1] += dSize;\n                }\n            }\n            moved += dSize;\n        });\n        baseOffset = mapping.maps[i].map(baseOffset, -1);\n    }\n    // Find the child nodes that still correspond to a single node,\n    // recursively call mapInner on them and update their positions.\n    let mustRebuild = false;\n    for(let i = 0; i < children.length; i += 3)if (children[i + 1] < 0) {\n        if (children[i + 1] == -2) {\n            mustRebuild = true;\n            children[i + 1] = -1;\n            continue;\n        }\n        let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset;\n        if (fromLocal < 0 || fromLocal >= node.content.size) {\n            mustRebuild = true;\n            continue;\n        }\n        // Must read oldChildren because children was tagged with -1\n        let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;\n        let { index, offset: childOffset } = node.content.findIndex(fromLocal);\n        let childNode = node.maybeChild(index);\n        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n            let mapped = children[i + 2].mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options);\n            if (mapped != empty) {\n                children[i] = fromLocal;\n                children[i + 1] = toLocal;\n                children[i + 2] = mapped;\n            } else {\n                children[i + 1] = -2;\n                mustRebuild = true;\n            }\n        } else {\n            mustRebuild = true;\n        }\n    }\n    // Remaining children must be collected and rebuilt into the appropriate structure\n    if (mustRebuild) {\n        let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n        let built = buildTree(decorations, node, 0, options);\n        newLocal = built.local;\n        for(let i = 0; i < children.length; i += 3)if (children[i + 1] < 0) {\n            children.splice(i, 3);\n            i -= 3;\n        }\n        for(let i = 0, j = 0; i < built.children.length; i += 3){\n            let from = built.children[i];\n            while(j < children.length && children[j] < from)j += 3;\n            children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);\n        }\n    }\n    return new DecorationSet(newLocal.sort(byPos), children);\n}\nfunction moveSpans(spans, offset) {\n    if (!offset || !spans.length) return spans;\n    let result = [];\n    for(let i = 0; i < spans.length; i++){\n        let span = spans[i];\n        result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n    }\n    return result;\n}\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n    // Gather all decorations from the remaining marked children\n    function gather(set, oldOffset) {\n        for(let i = 0; i < set.local.length; i++){\n            let mapped = set.local[i].map(mapping, offset, oldOffset);\n            if (mapped) decorations.push(mapped);\n            else if (options.onRemove) options.onRemove(set.local[i].spec);\n        }\n        for(let i = 0; i < set.children.length; i += 3)gather(set.children[i + 2], set.children[i] + oldOffset + 1);\n    }\n    for(let i = 0; i < children.length; i += 3)if (children[i + 1] == -1) gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n    return decorations;\n}\nfunction takeSpansForNode(spans, node, offset) {\n    if (node.isLeaf) return null;\n    let end = offset + node.nodeSize, found = null;\n    for(let i = 0, span; i < spans.length; i++){\n        if ((span = spans[i]) && span.from > offset && span.to < end) {\n            (found || (found = [])).push(span);\n            spans[i] = null;\n        }\n    }\n    return found;\n}\nfunction withoutNulls(array) {\n    let result = [];\n    for(let i = 0; i < array.length; i++)if (array[i] != null) result.push(array[i]);\n    return result;\n}\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtracted from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n    let children = [], hasNulls = false;\n    node.forEach((childNode, localStart)=>{\n        let found = takeSpansForNode(spans, childNode, localStart + offset);\n        if (found) {\n            hasNulls = true;\n            let subtree = buildTree(found, childNode, offset + localStart + 1, options);\n            if (subtree != empty) children.push(localStart, localStart + childNode.nodeSize, subtree);\n        }\n    });\n    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n    for(let i = 0; i < locals.length; i++)if (!locals[i].type.valid(node, locals[i])) {\n        if (options.onRemove) options.onRemove(locals[i].spec);\n        locals.splice(i--, 1);\n    }\n    return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n}\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n    return a.from - b.from || a.to - b.to;\n}\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n    let working = spans;\n    for(let i = 0; i < working.length - 1; i++){\n        let span = working[i];\n        if (span.from != span.to) for(let j = i + 1; j < working.length; j++){\n            let next = working[j];\n            if (next.from == span.from) {\n                if (next.to != span.to) {\n                    if (working == spans) working = spans.slice();\n                    // Followed by a partially overlapping larger span. Split that\n                    // span.\n                    working[j] = next.copy(next.from, span.to);\n                    insertAhead(working, j + 1, next.copy(span.to, next.to));\n                }\n                continue;\n            } else {\n                if (next.from < span.to) {\n                    if (working == spans) working = spans.slice();\n                    // The end of this one overlaps with a subsequent span. Split\n                    // this one.\n                    working[i] = span.copy(span.from, next.from);\n                    insertAhead(working, j, span.copy(next.from, span.to));\n                }\n                break;\n            }\n        }\n    }\n    return working;\n}\nfunction insertAhead(array, i, deco) {\n    while(i < array.length && byPos(deco, array[i]) > 0)i++;\n    array.splice(i, 0, deco);\n}\n// Get the decorations associated with the current props of a view.\nfunction viewDecorations(view) {\n    let found = [];\n    view.someProp(\"decorations\", (f)=>{\n        let result = f(view.state);\n        if (result && result != empty) found.push(result);\n    });\n    if (view.cursorWrapper) found.push(DecorationSet.create(view.state.doc, [\n        view.cursorWrapper.deco\n    ]));\n    return DecorationGroup.from(found);\n}\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true,\n    attributes: true,\n    attributeOldValue: true,\n    subtree: true\n};\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nconst useCharData = ie && ie_version <= 11;\nclass SelectionState {\n    constructor(){\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    set(sel) {\n        this.anchorNode = sel.anchorNode;\n        this.anchorOffset = sel.anchorOffset;\n        this.focusNode = sel.focusNode;\n        this.focusOffset = sel.focusOffset;\n    }\n    clear() {\n        this.anchorNode = this.focusNode = null;\n    }\n    eq(sel) {\n        return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n    }\n}\nclass DOMObserver {\n    constructor(view, handleDOMChange){\n        this.view = view;\n        this.handleDOMChange = handleDOMChange;\n        this.queue = [];\n        this.flushingSoon = -1;\n        this.observer = null;\n        this.currentSelection = new SelectionState;\n        this.onCharData = null;\n        this.suppressingSelectionUpdates = false;\n        this.lastChangedTextNode = null;\n        this.observer = window.MutationObserver && new window.MutationObserver((mutations)=>{\n            for(let i = 0; i < mutations.length; i++)this.queue.push(mutations[i]);\n            // IE11 will sometimes (on backspacing out a single character\n            // text node after a BR node) call the observer callback\n            // before actually updating the DOM, which will cause\n            // ProseMirror to miss the change (see #930)\n            if (ie && ie_version <= 11 && mutations.some((m)=>m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();\n            else this.flush();\n        });\n        if (useCharData) {\n            this.onCharData = (e)=>{\n                this.queue.push({\n                    target: e.target,\n                    type: \"characterData\",\n                    oldValue: e.prevValue\n                });\n                this.flushSoon();\n            };\n        }\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    flushSoon() {\n        if (this.flushingSoon < 0) this.flushingSoon = window.setTimeout(()=>{\n            this.flushingSoon = -1;\n            this.flush();\n        }, 20);\n    }\n    forceFlush() {\n        if (this.flushingSoon > -1) {\n            window.clearTimeout(this.flushingSoon);\n            this.flushingSoon = -1;\n            this.flush();\n        }\n    }\n    start() {\n        if (this.observer) {\n            this.observer.takeRecords();\n            this.observer.observe(this.view.dom, observeOptions);\n        }\n        if (this.onCharData) this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.connectSelection();\n    }\n    stop() {\n        if (this.observer) {\n            let take = this.observer.takeRecords();\n            if (take.length) {\n                for(let i = 0; i < take.length; i++)this.queue.push(take[i]);\n                window.setTimeout(()=>this.flush(), 20);\n            }\n            this.observer.disconnect();\n        }\n        if (this.onCharData) this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.disconnectSelection();\n    }\n    connectSelection() {\n        this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    disconnectSelection() {\n        this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    suppressSelectionUpdates() {\n        this.suppressingSelectionUpdates = true;\n        setTimeout(()=>this.suppressingSelectionUpdates = false, 50);\n    }\n    onSelectionChange() {\n        if (!hasFocusAndSelection(this.view)) return;\n        if (this.suppressingSelectionUpdates) return selectionToDOM(this.view);\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n            let sel = this.view.domSelectionRange();\n            // Selection.isCollapsed isn't reliable on IE\n            if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) return this.flushSoon();\n        }\n        this.flush();\n    }\n    setCurSelection() {\n        this.currentSelection.set(this.view.domSelectionRange());\n    }\n    ignoreSelectionChange(sel) {\n        if (!sel.focusNode) return true;\n        let ancestors = new Set, container;\n        for(let scan = sel.focusNode; scan; scan = parentNode(scan))ancestors.add(scan);\n        for(let scan = sel.anchorNode; scan; scan = parentNode(scan))if (ancestors.has(scan)) {\n            container = scan;\n            break;\n        }\n        let desc = container && this.view.docView.nearestDesc(container);\n        if (desc && desc.ignoreMutation({\n            type: \"selection\",\n            target: container.nodeType == 3 ? container.parentNode : container\n        })) {\n            this.setCurSelection();\n            return true;\n        }\n    }\n    pendingRecords() {\n        if (this.observer) for (let mut of this.observer.takeRecords())this.queue.push(mut);\n        return this.queue;\n    }\n    flush() {\n        let { view } = this;\n        if (!view.docView || this.flushingSoon > -1) return;\n        let mutations = this.pendingRecords();\n        if (mutations.length) this.queue = [];\n        let sel = view.domSelectionRange();\n        let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n        let from = -1, to = -1, typeOver = false, added = [];\n        if (view.editable) {\n            for(let i = 0; i < mutations.length; i++){\n                let result = this.registerMutation(mutations[i], added);\n                if (result) {\n                    from = from < 0 ? result.from : Math.min(result.from, from);\n                    to = to < 0 ? result.to : Math.max(result.to, to);\n                    if (result.typeOver) typeOver = true;\n                }\n            }\n        }\n        if (gecko && added.length) {\n            let brs = added.filter((n)=>n.nodeName == \"BR\");\n            if (brs.length == 2) {\n                let [a, b] = brs;\n                if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove();\n                else a.remove();\n            } else {\n                let { focusNode } = this.currentSelection;\n                for (let br of brs){\n                    let parent = br.parentNode;\n                    if (parent && parent.nodeName == \"LI\" && (!focusNode || blockParent(view, focusNode) != parent)) br.remove();\n                }\n            }\n        }\n        let readSel = null;\n        // If it looks like the browser has reset the selection to the\n        // start of the document after focus, restore the selection from\n        // the state\n        if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(view.state.doc.resolve(0), 1))) {\n            view.input.lastFocus = 0;\n            selectionToDOM(view);\n            this.currentSelection.set(sel);\n            view.scrollToSelection();\n        } else if (from > -1 || newSel) {\n            if (from > -1) {\n                view.docView.markDirty(from, to);\n                checkCSS(view);\n            }\n            this.handleDOMChange(from, to, typeOver, added);\n            if (view.docView && view.docView.dirty) view.updateState(view.state);\n            else if (!this.currentSelection.eq(sel)) selectionToDOM(view);\n            this.currentSelection.set(sel);\n        }\n    }\n    registerMutation(mut, added) {\n        // Ignore mutations inside nodes that were already noted as inserted\n        if (added.indexOf(mut.target) > -1) return null;\n        let desc = this.view.docView.nearestDesc(mut.target);\n        if (mut.type == \"attributes\" && (desc == this.view.docView || mut.attributeName == \"contenteditable\" || // Firefox sometimes fires spurious events for null/empty styles\n        mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))) return null;\n        if (!desc || desc.ignoreMutation(mut)) return null;\n        if (mut.type == \"childList\") {\n            for(let i = 0; i < mut.addedNodes.length; i++){\n                let node = mut.addedNodes[i];\n                added.push(node);\n                if (node.nodeType == 3) this.lastChangedTextNode = node;\n            }\n            if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) return {\n                from: desc.posBefore,\n                to: desc.posAfter\n            };\n            let prev = mut.previousSibling, next = mut.nextSibling;\n            if (ie && ie_version <= 11 && mut.addedNodes.length) {\n                // IE11 gives us incorrect next/prev siblings for some\n                // insertions, so if there are added nodes, recompute those\n                for(let i = 0; i < mut.addedNodes.length; i++){\n                    let { previousSibling, nextSibling } = mut.addedNodes[i];\n                    if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling;\n                    if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling;\n                }\n            }\n            let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;\n            let from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n            let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;\n            let to = desc.localPosFromDOM(mut.target, toOffset, 1);\n            return {\n                from,\n                to\n            };\n        } else if (mut.type == \"attributes\") {\n            return {\n                from: desc.posAtStart - desc.border,\n                to: desc.posAtEnd + desc.border\n            };\n        } else {\n            this.lastChangedTextNode = mut.target;\n            return {\n                from: desc.posAtStart,\n                to: desc.posAtEnd,\n                // An event was generated for a text change that didn't change\n                // any text. Mark the dom change to fall back to assuming the\n                // selection was typed over with an identical value if it can't\n                // find another change.\n                typeOver: mut.target.nodeValue == mut.oldValue\n            };\n        }\n    }\n}\nlet cssChecked = new WeakMap();\nlet cssCheckWarned = false;\nfunction checkCSS(view) {\n    if (cssChecked.has(view)) return;\n    cssChecked.set(view, null);\n    if ([\n        \"normal\",\n        \"nowrap\",\n        \"pre-line\"\n    ].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n        view.requiresGeckoHackNode = gecko;\n        if (cssCheckWarned) return;\n        console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\");\n        cssCheckWarned = true;\n    }\n}\nfunction rangeToSelectionRange(view, range) {\n    let anchorNode = range.startContainer, anchorOffset = range.startOffset;\n    let focusNode = range.endContainer, focusOffset = range.endOffset;\n    let currentAnchor = view.domAtPos(view.state.selection.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [\n        focusNode,\n        focusOffset,\n        anchorNode,\n        anchorOffset\n    ];\n    return {\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset\n    };\n}\n// Used to work around a Safari Selection/shadow DOM bug\n// Based on https://github.com/codemirror/dev/issues/414 fix\nfunction safariShadowSelectionRange(view, selection) {\n    if (selection.getComposedRanges) {\n        let range = selection.getComposedRanges(view.root)[0];\n        if (range) return rangeToSelectionRange(view, range);\n    }\n    let found;\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    // Because Safari (at least in 2018-2022) doesn't provide regular\n    // access to the selection inside a shadowRoot, we have to perform a\n    // ridiculous hack to get at itusing `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    view.dom.addEventListener(\"beforeinput\", read, true);\n    document.execCommand(\"indent\");\n    view.dom.removeEventListener(\"beforeinput\", read, true);\n    return found ? rangeToSelectionRange(view, found) : null;\n}\nfunction blockParent(view, node) {\n    for(let p = node.parentNode; p && p != view.dom; p = p.parentNode){\n        let desc = view.docView.nearestDesc(p, true);\n        if (desc && desc.node.isBlock) return p;\n    }\n    return null;\n}\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\nfunction parseBetween(view, from_, to_) {\n    let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);\n    let domSel = view.domSelectionRange();\n    let find;\n    let anchor = domSel.anchorNode;\n    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n        find = [\n            {\n                node: anchor,\n                offset: domSel.anchorOffset\n            }\n        ];\n        if (!selectionCollapsed(domSel)) find.push({\n            node: domSel.focusNode,\n            offset: domSel.focusOffset\n        });\n    }\n    // Work around issue in Chrome where backspacing sometimes replaces\n    // the deleted content with a random BR node (issues #799, #831)\n    if (chrome && view.input.lastKeyCode === 8) {\n        for(let off = toOffset; off > fromOffset; off--){\n            let node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n            if (node.nodeName == \"BR\" && !desc) {\n                toOffset = off;\n                break;\n            }\n            if (!desc || desc.size) break;\n        }\n    }\n    let startDoc = view.state.doc;\n    let parser = view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n    let $from = startDoc.resolve(from);\n    let sel = null, doc = parser.parse(parent, {\n        topNode: $from.parent,\n        topMatch: $from.parent.contentMatchAt($from.index()),\n        topOpen: true,\n        from: fromOffset,\n        to: toOffset,\n        preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n        findPositions: find,\n        ruleFromNode,\n        context: $from\n    });\n    if (find && find[0].pos != null) {\n        let anchor = find[0].pos, head = find[1] && find[1].pos;\n        if (head == null) head = anchor;\n        sel = {\n            anchor: anchor + from,\n            head: head + from\n        };\n    }\n    return {\n        doc,\n        sel,\n        from,\n        to\n    };\n}\nfunction ruleFromNode(dom) {\n    let desc = dom.pmViewDesc;\n    if (desc) {\n        return desc.parseRule();\n    } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n        // Safari replaces the list item or table cell with a BR\n        // directly in the list node (?!) if you delete the last\n        // character in a list item or table cell (#708, #862)\n        if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n            let skip = document.createElement(\"div\");\n            skip.appendChild(document.createElement(\"li\"));\n            return {\n                skip\n            };\n        } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n            return {\n                ignore: true\n            };\n        }\n    } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n        return {\n            ignore: true\n        };\n    }\n    return null;\n}\nconst isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);\n    view.input.compositionPendingChanges = 0;\n    if (from < 0) {\n        let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n        let newSel = selectionFromDOM(view, origin);\n        if (newSel && !view.state.selection.eq(newSel)) {\n            if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) return;\n            let tr = view.state.tr.setSelection(newSel);\n            if (origin == \"pointer\") tr.setMeta(\"pointer\", true);\n            else if (origin == \"key\") tr.scrollIntoView();\n            if (compositionID) tr.setMeta(\"composition\", compositionID);\n            view.dispatch(tr);\n        }\n        return;\n    }\n    let $before = view.state.doc.resolve(from);\n    let shared = $before.sharedDepth(to);\n    from = $before.before(shared + 1);\n    to = view.state.doc.resolve(to).after(shared + 1);\n    let sel = view.state.selection;\n    let parse = parseBetween(view, from, to);\n    let doc = view.state.doc, compare = doc.slice(parse.from, parse.to);\n    let preferredPos, preferredSide;\n    // Prefer anchoring to end when Backspace is pressed\n    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n        preferredPos = view.state.selection.to;\n        preferredSide = \"end\";\n    } else {\n        preferredPos = view.state.selection.from;\n        preferredSide = \"start\";\n    }\n    view.input.lastKeyCode = null;\n    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n    if (change) view.input.domChangeCount++;\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n)=>n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    if (!change) {\n        if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n            change = {\n                start: sel.from,\n                endA: sel.to,\n                endB: sel.to\n            };\n        } else {\n            if (parse.sel) {\n                let sel = resolveSelection(view, view.state.doc, parse.sel);\n                if (sel && !sel.eq(view.state.selection)) {\n                    let tr = view.state.tr.setSelection(sel);\n                    if (compositionID) tr.setMeta(\"composition\", compositionID);\n                    view.dispatch(tr);\n                }\n            }\n            return;\n        }\n    }\n    // Handle the case where overwriting a selection by typing matches\n    // the start or end of the selected content, creating a change\n    // that's smaller than what was actually overwritten.\n    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {\n            change.start = view.state.selection.from;\n        } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {\n            change.endB += view.state.selection.to - change.endA;\n            change.endA = view.state.selection.to;\n        }\n    }\n    // IE11 will insert a non-breaking space _ahead_ of the space after\n    // the cursor space when adding a space before another space. When\n    // that happened, adjust the change to cover the space instead.\n    if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\xa0\") {\n        change.start--;\n        change.endA--;\n        change.endB--;\n    }\n    let $from = parse.doc.resolveNoCache(change.start - parse.from);\n    let $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    let $fromA = doc.resolve(change.start);\n    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n    let nextSel;\n    // If this looks like the effect of pressing Enter (or was recorded\n    // as being an iOS enter press), just dispatch an Enter key instead.\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n)=>n.nodeName == \"DIV\" || n.nodeName == \"P\")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && (nextSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head > $from.pos) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    // Same for backspace\n    if (view.state.selection.anchor > change.start && looksLikeBackspace(doc, change.start, change.endA, $from, $to) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(8, \"Backspace\")))) {\n        if (android && chrome) view.domObserver.suppressSelectionUpdates(); // #820\n        return;\n    }\n    // Chrome will occasionally, during composition, delete the\n    // entire composition and then immediately insert it again. This is\n    // used to detect that situation.\n    if (chrome && change.endB == change.start) view.input.lastChromeDelete = Date.now();\n    // This tries to detect Android virtual keyboard\n    // enter-and-pick-suggestion action. That sometimes (see issue\n    // #1059) first fires a DOM mutation, before moving the selection to\n    // the newly created block. And then, because ProseMirror cleans up\n    // the DOM selection, it gives up moving the selection entirely,\n    // leaving the cursor in the wrong place. When that happens, we drop\n    // the new paragraph from the initial change, and fire a simulated\n    // enter key afterwards.\n    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n        change.endB -= 2;\n        $to = parse.doc.resolveNoCache(change.endB - parse.from);\n        setTimeout(()=>{\n            view.someProp(\"handleKeyDown\", function(f) {\n                return f(view, keyEvent(13, \"Enter\"));\n            });\n        }, 20);\n    }\n    let chFrom = change.start, chTo = change.endA;\n    let tr, storedMarks, markChange;\n    if (inlineChange) {\n        if ($from.pos == $to.pos) {\n            // IE11 sometimes weirdly moves the DOM selection around after\n            // backspacing out the first element in a textblock\n            if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n                view.domObserver.suppressSelectionUpdates();\n                setTimeout(()=>selectionToDOM(view), 20);\n            }\n            tr = view.state.tr.delete(chFrom, chTo);\n            storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));\n        } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {\n            tr = view.state.tr;\n            if (markChange.type == \"add\") tr.addMark(chFrom, chTo, markChange.mark);\n            else tr.removeMark(chFrom, chTo, markChange.mark);\n        } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n            // Both positions in the same text node -- simply insert text\n            let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n            if (view.someProp(\"handleTextInput\", (f)=>f(view, chFrom, chTo, text))) return;\n            tr = view.state.tr.insertText(text, chFrom, chTo);\n        }\n    }\n    if (!tr) tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n    if (parse.sel) {\n        let sel = resolveSelection(view, tr.doc, parse.sel);\n        // Chrome will sometimes, during composition, report the\n        // selection in the wrong place. If it looks like that is\n        // happening, don't update the selection.\n        // Edge just doesn't move the cursor forward when you start typing\n        // in an empty block or between br nodes.\n        if (sel && !(chrome && view.composing && sel.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel.head == chFrom || sel.head == tr.mapping.map(chTo) - 1) || ie && sel.empty && sel.head == chFrom)) tr.setSelection(sel);\n    }\n    if (storedMarks) tr.ensureMarks(storedMarks);\n    if (compositionID) tr.setMeta(\"composition\", compositionID);\n    view.dispatch(tr.scrollIntoView());\n}\nfunction resolveSelection(view, doc, parsedSel) {\n    if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null;\n    return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));\n}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n    let added = curMarks, removed = prevMarks, type, mark, update;\n    for(let i = 0; i < prevMarks.length; i++)added = prevMarks[i].removeFromSet(added);\n    for(let i = 0; i < curMarks.length; i++)removed = curMarks[i].removeFromSet(removed);\n    if (added.length == 1 && removed.length == 0) {\n        mark = added[0];\n        type = \"add\";\n        update = (node)=>node.mark(mark.addToSet(node.marks));\n    } else if (added.length == 0 && removed.length == 1) {\n        mark = removed[0];\n        type = \"remove\";\n        update = (node)=>node.mark(mark.removeFromSet(node.marks));\n    } else {\n        return null;\n    }\n    let updated = [];\n    for(let i = 0; i < prev.childCount; i++)updated.push(update(prev.child(i)));\n    if (prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated).eq(cur)) return {\n        mark,\n        type\n    };\n}\nfunction looksLikeBackspace(old, start, end, $newStart, $newEnd) {\n    if (end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into\n    skipClosingAndOpening($newStart, true, false) < $newEnd.pos) return false;\n    let $start = old.resolve(start);\n    // Handle the case where, rather than joining blocks, the change just removed an entire block\n    if (!$newStart.parent.isTextblock) {\n        let after = $start.nodeAfter;\n        return after != null && end == start + after.nodeSize;\n    }\n    // Start must be at the end of a block\n    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) return false;\n    let $next = old.resolve(skipClosingAndOpening($start, true, true));\n    // The next textblock must start before end and end near it\n    if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) return false;\n    // The fragments after the join point must match\n    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n}\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n    while(depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)){\n        depth--;\n        end++;\n        fromEnd = false;\n    }\n    if (mayOpen) {\n        let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n        while(next && !next.isLeaf){\n            next = next.firstChild;\n            end++;\n        }\n    }\n    return end;\n}\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n    let start = a.findDiffStart(b, pos);\n    if (start == null) return null;\n    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, start - Math.min(endA, endB));\n        preferredPos -= endA + adjust - start;\n    }\n    if (endA < start && a.size < b.size) {\n        let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1))) start += move ? 1 : -1;\n        endB = start + (endB - endA);\n        endA = start;\n    } else if (endB < start) {\n        let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1))) start += move ? 1 : -1;\n        endA = start + (endA - endB);\n        endB = start;\n    }\n    return {\n        start,\n        endA,\n        endB\n    };\n}\nfunction isSurrogatePair(str) {\n    if (str.length != 2) return false;\n    let a = str.charCodeAt(0), b = str.charCodeAt(1);\n    return a >= 0xDC00 && a <= 0xDFFF && b >= 0xD800 && b <= 0xDBFF;\n}\n/**\n@internal\n*/ const __parseFromClipboard = parseFromClipboard;\n/**\n@internal\n*/ const __endComposition = endComposition;\n/**\nAn editor view manages the DOM structure that represents an\neditable document. Its state and behavior are determined by its\n[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).\n*/ class EditorView {\n    /**\n    Create a view. `place` may be a DOM node that the editor should\n    be appended to, a function that will place it into the document,\n    or an object whose `mount` property holds the node to use as the\n    document container. If it is `null`, the editor will not be\n    added to the document.\n    */ constructor(place, props){\n        this._root = null;\n        /**\n        @internal\n        */ this.focused = false;\n        /**\n        Kludge used to work around a Chrome bug @internal\n        */ this.trackWrites = null;\n        this.mounted = false;\n        /**\n        @internal\n        */ this.markCursor = null;\n        /**\n        @internal\n        */ this.cursorWrapper = null;\n        /**\n        @internal\n        */ this.lastSelectedViewDesc = undefined;\n        /**\n        @internal\n        */ this.input = new InputState;\n        this.prevDirectPlugins = [];\n        this.pluginViews = [];\n        /**\n        Holds `true` when a hack node is needed in Firefox to prevent the\n        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)\n        @internal\n        */ this.requiresGeckoHackNode = false;\n        /**\n        When editor content is being dragged, this object contains\n        information about the dragged slice and whether it is being\n        copied or moved. At any other time, it is null.\n        */ this.dragging = null;\n        this._props = props;\n        this.state = props.state;\n        this.directPlugins = props.plugins || [];\n        this.directPlugins.forEach(checkStateComponent);\n        this.dispatch = this.dispatch.bind(this);\n        this.dom = place && place.mount || document.createElement(\"div\");\n        if (place) {\n            if (place.appendChild) place.appendChild(this.dom);\n            else if (typeof place == \"function\") place(this.dom);\n            else if (place.mount) this.mounted = true;\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        this.nodeViews = buildNodeViews(this);\n        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n        this.domObserver = new DOMObserver(this, (from, to, typeOver, added)=>readDOMChange(this, from, to, typeOver, added));\n        this.domObserver.start();\n        initInput(this);\n        this.updatePluginViews();\n    }\n    /**\n    Holds `true` when a\n    [composition](https://w3c.github.io/uievents/#events-compositionevents)\n    is active.\n    */ get composing() {\n        return this.input.composing;\n    }\n    /**\n    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).\n    */ get props() {\n        if (this._props.state != this.state) {\n            let prev = this._props;\n            this._props = {};\n            for(let name in prev)this._props[name] = prev[name];\n            this._props.state = this.state;\n        }\n        return this._props;\n    }\n    /**\n    Update the view's props. Will immediately cause an update to\n    the DOM.\n    */ update(props) {\n        if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this);\n        let prevProps = this._props;\n        this._props = props;\n        if (props.plugins) {\n            props.plugins.forEach(checkStateComponent);\n            this.directPlugins = props.plugins;\n        }\n        this.updateStateInner(props.state, prevProps);\n    }\n    /**\n    Update the view by updating existing props object with the object\n    given as argument. Equivalent to `view.update(Object.assign({},\n    view.props, props))`.\n    */ setProps(props) {\n        let updated = {};\n        for(let name in this._props)updated[name] = this._props[name];\n        updated.state = this.state;\n        for(let name in props)updated[name] = props[name];\n        this.update(updated);\n    }\n    /**\n    Update the editor's `state` prop, without touching any of the\n    other props.\n    */ updateState(state) {\n        this.updateStateInner(state, this._props);\n    }\n    updateStateInner(state, prevProps) {\n        var _a;\n        let prev = this.state, redraw = false, updateSel = false;\n        // When stored marks are added, stop composition, so that they can\n        // be displayed.\n        if (state.storedMarks && this.composing) {\n            clearComposition(this);\n            updateSel = true;\n        }\n        this.state = state;\n        let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n        if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n            let nodeViews = buildNodeViews(this);\n            if (changedNodeViews(nodeViews, this.nodeViews)) {\n                this.nodeViews = nodeViews;\n                redraw = true;\n            }\n        }\n        if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n            ensureListeners(this);\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n        let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? \"reset\" : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n        let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n        if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true;\n        let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n        if (updateSel) {\n            this.domObserver.stop();\n            // Work around an issue in Chrome, IE, and Edge where changing\n            // the DOM around an active selection puts it into a broken\n            // state where the thing the user sees differs from the\n            // selection reported by the Selection object (#710, #973,\n            // #1011, #1013, #1035).\n            let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n            if (updateDoc) {\n                // If the node that the selection points into is written to,\n                // Chrome sometimes starts misreporting the selection, so this\n                // tracks that and forces a selection reset when our update\n                // did write to the node.\n                let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;\n                if (this.composing) this.input.compositionNode = findCompositionNode(this);\n                if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n                    this.docView.updateOuterDeco(outerDeco);\n                    this.docView.destroy();\n                    this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n                }\n                if (chromeKludge && !this.trackWrites) forceSelUpdate = true;\n            }\n            // Work around for an issue where an update arriving right between\n            // a DOM selection change and the \"selectionchange\" event for it\n            // can cause a spurious DOM selection update, disrupting mouse\n            // drag selection.\n            if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {\n                selectionToDOM(this, forceSelUpdate);\n            } else {\n                syncNodeSelection(this, state.selection);\n                this.domObserver.setCurSelection();\n            }\n            this.domObserver.start();\n        }\n        this.updatePluginViews(prev);\n        if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc)) this.updateDraggedNode(this.dragging, prev);\n        if (scroll == \"reset\") {\n            this.dom.scrollTop = 0;\n        } else if (scroll == \"to selection\") {\n            this.scrollToSelection();\n        } else if (oldScrollPos) {\n            resetScrollPos(oldScrollPos);\n        }\n    }\n    /**\n    @internal\n    */ scrollToSelection() {\n        let startDOM = this.domSelectionRange().focusNode;\n        if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;\n        else if (this.someProp(\"handleScrollToSelection\", (f)=>f(this))) ;\n        else if (this.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n            let target = this.docView.domAfterPos(this.state.selection.from);\n            if (target.nodeType == 1) scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n        } else {\n            scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n        }\n    }\n    destroyPluginViews() {\n        let view;\n        while(view = this.pluginViews.pop())if (view.destroy) view.destroy();\n    }\n    updatePluginViews(prevState) {\n        if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n            this.prevDirectPlugins = this.directPlugins;\n            this.destroyPluginViews();\n            for(let i = 0; i < this.directPlugins.length; i++){\n                let plugin = this.directPlugins[i];\n                if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));\n            }\n            for(let i = 0; i < this.state.plugins.length; i++){\n                let plugin = this.state.plugins[i];\n                if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));\n            }\n        } else {\n            for(let i = 0; i < this.pluginViews.length; i++){\n                let pluginView = this.pluginViews[i];\n                if (pluginView.update) pluginView.update(this, prevState);\n            }\n        }\n    }\n    updateDraggedNode(dragging, prev) {\n        let sel = dragging.node, found = -1;\n        if (this.state.doc.nodeAt(sel.from) == sel.node) {\n            found = sel.from;\n        } else {\n            let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);\n            let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);\n            if (moved == sel.node) found = movedPos;\n        }\n        this.dragging = new Dragging(dragging.slice, dragging.move, found < 0 ? undefined : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(this.state.doc, found));\n    }\n    someProp(propName, f) {\n        let prop = this._props && this._props[propName], value;\n        if (prop != null && (value = f ? f(prop) : prop)) return value;\n        for(let i = 0; i < this.directPlugins.length; i++){\n            let prop = this.directPlugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop)) return value;\n        }\n        let plugins = this.state.plugins;\n        if (plugins) for(let i = 0; i < plugins.length; i++){\n            let prop = plugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop)) return value;\n        }\n    }\n    /**\n    Query whether the view has focus.\n    */ hasFocus() {\n        // Work around IE not handling focus correctly if resize handles are shown.\n        // If the cursor is inside an element with resize handles, activeElement\n        // will be that element instead of this.dom.\n        if (ie) {\n            // If activeElement is within this.dom, and there are no other elements\n            // setting `contenteditable` to false in between, treat it as focused.\n            let node = this.root.activeElement;\n            if (node == this.dom) return true;\n            if (!node || !this.dom.contains(node)) return false;\n            while(node && this.dom != node && this.dom.contains(node)){\n                if (node.contentEditable == \"false\") return false;\n                node = node.parentElement;\n            }\n            return true;\n        }\n        return this.root.activeElement == this.dom;\n    }\n    /**\n    Focus the editor.\n    */ focus() {\n        this.domObserver.stop();\n        if (this.editable) focusPreventScroll(this.dom);\n        selectionToDOM(this);\n        this.domObserver.start();\n    }\n    /**\n    Get the document root in which the editor exists. This will\n    usually be the top-level `document`, but might be a [shadow\n    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n    root if the editor is inside one.\n    */ get root() {\n        let cached = this._root;\n        if (cached == null) for(let search = this.dom.parentNode; search; search = search.parentNode){\n            if (search.nodeType == 9 || search.nodeType == 11 && search.host) {\n                if (!search.getSelection) Object.getPrototypeOf(search).getSelection = ()=>search.ownerDocument.getSelection();\n                return this._root = search;\n            }\n        }\n        return cached || document;\n    }\n    /**\n    When an existing editor view is moved to a new document or\n    shadow tree, call this to make it recompute its root.\n    */ updateRoot() {\n        this._root = null;\n    }\n    /**\n    Given a pair of viewport coordinates, return the document\n    position that corresponds to them. May return null if the given\n    coordinates aren't inside of the editor. When an object is\n    returned, its `pos` property is the position nearest to the\n    coordinates, and its `inside` property holds the position of the\n    inner node that the position falls inside of, or -1 if it is at\n    the top level, not in any node.\n    */ posAtCoords(coords) {\n        return posAtCoords(this, coords);\n    }\n    /**\n    Returns the viewport rectangle at a given document position.\n    `left` and `right` will be the same number, as this returns a\n    flat cursor-ish rectangle. If the position is between two things\n    that aren't directly adjacent, `side` determines which element\n    is used. When < 0, the element before the position is used,\n    otherwise the element after.\n    */ coordsAtPos(pos, side = 1) {\n        return coordsAtPos(this, pos, side);\n    }\n    /**\n    Find the DOM position that corresponds to the given document\n    position. When `side` is negative, find the position as close as\n    possible to the content before the position. When positive,\n    prefer positions close to the content after the position. When\n    zero, prefer as shallow a position as possible.\n    \n    Note that you should **not** mutate the editor's internal DOM,\n    only inspect it (and even that is usually not necessary).\n    */ domAtPos(pos, side = 0) {\n        return this.docView.domFromPos(pos, side);\n    }\n    /**\n    Find the DOM node that represents the document node after the\n    given position. May return `null` when the position doesn't point\n    in front of a node or if the node is inside an opaque node view.\n    \n    This is intended to be able to call things like\n    `getBoundingClientRect` on that DOM node. Do **not** mutate the\n    editor DOM directly, or add styling this way, since that will be\n    immediately overriden by the editor as it redraws the node.\n    */ nodeDOM(pos) {\n        let desc = this.docView.descAt(pos);\n        return desc ? desc.nodeDOM : null;\n    }\n    /**\n    Find the document position that corresponds to a given DOM\n    position. (Whenever possible, it is preferable to inspect the\n    document structure directly, rather than poking around in the\n    DOM, but sometimesfor example when interpreting an event\n    targetyou don't have a choice.)\n    \n    The `bias` parameter can be used to influence which side of a DOM\n    node to use when the position is inside a leaf node.\n    */ posAtDOM(node, offset, bias = -1) {\n        let pos = this.docView.posFromDOM(node, offset, bias);\n        if (pos == null) throw new RangeError(\"DOM position not inside the editor\");\n        return pos;\n    }\n    /**\n    Find out whether the selection is at the end of a textblock when\n    moving in a given direction. When, for example, given `\"left\"`,\n    it will return true if moving left from the current cursor\n    position would leave that position's parent textblock. Will apply\n    to the view's current state by default, but it is possible to\n    pass a different state.\n    */ endOfTextblock(dir, state) {\n        return endOfTextblock(this, state || this.state, dir);\n    }\n    /**\n    Run the editor's paste logic with the given HTML string. The\n    `event`, if given, will be passed to the\n    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.\n    */ pasteHTML(html, event) {\n        return doPaste(this, \"\", html, false, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Run the editor's paste logic with the given plain-text input.\n    */ pasteText(text, event) {\n        return doPaste(this, text, null, true, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Serialize the given slice as it would be if it was copied from\n    this editor. Returns a DOM element that contains a\n    representation of the slice as its children, a textual\n    representation, and the transformed slice (which can be\n    different from the given input due to hooks like\n    [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).\n    */ serializeForClipboard(slice) {\n        return serializeForClipboard(this, slice);\n    }\n    /**\n    Removes the editor from the DOM and destroys all [node\n    views](https://prosemirror.net/docs/ref/#view.NodeView).\n    */ destroy() {\n        if (!this.docView) return;\n        destroyInput(this);\n        this.destroyPluginViews();\n        if (this.mounted) {\n            this.docView.update(this.state.doc, [], viewDecorations(this), this);\n            this.dom.textContent = \"\";\n        } else if (this.dom.parentNode) {\n            this.dom.parentNode.removeChild(this.dom);\n        }\n        this.docView.destroy();\n        this.docView = null;\n        clearReusedRange();\n    }\n    /**\n    This is true when the view has been\n    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be\n    used anymore).\n    */ get isDestroyed() {\n        return this.docView == null;\n    }\n    /**\n    Used for testing.\n    */ dispatchEvent(event) {\n        return dispatchEvent(this, event);\n    }\n    /**\n    Dispatch a transaction. Will call\n    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)\n    when given, and otherwise defaults to applying the transaction to\n    the current state and calling\n    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.\n    This method is bound to the view instance, so that it can be\n    easily passed around.\n    */ dispatch(tr) {\n        let dispatchTransaction = this._props.dispatchTransaction;\n        if (dispatchTransaction) dispatchTransaction.call(this, tr);\n        else this.updateState(this.state.apply(tr));\n    }\n    /**\n    @internal\n    */ domSelectionRange() {\n        let sel = this.domSelection();\n        if (!sel) return {\n            focusNode: null,\n            focusOffset: 0,\n            anchorNode: null,\n            anchorOffset: 0\n        };\n        return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;\n    }\n    /**\n    @internal\n    */ domSelection() {\n        return this.root.getSelection();\n    }\n}\nfunction computeDocDeco(view) {\n    let attrs = Object.create(null);\n    attrs.class = \"ProseMirror\";\n    attrs.contenteditable = String(view.editable);\n    view.someProp(\"attributes\", (value)=>{\n        if (typeof value == \"function\") value = value(view.state);\n        if (value) for(let attr in value){\n            if (attr == \"class\") attrs.class += \" \" + value[attr];\n            else if (attr == \"style\") attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n            else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\") attrs[attr] = String(value[attr]);\n        }\n    });\n    if (!attrs.translate) attrs.translate = \"no\";\n    return [\n        Decoration.node(0, view.state.doc.content.size, attrs)\n    ];\n}\nfunction updateCursorWrapper(view) {\n    if (view.markCursor) {\n        let dom = document.createElement(\"img\");\n        dom.className = \"ProseMirror-separator\";\n        dom.setAttribute(\"mark-placeholder\", \"true\");\n        dom.setAttribute(\"alt\", \"\");\n        view.cursorWrapper = {\n            dom,\n            deco: Decoration.widget(view.state.selection.from, dom, {\n                raw: true,\n                marks: view.markCursor\n            })\n        };\n    } else {\n        view.cursorWrapper = null;\n    }\n}\nfunction getEditable(view) {\n    return !view.someProp(\"editable\", (value)=>value(view.state) === false);\n}\nfunction selectionContextChanged(sel1, sel2) {\n    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n}\nfunction buildNodeViews(view) {\n    let result = Object.create(null);\n    function add(obj) {\n        for(let prop in obj)if (!Object.prototype.hasOwnProperty.call(result, prop)) result[prop] = obj[prop];\n    }\n    view.someProp(\"nodeViews\", add);\n    view.someProp(\"markViews\", add);\n    return result;\n}\nfunction changedNodeViews(a, b) {\n    let nA = 0, nB = 0;\n    for(let prop in a){\n        if (a[prop] != b[prop]) return true;\n        nA++;\n    }\n    for(let _ in b)nB++;\n    return nA != nB;\n}\nfunction checkStateComponent(plugin) {\n    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) throw new RangeError(\"Plugins passed directly to the view must not have a state component\");\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBGO0FBQ047QUFDbEM7QUFFbEQsTUFBTVUsV0FBVyxTQUFVQyxJQUFJO0lBQzNCLElBQUssSUFBSUMsUUFBUSxJQUFJQSxRQUFTO1FBQzFCRCxPQUFPQSxLQUFLRSxlQUFlO1FBQzNCLElBQUksQ0FBQ0YsTUFDRCxPQUFPQztJQUNmO0FBQ0o7QUFDQSxNQUFNRSxhQUFhLFNBQVVILElBQUk7SUFDN0IsSUFBSUksU0FBU0osS0FBS0ssWUFBWSxJQUFJTCxLQUFLRyxVQUFVO0lBQ2pELE9BQU9DLFVBQVVBLE9BQU9FLFFBQVEsSUFBSSxLQUFLRixPQUFPRyxJQUFJLEdBQUdIO0FBQzNEO0FBQ0EsSUFBSUksY0FBYztBQUNsQixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDRCQUE0QjtBQUM1QixNQUFNQyxZQUFZLFNBQVVULElBQUksRUFBRVUsSUFBSSxFQUFFQyxFQUFFO0lBQ3RDLElBQUlDLFFBQVFKLGVBQWdCQSxDQUFBQSxjQUFjSyxTQUFTQyxXQUFXLEVBQUM7SUFDL0RGLE1BQU1HLE1BQU0sQ0FBQ2YsTUFBTVcsTUFBTSxPQUFPWCxLQUFLZ0IsU0FBUyxDQUFDQyxNQUFNLEdBQUdOO0lBQ3hEQyxNQUFNTSxRQUFRLENBQUNsQixNQUFNVSxRQUFRO0lBQzdCLE9BQU9FO0FBQ1g7QUFDQSxNQUFNTyxtQkFBbUI7SUFDckJYLGNBQWM7QUFDbEI7QUFDQSxxRUFBcUU7QUFDckUsa0VBQWtFO0FBQ2xFLDZDQUE2QztBQUM3QyxNQUFNWSx1QkFBdUIsU0FBVXBCLElBQUksRUFBRXFCLEdBQUcsRUFBRUMsVUFBVSxFQUFFQyxTQUFTO0lBQ25FLE9BQU9ELGNBQWVFLENBQUFBLFFBQVF4QixNQUFNcUIsS0FBS0MsWUFBWUMsV0FBVyxDQUFDLE1BQzdEQyxRQUFReEIsTUFBTXFCLEtBQUtDLFlBQVlDLFdBQVcsRUFBQztBQUNuRDtBQUNBLE1BQU1FLGVBQWU7QUFDckIsU0FBU0QsUUFBUXhCLElBQUksRUFBRXFCLEdBQUcsRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQUVHLEdBQUc7SUFDbEQsT0FBUztRQUNMLElBQUkxQixRQUFRc0IsY0FBY0QsT0FBT0UsV0FDN0IsT0FBTztRQUNYLElBQUlGLE9BQVFLLENBQUFBLE1BQU0sSUFBSSxJQUFJQyxTQUFTM0IsS0FBSSxHQUFJO1lBQ3ZDLElBQUlJLFNBQVNKLEtBQUtHLFVBQVU7WUFDNUIsSUFBSSxDQUFDQyxVQUFVQSxPQUFPRSxRQUFRLElBQUksS0FBS3NCLGFBQWE1QixTQUFTeUIsYUFBYUksSUFBSSxDQUFDN0IsS0FBSzhCLFFBQVEsS0FDeEY5QixLQUFLK0IsZUFBZSxJQUFJLFNBQ3hCLE9BQU87WUFDWFYsTUFBTXRCLFNBQVNDLFFBQVMwQixDQUFBQSxNQUFNLElBQUksSUFBSTtZQUN0QzFCLE9BQU9JO1FBQ1gsT0FDSyxJQUFJSixLQUFLTSxRQUFRLElBQUksR0FBRztZQUN6Qk4sT0FBT0EsS0FBS2dDLFVBQVUsQ0FBQ1gsTUFBT0ssQ0FBQUEsTUFBTSxJQUFJLENBQUMsSUFBSSxHQUFHO1lBQ2hELElBQUkxQixLQUFLK0IsZUFBZSxJQUFJLFNBQ3hCLE9BQU87WUFDWFYsTUFBTUssTUFBTSxJQUFJQyxTQUFTM0IsUUFBUTtRQUNyQyxPQUNLO1lBQ0QsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBLFNBQVMyQixTQUFTM0IsSUFBSTtJQUNsQixPQUFPQSxLQUFLTSxRQUFRLElBQUksSUFBSU4sS0FBS2dCLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHakIsS0FBS2dDLFVBQVUsQ0FBQ2YsTUFBTTtBQUM5RTtBQUNBLFNBQVNnQixpQkFBaUJqQyxJQUFJLEVBQUVrQyxNQUFNO0lBQ2xDLE9BQVM7UUFDTCxJQUFJbEMsS0FBS00sUUFBUSxJQUFJLEtBQUs0QixRQUN0QixPQUFPbEM7UUFDWCxJQUFJQSxLQUFLTSxRQUFRLElBQUksS0FBSzRCLFNBQVMsR0FBRztZQUNsQyxJQUFJbEMsS0FBSytCLGVBQWUsSUFBSSxTQUN4QixPQUFPO1lBQ1gvQixPQUFPQSxLQUFLZ0MsVUFBVSxDQUFDRSxTQUFTLEVBQUU7WUFDbENBLFNBQVNQLFNBQVMzQjtRQUN0QixPQUNLLElBQUlBLEtBQUtHLFVBQVUsSUFBSSxDQUFDeUIsYUFBYTVCLE9BQU87WUFDN0NrQyxTQUFTbkMsU0FBU0M7WUFDbEJBLE9BQU9BLEtBQUtHLFVBQVU7UUFDMUIsT0FDSztZQUNELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQSxTQUFTZ0MsZ0JBQWdCbkMsSUFBSSxFQUFFa0MsTUFBTTtJQUNqQyxPQUFTO1FBQ0wsSUFBSWxDLEtBQUtNLFFBQVEsSUFBSSxLQUFLNEIsU0FBU2xDLEtBQUtnQixTQUFTLENBQUNDLE1BQU0sRUFDcEQsT0FBT2pCO1FBQ1gsSUFBSUEsS0FBS00sUUFBUSxJQUFJLEtBQUs0QixTQUFTbEMsS0FBS2dDLFVBQVUsQ0FBQ2YsTUFBTSxFQUFFO1lBQ3ZELElBQUlqQixLQUFLK0IsZUFBZSxJQUFJLFNBQ3hCLE9BQU87WUFDWC9CLE9BQU9BLEtBQUtnQyxVQUFVLENBQUNFLE9BQU87WUFDOUJBLFNBQVM7UUFDYixPQUNLLElBQUlsQyxLQUFLRyxVQUFVLElBQUksQ0FBQ3lCLGFBQWE1QixPQUFPO1lBQzdDa0MsU0FBU25DLFNBQVNDLFFBQVE7WUFDMUJBLE9BQU9BLEtBQUtHLFVBQVU7UUFDMUIsT0FDSztZQUNELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQSxTQUFTaUMsU0FBU3BDLElBQUksRUFBRWtDLE1BQU0sRUFBRTlCLE1BQU07SUFDbEMsSUFBSyxJQUFJaUMsVUFBVUgsVUFBVSxHQUFHSSxRQUFRSixVQUFVUCxTQUFTM0IsT0FBT3FDLFdBQVdDLE9BQVE7UUFDakYsSUFBSXRDLFFBQVFJLFFBQ1IsT0FBTztRQUNYLElBQUlILFFBQVFGLFNBQVNDO1FBQ3JCQSxPQUFPQSxLQUFLRyxVQUFVO1FBQ3RCLElBQUksQ0FBQ0gsTUFDRCxPQUFPO1FBQ1hxQyxVQUFVQSxXQUFXcEMsU0FBUztRQUM5QnFDLFFBQVFBLFNBQVNyQyxTQUFTMEIsU0FBUzNCO0lBQ3ZDO0FBQ0o7QUFDQSxTQUFTNEIsYUFBYVcsR0FBRztJQUNyQixJQUFJQztJQUNKLElBQUssSUFBSUMsTUFBTUYsS0FBS0UsS0FBS0EsTUFBTUEsSUFBSXRDLFVBQVUsQ0FDekMsSUFBSXFDLE9BQU9DLElBQUlDLFVBQVUsRUFDckI7SUFDUixPQUFPRixRQUFRQSxLQUFLeEMsSUFBSSxJQUFJd0MsS0FBS3hDLElBQUksQ0FBQzJDLE9BQU8sSUFBS0gsQ0FBQUEsS0FBS0QsR0FBRyxJQUFJQSxPQUFPQyxLQUFLSSxVQUFVLElBQUlMLEdBQUU7QUFDOUY7QUFDQSx3RkFBd0Y7QUFDeEYsMkRBQTJEO0FBQzNELE1BQU1NLHFCQUFxQixTQUFVQyxNQUFNO0lBQ3ZDLE9BQU9BLE9BQU9DLFNBQVMsSUFBSTNCLHFCQUFxQjBCLE9BQU9DLFNBQVMsRUFBRUQsT0FBT0UsV0FBVyxFQUFFRixPQUFPRyxVQUFVLEVBQUVILE9BQU9JLFlBQVk7QUFDaEk7QUFDQSxTQUFTQyxTQUFTQyxPQUFPLEVBQUVDLEdBQUc7SUFDMUIsSUFBSUMsUUFBUXpDLFNBQVMwQyxXQUFXLENBQUM7SUFDakNELE1BQU1FLFNBQVMsQ0FBQyxXQUFXLE1BQU07SUFDakNGLE1BQU1GLE9BQU8sR0FBR0E7SUFDaEJFLE1BQU1ELEdBQUcsR0FBR0MsTUFBTUcsSUFBSSxHQUFHSjtJQUN6QixPQUFPQztBQUNYO0FBQ0EsU0FBU0ksa0JBQWtCQyxHQUFHO0lBQzFCLElBQUlDLE1BQU1ELElBQUlFLGFBQWE7SUFDM0IsTUFBT0QsT0FBT0EsSUFBSUUsVUFBVSxDQUN4QkYsTUFBTUEsSUFBSUUsVUFBVSxDQUFDRCxhQUFhO0lBQ3RDLE9BQU9EO0FBQ1g7QUFDQSxTQUFTRyxlQUFlSixHQUFHLEVBQUVLLENBQUMsRUFBRUMsQ0FBQztJQUM3QixJQUFJTixJQUFJTyxzQkFBc0IsRUFBRTtRQUM1QixJQUFJO1lBQ0EsSUFBSUMsTUFBTVIsSUFBSU8sc0JBQXNCLENBQUNGLEdBQUdDO1lBQ3hDLDREQUE0RDtZQUM1RCw4REFBOEQ7WUFDOUQsU0FBUztZQUNULElBQUlFLEtBQ0EsT0FBTztnQkFBRW5FLE1BQU1tRSxJQUFJQyxVQUFVO2dCQUFFbEMsUUFBUW1DLEtBQUtDLEdBQUcsQ0FBQzNDLFNBQVN3QyxJQUFJQyxVQUFVLEdBQUdELElBQUlqQyxNQUFNO1lBQUU7UUFDOUYsRUFDQSxPQUFPcUMsR0FBRyxDQUFFO0lBQ2hCO0lBQ0EsSUFBSVosSUFBSWEsbUJBQW1CLEVBQUU7UUFDekIsSUFBSTVELFFBQVErQyxJQUFJYSxtQkFBbUIsQ0FBQ1IsR0FBR0M7UUFDdkMsSUFBSXJELE9BQ0EsT0FBTztZQUFFWixNQUFNWSxNQUFNNkQsY0FBYztZQUFFdkMsUUFBUW1DLEtBQUtDLEdBQUcsQ0FBQzNDLFNBQVNmLE1BQU02RCxjQUFjLEdBQUc3RCxNQUFNOEQsV0FBVztRQUFFO0lBQ2pIO0FBQ0o7QUFFQSxNQUFNQyxNQUFNLE9BQU9DLGFBQWEsY0FBY0EsWUFBWTtBQUMxRCxNQUFNakIsTUFBTSxPQUFPOUMsWUFBWSxjQUFjQSxXQUFXO0FBQ3hELE1BQU1nRSxRQUFRLE9BQVFGLElBQUlHLFNBQVMsSUFBSztBQUN4QyxNQUFNQyxVQUFVLGNBQWNDLElBQUksQ0FBQ0g7QUFDbkMsTUFBTUksWUFBWSxVQUFVRCxJQUFJLENBQUNIO0FBQ2pDLE1BQU1LLFVBQVUsd0NBQXdDRixJQUFJLENBQUNIO0FBQzdELE1BQU1NLEtBQUssQ0FBQyxDQUFFRixDQUFBQSxhQUFhQyxXQUFXSCxPQUFNO0FBQzVDLE1BQU1LLGFBQWFILFlBQVlwRSxTQUFTd0UsWUFBWSxHQUFHSCxVQUFVLENBQUNBLE9BQU8sQ0FBQyxFQUFFLEdBQUdILFVBQVUsQ0FBQ0EsT0FBTyxDQUFDLEVBQUUsR0FBRztBQUN2RyxNQUFNTyxRQUFRLENBQUNILE1BQU0sZ0JBQWdCdEQsSUFBSSxDQUFDZ0Q7QUFDMUNTLFNBQVMsQ0FBQyxDQUFDLGlCQUFpQk4sSUFBSSxDQUFDSCxVQUFVO0lBQUM7SUFBRztDQUFFLENBQUMsQ0FBQyxFQUFFO0FBQ3JELE1BQU1VLFVBQVUsQ0FBQ0osTUFBTSxnQkFBZ0JILElBQUksQ0FBQ0g7QUFDNUMsTUFBTVcsU0FBUyxDQUFDLENBQUNEO0FBQ2pCLE1BQU1FLGlCQUFpQkYsVUFBVSxDQUFDQSxPQUFPLENBQUMsRUFBRSxHQUFHO0FBQy9DLE1BQU1HLFNBQVMsQ0FBQ1AsTUFBTSxDQUFDLENBQUNSLE9BQU8saUJBQWlCOUMsSUFBSSxDQUFDOEMsSUFBSWdCLE1BQU07QUFDL0Qsa0RBQWtEO0FBQ2xELE1BQU1DLE1BQU1GLFVBQVcsZUFBYzdELElBQUksQ0FBQ2dELFVBQVUsQ0FBQyxDQUFDRixPQUFPQSxJQUFJa0IsY0FBYyxHQUFHO0FBQ2xGLE1BQU1DLE1BQU1GLE9BQVFqQixDQUFBQSxNQUFNLE1BQU05QyxJQUFJLENBQUM4QyxJQUFJb0IsUUFBUSxJQUFJLEtBQUk7QUFDekQsTUFBTUMsVUFBVXJCLE1BQU0sTUFBTTlDLElBQUksQ0FBQzhDLElBQUlvQixRQUFRLElBQUk7QUFDakQsTUFBTUUsVUFBVSxhQUFhcEUsSUFBSSxDQUFDZ0Q7QUFDbEMsTUFBTXFCLFNBQVMsQ0FBQyxDQUFDdkMsT0FBTyx5QkFBeUJBLElBQUl3QyxlQUFlLENBQUNDLEtBQUs7QUFDMUUsTUFBTUMsaUJBQWlCSCxTQUFTLENBQUMsQ0FBQyx1QkFBdUJsQixJQUFJLENBQUNKLFVBQVVFLFNBQVMsS0FBSztJQUFDO0lBQUc7Q0FBRSxDQUFDLENBQUMsRUFBRSxHQUFHO0FBRW5HLFNBQVN3QixXQUFXM0MsR0FBRztJQUNuQixJQUFJNEMsS0FBSzVDLElBQUk2QyxXQUFXLElBQUk3QyxJQUFJNkMsV0FBVyxDQUFDQyxjQUFjO0lBQzFELElBQUlGLElBQ0EsT0FBTztRQUNIRyxNQUFNO1FBQUdDLE9BQU9KLEdBQUdLLEtBQUs7UUFDeEJDLEtBQUs7UUFBR0MsUUFBUVAsR0FBR1EsTUFBTTtJQUM3QjtJQUNKLE9BQU87UUFBRUwsTUFBTTtRQUFHQyxPQUFPaEQsSUFBSXdDLGVBQWUsQ0FBQ2EsV0FBVztRQUNwREgsS0FBSztRQUFHQyxRQUFRbkQsSUFBSXdDLGVBQWUsQ0FBQ2MsWUFBWTtJQUFDO0FBQ3pEO0FBQ0EsU0FBU0MsUUFBUUMsS0FBSyxFQUFFQyxJQUFJO0lBQ3hCLE9BQU8sT0FBT0QsU0FBUyxXQUFXQSxRQUFRQSxLQUFLLENBQUNDLEtBQUs7QUFDekQ7QUFDQSxTQUFTQyxXQUFXckgsSUFBSTtJQUNwQixJQUFJc0gsT0FBT3RILEtBQUt1SCxxQkFBcUI7SUFDckMsc0RBQXNEO0lBQ3RELElBQUlDLFNBQVMsS0FBTVosS0FBSyxHQUFHNUcsS0FBS3lILFdBQVcsSUFBSztJQUNoRCxJQUFJQyxTQUFTLEtBQU1YLE1BQU0sR0FBRy9HLEtBQUsySCxZQUFZLElBQUs7SUFDbEQsNERBQTREO0lBQzVELE9BQU87UUFBRWpCLE1BQU1ZLEtBQUtaLElBQUk7UUFBRUMsT0FBT1csS0FBS1osSUFBSSxHQUFHMUcsS0FBS2dILFdBQVcsR0FBR1E7UUFDNURYLEtBQUtTLEtBQUtULEdBQUc7UUFBRUMsUUFBUVEsS0FBS1QsR0FBRyxHQUFHN0csS0FBS2lILFlBQVksR0FBR1M7SUFBTztBQUNyRTtBQUNBLFNBQVNFLG1CQUFtQkMsSUFBSSxFQUFFUCxJQUFJLEVBQUVRLFFBQVE7SUFDNUMsSUFBSUMsa0JBQWtCRixLQUFLRyxRQUFRLENBQUMsc0JBQXNCLEdBQUdDLGVBQWVKLEtBQUtHLFFBQVEsQ0FBQyxtQkFBbUI7SUFDN0csSUFBSXJFLE1BQU1rRSxLQUFLdEYsR0FBRyxDQUFDMkYsYUFBYTtJQUNoQyxJQUFLLElBQUk5SCxTQUFTMEgsWUFBWUQsS0FBS3RGLEdBQUcsR0FBSTtRQUN0QyxJQUFJLENBQUNuQyxRQUNEO1FBQ0osSUFBSUEsT0FBT0UsUUFBUSxJQUFJLEdBQUc7WUFDdEJGLFNBQVNELFdBQVdDO1lBQ3BCO1FBQ0o7UUFDQSxJQUFJd0QsTUFBTXhEO1FBQ1YsSUFBSStILFFBQVF2RSxPQUFPRCxJQUFJeUUsSUFBSTtRQUMzQixJQUFJQyxXQUFXRixRQUFRN0IsV0FBVzNDLE9BQU8wRCxXQUFXekQ7UUFDcEQsSUFBSTBFLFFBQVEsR0FBR0MsUUFBUTtRQUN2QixJQUFJakIsS0FBS1QsR0FBRyxHQUFHd0IsU0FBU3hCLEdBQUcsR0FBR0ssUUFBUWEsaUJBQWlCLFFBQ25EUSxRQUFRLENBQUVGLENBQUFBLFNBQVN4QixHQUFHLEdBQUdTLEtBQUtULEdBQUcsR0FBR0ssUUFBUWUsY0FBYyxNQUFLO2FBQzlELElBQUlYLEtBQUtSLE1BQU0sR0FBR3VCLFNBQVN2QixNQUFNLEdBQUdJLFFBQVFhLGlCQUFpQixXQUM5RFEsUUFBUWpCLEtBQUtSLE1BQU0sR0FBR1EsS0FBS1QsR0FBRyxHQUFHd0IsU0FBU3ZCLE1BQU0sR0FBR3VCLFNBQVN4QixHQUFHLEdBQ3pEUyxLQUFLVCxHQUFHLEdBQUdLLFFBQVFlLGNBQWMsU0FBU0ksU0FBU3hCLEdBQUcsR0FDdERTLEtBQUtSLE1BQU0sR0FBR3VCLFNBQVN2QixNQUFNLEdBQUdJLFFBQVFlLGNBQWM7UUFDaEUsSUFBSVgsS0FBS1osSUFBSSxHQUFHMkIsU0FBUzNCLElBQUksR0FBR1EsUUFBUWEsaUJBQWlCLFNBQ3JETyxRQUFRLENBQUVELENBQUFBLFNBQVMzQixJQUFJLEdBQUdZLEtBQUtaLElBQUksR0FBR1EsUUFBUWUsY0FBYyxPQUFNO2FBQ2pFLElBQUlYLEtBQUtYLEtBQUssR0FBRzBCLFNBQVMxQixLQUFLLEdBQUdPLFFBQVFhLGlCQUFpQixVQUM1RE8sUUFBUWhCLEtBQUtYLEtBQUssR0FBRzBCLFNBQVMxQixLQUFLLEdBQUdPLFFBQVFlLGNBQWM7UUFDaEUsSUFBSUssU0FBU0MsT0FBTztZQUNoQixJQUFJSixPQUFPO2dCQUNQeEUsSUFBSTZDLFdBQVcsQ0FBQ2dDLFFBQVEsQ0FBQ0YsT0FBT0M7WUFDcEMsT0FDSztnQkFDRCxJQUFJRSxTQUFTN0UsSUFBSThFLFVBQVUsRUFBRUMsU0FBUy9FLElBQUlnRixTQUFTO2dCQUNuRCxJQUFJTCxPQUNBM0UsSUFBSWdGLFNBQVMsSUFBSUw7Z0JBQ3JCLElBQUlELE9BQ0ExRSxJQUFJOEUsVUFBVSxJQUFJSjtnQkFDdEIsSUFBSU8sS0FBS2pGLElBQUk4RSxVQUFVLEdBQUdELFFBQVFLLEtBQUtsRixJQUFJZ0YsU0FBUyxHQUFHRDtnQkFDdkRyQixPQUFPO29CQUFFWixNQUFNWSxLQUFLWixJQUFJLEdBQUdtQztvQkFBSWhDLEtBQUtTLEtBQUtULEdBQUcsR0FBR2lDO29CQUFJbkMsT0FBT1csS0FBS1gsS0FBSyxHQUFHa0M7b0JBQUkvQixRQUFRUSxLQUFLUixNQUFNLEdBQUdnQztnQkFBRztZQUN4RztRQUNKO1FBQ0EsSUFBSTNFLE1BQU1nRSxRQUFRLFVBQVVZLGlCQUFpQjNJLFFBQVE0SSxRQUFRO1FBQzdELElBQUksbUJBQW1CbkgsSUFBSSxDQUFDc0MsTUFDeEI7UUFDSi9ELFNBQVMrRCxPQUFPLGFBQWEvRCxPQUFPNkksWUFBWSxHQUFHOUksV0FBV0M7SUFDbEU7QUFDSjtBQUNBLHFFQUFxRTtBQUNyRSxtRUFBbUU7QUFDbkUscUVBQXFFO0FBQ3JFLDhDQUE4QztBQUM5QyxTQUFTOEksZUFBZXJCLElBQUk7SUFDeEIsSUFBSVAsT0FBT08sS0FBS3RGLEdBQUcsQ0FBQ2dGLHFCQUFxQixJQUFJb0IsU0FBU3RFLEtBQUs4RSxHQUFHLENBQUMsR0FBRzdCLEtBQUtULEdBQUc7SUFDMUUsSUFBSXVDLFFBQVFDO0lBQ1osSUFBSyxJQUFJckYsSUFBSSxDQUFDc0QsS0FBS1osSUFBSSxHQUFHWSxLQUFLWCxLQUFLLElBQUksR0FBRzFDLElBQUkwRSxTQUFTLEdBQUcxRSxJQUFJSSxLQUFLQyxHQUFHLENBQUNnRixhQUFhaEMsS0FBS1IsTUFBTSxHQUFHN0MsS0FBSyxFQUFHO1FBQ3ZHLElBQUkxQixNQUFNc0YsS0FBSzBCLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUN4RixHQUFHQztRQUN4QyxJQUFJLENBQUMxQixPQUFPQSxPQUFPc0YsS0FBS3RGLEdBQUcsSUFBSSxDQUFDc0YsS0FBS3RGLEdBQUcsQ0FBQ2tILFFBQVEsQ0FBQ2xILE1BQzlDO1FBQ0osSUFBSW1ILFlBQVluSCxJQUFJZ0YscUJBQXFCO1FBQ3pDLElBQUltQyxVQUFVN0MsR0FBRyxJQUFJOEIsU0FBUyxJQUFJO1lBQzlCUyxTQUFTN0c7WUFDVDhHLFNBQVNLLFVBQVU3QyxHQUFHO1lBQ3RCO1FBQ0o7SUFDSjtJQUNBLE9BQU87UUFBRXVDLFFBQVFBO1FBQVFDLFFBQVFBO1FBQVFNLE9BQU9DLFlBQVkvQixLQUFLdEYsR0FBRztJQUFFO0FBQzFFO0FBQ0EsU0FBU3FILFlBQVlySCxHQUFHO0lBQ3BCLElBQUlvSCxRQUFRLEVBQUUsRUFBRWhHLE1BQU1wQixJQUFJMkYsYUFBYTtJQUN2QyxJQUFLLElBQUl6RixNQUFNRixLQUFLRSxLQUFLQSxNQUFNdEMsV0FBV3NDLEtBQU07UUFDNUNrSCxNQUFNRSxJQUFJLENBQUM7WUFBRXRILEtBQUtFO1lBQUtvRSxLQUFLcEUsSUFBSW1HLFNBQVM7WUFBRWxDLE1BQU1qRSxJQUFJaUcsVUFBVTtRQUFDO1FBQ2hFLElBQUluRyxPQUFPb0IsS0FDUDtJQUNSO0lBQ0EsT0FBT2dHO0FBQ1g7QUFDQSxzRUFBc0U7QUFDdEUsaURBQWlEO0FBQ2pELFNBQVNHLGVBQWUsRUFBRVYsTUFBTSxFQUFFQyxNQUFNLEVBQUVNLEtBQUssRUFBRTtJQUM3QyxJQUFJSSxZQUFZWCxTQUFTQSxPQUFPN0IscUJBQXFCLEdBQUdWLEdBQUcsR0FBRztJQUM5RG1ELG1CQUFtQkwsT0FBT0ksYUFBYSxJQUFJLElBQUlBLFlBQVlWO0FBQy9EO0FBQ0EsU0FBU1csbUJBQW1CTCxLQUFLLEVBQUVNLElBQUk7SUFDbkMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlQLE1BQU0xSSxNQUFNLEVBQUVpSixJQUFLO1FBQ25DLElBQUksRUFBRTNILEdBQUcsRUFBRXNFLEdBQUcsRUFBRUgsSUFBSSxFQUFFLEdBQUdpRCxLQUFLLENBQUNPLEVBQUU7UUFDakMsSUFBSTNILElBQUlxRyxTQUFTLElBQUkvQixNQUFNb0QsTUFDdkIxSCxJQUFJcUcsU0FBUyxHQUFHL0IsTUFBTW9EO1FBQzFCLElBQUkxSCxJQUFJbUcsVUFBVSxJQUFJaEMsTUFDbEJuRSxJQUFJbUcsVUFBVSxHQUFHaEM7SUFDekI7QUFDSjtBQUNBLElBQUl5RCx5QkFBeUI7QUFDN0Isc0VBQXNFO0FBQ3RFLHdDQUF3QztBQUN4QyxTQUFTQyxtQkFBbUI3SCxHQUFHO0lBQzNCLElBQUlBLElBQUk4SCxTQUFTLEVBQ2IsT0FBTzlILElBQUk4SCxTQUFTLElBQUksUUFBUTtJQUNwQyxJQUFJRix3QkFDQSxPQUFPNUgsSUFBSStILEtBQUssQ0FBQ0g7SUFDckIsSUFBSUksU0FBU1gsWUFBWXJIO0lBQ3pCQSxJQUFJK0gsS0FBSyxDQUFDSCwwQkFBMEIsT0FBTztRQUN2QyxJQUFJSyxpQkFBZ0I7WUFDaEJMLHlCQUF5QjtnQkFBRUssZUFBZTtZQUFLO1lBQy9DLE9BQU87UUFDWDtJQUNKLElBQUlDO0lBQ0osSUFBSSxDQUFDTix3QkFBd0I7UUFDekJBLHlCQUF5QjtRQUN6QkgsbUJBQW1CTyxRQUFRO0lBQy9CO0FBQ0o7QUFDQSxTQUFTRyxpQkFBaUIxSyxJQUFJLEVBQUUySyxNQUFNO0lBQ2xDLElBQUlDLFNBQVNDLFlBQVksS0FBS0MsZUFBZTVJLFNBQVM7SUFDdEQsSUFBSTZJLFNBQVNKLE9BQU85RCxHQUFHLEVBQUVtRSxTQUFTTCxPQUFPOUQsR0FBRztJQUM1QyxJQUFJb0UsWUFBWUM7SUFDaEIsSUFBSyxJQUFJQyxRQUFRbkwsS0FBS29MLFVBQVUsRUFBRUMsYUFBYSxHQUFHRixPQUFPQSxRQUFRQSxNQUFNRyxXQUFXLEVBQUVELGFBQWM7UUFDOUYsSUFBSUU7UUFDSixJQUFJSixNQUFNN0ssUUFBUSxJQUFJLEdBQ2xCaUwsUUFBUUosTUFBTUssY0FBYzthQUMzQixJQUFJTCxNQUFNN0ssUUFBUSxJQUFJLEdBQ3ZCaUwsUUFBUTlLLFVBQVUwSyxPQUFPSyxjQUFjO2FBRXZDO1FBQ0osSUFBSyxJQUFJdEIsSUFBSSxHQUFHQSxJQUFJcUIsTUFBTXRLLE1BQU0sRUFBRWlKLElBQUs7WUFDbkMsSUFBSTVDLE9BQU9pRSxLQUFLLENBQUNyQixFQUFFO1lBQ25CLElBQUk1QyxLQUFLVCxHQUFHLElBQUlrRSxVQUFVekQsS0FBS1IsTUFBTSxJQUFJa0UsUUFBUTtnQkFDN0NELFNBQVMxRyxLQUFLOEUsR0FBRyxDQUFDN0IsS0FBS1IsTUFBTSxFQUFFaUU7Z0JBQy9CQyxTQUFTM0csS0FBS0MsR0FBRyxDQUFDZ0QsS0FBS1QsR0FBRyxFQUFFbUU7Z0JBQzVCLElBQUlTLEtBQUtuRSxLQUFLWixJQUFJLEdBQUdpRSxPQUFPakUsSUFBSSxHQUFHWSxLQUFLWixJQUFJLEdBQUdpRSxPQUFPakUsSUFBSSxHQUNwRFksS0FBS1gsS0FBSyxHQUFHZ0UsT0FBT2pFLElBQUksR0FBR2lFLE9BQU9qRSxJQUFJLEdBQUdZLEtBQUtYLEtBQUssR0FBRztnQkFDNUQsSUFBSThFLEtBQUtaLFdBQVc7b0JBQ2hCRCxVQUFVTztvQkFDVk4sWUFBWVk7b0JBQ1pYLGdCQUFnQlcsTUFBTWIsUUFBUXRLLFFBQVEsSUFBSSxJQUFJO3dCQUMxQ29HLE1BQU1ZLEtBQUtYLEtBQUssR0FBR2dFLE9BQU9qRSxJQUFJLEdBQUdZLEtBQUtYLEtBQUssR0FBR1csS0FBS1osSUFBSTt3QkFDdkRHLEtBQUs4RCxPQUFPOUQsR0FBRztvQkFDbkIsSUFBSThEO29CQUNKLElBQUlRLE1BQU03SyxRQUFRLElBQUksS0FBS21MLElBQ3ZCdkosU0FBU21KLGFBQWNWLENBQUFBLE9BQU9qRSxJQUFJLElBQUksQ0FBQ1ksS0FBS1osSUFBSSxHQUFHWSxLQUFLWCxLQUFLLElBQUksSUFBSSxJQUFJO29CQUM3RTtnQkFDSjtZQUNKLE9BQ0ssSUFBSVcsS0FBS1QsR0FBRyxHQUFHOEQsT0FBTzlELEdBQUcsSUFBSSxDQUFDb0UsY0FBYzNELEtBQUtaLElBQUksSUFBSWlFLE9BQU9qRSxJQUFJLElBQUlZLEtBQUtYLEtBQUssSUFBSWdFLE9BQU9qRSxJQUFJLEVBQUU7Z0JBQ3BHdUUsYUFBYUU7Z0JBQ2JELGNBQWM7b0JBQUV4RSxNQUFNckMsS0FBSzhFLEdBQUcsQ0FBQzdCLEtBQUtaLElBQUksRUFBRXJDLEtBQUtDLEdBQUcsQ0FBQ2dELEtBQUtYLEtBQUssRUFBRWdFLE9BQU9qRSxJQUFJO29CQUFJRyxLQUFLUyxLQUFLVCxHQUFHO2dCQUFDO1lBQ2hHO1lBQ0EsSUFBSSxDQUFDK0QsV0FBWUQsQ0FBQUEsT0FBT2pFLElBQUksSUFBSVksS0FBS1gsS0FBSyxJQUFJZ0UsT0FBTzlELEdBQUcsSUFBSVMsS0FBS1QsR0FBRyxJQUNoRThELE9BQU9qRSxJQUFJLElBQUlZLEtBQUtaLElBQUksSUFBSWlFLE9BQU85RCxHQUFHLElBQUlTLEtBQUtSLE1BQU0sR0FDckQ1RSxTQUFTbUosYUFBYTtRQUM5QjtJQUNKO0lBQ0EsSUFBSSxDQUFDVCxXQUFXSyxZQUFZO1FBQ3hCTCxVQUFVSztRQUNWSCxnQkFBZ0JJO1FBQ2hCTCxZQUFZO0lBQ2hCO0lBQ0EsSUFBSUQsV0FBV0EsUUFBUXRLLFFBQVEsSUFBSSxHQUMvQixPQUFPb0wsaUJBQWlCZCxTQUFTRTtJQUNyQyxJQUFJLENBQUNGLFdBQVlDLGFBQWFELFFBQVF0SyxRQUFRLElBQUksR0FDOUMsT0FBTztRQUFFTjtRQUFNa0M7SUFBTztJQUMxQixPQUFPd0ksaUJBQWlCRSxTQUFTRTtBQUNyQztBQUNBLFNBQVNZLGlCQUFpQjFMLElBQUksRUFBRTJLLE1BQU07SUFDbEMsSUFBSWdCLE1BQU0zTCxLQUFLZ0IsU0FBUyxDQUFDQyxNQUFNO0lBQy9CLElBQUlMLFFBQVFDLFNBQVNDLFdBQVc7SUFDaEMsSUFBSyxJQUFJb0osSUFBSSxHQUFHQSxJQUFJeUIsS0FBS3pCLElBQUs7UUFDMUJ0SixNQUFNRyxNQUFNLENBQUNmLE1BQU1rSyxJQUFJO1FBQ3ZCdEosTUFBTU0sUUFBUSxDQUFDbEIsTUFBTWtLO1FBQ3JCLElBQUk1QyxPQUFPc0UsV0FBV2hMLE9BQU87UUFDN0IsSUFBSTBHLEtBQUtULEdBQUcsSUFBSVMsS0FBS1IsTUFBTSxFQUN2QjtRQUNKLElBQUkrRSxPQUFPbEIsUUFBUXJELE9BQ2YsT0FBTztZQUFFdEg7WUFBTWtDLFFBQVFnSSxJQUFLUyxDQUFBQSxPQUFPakUsSUFBSSxJQUFJLENBQUNZLEtBQUtaLElBQUksR0FBR1ksS0FBS1gsS0FBSyxJQUFJLElBQUksSUFBSTtRQUFHO0lBQ3pGO0lBQ0EsT0FBTztRQUFFM0c7UUFBTWtDLFFBQVE7SUFBRTtBQUM3QjtBQUNBLFNBQVMySixPQUFPbEIsTUFBTSxFQUFFckQsSUFBSTtJQUN4QixPQUFPcUQsT0FBT2pFLElBQUksSUFBSVksS0FBS1osSUFBSSxHQUFHLEtBQUtpRSxPQUFPakUsSUFBSSxJQUFJWSxLQUFLWCxLQUFLLEdBQUcsS0FDL0RnRSxPQUFPOUQsR0FBRyxJQUFJUyxLQUFLVCxHQUFHLEdBQUcsS0FBSzhELE9BQU85RCxHQUFHLElBQUlTLEtBQUtSLE1BQU0sR0FBRztBQUNsRTtBQUNBLFNBQVNnRixhQUFhdkosR0FBRyxFQUFFb0ksTUFBTTtJQUM3QixJQUFJdkssU0FBU21DLElBQUlwQyxVQUFVO0lBQzNCLElBQUlDLFVBQVUsUUFBUXlCLElBQUksQ0FBQ3pCLE9BQU8wQixRQUFRLEtBQUs2SSxPQUFPakUsSUFBSSxHQUFHbkUsSUFBSWdGLHFCQUFxQixHQUFHYixJQUFJLEVBQ3pGLE9BQU90RztJQUNYLE9BQU9tQztBQUNYO0FBQ0EsU0FBU3dKLGVBQWVsRSxJQUFJLEVBQUVqRSxHQUFHLEVBQUUrRyxNQUFNO0lBQ3JDLElBQUksRUFBRTNLLElBQUksRUFBRWtDLE1BQU0sRUFBRSxHQUFHd0ksaUJBQWlCOUcsS0FBSytHLFNBQVNxQixPQUFPLENBQUM7SUFDOUQsSUFBSWhNLEtBQUtNLFFBQVEsSUFBSSxLQUFLLENBQUNOLEtBQUtvTCxVQUFVLEVBQUU7UUFDeEMsSUFBSTlELE9BQU90SCxLQUFLdUgscUJBQXFCO1FBQ3JDeUUsT0FBTzFFLEtBQUtaLElBQUksSUFBSVksS0FBS1gsS0FBSyxJQUFJZ0UsT0FBT2pFLElBQUksR0FBRyxDQUFDWSxLQUFLWixJQUFJLEdBQUdZLEtBQUtYLEtBQUssSUFBSSxJQUFJLElBQUksQ0FBQztJQUN4RjtJQUNBLE9BQU9rQixLQUFLb0UsT0FBTyxDQUFDQyxVQUFVLENBQUNsTSxNQUFNa0MsUUFBUThKO0FBQ2pEO0FBQ0EsU0FBU0csYUFBYXRFLElBQUksRUFBRTdILElBQUksRUFBRWtDLE1BQU0sRUFBRXlJLE1BQU07SUFDNUMsNkRBQTZEO0lBQzdELG9FQUFvRTtJQUNwRSxvRUFBb0U7SUFDcEUsZ0VBQWdFO0lBQ2hFLGlFQUFpRTtJQUNqRSw4REFBOEQ7SUFDOUQsSUFBSXlCLGVBQWUsQ0FBQztJQUNwQixJQUFLLElBQUkzSixNQUFNekMsTUFBTXFNLFdBQVcsUUFBUztRQUNyQyxJQUFJNUosT0FBT29GLEtBQUt0RixHQUFHLEVBQ2Y7UUFDSixJQUFJQyxPQUFPcUYsS0FBS29FLE9BQU8sQ0FBQ0ssV0FBVyxDQUFDN0osS0FBSyxPQUFPNkU7UUFDaEQsSUFBSSxDQUFDOUUsTUFDRCxPQUFPO1FBQ1gsSUFBSUEsS0FBS0QsR0FBRyxDQUFDakMsUUFBUSxJQUFJLEtBQU1rQyxDQUFBQSxLQUFLeEMsSUFBSSxDQUFDMkMsT0FBTyxJQUFJSCxLQUFLcEMsTUFBTSxJQUFJLENBQUNvQyxLQUFLSSxVQUFVLEtBQy9FLHFEQUFxRDtRQUNwRCxFQUFDMEUsT0FBTzlFLEtBQUtELEdBQUcsQ0FBQ2dGLHFCQUFxQixFQUFDLEVBQUdYLEtBQUssSUFBSVUsS0FBS1AsTUFBTSxHQUFHO1lBQ2xFLElBQUl2RSxLQUFLeEMsSUFBSSxDQUFDMkMsT0FBTyxJQUFJSCxLQUFLcEMsTUFBTSxFQUFFO2dCQUNsQyxrRkFBa0Y7Z0JBQ2xGLElBQUksQ0FBQ2lNLFlBQVkvRSxLQUFLWixJQUFJLEdBQUdpRSxPQUFPakUsSUFBSSxJQUFJWSxLQUFLVCxHQUFHLEdBQUc4RCxPQUFPOUQsR0FBRyxFQUM3RHVGLGVBQWU1SixLQUFLK0osU0FBUztxQkFDNUIsSUFBSSxDQUFDRixZQUFZL0UsS0FBS1gsS0FBSyxHQUFHZ0UsT0FBT2pFLElBQUksSUFBSVksS0FBS1IsTUFBTSxHQUFHNkQsT0FBTzlELEdBQUcsRUFDdEV1RixlQUFlNUosS0FBS2dLLFFBQVE7Z0JBQ2hDSCxXQUFXO1lBQ2Y7WUFDQSxJQUFJLENBQUM3SixLQUFLSSxVQUFVLElBQUl3SixlQUFlLEtBQUssQ0FBQzVKLEtBQUt4QyxJQUFJLENBQUN5TSxNQUFNLEVBQUU7Z0JBQzNELDRFQUE0RTtnQkFDNUUsSUFBSUMsU0FBU2xLLEtBQUt4QyxJQUFJLENBQUMyQyxPQUFPLEdBQUdnSSxPQUFPOUQsR0FBRyxHQUFHLENBQUNTLEtBQUtULEdBQUcsR0FBR1MsS0FBS1IsTUFBTSxJQUFJLElBQ25FNkQsT0FBT2pFLElBQUksR0FBRyxDQUFDWSxLQUFLWixJQUFJLEdBQUdZLEtBQUtYLEtBQUssSUFBSTtnQkFDL0MsT0FBTytGLFNBQVNsSyxLQUFLK0osU0FBUyxHQUFHL0osS0FBS2dLLFFBQVE7WUFDbEQ7UUFDSjtRQUNBL0osTUFBTUQsS0FBS0QsR0FBRyxDQUFDcEMsVUFBVTtJQUM3QjtJQUNBLE9BQU9pTSxlQUFlLENBQUMsSUFBSUEsZUFBZXZFLEtBQUtvRSxPQUFPLENBQUNDLFVBQVUsQ0FBQ2xNLE1BQU1rQyxRQUFRLENBQUM7QUFDckY7QUFDQSxTQUFTc0gsaUJBQWlCbUQsT0FBTyxFQUFFaEMsTUFBTSxFQUFFaUMsR0FBRztJQUMxQyxJQUFJakIsTUFBTWdCLFFBQVEzSyxVQUFVLENBQUNmLE1BQU07SUFDbkMsSUFBSTBLLE9BQU9pQixJQUFJL0YsR0FBRyxHQUFHK0YsSUFBSTlGLE1BQU0sRUFBRTtRQUM3QixJQUFLLElBQUkrRixTQUFTeEksS0FBSzhFLEdBQUcsQ0FBQyxHQUFHOUUsS0FBS0MsR0FBRyxDQUFDcUgsTUFBTSxHQUFHdEgsS0FBS3lJLEtBQUssQ0FBQ25CLE1BQU9oQixDQUFBQSxPQUFPOUQsR0FBRyxHQUFHK0YsSUFBSS9GLEdBQUcsSUFBSytGLENBQUFBLElBQUk5RixNQUFNLEdBQUc4RixJQUFJL0YsR0FBRyxLQUFLLEtBQUtxRCxJQUFJMkMsU0FBVTtZQUNuSSxJQUFJMUIsUUFBUXdCLFFBQVEzSyxVQUFVLENBQUNrSSxFQUFFO1lBQ2pDLElBQUlpQixNQUFNN0ssUUFBUSxJQUFJLEdBQUc7Z0JBQ3JCLElBQUlpTCxRQUFRSixNQUFNSyxjQUFjO2dCQUNoQyxJQUFLLElBQUl1QixJQUFJLEdBQUdBLElBQUl4QixNQUFNdEssTUFBTSxFQUFFOEwsSUFBSztvQkFDbkMsSUFBSXpGLE9BQU9pRSxLQUFLLENBQUN3QixFQUFFO29CQUNuQixJQUFJbEIsT0FBT2xCLFFBQVFyRCxPQUNmLE9BQU9rQyxpQkFBaUIyQixPQUFPUixRQUFRckQ7Z0JBQy9DO1lBQ0o7WUFDQSxJQUFJLENBQUM0QyxJQUFJLENBQUNBLElBQUksS0FBS3lCLEdBQUUsS0FBTWtCLFFBQ3ZCO1FBQ1I7SUFDSjtJQUNBLE9BQU9GO0FBQ1g7QUFDQSx5RUFBeUU7QUFDekUsU0FBU0ssWUFBWW5GLElBQUksRUFBRThDLE1BQU07SUFDN0IsSUFBSWhILE1BQU1rRSxLQUFLdEYsR0FBRyxDQUFDMkYsYUFBYSxFQUFFbEksTUFBTWtDLFNBQVM7SUFDakQsSUFBSStLLFFBQVFsSixlQUFlSixLQUFLZ0gsT0FBT2pFLElBQUksRUFBRWlFLE9BQU85RCxHQUFHO0lBQ3ZELElBQUlvRyxPQUNDLEdBQUVqTixJQUFJLEVBQUVrQyxNQUFNLEVBQUUsR0FBRytLLEtBQUk7SUFDNUIsSUFBSXJKLE1BQU0sQ0FBQ2lFLEtBQUswQixJQUFJLENBQUNDLGdCQUFnQixHQUFHM0IsS0FBSzBCLElBQUksR0FBRzVGLEdBQUUsRUFDakQ2RixnQkFBZ0IsQ0FBQ21CLE9BQU9qRSxJQUFJLEVBQUVpRSxPQUFPOUQsR0FBRztJQUM3QyxJQUFJMUM7SUFDSixJQUFJLENBQUNQLE9BQU8sQ0FBQ2lFLEtBQUt0RixHQUFHLENBQUNrSCxRQUFRLENBQUM3RixJQUFJdEQsUUFBUSxJQUFJLElBQUlzRCxJQUFJekQsVUFBVSxHQUFHeUQsTUFBTTtRQUN0RSxJQUFJZ0osTUFBTS9FLEtBQUt0RixHQUFHLENBQUNnRixxQkFBcUI7UUFDeEMsSUFBSSxDQUFDc0UsT0FBT2xCLFFBQVFpQyxNQUNoQixPQUFPO1FBQ1hoSixNQUFNNEYsaUJBQWlCM0IsS0FBS3RGLEdBQUcsRUFBRW9JLFFBQVFpQztRQUN6QyxJQUFJLENBQUNoSixLQUNELE9BQU87SUFDZjtJQUNBLDRFQUE0RTtJQUM1RSxJQUFJOEIsUUFBUTtRQUNSLElBQUssSUFBSXdILElBQUl0SixLQUFLNUQsUUFBUWtOLEdBQUdBLElBQUkvTSxXQUFXK00sR0FDeEMsSUFBSUEsRUFBRUMsU0FBUyxFQUNYbk4sT0FBT3lLO0lBQ25CO0lBQ0E3RyxNQUFNa0ksYUFBYWxJLEtBQUsrRztJQUN4QixJQUFJM0ssTUFBTTtRQUNOLElBQUlzRixTQUFTdEYsS0FBS00sUUFBUSxJQUFJLEdBQUc7WUFDN0Isa0VBQWtFO1lBQ2xFLDhEQUE4RDtZQUM5RDRCLFNBQVNtQyxLQUFLQyxHQUFHLENBQUNwQyxRQUFRbEMsS0FBS2dDLFVBQVUsQ0FBQ2YsTUFBTTtZQUNoRCw0REFBNEQ7WUFDNUQsK0JBQStCO1lBQy9CLElBQUlpQixTQUFTbEMsS0FBS2dDLFVBQVUsQ0FBQ2YsTUFBTSxFQUFFO2dCQUNqQyxJQUFJbU0sT0FBT3BOLEtBQUtnQyxVQUFVLENBQUNFLE9BQU8sRUFBRTBLO2dCQUNwQyxJQUFJUSxLQUFLdEwsUUFBUSxJQUFJLFNBQVMsQ0FBQzhLLE1BQU1RLEtBQUs3RixxQkFBcUIsRUFBQyxFQUFHWixLQUFLLElBQUlnRSxPQUFPakUsSUFBSSxJQUNuRmtHLElBQUk5RixNQUFNLEdBQUc2RCxPQUFPOUQsR0FBRyxFQUN2QjNFO1lBQ1I7UUFDSjtRQUNBLElBQUltTDtRQUNKLGtIQUFrSDtRQUNsSCxJQUFJbkgsVUFBVWhFLFVBQVVsQyxLQUFLTSxRQUFRLElBQUksS0FBSyxDQUFDK00sT0FBT3JOLEtBQUtnQyxVQUFVLENBQUNFLFNBQVMsRUFBRSxFQUFFNUIsUUFBUSxJQUFJLEtBQzNGK00sS0FBS3RMLGVBQWUsSUFBSSxXQUFXc0wsS0FBSzlGLHFCQUFxQixHQUFHVixHQUFHLElBQUk4RCxPQUFPOUQsR0FBRyxFQUNqRjNFO1FBQ0osOERBQThEO1FBQzlELHdEQUF3RDtRQUN4RCxJQUFJbEMsUUFBUTZILEtBQUt0RixHQUFHLElBQUlMLFVBQVVsQyxLQUFLZ0MsVUFBVSxDQUFDZixNQUFNLEdBQUcsS0FBS2pCLEtBQUtzTixTQUFTLENBQUNoTixRQUFRLElBQUksS0FDdkZxSyxPQUFPOUQsR0FBRyxHQUFHN0csS0FBS3NOLFNBQVMsQ0FBQy9GLHFCQUFxQixHQUFHVCxNQUFNLEVBQzFEM0MsTUFBTTBELEtBQUswRixLQUFLLENBQUM1SixHQUFHLENBQUM2SixPQUFPLENBQUNDLElBQUk7YUFJaEMsSUFBSXZMLFVBQVUsS0FBS2xDLEtBQUtNLFFBQVEsSUFBSSxLQUFLTixLQUFLZ0MsVUFBVSxDQUFDRSxTQUFTLEVBQUUsQ0FBQ0osUUFBUSxJQUFJLE1BQ2xGcUMsTUFBTWdJLGFBQWF0RSxNQUFNN0gsTUFBTWtDLFFBQVF5STtJQUMvQztJQUNBLElBQUl4RyxPQUFPLE1BQ1BBLE1BQU00SCxlQUFlbEUsTUFBTWpFLEtBQUsrRztJQUNwQyxJQUFJbkksT0FBT3FGLEtBQUtvRSxPQUFPLENBQUNLLFdBQVcsQ0FBQzFJLEtBQUs7SUFDekMsT0FBTztRQUFFTztRQUFLdUosUUFBUWxMLE9BQU9BLEtBQUttTCxVQUFVLEdBQUduTCxLQUFLb0wsTUFBTSxHQUFHLENBQUM7SUFBRTtBQUNwRTtBQUNBLFNBQVNDLFFBQVF2RyxJQUFJO0lBQ2pCLE9BQU9BLEtBQUtULEdBQUcsR0FBR1MsS0FBS1IsTUFBTSxJQUFJUSxLQUFLWixJQUFJLEdBQUdZLEtBQUtYLEtBQUs7QUFDM0Q7QUFDQSxTQUFTaUYsV0FBV2tDLE1BQU0sRUFBRTlCLElBQUk7SUFDNUIsSUFBSVQsUUFBUXVDLE9BQU90QyxjQUFjO0lBQ2pDLElBQUlELE1BQU10SyxNQUFNLEVBQUU7UUFDZCxJQUFJOE0sUUFBUXhDLEtBQUssQ0FBQ1MsT0FBTyxJQUFJLElBQUlULE1BQU10SyxNQUFNLEdBQUcsRUFBRTtRQUNsRCxJQUFJNE0sUUFBUUUsUUFDUixPQUFPQTtJQUNmO0lBQ0EsT0FBT0MsTUFBTUMsU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUksQ0FBQzVDLE9BQU9zQyxZQUFZQyxPQUFPdkcscUJBQXFCO0FBQ3BGO0FBQ0EsTUFBTTZHLE9BQU87QUFDYixvRUFBb0U7QUFDcEUsc0RBQXNEO0FBQ3RELFNBQVNDLFlBQVl4RyxJQUFJLEVBQUUxRCxHQUFHLEVBQUVpRCxJQUFJO0lBQ2hDLElBQUksRUFBRXBILElBQUksRUFBRWtDLE1BQU0sRUFBRW9NLElBQUksRUFBRSxHQUFHekcsS0FBS29FLE9BQU8sQ0FBQ3NDLFVBQVUsQ0FBQ3BLLEtBQUtpRCxPQUFPLElBQUksQ0FBQyxJQUFJO0lBQzFFLElBQUlvSCxvQkFBb0J0SSxVQUFVWjtJQUNsQyxJQUFJdEYsS0FBS00sUUFBUSxJQUFJLEdBQUc7UUFDcEIsb0VBQW9FO1FBQ3BFLDZDQUE2QztRQUM3QyxJQUFJa08scUJBQXNCSixDQUFBQSxLQUFLdk0sSUFBSSxDQUFDN0IsS0FBS2dCLFNBQVMsS0FBTW9HLENBQUFBLE9BQU8sSUFBSSxDQUFDbEYsU0FBU0EsVUFBVWxDLEtBQUtnQixTQUFTLENBQUNDLE1BQU0sSUFBSTtZQUM1RyxJQUFJcUcsT0FBT3NFLFdBQVduTCxVQUFVVCxNQUFNa0MsUUFBUUEsU0FBU2tGO1lBQ3ZELDhEQUE4RDtZQUM5RCxzREFBc0Q7WUFDdEQsNkRBQTZEO1lBQzdELElBQUk5QixTQUFTcEQsVUFBVSxLQUFLTCxJQUFJLENBQUM3QixLQUFLZ0IsU0FBUyxDQUFDa0IsU0FBUyxFQUFFLEtBQUtBLFNBQVNsQyxLQUFLZ0IsU0FBUyxDQUFDQyxNQUFNLEVBQUU7Z0JBQzVGLElBQUl3TixhQUFhN0MsV0FBV25MLFVBQVVULE1BQU1rQyxTQUFTLEdBQUdBLFNBQVMsSUFBSSxDQUFDO2dCQUN0RSxJQUFJdU0sV0FBVzVILEdBQUcsSUFBSVMsS0FBS1QsR0FBRyxFQUFFO29CQUM1QixJQUFJNkgsWUFBWTlDLFdBQVduTCxVQUFVVCxNQUFNa0MsUUFBUUEsU0FBUyxJQUFJLENBQUM7b0JBQ2pFLElBQUl3TSxVQUFVN0gsR0FBRyxJQUFJUyxLQUFLVCxHQUFHLEVBQ3pCLE9BQU84SCxTQUFTRCxXQUFXQSxVQUFVaEksSUFBSSxHQUFHK0gsV0FBVy9ILElBQUk7Z0JBQ25FO1lBQ0o7WUFDQSxPQUFPWTtRQUNYLE9BQ0s7WUFDRCxJQUFJNUcsT0FBT3dCLFFBQVF2QixLQUFLdUIsUUFBUTBNLFdBQVd4SCxPQUFPLElBQUksSUFBSSxDQUFDO1lBQzNELElBQUlBLE9BQU8sS0FBSyxDQUFDbEYsUUFBUTtnQkFDckJ2QjtnQkFDQWlPLFdBQVcsQ0FBQztZQUNoQixPQUNLLElBQUl4SCxRQUFRLEtBQUtsRixVQUFVbEMsS0FBS2dCLFNBQVMsQ0FBQ0MsTUFBTSxFQUFFO2dCQUNuRFA7Z0JBQ0FrTyxXQUFXO1lBQ2YsT0FDSyxJQUFJeEgsT0FBTyxHQUFHO2dCQUNmMUc7WUFDSixPQUNLO2dCQUNEQztZQUNKO1lBQ0EsT0FBT2dPLFNBQVMvQyxXQUFXbkwsVUFBVVQsTUFBTVUsTUFBTUMsS0FBS2lPLFdBQVdBLFdBQVc7UUFDaEY7SUFDSjtJQUNBLElBQUlDLE9BQU9oSCxLQUFLMEYsS0FBSyxDQUFDNUosR0FBRyxDQUFDbUwsT0FBTyxDQUFDM0ssTUFBT21LLENBQUFBLFFBQVE7SUFDakQsNENBQTRDO0lBQzVDLElBQUksQ0FBQ08sS0FBS3pPLE1BQU0sQ0FBQzJPLGFBQWEsRUFBRTtRQUM1QixJQUFJVCxRQUFRLFFBQVFwTSxVQUFXa0YsQ0FBQUEsT0FBTyxLQUFLbEYsVUFBVVAsU0FBUzNCLEtBQUksR0FBSTtZQUNsRSxJQUFJME0sU0FBUzFNLEtBQUtnQyxVQUFVLENBQUNFLFNBQVMsRUFBRTtZQUN4QyxJQUFJd0ssT0FBT3BNLFFBQVEsSUFBSSxHQUNuQixPQUFPME8sU0FBU3RDLE9BQU9uRixxQkFBcUIsSUFBSTtRQUN4RDtRQUNBLElBQUkrRyxRQUFRLFFBQVFwTSxTQUFTUCxTQUFTM0IsT0FBTztZQUN6QyxJQUFJaVAsUUFBUWpQLEtBQUtnQyxVQUFVLENBQUNFLE9BQU87WUFDbkMsSUFBSStNLE1BQU0zTyxRQUFRLElBQUksR0FDbEIsT0FBTzBPLFNBQVNDLE1BQU0xSCxxQkFBcUIsSUFBSTtRQUN2RDtRQUNBLE9BQU95SCxTQUFTaFAsS0FBS3VILHFCQUFxQixJQUFJSCxRQUFRO0lBQzFEO0lBQ0EsbURBQW1EO0lBQ25ELElBQUlrSCxRQUFRLFFBQVFwTSxVQUFXa0YsQ0FBQUEsT0FBTyxLQUFLbEYsVUFBVVAsU0FBUzNCLEtBQUksR0FBSTtRQUNsRSxJQUFJME0sU0FBUzFNLEtBQUtnQyxVQUFVLENBQUNFLFNBQVMsRUFBRTtRQUN4QyxJQUFJNEwsU0FBU3BCLE9BQU9wTSxRQUFRLElBQUksSUFBSUcsVUFBVWlNLFFBQVEvSyxTQUFTK0ssVUFBVzhCLENBQUFBLG9CQUFvQixJQUFJLE1BRzVGOUIsT0FBT3BNLFFBQVEsSUFBSSxLQUFNb00sQ0FBQUEsT0FBTzVLLFFBQVEsSUFBSSxRQUFRLENBQUM0SyxPQUFPcEIsV0FBVyxJQUFJb0IsU0FBUztRQUMxRixJQUFJb0IsUUFDQSxPQUFPYSxTQUFTL0MsV0FBV2tDLFFBQVEsSUFBSTtJQUMvQztJQUNBLElBQUlRLFFBQVEsUUFBUXBNLFNBQVNQLFNBQVMzQixPQUFPO1FBQ3pDLElBQUlpUCxRQUFRalAsS0FBS2dDLFVBQVUsQ0FBQ0UsT0FBTztRQUNuQyxNQUFPK00sTUFBTXZNLFVBQVUsSUFBSXVNLE1BQU12TSxVQUFVLENBQUN3TSxlQUFlLENBQ3ZERCxRQUFRQSxNQUFNM0QsV0FBVztRQUM3QixJQUFJd0MsU0FBUyxDQUFDbUIsUUFBUSxPQUFPQSxNQUFNM08sUUFBUSxJQUFJLElBQUlHLFVBQVV3TyxPQUFPLEdBQUlULG9CQUFvQixJQUFJLEtBQzFGUyxNQUFNM08sUUFBUSxJQUFJLElBQUkyTyxRQUFRO1FBQ3BDLElBQUluQixRQUNBLE9BQU9hLFNBQVMvQyxXQUFXa0MsUUFBUSxDQUFDLElBQUk7SUFDaEQ7SUFDQSxtRUFBbUU7SUFDbkUsT0FBT2EsU0FBUy9DLFdBQVc1TCxLQUFLTSxRQUFRLElBQUksSUFBSUcsVUFBVVQsUUFBUUEsTUFBTSxDQUFDb0gsT0FBT0EsUUFBUTtBQUM1RjtBQUNBLFNBQVN1SCxTQUFTckgsSUFBSSxFQUFFWixJQUFJO0lBQ3hCLElBQUlZLEtBQUtWLEtBQUssSUFBSSxHQUNkLE9BQU9VO0lBQ1gsSUFBSXRELElBQUkwQyxPQUFPWSxLQUFLWixJQUFJLEdBQUdZLEtBQUtYLEtBQUs7SUFDckMsT0FBTztRQUFFRSxLQUFLUyxLQUFLVCxHQUFHO1FBQUVDLFFBQVFRLEtBQUtSLE1BQU07UUFBRUosTUFBTTFDO1FBQUcyQyxPQUFPM0M7SUFBRTtBQUNuRTtBQUNBLFNBQVNnTCxTQUFTMUgsSUFBSSxFQUFFVCxHQUFHO0lBQ3ZCLElBQUlTLEtBQUtQLE1BQU0sSUFBSSxHQUNmLE9BQU9PO0lBQ1gsSUFBSXJELElBQUk0QyxNQUFNUyxLQUFLVCxHQUFHLEdBQUdTLEtBQUtSLE1BQU07SUFDcEMsT0FBTztRQUFFRCxLQUFLNUM7UUFBRzZDLFFBQVE3QztRQUFHeUMsTUFBTVksS0FBS1osSUFBSTtRQUFFQyxPQUFPVyxLQUFLWCxLQUFLO0lBQUM7QUFDbkU7QUFDQSxTQUFTd0ksaUJBQWlCdEgsSUFBSSxFQUFFMEYsS0FBSyxFQUFFNkIsQ0FBQztJQUNwQyxJQUFJQyxZQUFZeEgsS0FBSzBGLEtBQUssRUFBRStCLFNBQVN6SCxLQUFLMEIsSUFBSSxDQUFDMUYsYUFBYTtJQUM1RCxJQUFJd0wsYUFBYTlCLE9BQ2IxRixLQUFLMEgsV0FBVyxDQUFDaEM7SUFDckIsSUFBSStCLFVBQVV6SCxLQUFLdEYsR0FBRyxFQUNsQnNGLEtBQUt5QyxLQUFLO0lBQ2QsSUFBSTtRQUNBLE9BQU84RTtJQUNYLFNBQ1E7UUFDSixJQUFJQyxhQUFhOUIsT0FDYjFGLEtBQUswSCxXQUFXLENBQUNGO1FBQ3JCLElBQUlDLFVBQVV6SCxLQUFLdEYsR0FBRyxJQUFJK00sUUFDdEJBLE9BQU9oRixLQUFLO0lBQ3BCO0FBQ0o7QUFDQSx3REFBd0Q7QUFDeEQsNENBQTRDO0FBQzVDLFNBQVNrRix1QkFBdUIzSCxJQUFJLEVBQUUwRixLQUFLLEVBQUU3TCxHQUFHO0lBQzVDLElBQUkrTixNQUFNbEMsTUFBTW1DLFNBQVM7SUFDekIsSUFBSUMsT0FBT2pPLE9BQU8sT0FBTytOLElBQUlHLEtBQUssR0FBR0gsSUFBSUksR0FBRztJQUM1QyxPQUFPVixpQkFBaUJ0SCxNQUFNMEYsT0FBTztRQUNqQyxJQUFJLEVBQUV2TixNQUFNdUMsR0FBRyxFQUFFLEdBQUdzRixLQUFLb0UsT0FBTyxDQUFDc0MsVUFBVSxDQUFDb0IsS0FBS3hMLEdBQUcsRUFBRXpDLE9BQU8sT0FBTyxDQUFDLElBQUk7UUFDekUsT0FBUztZQUNMLElBQUlvTyxVQUFVakksS0FBS29FLE9BQU8sQ0FBQ0ssV0FBVyxDQUFDL0osS0FBSztZQUM1QyxJQUFJLENBQUN1TixTQUNEO1lBQ0osSUFBSUEsUUFBUTlQLElBQUksQ0FBQzJDLE9BQU8sRUFBRTtnQkFDdEJKLE1BQU11TixRQUFRbE4sVUFBVSxJQUFJa04sUUFBUXZOLEdBQUc7Z0JBQ3ZDO1lBQ0o7WUFDQUEsTUFBTXVOLFFBQVF2TixHQUFHLENBQUNwQyxVQUFVO1FBQ2hDO1FBQ0EsSUFBSXdLLFNBQVMwRCxZQUFZeEcsTUFBTThILEtBQUt4TCxHQUFHLEVBQUU7UUFDekMsSUFBSyxJQUFJZ0gsUUFBUTVJLElBQUk2SSxVQUFVLEVBQUVELE9BQU9BLFFBQVFBLE1BQU1HLFdBQVcsQ0FBRTtZQUMvRCxJQUFJeUU7WUFDSixJQUFJNUUsTUFBTTdLLFFBQVEsSUFBSSxHQUNsQnlQLFFBQVE1RSxNQUFNSyxjQUFjO2lCQUMzQixJQUFJTCxNQUFNN0ssUUFBUSxJQUFJLEdBQ3ZCeVAsUUFBUXRQLFVBQVUwSyxPQUFPLEdBQUdBLE1BQU1uSyxTQUFTLENBQUNDLE1BQU0sRUFBRXVLLGNBQWM7aUJBRWxFO1lBQ0osSUFBSyxJQUFJdEIsSUFBSSxHQUFHQSxJQUFJNkYsTUFBTTlPLE1BQU0sRUFBRWlKLElBQUs7Z0JBQ25DLElBQUkwQyxNQUFNbUQsS0FBSyxDQUFDN0YsRUFBRTtnQkFDbEIsSUFBSTBDLElBQUk5RixNQUFNLEdBQUc4RixJQUFJL0YsR0FBRyxHQUFHLEtBQ3RCbkYsQ0FBQUEsT0FBTyxPQUFPaUosT0FBTzlELEdBQUcsR0FBRytGLElBQUkvRixHQUFHLEdBQUcsQ0FBQytGLElBQUk5RixNQUFNLEdBQUc2RCxPQUFPOUQsR0FBRyxJQUFJLElBQzVEK0YsSUFBSTlGLE1BQU0sR0FBRzZELE9BQU83RCxNQUFNLEdBQUcsQ0FBQzZELE9BQU83RCxNQUFNLEdBQUc4RixJQUFJL0YsR0FBRyxJQUFJLElBQy9ELE9BQU87WUFDZjtRQUNKO1FBQ0EsT0FBTztJQUNYO0FBQ0o7QUFDQSxNQUFNbUosV0FBVztBQUNqQixTQUFTQyx5QkFBeUJwSSxJQUFJLEVBQUUwRixLQUFLLEVBQUU3TCxHQUFHO0lBQzlDLElBQUksRUFBRXdPLEtBQUssRUFBRSxHQUFHM0MsTUFBTW1DLFNBQVM7SUFDL0IsSUFBSSxDQUFDUSxNQUFNOVAsTUFBTSxDQUFDK1AsV0FBVyxFQUN6QixPQUFPO0lBQ1gsSUFBSWpPLFNBQVNnTyxNQUFNRSxZQUFZLEVBQUUvTixVQUFVLENBQUNILFFBQVFJLFFBQVFKLFVBQVVnTyxNQUFNOVAsTUFBTSxDQUFDb04sT0FBTyxDQUFDQyxJQUFJO0lBQy9GLElBQUlnQyxNQUFNNUgsS0FBS3dJLFlBQVk7SUFDM0IsSUFBSSxDQUFDWixLQUNELE9BQU9TLE1BQU0vTCxHQUFHLElBQUkrTCxNQUFNSSxLQUFLLE1BQU1KLE1BQU0vTCxHQUFHLElBQUkrTCxNQUFNSyxHQUFHO0lBQy9ELDhEQUE4RDtJQUM5RCw2REFBNkQ7SUFDN0QsSUFBSSxDQUFDUCxTQUFTbk8sSUFBSSxDQUFDcU8sTUFBTTlQLE1BQU0sQ0FBQ29RLFdBQVcsS0FBSyxDQUFDZixJQUFJZ0IsTUFBTSxFQUN2RCxPQUFPL08sT0FBTyxVQUFVQSxPQUFPLGFBQWFXLFVBQVVDO0lBQzFELE9BQU82TSxpQkFBaUJ0SCxNQUFNMEYsT0FBTztRQUNqQyx5REFBeUQ7UUFDekQsZ0VBQWdFO1FBQ2hFLDZEQUE2RDtRQUM3RCxpRUFBaUU7UUFDakUsaUJBQWlCO1FBQ2pCLElBQUksRUFBRXhLLFdBQVcyTixPQUFPLEVBQUUxTixhQUFhMk4sTUFBTSxFQUFFMU4sVUFBVSxFQUFFQyxZQUFZLEVBQUUsR0FBRzJFLEtBQUsrSSxpQkFBaUI7UUFDbEcsSUFBSUMsZUFBZXBCLElBQUlxQixjQUFjLENBQUMsbUJBQW1COztRQUV6RHJCLElBQUlnQixNQUFNLENBQUMsUUFBUS9PLEtBQUs7UUFDeEIsSUFBSXFQLFlBQVliLE1BQU1jLEtBQUssR0FBR25KLEtBQUtvRSxPQUFPLENBQUNnRixXQUFXLENBQUNmLE1BQU14RCxNQUFNLE1BQU03RSxLQUFLdEYsR0FBRztRQUNqRixJQUFJLEVBQUVRLFdBQVdtTyxPQUFPLEVBQUVsTyxhQUFhbU8sTUFBTSxFQUFFLEdBQUd0SixLQUFLK0ksaUJBQWlCO1FBQ3hFLElBQUlRLFNBQVNGLFdBQVcsQ0FBQ0gsVUFBVXRILFFBQVEsQ0FBQ3lILFFBQVE1USxRQUFRLElBQUksSUFBSTRRLFVBQVVBLFFBQVEvUSxVQUFVLEtBQzNGdVEsV0FBV1EsV0FBV1AsVUFBVVE7UUFDckMsaUNBQWlDO1FBQ2pDLElBQUk7WUFDQTFCLElBQUk0QixRQUFRLENBQUNwTyxZQUFZQztZQUN6QixJQUFJd04sV0FBWUEsQ0FBQUEsV0FBV3pOLGNBQWMwTixVQUFVek4sWUFBVyxLQUFNdU0sSUFBSTZCLE1BQU0sRUFDMUU3QixJQUFJNkIsTUFBTSxDQUFDWixTQUFTQztRQUM1QixFQUNBLE9BQU9wTSxHQUFHLENBQUU7UUFDWixJQUFJc00sZ0JBQWdCLE1BQ2hCcEIsSUFBSXFCLGNBQWMsR0FBR0Q7UUFDekIsT0FBT087SUFDWDtBQUNKO0FBQ0EsSUFBSUcsY0FBYztBQUNsQixJQUFJQyxZQUFZO0FBQ2hCLElBQUlDLGVBQWU7QUFDbkIsU0FBU0MsZUFBZTdKLElBQUksRUFBRTBGLEtBQUssRUFBRTdMLEdBQUc7SUFDcEMsSUFBSTZQLGVBQWVoRSxTQUFTaUUsYUFBYTlQLEtBQ3JDLE9BQU8rUDtJQUNYRixjQUFjaEU7SUFDZGlFLFlBQVk5UDtJQUNaLE9BQU8rUCxlQUFlL1AsT0FBTyxRQUFRQSxPQUFPLFNBQ3RDOE4sdUJBQXVCM0gsTUFBTTBGLE9BQU83TCxPQUNwQ3VPLHlCQUF5QnBJLE1BQU0wRixPQUFPN0w7QUFDaEQ7QUFFQSxzRUFBc0U7QUFDdEUsNkRBQTZEO0FBQzdELEVBQUU7QUFDRixvREFBb0Q7QUFDcEQsRUFBRTtBQUNGLGdFQUFnRTtBQUNoRSxtQkFBbUI7QUFDbkIsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSxlQUFlO0FBQ2YsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxNQUFNaVEsWUFBWSxHQUFHQyxjQUFjLEdBQUdDLGdCQUFnQixHQUFHQyxhQUFhO0FBQ3RFLGtFQUFrRTtBQUNsRSxzQ0FBc0M7QUFDdEMsTUFBTUM7SUFDRkMsWUFBWTVSLE1BQU0sRUFBRTZSLFFBQVEsRUFBRTFQLEdBQUcsRUFDakMsa0VBQWtFO0lBQ2xFLGtDQUFrQztJQUNsQ0ssVUFBVSxDQUFFO1FBQ1IsSUFBSSxDQUFDeEMsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQzZSLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDMVAsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0ssVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNzUCxLQUFLLEdBQUdQO1FBQ2Isa0VBQWtFO1FBQ2xFLGVBQWU7UUFDZnBQLElBQUlHLFVBQVUsR0FBRyxJQUFJO0lBQ3pCO0lBQ0EsNkRBQTZEO0lBQzdELG9CQUFvQjtJQUNwQnlQLGNBQWNDLE1BQU0sRUFBRTtRQUFFLE9BQU87SUFBTztJQUN0Q0MsWUFBWUMsSUFBSSxFQUFFO1FBQUUsT0FBTztJQUFPO0lBQ2xDQyxZQUFZdlMsSUFBSSxFQUFFd1MsU0FBUyxFQUFFQyxTQUFTLEVBQUU7UUFBRSxPQUFPO0lBQU87SUFDeERDLFlBQVk1USxRQUFRLEVBQUU7UUFBRSxPQUFPO0lBQU87SUFDdEMsNkRBQTZEO0lBQzdELG1FQUFtRTtJQUNuRSxjQUFjO0lBQ2Q2USxZQUFZO1FBQUUsT0FBTztJQUFNO0lBQzNCLGdFQUFnRTtJQUNoRSxzQkFBc0I7SUFDdEJDLFVBQVV0UCxLQUFLLEVBQUU7UUFBRSxPQUFPO0lBQU87SUFDakMsb0RBQW9EO0lBQ3BELElBQUltSyxPQUFPO1FBQ1AsSUFBSUEsT0FBTztRQUNYLElBQUssSUFBSXZELElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUMrSCxRQUFRLENBQUNoUixNQUFNLEVBQUVpSixJQUN0Q3VELFFBQVEsSUFBSSxDQUFDd0UsUUFBUSxDQUFDL0gsRUFBRSxDQUFDdUQsSUFBSTtRQUNqQyxPQUFPQTtJQUNYO0lBQ0EsK0RBQStEO0lBQy9ELG9CQUFvQjtJQUNwQixJQUFJRyxTQUFTO1FBQUUsT0FBTztJQUFHO0lBQ3pCaUYsVUFBVTtRQUNOLElBQUksQ0FBQ3pTLE1BQU0sR0FBR3FLO1FBQ2QsSUFBSSxJQUFJLENBQUNsSSxHQUFHLENBQUNHLFVBQVUsSUFBSSxJQUFJLEVBQzNCLElBQUksQ0FBQ0gsR0FBRyxDQUFDRyxVQUFVLEdBQUcrSDtRQUMxQixJQUFLLElBQUlQLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUMrSCxRQUFRLENBQUNoUixNQUFNLEVBQUVpSixJQUN0QyxJQUFJLENBQUMrSCxRQUFRLENBQUMvSCxFQUFFLENBQUMySSxPQUFPO0lBQ2hDO0lBQ0FDLGVBQWUzSCxLQUFLLEVBQUU7UUFDbEIsSUFBSyxJQUFJakIsSUFBSSxHQUFHL0YsTUFBTSxJQUFJLENBQUN3SixVQUFVLEdBQUd6RCxJQUFLO1lBQ3pDLElBQUl6SCxNQUFNLElBQUksQ0FBQ3dQLFFBQVEsQ0FBQy9ILEVBQUU7WUFDMUIsSUFBSXpILE9BQU8wSSxPQUNQLE9BQU9oSDtZQUNYQSxPQUFPMUIsSUFBSWdMLElBQUk7UUFDbkI7SUFDSjtJQUNBLElBQUlsQixZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUNuTSxNQUFNLENBQUMwUyxjQUFjLENBQUMsSUFBSTtJQUMxQztJQUNBLElBQUluRixhQUFhO1FBQ2IsT0FBTyxJQUFJLENBQUN2TixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLENBQUMwUyxjQUFjLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQ2xGLE1BQU0sR0FBRztJQUMxRTtJQUNBLElBQUlwQixXQUFXO1FBQ1gsT0FBTyxJQUFJLENBQUNELFNBQVMsR0FBRyxJQUFJLENBQUNrQixJQUFJO0lBQ3JDO0lBQ0EsSUFBSXNGLFdBQVc7UUFDWCxPQUFPLElBQUksQ0FBQ3BGLFVBQVUsR0FBRyxJQUFJLENBQUNGLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQ0csTUFBTTtJQUN4RDtJQUNBb0YsZ0JBQWdCelEsR0FBRyxFQUFFTCxNQUFNLEVBQUU4SixJQUFJLEVBQUU7UUFDL0Isa0VBQWtFO1FBQ2xFLCtCQUErQjtRQUMvQixJQUFJLElBQUksQ0FBQ3BKLFVBQVUsSUFBSSxJQUFJLENBQUNBLFVBQVUsQ0FBQzZHLFFBQVEsQ0FBQ2xILElBQUlqQyxRQUFRLElBQUksSUFBSWlDLE1BQU1BLElBQUlwQyxVQUFVLEdBQUc7WUFDdkYsSUFBSTZMLE9BQU8sR0FBRztnQkFDVixJQUFJaUgsV0FBV3pRO2dCQUNmLElBQUlELE9BQU8sSUFBSSxDQUFDSyxVQUFVLEVBQUU7b0JBQ3hCcVEsWUFBWTFRLElBQUlQLFVBQVUsQ0FBQ0UsU0FBUyxFQUFFO2dCQUMxQyxPQUNLO29CQUNELE1BQU9LLElBQUlwQyxVQUFVLElBQUksSUFBSSxDQUFDeUMsVUFBVSxDQUNwQ0wsTUFBTUEsSUFBSXBDLFVBQVU7b0JBQ3hCOFMsWUFBWTFRLElBQUlyQyxlQUFlO2dCQUNuQztnQkFDQSxNQUFPK1MsYUFBYSxDQUFFLEVBQUN6USxPQUFPeVEsVUFBVXZRLFVBQVUsS0FBS0YsS0FBS3BDLE1BQU0sSUFBSSxJQUFJLEVBQ3RFNlMsWUFBWUEsVUFBVS9TLGVBQWU7Z0JBQ3pDLE9BQU8rUyxZQUFZLElBQUksQ0FBQ0gsY0FBYyxDQUFDdFEsUUFBUUEsS0FBS2lMLElBQUksR0FBRyxJQUFJLENBQUNFLFVBQVU7WUFDOUUsT0FDSztnQkFDRCxJQUFJdUYsVUFBVTFRO2dCQUNkLElBQUlELE9BQU8sSUFBSSxDQUFDSyxVQUFVLEVBQUU7b0JBQ3hCc1EsV0FBVzNRLElBQUlQLFVBQVUsQ0FBQ0UsT0FBTztnQkFDckMsT0FDSztvQkFDRCxNQUFPSyxJQUFJcEMsVUFBVSxJQUFJLElBQUksQ0FBQ3lDLFVBQVUsQ0FDcENMLE1BQU1BLElBQUlwQyxVQUFVO29CQUN4QitTLFdBQVczUSxJQUFJK0ksV0FBVztnQkFDOUI7Z0JBQ0EsTUFBTzRILFlBQVksQ0FBRSxFQUFDMVEsT0FBTzBRLFNBQVN4USxVQUFVLEtBQUtGLEtBQUtwQyxNQUFNLElBQUksSUFBSSxFQUNwRThTLFdBQVdBLFNBQVM1SCxXQUFXO2dCQUNuQyxPQUFPNEgsV0FBVyxJQUFJLENBQUNKLGNBQWMsQ0FBQ3RRLFFBQVEsSUFBSSxDQUFDdVEsUUFBUTtZQUMvRDtRQUNKO1FBQ0EsOERBQThEO1FBQzlELGdFQUFnRTtRQUNoRSx5Q0FBeUM7UUFDekMsSUFBSXpRO1FBQ0osSUFBSUMsT0FBTyxJQUFJLENBQUNBLEdBQUcsSUFBSSxJQUFJLENBQUNLLFVBQVUsRUFBRTtZQUNwQ04sUUFBUUosU0FBU25DLFNBQVMsSUFBSSxDQUFDNkMsVUFBVTtRQUM3QyxPQUNLLElBQUksSUFBSSxDQUFDQSxVQUFVLElBQUksSUFBSSxDQUFDQSxVQUFVLElBQUksSUFBSSxDQUFDTCxHQUFHLElBQUksSUFBSSxDQUFDQSxHQUFHLENBQUNrSCxRQUFRLENBQUMsSUFBSSxDQUFDN0csVUFBVSxHQUFHO1lBQzNGTixRQUFRQyxJQUFJNFEsdUJBQXVCLENBQUMsSUFBSSxDQUFDdlEsVUFBVSxJQUFJO1FBQzNELE9BQ0ssSUFBSSxJQUFJLENBQUNMLEdBQUcsQ0FBQzZJLFVBQVUsRUFBRTtZQUMxQixJQUFJbEosVUFBVSxHQUNWLElBQUssSUFBSWtSLFNBQVM3USxNQUFNNlEsU0FBU0EsT0FBT2pULFVBQVUsQ0FBRTtnQkFDaEQsSUFBSWlULFVBQVUsSUFBSSxDQUFDN1EsR0FBRyxFQUFFO29CQUNwQkQsUUFBUTtvQkFDUjtnQkFDSjtnQkFDQSxJQUFJOFEsT0FBT2xULGVBQWUsRUFDdEI7WUFDUjtZQUNKLElBQUlvQyxTQUFTLFFBQVFKLFVBQVVLLElBQUlQLFVBQVUsQ0FBQ2YsTUFBTSxFQUNoRCxJQUFLLElBQUltUyxTQUFTN1EsTUFBTTZRLFNBQVNBLE9BQU9qVCxVQUFVLENBQUU7Z0JBQ2hELElBQUlpVCxVQUFVLElBQUksQ0FBQzdRLEdBQUcsRUFBRTtvQkFDcEJELFFBQVE7b0JBQ1I7Z0JBQ0o7Z0JBQ0EsSUFBSThRLE9BQU85SCxXQUFXLEVBQ2xCO1lBQ1I7UUFDUjtRQUNBLE9BQU8sQ0FBQ2hKLFNBQVMsT0FBTzBKLE9BQU8sSUFBSTFKLEtBQUksSUFBSyxJQUFJLENBQUN5USxRQUFRLEdBQUcsSUFBSSxDQUFDcEYsVUFBVTtJQUMvRTtJQUNBckIsWUFBWS9KLEdBQUcsRUFBRThRLFlBQVksS0FBSyxFQUFFO1FBQ2hDLElBQUssSUFBSXRGLFFBQVEsTUFBTXRMLE1BQU1GLEtBQUtFLEtBQUtBLE1BQU1BLElBQUl0QyxVQUFVLENBQUU7WUFDekQsSUFBSXFDLE9BQU8sSUFBSSxDQUFDOFEsT0FBTyxDQUFDN1EsTUFBTThRO1lBQzlCLElBQUkvUSxRQUFTLEVBQUM2USxhQUFhN1EsS0FBS3hDLElBQUksR0FBRztnQkFDbkMsNERBQTREO2dCQUM1RCxJQUFJK04sU0FBVXdGLENBQUFBLFVBQVUvUSxLQUFLK1EsT0FBTyxLQUNoQyxDQUFFQSxDQUFBQSxRQUFRalQsUUFBUSxJQUFJLElBQUlpVCxRQUFROUosUUFBUSxDQUFDbEgsSUFBSWpDLFFBQVEsSUFBSSxJQUFJaUMsTUFBTUEsSUFBSXBDLFVBQVUsSUFBSW9ULFdBQVdoUixHQUFFLEdBQ3BHd0wsUUFBUTtxQkFFUixPQUFPdkw7WUFDZjtRQUNKO0lBQ0o7SUFDQThRLFFBQVEvUSxHQUFHLEVBQUU7UUFDVCxJQUFJQyxPQUFPRCxJQUFJRyxVQUFVO1FBQ3pCLElBQUssSUFBSUQsTUFBTUQsTUFBTUMsS0FBS0EsTUFBTUEsSUFBSXJDLE1BQU0sQ0FDdEMsSUFBSXFDLE9BQU8sSUFBSSxFQUNYLE9BQU9EO0lBQ25CO0lBQ0EwSixXQUFXM0osR0FBRyxFQUFFTCxNQUFNLEVBQUU4SixJQUFJLEVBQUU7UUFDMUIsSUFBSyxJQUFJd0gsT0FBT2pSLEtBQUtpUixNQUFNQSxPQUFPQSxLQUFLclQsVUFBVSxDQUFFO1lBQy9DLElBQUlxQyxPQUFPLElBQUksQ0FBQzhRLE9BQU8sQ0FBQ0U7WUFDeEIsSUFBSWhSLE1BQ0EsT0FBT0EsS0FBS3dRLGVBQWUsQ0FBQ3pRLEtBQUtMLFFBQVE4SjtRQUNqRDtRQUNBLE9BQU8sQ0FBQztJQUNaO0lBQ0Esa0VBQWtFO0lBQ2xFLDJEQUEyRDtJQUMzRHlILE9BQU90UCxHQUFHLEVBQUU7UUFDUixJQUFLLElBQUkrRixJQUFJLEdBQUdoSSxTQUFTLEdBQUdnSSxJQUFJLElBQUksQ0FBQytILFFBQVEsQ0FBQ2hSLE1BQU0sRUFBRWlKLElBQUs7WUFDdkQsSUFBSWlCLFFBQVEsSUFBSSxDQUFDOEcsUUFBUSxDQUFDL0gsRUFBRSxFQUFFcUcsTUFBTXJPLFNBQVNpSixNQUFNc0MsSUFBSTtZQUN2RCxJQUFJdkwsVUFBVWlDLE9BQU9vTSxPQUFPck8sUUFBUTtnQkFDaEMsTUFBTyxDQUFDaUosTUFBTXlDLE1BQU0sSUFBSXpDLE1BQU04RyxRQUFRLENBQUNoUixNQUFNLENBQUU7b0JBQzNDLElBQUssSUFBSWlKLElBQUksR0FBR0EsSUFBSWlCLE1BQU04RyxRQUFRLENBQUNoUixNQUFNLEVBQUVpSixJQUFLO3dCQUM1QyxJQUFJd0osUUFBUXZJLE1BQU04RyxRQUFRLENBQUMvSCxFQUFFO3dCQUM3QixJQUFJd0osTUFBTWpHLElBQUksRUFBRTs0QkFDWnRDLFFBQVF1STs0QkFDUjt3QkFDSjtvQkFDSjtnQkFDSjtnQkFDQSxPQUFPdkk7WUFDWDtZQUNBLElBQUloSCxNQUFNb00sS0FDTixPQUFPcEYsTUFBTXNJLE1BQU0sQ0FBQ3RQLE1BQU1qQyxTQUFTaUosTUFBTXlDLE1BQU07WUFDbkQxTCxTQUFTcU87UUFDYjtJQUNKO0lBQ0FoQyxXQUFXcEssR0FBRyxFQUFFaUQsSUFBSSxFQUFFO1FBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUN4RSxVQUFVLEVBQ2hCLE9BQU87WUFBRTVDLE1BQU0sSUFBSSxDQUFDdUMsR0FBRztZQUFFTCxRQUFRO1lBQUdvTSxNQUFNbkssTUFBTTtRQUFFO1FBQ3RELDZDQUE2QztRQUM3QyxJQUFJK0YsSUFBSSxHQUFHaEksU0FBUztRQUNwQixJQUFLLElBQUl5UixTQUFTLEdBQUd6SixJQUFJLElBQUksQ0FBQytILFFBQVEsQ0FBQ2hSLE1BQU0sRUFBRWlKLElBQUs7WUFDaEQsSUFBSWlCLFFBQVEsSUFBSSxDQUFDOEcsUUFBUSxDQUFDL0gsRUFBRSxFQUFFcUcsTUFBTW9ELFNBQVN4SSxNQUFNc0MsSUFBSTtZQUN2RCxJQUFJOEMsTUFBTXBNLE9BQU9nSCxpQkFBaUJ5SSxzQkFBc0I7Z0JBQ3BEMVIsU0FBU2lDLE1BQU13UDtnQkFDZjtZQUNKO1lBQ0FBLFNBQVNwRDtRQUNiO1FBQ0EsMERBQTBEO1FBQzFELElBQUlyTyxRQUNBLE9BQU8sSUFBSSxDQUFDK1AsUUFBUSxDQUFDL0gsRUFBRSxDQUFDcUUsVUFBVSxDQUFDck0sU0FBUyxJQUFJLENBQUMrUCxRQUFRLENBQUMvSCxFQUFFLENBQUMwRCxNQUFNLEVBQUV4RztRQUN6RSxpRkFBaUY7UUFDakYsSUFBSyxJQUFJaUcsTUFBTW5ELEtBQUssQ0FBQyxDQUFDbUQsT0FBTyxJQUFJLENBQUM0RSxRQUFRLENBQUMvSCxJQUFJLEVBQUUsRUFBRXVELElBQUksSUFBSUosZ0JBQWdCd0csa0JBQWtCeEcsS0FBS2pHLElBQUksSUFBSSxHQUFHOEMsSUFBSyxDQUFFO1FBQ3BILHNDQUFzQztRQUN0QyxJQUFJOUMsUUFBUSxHQUFHO1lBQ1gsSUFBSWlHLE1BQU15RyxRQUFRO1lBQ2xCLE9BQVE1SixLQUFLNEosUUFBUSxNQUFPO2dCQUN4QnpHLE9BQU9uRCxJQUFJLElBQUksQ0FBQytILFFBQVEsQ0FBQy9ILElBQUksRUFBRSxHQUFHO2dCQUNsQyxJQUFJLENBQUNtRCxRQUFRQSxLQUFLOUssR0FBRyxDQUFDcEMsVUFBVSxJQUFJLElBQUksQ0FBQ3lDLFVBQVUsRUFDL0M7WUFDUjtZQUNBLElBQUl5SyxRQUFRakcsUUFBUTBNLFNBQVMsQ0FBQ3pHLEtBQUtPLE1BQU0sSUFBSSxDQUFDUCxLQUFLMEcsT0FBTyxFQUN0RCxPQUFPMUcsS0FBS2tCLFVBQVUsQ0FBQ2xCLEtBQUtJLElBQUksRUFBRXJHO1lBQ3RDLE9BQU87Z0JBQUVwSCxNQUFNLElBQUksQ0FBQzRDLFVBQVU7Z0JBQUVWLFFBQVFtTCxPQUFPdE4sU0FBU3NOLEtBQUs5SyxHQUFHLElBQUksSUFBSTtZQUFFO1FBQzlFLE9BQ0s7WUFDRCxJQUFJNkssTUFBTTBHLFFBQVE7WUFDbEIsT0FBUTVKLEtBQUs0SixRQUFRLE1BQU87Z0JBQ3hCMUcsT0FBT2xELElBQUksSUFBSSxDQUFDK0gsUUFBUSxDQUFDaFIsTUFBTSxHQUFHLElBQUksQ0FBQ2dSLFFBQVEsQ0FBQy9ILEVBQUUsR0FBRztnQkFDckQsSUFBSSxDQUFDa0QsUUFBUUEsS0FBSzdLLEdBQUcsQ0FBQ3BDLFVBQVUsSUFBSSxJQUFJLENBQUN5QyxVQUFVLEVBQy9DO1lBQ1I7WUFDQSxJQUFJd0ssUUFBUTBHLFNBQVMsQ0FBQzFHLEtBQUtRLE1BQU0sSUFBSSxDQUFDUixLQUFLMkcsT0FBTyxFQUM5QyxPQUFPM0csS0FBS21CLFVBQVUsQ0FBQyxHQUFHbkg7WUFDOUIsT0FBTztnQkFBRXBILE1BQU0sSUFBSSxDQUFDNEMsVUFBVTtnQkFBRVYsUUFBUWtMLE9BQU9yTixTQUFTcU4sS0FBSzdLLEdBQUcsSUFBSSxJQUFJLENBQUNLLFVBQVUsQ0FBQ1osVUFBVSxDQUFDZixNQUFNO1lBQUM7UUFDMUc7SUFDSjtJQUNBLGtFQUFrRTtJQUNsRSxTQUFTO0lBQ1QrUyxXQUFXdFQsSUFBSSxFQUFFQyxFQUFFLEVBQUVzVCxPQUFPLENBQUMsRUFBRTtRQUMzQixJQUFJLElBQUksQ0FBQ2hDLFFBQVEsQ0FBQ2hSLE1BQU0sSUFBSSxHQUN4QixPQUFPO1lBQUVqQixNQUFNLElBQUksQ0FBQzRDLFVBQVU7WUFBRWxDO1lBQU1DO1lBQUl1VCxZQUFZO1lBQUdDLFVBQVUsSUFBSSxDQUFDdlIsVUFBVSxDQUFDWixVQUFVLENBQUNmLE1BQU07UUFBQztRQUN6RyxJQUFJaVQsYUFBYSxDQUFDLEdBQUdDLFdBQVcsQ0FBQztRQUNqQyxJQUFLLElBQUlqUyxTQUFTK1IsTUFBTS9KLElBQUksSUFBSUEsSUFBSztZQUNqQyxJQUFJaUIsUUFBUSxJQUFJLENBQUM4RyxRQUFRLENBQUMvSCxFQUFFLEVBQUVxRyxNQUFNck8sU0FBU2lKLE1BQU1zQyxJQUFJO1lBQ3ZELElBQUl5RyxjQUFjLENBQUMsS0FBS3hULFFBQVE2UCxLQUFLO2dCQUNqQyxJQUFJNkQsWUFBWWxTLFNBQVNpSixNQUFNeUMsTUFBTTtnQkFDckMsNERBQTREO2dCQUM1RCxJQUFJbE4sUUFBUTBULGFBQWF6VCxNQUFNNFAsTUFBTXBGLE1BQU15QyxNQUFNLElBQUl6QyxNQUFNbkwsSUFBSSxJQUMzRG1MLE1BQU12SSxVQUFVLElBQUksSUFBSSxDQUFDQSxVQUFVLENBQUM2RyxRQUFRLENBQUMwQixNQUFNdkksVUFBVSxHQUM3RCxPQUFPdUksTUFBTTZJLFVBQVUsQ0FBQ3RULE1BQU1DLElBQUl5VDtnQkFDdEMxVCxPQUFPd0I7Z0JBQ1AsSUFBSyxJQUFJNkssSUFBSTdDLEdBQUc2QyxJQUFJLEdBQUdBLElBQUs7b0JBQ3hCLElBQUlNLE9BQU8sSUFBSSxDQUFDNEUsUUFBUSxDQUFDbEYsSUFBSSxFQUFFO29CQUMvQixJQUFJTSxLQUFLSSxJQUFJLElBQUlKLEtBQUs5SyxHQUFHLENBQUNwQyxVQUFVLElBQUksSUFBSSxDQUFDeUMsVUFBVSxJQUFJLENBQUN5SyxLQUFLZ0gsWUFBWSxDQUFDLElBQUk7d0JBQzlFSCxhQUFhblUsU0FBU3NOLEtBQUs5SyxHQUFHLElBQUk7d0JBQ2xDO29CQUNKO29CQUNBN0IsUUFBUTJNLEtBQUtJLElBQUk7Z0JBQ3JCO2dCQUNBLElBQUl5RyxjQUFjLENBQUMsR0FDZkEsYUFBYTtZQUNyQjtZQUNBLElBQUlBLGFBQWEsQ0FBQyxLQUFNM0QsQ0FBQUEsTUFBTTVQLE1BQU11SixLQUFLLElBQUksQ0FBQytILFFBQVEsQ0FBQ2hSLE1BQU0sR0FBRyxJQUFJO2dCQUNoRU4sS0FBSzRQO2dCQUNMLElBQUssSUFBSXhELElBQUk3QyxJQUFJLEdBQUc2QyxJQUFJLElBQUksQ0FBQ2tGLFFBQVEsQ0FBQ2hSLE1BQU0sRUFBRThMLElBQUs7b0JBQy9DLElBQUlLLE9BQU8sSUFBSSxDQUFDNkUsUUFBUSxDQUFDbEYsRUFBRTtvQkFDM0IsSUFBSUssS0FBS0ssSUFBSSxJQUFJTCxLQUFLN0ssR0FBRyxDQUFDcEMsVUFBVSxJQUFJLElBQUksQ0FBQ3lDLFVBQVUsSUFBSSxDQUFDd0ssS0FBS2lILFlBQVksQ0FBQyxDQUFDLElBQUk7d0JBQy9FRixXQUFXcFUsU0FBU3FOLEtBQUs3SyxHQUFHO3dCQUM1QjtvQkFDSjtvQkFDQTVCLE1BQU15TSxLQUFLSyxJQUFJO2dCQUNuQjtnQkFDQSxJQUFJMEcsWUFBWSxDQUFDLEdBQ2JBLFdBQVcsSUFBSSxDQUFDdlIsVUFBVSxDQUFDWixVQUFVLENBQUNmLE1BQU07Z0JBQ2hEO1lBQ0o7WUFDQWlCLFNBQVNxTztRQUNiO1FBQ0EsT0FBTztZQUFFdlEsTUFBTSxJQUFJLENBQUM0QyxVQUFVO1lBQUVsQztZQUFNQztZQUFJdVQ7WUFBWUM7UUFBUztJQUNuRTtJQUNBRSxhQUFhak4sSUFBSSxFQUFFO1FBQ2YsSUFBSSxJQUFJLENBQUN3RyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUNoTCxVQUFVLElBQUksQ0FBQyxJQUFJLENBQUNxUCxRQUFRLENBQUNoUixNQUFNLEVBQ3hELE9BQU87UUFDWCxJQUFJa0ssUUFBUSxJQUFJLENBQUM4RyxRQUFRLENBQUM3SyxPQUFPLElBQUksSUFBSSxJQUFJLENBQUM2SyxRQUFRLENBQUNoUixNQUFNLEdBQUcsRUFBRTtRQUNsRSxPQUFPa0ssTUFBTXNDLElBQUksSUFBSSxLQUFLdEMsTUFBTWtKLFlBQVksQ0FBQ2pOO0lBQ2pEO0lBQ0E2SixZQUFZOU0sR0FBRyxFQUFFO1FBQ2IsSUFBSSxFQUFFbkUsSUFBSSxFQUFFa0MsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDcU0sVUFBVSxDQUFDcEssS0FBSztRQUM1QyxJQUFJbkUsS0FBS00sUUFBUSxJQUFJLEtBQUs0QixVQUFVbEMsS0FBS2dDLFVBQVUsQ0FBQ2YsTUFBTSxFQUN0RCxNQUFNLElBQUlxVCxXQUFXLHVCQUF1Qm5RO1FBQ2hELE9BQU9uRSxLQUFLZ0MsVUFBVSxDQUFDRSxPQUFPO0lBQ2xDO0lBQ0Esa0VBQWtFO0lBQ2xFLGlFQUFpRTtJQUNqRSxvRUFBb0U7SUFDcEUsa0VBQWtFO0lBQ2xFLGtFQUFrRTtJQUNsRXFTLGFBQWFDLE1BQU0sRUFBRUMsSUFBSSxFQUFFNU0sSUFBSSxFQUFFNk0sUUFBUSxLQUFLLEVBQUU7UUFDNUMsb0VBQW9FO1FBQ3BFLElBQUloVSxPQUFPMkQsS0FBS0MsR0FBRyxDQUFDa1EsUUFBUUMsT0FBTzlULEtBQUswRCxLQUFLOEUsR0FBRyxDQUFDcUwsUUFBUUM7UUFDekQsSUFBSyxJQUFJdkssSUFBSSxHQUFHaEksU0FBUyxHQUFHZ0ksSUFBSSxJQUFJLENBQUMrSCxRQUFRLENBQUNoUixNQUFNLEVBQUVpSixJQUFLO1lBQ3ZELElBQUlpQixRQUFRLElBQUksQ0FBQzhHLFFBQVEsQ0FBQy9ILEVBQUUsRUFBRXFHLE1BQU1yTyxTQUFTaUosTUFBTXNDLElBQUk7WUFDdkQsSUFBSS9NLE9BQU93QixVQUFVdkIsS0FBSzRQLEtBQ3RCLE9BQU9wRixNQUFNb0osWUFBWSxDQUFDQyxTQUFTdFMsU0FBU2lKLE1BQU15QyxNQUFNLEVBQUU2RyxPQUFPdlMsU0FBU2lKLE1BQU15QyxNQUFNLEVBQUUvRixNQUFNNk07WUFDbEd4UyxTQUFTcU87UUFDYjtRQUNBLElBQUlvRSxZQUFZLElBQUksQ0FBQ3BHLFVBQVUsQ0FBQ2lHLFFBQVFBLFNBQVMsQ0FBQyxJQUFJO1FBQ3RELElBQUlJLFVBQVVILFFBQVFELFNBQVNHLFlBQVksSUFBSSxDQUFDcEcsVUFBVSxDQUFDa0csTUFBTUEsT0FBTyxDQUFDLElBQUk7UUFDN0UsSUFBSTNSLFNBQVMrRSxLQUFLMEIsSUFBSSxDQUFDc0wsWUFBWTtRQUNuQyxJQUFJQyxXQUFXak4sS0FBSytJLGlCQUFpQjtRQUNyQyxJQUFJbUUsV0FBVztRQUNmLGlFQUFpRTtRQUNqRSxrRUFBa0U7UUFDbEUsNkRBQTZEO1FBQzdELGdEQUFnRDtRQUNoRCxJQUFJLENBQUN6UCxTQUFTSSxNQUFLLEtBQU04TyxVQUFVQyxNQUFNO1lBQ3JDLElBQUksRUFBRXpVLElBQUksRUFBRWtDLE1BQU0sRUFBRSxHQUFHeVM7WUFDdkIsSUFBSTNVLEtBQUtNLFFBQVEsSUFBSSxHQUFHO2dCQUNwQnlVLFdBQVcsQ0FBQyxDQUFFN1MsQ0FBQUEsVUFBVWxDLEtBQUtnQixTQUFTLENBQUNrQixTQUFTLEVBQUUsSUFBSSxJQUFHO2dCQUN6RCxjQUFjO2dCQUNkLElBQUk2UyxZQUFZN1MsVUFBVWxDLEtBQUtnQixTQUFTLENBQUNDLE1BQU0sRUFBRTtvQkFDN0MsSUFBSyxJQUFJdVMsT0FBT3hULE1BQU1pUCxPQUFPdUUsTUFBTUEsT0FBT0EsS0FBS3JULFVBQVUsQ0FBRTt3QkFDdkQsSUFBSThPLFFBQVF1RSxLQUFLbEksV0FBVyxFQUFFOzRCQUMxQixJQUFJMkQsTUFBTW5OLFFBQVEsSUFBSSxNQUNsQjZTLFlBQVlDLFVBQVU7Z0NBQUU1VSxNQUFNaVAsTUFBTTlPLFVBQVU7Z0NBQUUrQixRQUFRbkMsU0FBU2tQLFNBQVM7NEJBQUU7NEJBQ2hGO3dCQUNKO3dCQUNBLElBQUl6TSxPQUFPZ1IsS0FBSzlRLFVBQVU7d0JBQzFCLElBQUlGLFFBQVFBLEtBQUt4QyxJQUFJLElBQUl3QyxLQUFLeEMsSUFBSSxDQUFDMkMsT0FBTyxFQUN0QztvQkFDUjtnQkFDSjtZQUNKLE9BQ0s7Z0JBQ0QsSUFBSTBLLE9BQU9yTixLQUFLZ0MsVUFBVSxDQUFDRSxTQUFTLEVBQUU7Z0JBQ3RDNlMsV0FBVzFILFFBQVNBLENBQUFBLEtBQUt2TCxRQUFRLElBQUksUUFBUXVMLEtBQUt0TCxlQUFlLElBQUksT0FBTTtZQUMvRTtRQUNKO1FBQ0EsaUVBQWlFO1FBQ2pFLHNGQUFzRjtRQUN0RixJQUFJdUQsU0FBU3dQLFNBQVMvUixTQUFTLElBQUkrUixTQUFTL1IsU0FBUyxJQUFJNlIsUUFBUTVVLElBQUksSUFBSThVLFNBQVMvUixTQUFTLENBQUN6QyxRQUFRLElBQUksR0FBRztZQUN2RyxJQUFJMk8sUUFBUTZGLFNBQVMvUixTQUFTLENBQUNmLFVBQVUsQ0FBQzhTLFNBQVM5UixXQUFXLENBQUM7WUFDL0QsSUFBSWlNLFNBQVNBLE1BQU1sTixlQUFlLElBQUksU0FDbEMyUyxRQUFRO1FBQ2hCO1FBQ0EsSUFBSSxDQUFFQSxDQUFBQSxTQUFTSyxZQUFZclAsTUFBSyxLQUM1QnRFLHFCQUFxQnVULFVBQVUzVSxJQUFJLEVBQUUyVSxVQUFVelMsTUFBTSxFQUFFNFMsU0FBUzdSLFVBQVUsRUFBRTZSLFNBQVM1UixZQUFZLEtBQ2pHOUIscUJBQXFCd1QsUUFBUTVVLElBQUksRUFBRTRVLFFBQVExUyxNQUFNLEVBQUU0UyxTQUFTL1IsU0FBUyxFQUFFK1IsU0FBUzlSLFdBQVcsR0FDM0Y7UUFDSixpRUFBaUU7UUFDakUsMERBQTBEO1FBQzFELDJCQUEyQjtRQUMzQixJQUFJZ1MsaUJBQWlCO1FBQ3JCLElBQUksQ0FBQ2xTLE9BQU93TyxNQUFNLElBQUlrRCxVQUFVQyxJQUFHLEtBQU0sQ0FBQ00sVUFBVTtZQUNoRGpTLE9BQU91TyxRQUFRLENBQUNzRCxVQUFVM1UsSUFBSSxFQUFFMlUsVUFBVXpTLE1BQU07WUFDaEQsSUFBSTtnQkFDQSxJQUFJc1MsVUFBVUMsTUFDVjNSLE9BQU93TyxNQUFNLENBQUNzRCxRQUFRNVUsSUFBSSxFQUFFNFUsUUFBUTFTLE1BQU07Z0JBQzlDOFMsaUJBQWlCO1lBQ3JCLEVBQ0EsT0FBT3pRLEdBQUc7WUFDTixpRUFBaUU7WUFDakUsd0VBQXdFO1lBQ3hFLHVFQUF1RTtZQUN2RSx3QkFBd0I7WUFDeEIscUVBQXFFO1lBQ3JFLDBCQUEwQjtZQUM5QjtRQUNKO1FBQ0EsSUFBSSxDQUFDeVEsZ0JBQWdCO1lBQ2pCLElBQUlSLFNBQVNDLE1BQU07Z0JBQ2YsSUFBSVEsTUFBTU47Z0JBQ1ZBLFlBQVlDO2dCQUNaQSxVQUFVSztZQUNkO1lBQ0EsSUFBSXJVLFFBQVFDLFNBQVNDLFdBQVc7WUFDaENGLE1BQU1HLE1BQU0sQ0FBQzZULFFBQVE1VSxJQUFJLEVBQUU0VSxRQUFRMVMsTUFBTTtZQUN6Q3RCLE1BQU1NLFFBQVEsQ0FBQ3lULFVBQVUzVSxJQUFJLEVBQUUyVSxVQUFVelMsTUFBTTtZQUMvQ1ksT0FBT29TLGVBQWU7WUFDdEJwUyxPQUFPcVMsUUFBUSxDQUFDdlU7UUFDcEI7SUFDSjtJQUNBd1UsZUFBZUMsUUFBUSxFQUFFO1FBQ3JCLE9BQU8sQ0FBQyxJQUFJLENBQUN6UyxVQUFVLElBQUl5UyxTQUFTQyxJQUFJLElBQUk7SUFDaEQ7SUFDQSxJQUFJQyxjQUFjO1FBQ2QsT0FBTyxJQUFJLENBQUMzUyxVQUFVLElBQUksSUFBSSxDQUFDQSxVQUFVLElBQUksSUFBSSxDQUFDTCxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUNBLEdBQUcsQ0FBQ2tILFFBQVEsQ0FBQyxJQUFJLENBQUM3RyxVQUFVO0lBQy9GO0lBQ0EsNkRBQTZEO0lBQzdELDJEQUEyRDtJQUMzRDRTLFVBQVU5VSxJQUFJLEVBQUVDLEVBQUUsRUFBRTtRQUNoQixJQUFLLElBQUl1QixTQUFTLEdBQUdnSSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDK0gsUUFBUSxDQUFDaFIsTUFBTSxFQUFFaUosSUFBSztZQUN2RCxJQUFJaUIsUUFBUSxJQUFJLENBQUM4RyxRQUFRLENBQUMvSCxFQUFFLEVBQUVxRyxNQUFNck8sU0FBU2lKLE1BQU1zQyxJQUFJO1lBQ3ZELElBQUl2TCxVQUFVcU8sTUFBTTdQLFFBQVE2UCxPQUFPNVAsTUFBTXVCLFNBQVN4QixPQUFPNlAsT0FBTzVQLEtBQUt1QixRQUFRO2dCQUN6RSxJQUFJdVQsY0FBY3ZULFNBQVNpSixNQUFNeUMsTUFBTSxFQUFFOEgsWUFBWW5GLE1BQU1wRixNQUFNeUMsTUFBTTtnQkFDdkUsSUFBSWxOLFFBQVErVSxlQUFlOVUsTUFBTStVLFdBQVc7b0JBQ3hDLElBQUksQ0FBQ3hELEtBQUssR0FBR3hSLFFBQVF3QixVQUFVdkIsTUFBTTRQLE1BQU1zQixnQkFBZ0JEO29CQUMzRCxJQUFJbFIsUUFBUStVLGVBQWU5VSxNQUFNK1UsYUFDNUJ2SyxDQUFBQSxNQUFNb0ssV0FBVyxJQUFJcEssTUFBTTVJLEdBQUcsQ0FBQ3BDLFVBQVUsSUFBSSxJQUFJLENBQUN5QyxVQUFVLEdBQzdEdUksTUFBTStHLEtBQUssR0FBR0o7eUJBRWQzRyxNQUFNcUssU0FBUyxDQUFDOVUsT0FBTytVLGFBQWE5VSxLQUFLOFU7b0JBQzdDO2dCQUNKLE9BQ0s7b0JBQ0R0SyxNQUFNK0csS0FBSyxHQUFHL0csTUFBTTVJLEdBQUcsSUFBSTRJLE1BQU12SSxVQUFVLElBQUl1SSxNQUFNNUksR0FBRyxDQUFDcEMsVUFBVSxJQUFJLElBQUksQ0FBQ3lDLFVBQVUsSUFBSSxDQUFDdUksTUFBTThHLFFBQVEsQ0FBQ2hSLE1BQU0sR0FDMUc0USxnQkFBZ0JDO2dCQUMxQjtZQUNKO1lBQ0E1UCxTQUFTcU87UUFDYjtRQUNBLElBQUksQ0FBQzJCLEtBQUssR0FBR0w7SUFDakI7SUFDQThELG1CQUFtQjtRQUNmLElBQUlDLFFBQVE7UUFDWixJQUFLLElBQUk1VixPQUFPLElBQUksQ0FBQ0ksTUFBTSxFQUFFSixNQUFNQSxPQUFPQSxLQUFLSSxNQUFNLEVBQUV3VixRQUFTO1lBQzVELElBQUkxRCxRQUFRMEQsU0FBUyxJQUFJL0QsZ0JBQWdCRDtZQUN6QyxJQUFJNVIsS0FBS2tTLEtBQUssR0FBR0EsT0FDYmxTLEtBQUtrUyxLQUFLLEdBQUdBO1FBQ3JCO0lBQ0o7SUFDQSxJQUFJNkIsVUFBVTtRQUFFLE9BQU87SUFBTztJQUM5QixJQUFJN0Usa0JBQWtCO1FBQUUsT0FBTztJQUFPO0lBQ3RDekMsT0FBT29KLElBQUksRUFBRTtRQUFFLE9BQU87SUFBTztBQUNqQztBQUNBLG9FQUFvRTtBQUNwRSxvQ0FBb0M7QUFDcEMsTUFBTWhDLHVCQUF1QjlCO0lBQ3pCQyxZQUFZNVIsTUFBTSxFQUFFZ1MsTUFBTSxFQUFFdkssSUFBSSxFQUFFMUQsR0FBRyxDQUFFO1FBQ25DLElBQUkyUixNQUFNdlQsTUFBTTZQLE9BQU9rRCxJQUFJLENBQUNTLEtBQUs7UUFDakMsSUFBSSxPQUFPeFQsT0FBTyxZQUNkQSxNQUFNQSxJQUFJc0YsTUFBTTtZQUNaLElBQUksQ0FBQ2lPLE1BQ0QsT0FBTzNSO1lBQ1gsSUFBSTJSLEtBQUsxVixNQUFNLEVBQ1gsT0FBTzBWLEtBQUsxVixNQUFNLENBQUMwUyxjQUFjLENBQUNnRDtRQUMxQztRQUNKLElBQUksQ0FBQzFELE9BQU9rRCxJQUFJLENBQUNVLElBQUksQ0FBQ0MsR0FBRyxFQUFFO1lBQ3ZCLElBQUkxVCxJQUFJakMsUUFBUSxJQUFJLEdBQUc7Z0JBQ25CLElBQUk0VixPQUFPclYsU0FBU3NWLGFBQWEsQ0FBQztnQkFDbENELEtBQUtFLFdBQVcsQ0FBQzdUO2dCQUNqQkEsTUFBTTJUO1lBQ1Y7WUFDQTNULElBQUlSLGVBQWUsR0FBRztZQUN0QlEsSUFBSThULFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQ3RCO1FBQ0EsS0FBSyxDQUFDbFcsUUFBUSxFQUFFLEVBQUVtQyxLQUFLO1FBQ3ZCLElBQUksQ0FBQzZQLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZDBELE9BQU8sSUFBSTtJQUNmO0lBQ0EzRCxjQUFjQyxNQUFNLEVBQUU7UUFDbEIsT0FBTyxJQUFJLENBQUNGLEtBQUssSUFBSVAsYUFBYVMsT0FBT2tELElBQUksQ0FBQ2lCLEVBQUUsQ0FBQyxJQUFJLENBQUNuRSxNQUFNLENBQUNrRCxJQUFJO0lBQ3JFO0lBQ0EzQyxZQUFZO1FBQUUsT0FBTztZQUFFNkQsUUFBUTtRQUFLO0lBQUc7SUFDdkM1RCxVQUFVdFAsS0FBSyxFQUFFO1FBQ2IsSUFBSW1ULE9BQU8sSUFBSSxDQUFDckUsTUFBTSxDQUFDNEQsSUFBSSxDQUFDcEQsU0FBUztRQUNyQyxPQUFPNkQsT0FBT0EsS0FBS25ULFNBQVM7SUFDaEM7SUFDQThSLGVBQWVDLFFBQVEsRUFBRTtRQUNyQixPQUFPQSxTQUFTQyxJQUFJLElBQUksZUFBZSxJQUFJLENBQUNsRCxNQUFNLENBQUM0RCxJQUFJLENBQUNVLGVBQWU7SUFDM0U7SUFDQTdELFVBQVU7UUFDTixJQUFJLENBQUNULE1BQU0sQ0FBQ2tELElBQUksQ0FBQ3pDLE9BQU8sQ0FBQyxJQUFJLENBQUN0USxHQUFHO1FBQ2pDLEtBQUssQ0FBQ3NRO0lBQ1Y7SUFDQSxJQUFJa0IsVUFBVTtRQUFFLE9BQU87SUFBTTtJQUM3QixJQUFJM00sT0FBTztRQUFFLE9BQU8sSUFBSSxDQUFDZ0wsTUFBTSxDQUFDa0QsSUFBSSxDQUFDbE8sSUFBSTtJQUFFO0FBQy9DO0FBQ0EsTUFBTXVQLDRCQUE0QjVFO0lBQzlCQyxZQUFZNVIsTUFBTSxFQUFFbUMsR0FBRyxFQUFFcVUsT0FBTyxFQUFFZixJQUFJLENBQUU7UUFDcEMsS0FBSyxDQUFDelYsUUFBUSxFQUFFLEVBQUVtQyxLQUFLO1FBQ3ZCLElBQUksQ0FBQ3FVLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNmLElBQUksR0FBR0E7SUFDaEI7SUFDQSxJQUFJcEksT0FBTztRQUFFLE9BQU8sSUFBSSxDQUFDb0ksSUFBSSxDQUFDNVUsTUFBTTtJQUFFO0lBQ3RDK1IsZ0JBQWdCelEsR0FBRyxFQUFFTCxNQUFNLEVBQUU7UUFDekIsSUFBSUssT0FBTyxJQUFJLENBQUNxVSxPQUFPLEVBQ25CLE9BQU8sSUFBSSxDQUFDakosVUFBVSxHQUFJekwsQ0FBQUEsU0FBUyxJQUFJLENBQUN1TCxJQUFJLEdBQUc7UUFDbkQsT0FBTyxJQUFJLENBQUNFLFVBQVUsR0FBR3pMO0lBQzdCO0lBQ0FxTSxXQUFXcEssR0FBRyxFQUFFO1FBQ1osT0FBTztZQUFFbkUsTUFBTSxJQUFJLENBQUM0VyxPQUFPO1lBQUUxVSxRQUFRaUM7UUFBSTtJQUM3QztJQUNBaVIsZUFBZXlCLEdBQUcsRUFBRTtRQUNoQixPQUFPQSxJQUFJdkIsSUFBSSxLQUFLLG1CQUFtQnVCLElBQUkvSSxNQUFNLENBQUM5TSxTQUFTLElBQUk2VixJQUFJQyxRQUFRO0lBQy9FO0FBQ0o7QUFDQSw2REFBNkQ7QUFDN0Qsc0VBQXNFO0FBQ3RFLGtFQUFrRTtBQUNsRSw2REFBNkQ7QUFDN0QsYUFBYTtBQUNiLE1BQU1DLHFCQUFxQmhGO0lBQ3ZCQyxZQUFZNVIsTUFBTSxFQUFFa1MsSUFBSSxFQUFFL1AsR0FBRyxFQUFFSyxVQUFVLEVBQUVvVCxJQUFJLENBQUU7UUFDN0MsS0FBSyxDQUFDNVYsUUFBUSxFQUFFLEVBQUVtQyxLQUFLSztRQUN2QixJQUFJLENBQUMwUCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDMEQsSUFBSSxHQUFHQTtJQUNoQjtJQUNBLE9BQU9nQixPQUFPNVcsTUFBTSxFQUFFa1MsSUFBSSxFQUFFMkUsTUFBTSxFQUFFcFAsSUFBSSxFQUFFO1FBQ3RDLElBQUlxUCxTQUFTclAsS0FBS3NQLFNBQVMsQ0FBQzdFLEtBQUtnRCxJQUFJLENBQUM4QixJQUFJLENBQUM7UUFDM0MsSUFBSXBCLE9BQU9rQixVQUFVQSxPQUFPNUUsTUFBTXpLLE1BQU1vUDtRQUN4QyxJQUFJLENBQUNqQixRQUFRLENBQUNBLEtBQUt6VCxHQUFHLEVBQ2xCeVQsT0FBT3ZXLDREQUFhQSxDQUFDNFgsVUFBVSxDQUFDeFcsVUFBVXlSLEtBQUtnRCxJQUFJLENBQUNVLElBQUksQ0FBQ0QsS0FBSyxDQUFDekQsTUFBTTJFLFNBQVMsTUFBTTNFLEtBQUtnRixLQUFLO1FBQ2xHLE9BQU8sSUFBSVAsYUFBYTNXLFFBQVFrUyxNQUFNMEQsS0FBS3pULEdBQUcsRUFBRXlULEtBQUtwVCxVQUFVLElBQUlvVCxLQUFLelQsR0FBRyxFQUFFeVQ7SUFDakY7SUFDQXJELFlBQVk7UUFDUixJQUFJLElBQUssQ0FBQ1QsS0FBSyxHQUFHSixjQUFlLElBQUksQ0FBQ1EsSUFBSSxDQUFDZ0QsSUFBSSxDQUFDVSxJQUFJLENBQUN1QixhQUFhLEVBQzlELE9BQU87UUFDWCxPQUFPO1lBQUVqRixNQUFNLElBQUksQ0FBQ0EsSUFBSSxDQUFDZ0QsSUFBSSxDQUFDOEIsSUFBSTtZQUFFRSxPQUFPLElBQUksQ0FBQ2hGLElBQUksQ0FBQ2dGLEtBQUs7WUFBRUUsZ0JBQWdCLElBQUksQ0FBQzVVLFVBQVU7UUFBQztJQUNoRztJQUNBeVAsWUFBWUMsSUFBSSxFQUFFO1FBQUUsT0FBTyxJQUFJLENBQUNKLEtBQUssSUFBSUosY0FBYyxJQUFJLENBQUNRLElBQUksQ0FBQ2lFLEVBQUUsQ0FBQ2pFO0lBQU87SUFDM0VrRCxVQUFVOVUsSUFBSSxFQUFFQyxFQUFFLEVBQUU7UUFDaEIsS0FBSyxDQUFDNlUsVUFBVTlVLE1BQU1DO1FBQ3RCLHVDQUF1QztRQUN2QyxJQUFJLElBQUksQ0FBQ3VSLEtBQUssSUFBSVAsV0FBVztZQUN6QixJQUFJdlIsU0FBUyxJQUFJLENBQUNBLE1BQU07WUFDeEIsTUFBTyxDQUFDQSxPQUFPSixJQUFJLENBQ2ZJLFNBQVNBLE9BQU9BLE1BQU07WUFDMUIsSUFBSUEsT0FBTzhSLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUssRUFDekI5UixPQUFPOFIsS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSztZQUM3QixJQUFJLENBQUNBLEtBQUssR0FBR1A7UUFDakI7SUFDSjtJQUNBOEYsTUFBTS9XLElBQUksRUFBRUMsRUFBRSxFQUFFa0gsSUFBSSxFQUFFO1FBQ2xCLElBQUk2UCxPQUFPWCxhQUFhQyxNQUFNLENBQUMsSUFBSSxDQUFDNVcsTUFBTSxFQUFFLElBQUksQ0FBQ2tTLElBQUksRUFBRSxNQUFNeks7UUFDN0QsSUFBSThQLFFBQVEsSUFBSSxDQUFDMUYsUUFBUSxFQUFFeEUsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDM0MsSUFBSTlNLEtBQUs4TSxNQUNMa0ssUUFBUUMsYUFBYUQsT0FBT2hYLElBQUk4TSxNQUFNNUY7UUFDMUMsSUFBSW5ILE9BQU8sR0FDUGlYLFFBQVFDLGFBQWFELE9BQU8sR0FBR2pYLE1BQU1tSDtRQUN6QyxJQUFLLElBQUlxQyxJQUFJLEdBQUdBLElBQUl5TixNQUFNMVcsTUFBTSxFQUFFaUosSUFDOUJ5TixLQUFLLENBQUN6TixFQUFFLENBQUM5SixNQUFNLEdBQUdzWDtRQUN0QkEsS0FBS3pGLFFBQVEsR0FBRzBGO1FBQ2hCLE9BQU9EO0lBQ1g7SUFDQXRDLGVBQWVDLFFBQVEsRUFBRTtRQUNyQixPQUFPLElBQUksQ0FBQ1csSUFBSSxDQUFDWixjQUFjLEdBQUcsSUFBSSxDQUFDWSxJQUFJLENBQUNaLGNBQWMsQ0FBQ0MsWUFBWSxLQUFLLENBQUNELGVBQWVDO0lBQ2hHO0lBQ0F4QyxVQUFVO1FBQ04sSUFBSSxJQUFJLENBQUNtRCxJQUFJLENBQUNuRCxPQUFPLEVBQ2pCLElBQUksQ0FBQ21ELElBQUksQ0FBQ25ELE9BQU87UUFDckIsS0FBSyxDQUFDQTtJQUNWO0FBQ0o7QUFDQSxtRUFBbUU7QUFDbkUsbUVBQW1FO0FBQ25FLDhDQUE4QztBQUM5QyxNQUFNZ0YscUJBQXFCOUY7SUFDdkJDLFlBQVk1UixNQUFNLEVBQUVKLElBQUksRUFBRXdTLFNBQVMsRUFBRUMsU0FBUyxFQUFFbFEsR0FBRyxFQUFFSyxVQUFVLEVBQUUyUSxPQUFPLEVBQUUxTCxJQUFJLEVBQUUxRCxHQUFHLENBQUU7UUFDakYsS0FBSyxDQUFDL0QsUUFBUSxFQUFFLEVBQUVtQyxLQUFLSztRQUN2QixJQUFJLENBQUM1QyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDd1MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDYyxPQUFPLEdBQUdBO0lBQ25CO0lBQ0EsbUVBQW1FO0lBQ25FLGtFQUFrRTtJQUNsRSxvRUFBb0U7SUFDcEUsMEJBQTBCO0lBQzFCLEVBQUU7SUFDRixpRUFBaUU7SUFDakUsc0RBQXNEO0lBQ3RELGtFQUFrRTtJQUNsRSxlQUFlO0lBQ2YsT0FBT3lELE9BQU81VyxNQUFNLEVBQUVKLElBQUksRUFBRXdTLFNBQVMsRUFBRUMsU0FBUyxFQUFFNUssSUFBSSxFQUFFMUQsR0FBRyxFQUFFO1FBQ3pELElBQUkrUyxTQUFTclAsS0FBS3NQLFNBQVMsQ0FBQ25YLEtBQUtzVixJQUFJLENBQUM4QixJQUFJLENBQUMsRUFBRVU7UUFDN0MsSUFBSTlCLE9BQU9rQixVQUFVQSxPQUFPbFgsTUFBTTZILE1BQU07WUFDcEMsOERBQThEO1lBQzlELGdCQUFnQjtZQUNoQixJQUFJLENBQUNpUSxTQUNELE9BQU8zVDtZQUNYLElBQUkyVCxRQUFRMVgsTUFBTSxFQUNkLE9BQU8wWCxRQUFRMVgsTUFBTSxDQUFDMFMsY0FBYyxDQUFDZ0Y7UUFDN0MsR0FBR3RGLFdBQVdDO1FBQ2QsSUFBSWxRLE1BQU15VCxRQUFRQSxLQUFLelQsR0FBRyxFQUFFSyxhQUFhb1QsUUFBUUEsS0FBS3BULFVBQVU7UUFDaEUsSUFBSTVDLEtBQUt5TSxNQUFNLEVBQUU7WUFDYixJQUFJLENBQUNsSyxLQUNEQSxNQUFNMUIsU0FBU2tYLGNBQWMsQ0FBQy9YLEtBQUs2VixJQUFJO2lCQUN0QyxJQUFJdFQsSUFBSWpDLFFBQVEsSUFBSSxHQUNyQixNQUFNLElBQUlnVSxXQUFXO1FBQzdCLE9BQ0ssSUFBSSxDQUFDL1IsS0FBSztZQUNYLElBQUl5VCxPQUFPdlcsNERBQWFBLENBQUM0WCxVQUFVLENBQUN4VyxVQUFVYixLQUFLc1YsSUFBSSxDQUFDVSxJQUFJLENBQUNELEtBQUssQ0FBQy9WLE9BQU8sTUFBTUEsS0FBS3NYLEtBQUs7WUFDekYsR0FBRS9VLEdBQUcsRUFBRUssVUFBVSxFQUFFLEdBQUdvVCxJQUFHO1FBQzlCO1FBQ0EsSUFBSSxDQUFDcFQsY0FBYyxDQUFDNUMsS0FBS3lNLE1BQU0sSUFBSWxLLElBQUlULFFBQVEsSUFBSSxNQUFNO1lBQ3JELElBQUksQ0FBQ1MsSUFBSXlWLFlBQVksQ0FBQyxvQkFDbEJ6VixJQUFJUixlQUFlLEdBQUc7WUFDMUIsSUFBSS9CLEtBQUtzVixJQUFJLENBQUNVLElBQUksQ0FBQzdJLFNBQVMsRUFDeEI1SyxJQUFJNEssU0FBUyxHQUFHO1FBQ3hCO1FBQ0EsSUFBSW9HLFVBQVVoUjtRQUNkQSxNQUFNMFYsZUFBZTFWLEtBQUtpUSxXQUFXeFM7UUFDckMsSUFBSWdXLE1BQ0EsT0FBTzhCLFVBQVUsSUFBSUksbUJBQW1COVgsUUFBUUosTUFBTXdTLFdBQVdDLFdBQVdsUSxLQUFLSyxjQUFjLE1BQU0yUSxTQUFTeUMsTUFBTW5PLE1BQU0xRCxNQUFNO2FBQy9ILElBQUluRSxLQUFLeU0sTUFBTSxFQUNoQixPQUFPLElBQUkwTCxhQUFhL1gsUUFBUUosTUFBTXdTLFdBQVdDLFdBQVdsUSxLQUFLZ1IsU0FBUzFMO2FBRTFFLE9BQU8sSUFBSWdRLGFBQWF6WCxRQUFRSixNQUFNd1MsV0FBV0MsV0FBV2xRLEtBQUtLLGNBQWMsTUFBTTJRLFNBQVMxTCxNQUFNMUQsTUFBTTtJQUNsSDtJQUNBd08sWUFBWTtRQUNSLDBEQUEwRDtRQUMxRCxJQUFJLElBQUksQ0FBQzNTLElBQUksQ0FBQ3NWLElBQUksQ0FBQ1UsSUFBSSxDQUFDdUIsYUFBYSxFQUNqQyxPQUFPO1FBQ1gsK0RBQStEO1FBQy9ELDZEQUE2RDtRQUM3RCwrREFBK0Q7UUFDL0QsNEJBQTRCO1FBQzVCLElBQUlhLE9BQU87WUFBRXBZLE1BQU0sSUFBSSxDQUFDQSxJQUFJLENBQUNzVixJQUFJLENBQUM4QixJQUFJO1lBQUVFLE9BQU8sSUFBSSxDQUFDdFgsSUFBSSxDQUFDc1gsS0FBSztRQUFDO1FBQy9ELElBQUksSUFBSSxDQUFDdFgsSUFBSSxDQUFDc1YsSUFBSSxDQUFDK0MsVUFBVSxJQUFJLE9BQzdCRCxLQUFLRSxrQkFBa0IsR0FBRztRQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDMVYsVUFBVSxFQUFFO1lBQ2xCd1YsS0FBS0csVUFBVSxHQUFHLElBQU0sSUFBSSxDQUFDdlksSUFBSSxDQUFDd04sT0FBTztRQUM3QyxPQUNLLElBQUksQ0FBQyxJQUFJLENBQUMrSCxXQUFXLEVBQUU7WUFDeEI2QyxLQUFLWixjQUFjLEdBQUcsSUFBSSxDQUFDNVUsVUFBVTtRQUN6QyxPQUNLO1lBQ0Qsc0RBQXNEO1lBQ3RELGdFQUFnRTtZQUNoRSxjQUFjO1lBQ2QsSUFBSyxJQUFJc0gsSUFBSSxJQUFJLENBQUMrSCxRQUFRLENBQUNoUixNQUFNLEdBQUcsR0FBR2lKLEtBQUssR0FBR0EsSUFBSztnQkFDaEQsSUFBSWlCLFFBQVEsSUFBSSxDQUFDOEcsUUFBUSxDQUFDL0gsRUFBRTtnQkFDNUIsSUFBSSxJQUFJLENBQUMzSCxHQUFHLENBQUNrSCxRQUFRLENBQUMwQixNQUFNNUksR0FBRyxDQUFDcEMsVUFBVSxHQUFHO29CQUN6Q2lZLEtBQUtaLGNBQWMsR0FBR3JNLE1BQU01SSxHQUFHLENBQUNwQyxVQUFVO29CQUMxQztnQkFDSjtZQUNKO1lBQ0EsSUFBSSxDQUFDaVksS0FBS1osY0FBYyxFQUNwQlksS0FBS0csVUFBVSxHQUFHLElBQU03WSx1REFBUUEsQ0FBQzhZLEtBQUs7UUFDOUM7UUFDQSxPQUFPSjtJQUNYO0lBQ0E3RixZQUFZdlMsSUFBSSxFQUFFd1MsU0FBUyxFQUFFQyxTQUFTLEVBQUU7UUFDcEMsT0FBTyxJQUFJLENBQUNQLEtBQUssSUFBSVAsYUFBYTNSLEtBQUt1VyxFQUFFLENBQUMsSUFBSSxDQUFDdlcsSUFBSSxLQUMvQ3lZLGNBQWNqRyxXQUFXLElBQUksQ0FBQ0EsU0FBUyxLQUFLQyxVQUFVOEQsRUFBRSxDQUFDLElBQUksQ0FBQzlELFNBQVM7SUFDL0U7SUFDQSxJQUFJaEYsT0FBTztRQUFFLE9BQU8sSUFBSSxDQUFDek4sSUFBSSxDQUFDMkIsUUFBUTtJQUFFO0lBQ3hDLElBQUlpTSxTQUFTO1FBQUUsT0FBTyxJQUFJLENBQUM1TixJQUFJLENBQUMwWSxNQUFNLEdBQUcsSUFBSTtJQUFHO0lBQ2hELG1FQUFtRTtJQUNuRSxrRUFBa0U7SUFDbEUsMkRBQTJEO0lBQzNELG1CQUFtQjtJQUNuQkMsZUFBZTlRLElBQUksRUFBRTFELEdBQUcsRUFBRTtRQUN0QixJQUFJOFMsU0FBUyxJQUFJLENBQUNqWCxJQUFJLENBQUMrTyxhQUFhLEVBQUUxTixNQUFNOEM7UUFDNUMsSUFBSXlVLGNBQWMvUSxLQUFLZ1IsU0FBUyxHQUFHLElBQUksQ0FBQ0Msb0JBQW9CLENBQUNqUixNQUFNMUQsT0FBTztRQUMxRSxJQUFJNFUsbUJBQW1CSCxlQUFlQSxZQUFZelUsR0FBRyxHQUFHLENBQUMsSUFBSXlVLGNBQWM7UUFDM0UsSUFBSUkscUJBQXFCSixlQUFlQSxZQUFZelUsR0FBRyxHQUFHO1FBQzFELElBQUk4VSxVQUFVLElBQUlDLGdCQUFnQixJQUFJLEVBQUVILG9CQUFvQkEsaUJBQWlCL1ksSUFBSSxFQUFFNkg7UUFDbkZzUixTQUFTLElBQUksQ0FBQ25aLElBQUksRUFBRSxJQUFJLENBQUN5UyxTQUFTLEVBQUUsQ0FBQ0wsUUFBUWxJLEdBQUdrUDtZQUM1QyxJQUFJaEgsT0FBTzRELElBQUksQ0FBQ3FELEtBQUssRUFDakJKLFFBQVFLLFdBQVcsQ0FBQ2xILE9BQU80RCxJQUFJLENBQUNxRCxLQUFLLEVBQUVwQyxRQUFRcFA7aUJBQzlDLElBQUl1SyxPQUFPa0QsSUFBSSxDQUFDbE8sSUFBSSxJQUFJLEtBQUssQ0FBQ2dTLFlBQy9CSCxRQUFRSyxXQUFXLENBQUNwUCxLQUFLLElBQUksQ0FBQ2xLLElBQUksQ0FBQ3VaLFVBQVUsR0FBRzVaLG1EQUFJQSxDQUFDNlosSUFBSSxHQUFHLElBQUksQ0FBQ3haLElBQUksQ0FBQ21MLEtBQUssQ0FBQ2pCLEdBQUdtUCxLQUFLLEVBQUVwQyxRQUFRcFA7WUFDbEcsNkRBQTZEO1lBQzdELGtEQUFrRDtZQUNsRG9SLFFBQVFRLFdBQVcsQ0FBQ3JILFFBQVF2SyxNQUFNeEc7UUFDdEMsR0FBRyxDQUFDOEosT0FBT3FILFdBQVdDLFdBQVd2STtZQUM3Qiw0REFBNEQ7WUFDNUQrTyxRQUFRSyxXQUFXLENBQUNuTyxNQUFNa08sS0FBSyxFQUFFcEMsUUFBUXBQO1lBQ3pDLCtDQUErQztZQUMvQyxJQUFJNlI7WUFDSixJQUFJVCxRQUFRVSxhQUFhLENBQUN4TyxPQUFPcUgsV0FBV0MsV0FBV3ZJO2lCQUNsRCxJQUFJOE8sc0JBQXNCblIsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQ2hQLElBQUksR0FBR1csT0FDdkR3RyxLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUyxDQUFDL08sRUFBRSxHQUFHVSxNQUFNOEosTUFBTXhKLFFBQVEsSUFDOUMsQ0FBQytYLFlBQVlULFFBQVFXLGtCQUFrQixDQUFDaEIsWUFBWTVZLElBQUksS0FBSyxDQUFDLEtBQzlEaVosUUFBUVksWUFBWSxDQUFDMU8sT0FBT3FILFdBQVdDLFdBQVdpSCxXQUFXN1I7aUJBQzVELElBQUlvUixRQUFRYSxjQUFjLENBQUMzTyxPQUFPcUgsV0FBV0MsV0FBVzVLLE1BQU1xQyxHQUFHN0k7aUJBQ2pFO2dCQUNELHVCQUF1QjtnQkFDdkI0WCxRQUFRYyxPQUFPLENBQUM1TyxPQUFPcUgsV0FBV0MsV0FBVzVLLE1BQU14RztZQUN2RDtZQUNBQSxPQUFPOEosTUFBTXhKLFFBQVE7UUFDekI7UUFDQSx1REFBdUQ7UUFDdkRzWCxRQUFRSyxXQUFXLENBQUMsRUFBRSxFQUFFckMsUUFBUXBQO1FBQ2hDLElBQUksSUFBSSxDQUFDN0gsSUFBSSxDQUFDbVEsV0FBVyxFQUNyQjhJLFFBQVFlLGlCQUFpQjtRQUM3QmYsUUFBUWdCLFdBQVc7UUFDbkIsbUNBQW1DO1FBQ25DLElBQUloQixRQUFRaUIsT0FBTyxJQUFJLElBQUksQ0FBQ2hJLEtBQUssSUFBSUwsZUFBZTtZQUNoRCxnRkFBZ0Y7WUFDaEYsSUFBSWtILGtCQUNBLElBQUksQ0FBQ29CLHVCQUF1QixDQUFDdFMsTUFBTWtSO1lBQ3ZDcUIsWUFBWSxJQUFJLENBQUN4WCxVQUFVLEVBQUUsSUFBSSxDQUFDcVAsUUFBUSxFQUFFcEs7WUFDNUMsSUFBSWpDLEtBQ0F5VSxTQUFTLElBQUksQ0FBQzlYLEdBQUc7UUFDekI7SUFDSjtJQUNBdVcscUJBQXFCalIsSUFBSSxFQUFFMUQsR0FBRyxFQUFFO1FBQzVCLGtFQUFrRTtRQUNsRSwwQkFBMEI7UUFDMUIsSUFBSSxFQUFFekQsSUFBSSxFQUFFQyxFQUFFLEVBQUUsR0FBR2tILEtBQUswRixLQUFLLENBQUNtQyxTQUFTO1FBQ3ZDLElBQUksQ0FBRTdILENBQUFBLEtBQUswRixLQUFLLENBQUNtQyxTQUFTLFlBQVlyUSw0REFBWSxLQUFNcUIsT0FBT3lELE9BQU94RCxLQUFLd0QsTUFBTSxJQUFJLENBQUNuRSxJQUFJLENBQUN3TixPQUFPLENBQUNDLElBQUksRUFDbkcsT0FBTztRQUNYLElBQUk2TSxXQUFXelMsS0FBSzBTLEtBQUssQ0FBQ0MsZUFBZTtRQUN6QyxJQUFJLENBQUNGLFlBQVksQ0FBQyxJQUFJLENBQUMvWCxHQUFHLENBQUNrSCxRQUFRLENBQUM2USxTQUFTbmEsVUFBVSxHQUNuRCxPQUFPO1FBQ1gsSUFBSSxJQUFJLENBQUNILElBQUksQ0FBQytPLGFBQWEsRUFBRTtZQUN6QixrRUFBa0U7WUFDbEUsOERBQThEO1lBQzlELDhCQUE4QjtZQUM5QixJQUFJOEcsT0FBT3lFLFNBQVN0WixTQUFTO1lBQzdCLElBQUl5WixVQUFVQyxtQkFBbUIsSUFBSSxDQUFDMWEsSUFBSSxDQUFDd04sT0FBTyxFQUFFcUksTUFBTW5WLE9BQU95RCxLQUFLeEQsS0FBS3dEO1lBQzNFLE9BQU9zVyxVQUFVLElBQUksT0FBTztnQkFBRXphLE1BQU1zYTtnQkFBVW5XLEtBQUtzVztnQkFBUzVFO1lBQUs7UUFDckUsT0FDSztZQUNELE9BQU87Z0JBQUU3VixNQUFNc2E7Z0JBQVVuVyxLQUFLLENBQUM7Z0JBQUcwUixNQUFNO1lBQUc7UUFDL0M7SUFDSjtJQUNBc0Usd0JBQXdCdFMsSUFBSSxFQUFFLEVBQUU3SCxJQUFJLEVBQUVtRSxHQUFHLEVBQUUwUixJQUFJLEVBQUUsRUFBRTtRQUMvQyxnRUFBZ0U7UUFDaEUsSUFBSSxJQUFJLENBQUN2QyxPQUFPLENBQUN0VCxPQUNiO1FBQ0osbURBQW1EO1FBQ25ELElBQUkyYSxVQUFVM2E7UUFDZCxPQUFRMmEsVUFBVUEsUUFBUXhhLFVBQVUsQ0FBRTtZQUNsQyxJQUFJd2EsUUFBUXhhLFVBQVUsSUFBSSxJQUFJLENBQUN5QyxVQUFVLEVBQ3JDO1lBQ0osTUFBTytYLFFBQVF6YSxlQUFlLENBQzFCeWEsUUFBUXhhLFVBQVUsQ0FBQ3lhLFdBQVcsQ0FBQ0QsUUFBUXphLGVBQWU7WUFDMUQsTUFBT3lhLFFBQVFyUCxXQUFXLENBQ3RCcVAsUUFBUXhhLFVBQVUsQ0FBQ3lhLFdBQVcsQ0FBQ0QsUUFBUXJQLFdBQVc7WUFDdEQsSUFBSXFQLFFBQVFqWSxVQUFVLEVBQ2xCaVksUUFBUWpZLFVBQVUsR0FBRytIO1FBQzdCO1FBQ0EsSUFBSWpJLE9BQU8sSUFBSW1VLG9CQUFvQixJQUFJLEVBQUVnRSxTQUFTM2EsTUFBTTZWO1FBQ3hEaE8sS0FBSzBTLEtBQUssQ0FBQ00sZ0JBQWdCLENBQUNoUixJQUFJLENBQUNySDtRQUNqQyx5REFBeUQ7UUFDekQsSUFBSSxDQUFDeVAsUUFBUSxHQUFHMkYsYUFBYSxJQUFJLENBQUMzRixRQUFRLEVBQUU5TixLQUFLQSxNQUFNMFIsS0FBSzVVLE1BQU0sRUFBRTRHLE1BQU1yRjtJQUM5RTtJQUNBLG1FQUFtRTtJQUNuRSx5QkFBeUI7SUFDekJzWSxPQUFPOWEsSUFBSSxFQUFFd1MsU0FBUyxFQUFFQyxTQUFTLEVBQUU1SyxJQUFJLEVBQUU7UUFDckMsSUFBSSxJQUFJLENBQUNxSyxLQUFLLElBQUlKLGNBQ2QsQ0FBQzlSLEtBQUsrYSxVQUFVLENBQUMsSUFBSSxDQUFDL2EsSUFBSSxHQUMxQixPQUFPO1FBQ1gsSUFBSSxDQUFDZ2IsV0FBVyxDQUFDaGIsTUFBTXdTLFdBQVdDLFdBQVc1SztRQUM3QyxPQUFPO0lBQ1g7SUFDQW1ULFlBQVloYixJQUFJLEVBQUV3UyxTQUFTLEVBQUVDLFNBQVMsRUFBRTVLLElBQUksRUFBRTtRQUMxQyxJQUFJLENBQUNvVCxlQUFlLENBQUN6STtRQUNyQixJQUFJLENBQUN4UyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDeVMsU0FBUyxHQUFHQTtRQUNqQixJQUFJLElBQUksQ0FBQzdQLFVBQVUsRUFDZixJQUFJLENBQUMrVixjQUFjLENBQUM5USxNQUFNLElBQUksQ0FBQzhGLFVBQVU7UUFDN0MsSUFBSSxDQUFDdUUsS0FBSyxHQUFHUDtJQUNqQjtJQUNBc0osZ0JBQWdCekksU0FBUyxFQUFFO1FBQ3ZCLElBQUlpRyxjQUFjakcsV0FBVyxJQUFJLENBQUNBLFNBQVMsR0FDdkM7UUFDSixJQUFJMEksWUFBWSxJQUFJLENBQUMzSCxPQUFPLENBQUNqVCxRQUFRLElBQUk7UUFDekMsSUFBSTZhLFNBQVMsSUFBSSxDQUFDNVksR0FBRztRQUNyQixJQUFJLENBQUNBLEdBQUcsR0FBRzZZLGVBQWUsSUFBSSxDQUFDN1ksR0FBRyxFQUFFLElBQUksQ0FBQ2dSLE9BQU8sRUFBRThILGlCQUFpQixJQUFJLENBQUM3SSxTQUFTLEVBQUUsSUFBSSxDQUFDeFMsSUFBSSxFQUFFa2IsWUFBWUcsaUJBQWlCN0ksV0FBVyxJQUFJLENBQUN4UyxJQUFJLEVBQUVrYjtRQUNqSixJQUFJLElBQUksQ0FBQzNZLEdBQUcsSUFBSTRZLFFBQVE7WUFDcEJBLE9BQU96WSxVQUFVLEdBQUcrSDtZQUNwQixJQUFJLENBQUNsSSxHQUFHLENBQUNHLFVBQVUsR0FBRyxJQUFJO1FBQzlCO1FBQ0EsSUFBSSxDQUFDOFAsU0FBUyxHQUFHQTtJQUNyQjtJQUNBLDZDQUE2QztJQUM3QzhJLGFBQWE7UUFDVCxJQUFJLElBQUksQ0FBQy9ILE9BQU8sQ0FBQ2pULFFBQVEsSUFBSSxHQUN6QixJQUFJLENBQUNpVCxPQUFPLENBQUM4QyxTQUFTLENBQUNDLEdBQUcsQ0FBQztRQUMvQixJQUFJLElBQUksQ0FBQzFULFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQzVDLElBQUksQ0FBQ3NWLElBQUksQ0FBQ1UsSUFBSSxDQUFDN0ksU0FBUyxFQUNqRCxJQUFJLENBQUM1SyxHQUFHLENBQUM0SyxTQUFTLEdBQUc7SUFDN0I7SUFDQSwrQ0FBK0M7SUFDL0NvTyxlQUFlO1FBQ1gsSUFBSSxJQUFJLENBQUNoSSxPQUFPLENBQUNqVCxRQUFRLElBQUksR0FBRztZQUM1QixJQUFJLENBQUNpVCxPQUFPLENBQUM4QyxTQUFTLENBQUNtRixNQUFNLENBQUM7WUFDOUIsSUFBSSxJQUFJLENBQUM1WSxVQUFVLElBQUksQ0FBQyxJQUFJLENBQUM1QyxJQUFJLENBQUNzVixJQUFJLENBQUNVLElBQUksQ0FBQzdJLFNBQVMsRUFDakQsSUFBSSxDQUFDNUssR0FBRyxDQUFDa1osZUFBZSxDQUFDO1FBQ2pDO0lBQ0o7SUFDQSxJQUFJMUgsVUFBVTtRQUFFLE9BQU8sSUFBSSxDQUFDL1QsSUFBSSxDQUFDMGIsTUFBTTtJQUFFO0FBQzdDO0FBQ0EscUVBQXFFO0FBQ3JFLDhCQUE4QjtBQUM5QixTQUFTQyxZQUFZaFksR0FBRyxFQUFFNk8sU0FBUyxFQUFFQyxTQUFTLEVBQUVsUSxHQUFHLEVBQUVzRixJQUFJO0lBQ3JEb1EsZUFBZTFWLEtBQUtpUSxXQUFXN087SUFDL0IsSUFBSXNJLFVBQVUsSUFBSTRMLGFBQWFwTixXQUFXOUcsS0FBSzZPLFdBQVdDLFdBQVdsUSxLQUFLQSxLQUFLQSxLQUFLc0YsTUFBTTtJQUMxRixJQUFJb0UsUUFBUXJKLFVBQVUsRUFDbEJxSixRQUFRME0sY0FBYyxDQUFDOVEsTUFBTTtJQUNqQyxPQUFPb0U7QUFDWDtBQUNBLE1BQU1rTSxxQkFBcUJOO0lBQ3ZCN0YsWUFBWTVSLE1BQU0sRUFBRUosSUFBSSxFQUFFd1MsU0FBUyxFQUFFQyxTQUFTLEVBQUVsUSxHQUFHLEVBQUVnUixPQUFPLEVBQUUxTCxJQUFJLENBQUU7UUFDaEUsS0FBSyxDQUFDekgsUUFBUUosTUFBTXdTLFdBQVdDLFdBQVdsUSxLQUFLLE1BQU1nUixTQUFTMUwsTUFBTTtJQUN4RTtJQUNBOEssWUFBWTtRQUNSLElBQUlpSixPQUFPLElBQUksQ0FBQ3JJLE9BQU8sQ0FBQ3BULFVBQVU7UUFDbEMsTUFBT3liLFFBQVFBLFFBQVEsSUFBSSxDQUFDclosR0FBRyxJQUFJLENBQUNxWixLQUFLQyxRQUFRLENBQzdDRCxPQUFPQSxLQUFLemIsVUFBVTtRQUMxQixPQUFPO1lBQUV5YixNQUFPQSxRQUFRO1FBQU07SUFDbEM7SUFDQWQsT0FBTzlhLElBQUksRUFBRXdTLFNBQVMsRUFBRUMsU0FBUyxFQUFFNUssSUFBSSxFQUFFO1FBQ3JDLElBQUksSUFBSSxDQUFDcUssS0FBSyxJQUFJSixjQUFlLElBQUksQ0FBQ0ksS0FBSyxJQUFJUCxhQUFhLENBQUMsSUFBSSxDQUFDbUssUUFBUSxNQUN0RSxDQUFDOWIsS0FBSythLFVBQVUsQ0FBQyxJQUFJLENBQUMvYSxJQUFJLEdBQzFCLE9BQU87UUFDWCxJQUFJLENBQUNpYixlQUFlLENBQUN6STtRQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDTixLQUFLLElBQUlQLGFBQWEzUixLQUFLNlYsSUFBSSxJQUFJLElBQUksQ0FBQzdWLElBQUksQ0FBQzZWLElBQUksS0FBSzdWLEtBQUs2VixJQUFJLElBQUksSUFBSSxDQUFDdEMsT0FBTyxDQUFDdlMsU0FBUyxFQUFFO1lBQ2pHLElBQUksQ0FBQ3VTLE9BQU8sQ0FBQ3ZTLFNBQVMsR0FBR2hCLEtBQUs2VixJQUFJO1lBQ2xDLElBQUloTyxLQUFLa1UsV0FBVyxJQUFJLElBQUksQ0FBQ3hJLE9BQU8sRUFDaEMxTCxLQUFLa1UsV0FBVyxHQUFHO1FBQzNCO1FBQ0EsSUFBSSxDQUFDL2IsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2tTLEtBQUssR0FBR1A7UUFDYixPQUFPO0lBQ1g7SUFDQW1LLFdBQVc7UUFDUCxJQUFJL0ssWUFBWSxJQUFJLENBQUMzUSxNQUFNLENBQUN3QyxVQUFVO1FBQ3RDLElBQUssSUFBSW9aLElBQUksSUFBSSxDQUFDekksT0FBTyxFQUFFeUksR0FBR0EsSUFBSUEsRUFBRTdiLFVBQVUsQ0FDMUMsSUFBSTZiLEtBQUtqTCxXQUNMLE9BQU87UUFDZixPQUFPO0lBQ1g7SUFDQXhDLFdBQVdwSyxHQUFHLEVBQUU7UUFDWixPQUFPO1lBQUVuRSxNQUFNLElBQUksQ0FBQ3VULE9BQU87WUFBRXJSLFFBQVFpQztRQUFJO0lBQzdDO0lBQ0E2TyxnQkFBZ0J6USxHQUFHLEVBQUVMLE1BQU0sRUFBRThKLElBQUksRUFBRTtRQUMvQixJQUFJekosT0FBTyxJQUFJLENBQUNnUixPQUFPLEVBQ25CLE9BQU8sSUFBSSxDQUFDNUYsVUFBVSxHQUFHdEosS0FBS0MsR0FBRyxDQUFDcEMsUUFBUSxJQUFJLENBQUNsQyxJQUFJLENBQUM2VixJQUFJLENBQUM1VSxNQUFNO1FBQ25FLE9BQU8sS0FBSyxDQUFDK1IsZ0JBQWdCelEsS0FBS0wsUUFBUThKO0lBQzlDO0lBQ0FvSixlQUFlQyxRQUFRLEVBQUU7UUFDckIsT0FBT0EsU0FBU0MsSUFBSSxJQUFJLG1CQUFtQkQsU0FBU0MsSUFBSSxJQUFJO0lBQ2hFO0lBQ0FtQyxNQUFNL1csSUFBSSxFQUFFQyxFQUFFLEVBQUVrSCxJQUFJLEVBQUU7UUFDbEIsSUFBSTdILE9BQU8sSUFBSSxDQUFDQSxJQUFJLENBQUNpYyxHQUFHLENBQUN2YixNQUFNQyxLQUFLNEIsTUFBTTFCLFNBQVNrWCxjQUFjLENBQUMvWCxLQUFLNlYsSUFBSTtRQUMzRSxPQUFPLElBQUlzQyxhQUFhLElBQUksQ0FBQy9YLE1BQU0sRUFBRUosTUFBTSxJQUFJLENBQUN3UyxTQUFTLEVBQUUsSUFBSSxDQUFDQyxTQUFTLEVBQUVsUSxLQUFLQSxLQUFLc0Y7SUFDekY7SUFDQTJOLFVBQVU5VSxJQUFJLEVBQUVDLEVBQUUsRUFBRTtRQUNoQixLQUFLLENBQUM2VSxVQUFVOVUsTUFBTUM7UUFDdEIsSUFBSSxJQUFJLENBQUM0QixHQUFHLElBQUksSUFBSSxDQUFDZ1IsT0FBTyxJQUFLN1MsQ0FBQUEsUUFBUSxLQUFLQyxNQUFNLElBQUksQ0FBQzRTLE9BQU8sQ0FBQ3ZTLFNBQVMsQ0FBQ0MsTUFBTSxHQUM3RSxJQUFJLENBQUNpUixLQUFLLEdBQUdKO0lBQ3JCO0lBQ0EsSUFBSWlDLFVBQVU7UUFBRSxPQUFPO0lBQU87SUFDOUJ0SCxPQUFPb0osSUFBSSxFQUFFO1FBQUUsT0FBTyxJQUFJLENBQUM3VixJQUFJLENBQUM2VixJQUFJLElBQUlBO0lBQU07QUFDbEQ7QUFDQSxvRUFBb0U7QUFDcEUsdUNBQXVDO0FBQ3ZDLE1BQU1qQyw2QkFBNkI3QjtJQUMvQlksWUFBWTtRQUFFLE9BQU87WUFBRTZELFFBQVE7UUFBSztJQUFHO0lBQ3ZDOUQsWUFBWTVRLFFBQVEsRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDb1EsS0FBSyxJQUFJUCxhQUFhLElBQUksQ0FBQ3BQLEdBQUcsQ0FBQ1QsUUFBUSxJQUFJQTtJQUFVO0lBQ3pGLElBQUlpUyxVQUFVO1FBQUUsT0FBTztJQUFNO0lBQzdCLElBQUk3RSxrQkFBa0I7UUFBRSxPQUFPLElBQUksQ0FBQzNNLEdBQUcsQ0FBQ1QsUUFBUSxJQUFJO0lBQU87QUFDL0Q7QUFDQSxxRUFBcUU7QUFDckUsZ0VBQWdFO0FBQ2hFLGNBQWM7QUFDZCxNQUFNb1csMkJBQTJCTDtJQUM3QjdGLFlBQVk1UixNQUFNLEVBQUVKLElBQUksRUFBRXdTLFNBQVMsRUFBRUMsU0FBUyxFQUFFbFEsR0FBRyxFQUFFSyxVQUFVLEVBQUUyUSxPQUFPLEVBQUV5QyxJQUFJLEVBQUVuTyxJQUFJLEVBQUUxRCxHQUFHLENBQUU7UUFDdkYsS0FBSyxDQUFDL0QsUUFBUUosTUFBTXdTLFdBQVdDLFdBQVdsUSxLQUFLSyxZQUFZMlEsU0FBUzFMLE1BQU0xRDtRQUMxRSxJQUFJLENBQUM2UixJQUFJLEdBQUdBO0lBQ2hCO0lBQ0Esa0VBQWtFO0lBQ2xFLGtFQUFrRTtJQUNsRSx3QkFBd0I7SUFDeEI4RSxPQUFPOWEsSUFBSSxFQUFFd1MsU0FBUyxFQUFFQyxTQUFTLEVBQUU1SyxJQUFJLEVBQUU7UUFDckMsSUFBSSxJQUFJLENBQUNxSyxLQUFLLElBQUlKLFlBQ2QsT0FBTztRQUNYLElBQUksSUFBSSxDQUFDa0UsSUFBSSxDQUFDOEUsTUFBTSxJQUFLLEtBQUksQ0FBQzlhLElBQUksQ0FBQ3NWLElBQUksSUFBSXRWLEtBQUtzVixJQUFJLElBQUksSUFBSSxDQUFDVSxJQUFJLENBQUNrRyxTQUFTLEdBQUc7WUFDMUUsSUFBSTlLLFNBQVMsSUFBSSxDQUFDNEUsSUFBSSxDQUFDOEUsTUFBTSxDQUFDOWEsTUFBTXdTLFdBQVdDO1lBQy9DLElBQUlyQixRQUNBLElBQUksQ0FBQzRKLFdBQVcsQ0FBQ2hiLE1BQU13UyxXQUFXQyxXQUFXNUs7WUFDakQsT0FBT3VKO1FBQ1gsT0FDSyxJQUFJLENBQUMsSUFBSSxDQUFDeE8sVUFBVSxJQUFJLENBQUM1QyxLQUFLMFksTUFBTSxFQUFFO1lBQ3ZDLE9BQU87UUFDWCxPQUNLO1lBQ0QsT0FBTyxLQUFLLENBQUNvQyxPQUFPOWEsTUFBTXdTLFdBQVdDLFdBQVc1SztRQUNwRDtJQUNKO0lBQ0F5VCxhQUFhO1FBQ1QsSUFBSSxDQUFDdEYsSUFBSSxDQUFDc0YsVUFBVSxHQUFHLElBQUksQ0FBQ3RGLElBQUksQ0FBQ3NGLFVBQVUsS0FBSyxLQUFLLENBQUNBO0lBQzFEO0lBQ0FDLGVBQWU7UUFDWCxJQUFJLENBQUN2RixJQUFJLENBQUN1RixZQUFZLEdBQUcsSUFBSSxDQUFDdkYsSUFBSSxDQUFDdUYsWUFBWSxLQUFLLEtBQUssQ0FBQ0E7SUFDOUQ7SUFDQWhILGFBQWFDLE1BQU0sRUFBRUMsSUFBSSxFQUFFNU0sSUFBSSxFQUFFNk0sS0FBSyxFQUFFO1FBQ3BDLElBQUksQ0FBQ3NCLElBQUksQ0FBQ3pCLFlBQVksR0FBRyxJQUFJLENBQUN5QixJQUFJLENBQUN6QixZQUFZLENBQUNDLFFBQVFDLE1BQU01TSxLQUFLMEIsSUFBSSxJQUNqRSxLQUFLLENBQUNnTCxhQUFhQyxRQUFRQyxNQUFNNU0sTUFBTTZNO0lBQ2pEO0lBQ0E3QixVQUFVO1FBQ04sSUFBSSxJQUFJLENBQUNtRCxJQUFJLENBQUNuRCxPQUFPLEVBQ2pCLElBQUksQ0FBQ21ELElBQUksQ0FBQ25ELE9BQU87UUFDckIsS0FBSyxDQUFDQTtJQUNWO0lBQ0FELFVBQVV0UCxLQUFLLEVBQUU7UUFDYixPQUFPLElBQUksQ0FBQzBTLElBQUksQ0FBQ3BELFNBQVMsR0FBRyxJQUFJLENBQUNvRCxJQUFJLENBQUNwRCxTQUFTLENBQUN0UCxTQUFTO0lBQzlEO0lBQ0E4UixlQUFlQyxRQUFRLEVBQUU7UUFDckIsT0FBTyxJQUFJLENBQUNXLElBQUksQ0FBQ1osY0FBYyxHQUFHLElBQUksQ0FBQ1ksSUFBSSxDQUFDWixjQUFjLENBQUNDLFlBQVksS0FBSyxDQUFDRCxlQUFlQztJQUNoRztBQUNKO0FBQ0EsbUVBQW1FO0FBQ25FLGdFQUFnRTtBQUNoRSxtRUFBbUU7QUFDbkUsU0FBUytFLFlBQVlySixTQUFTLEVBQUVvTCxLQUFLLEVBQUV0VSxJQUFJO0lBQ3ZDLElBQUl0RixNQUFNd08sVUFBVTNGLFVBQVUsRUFBRWdSLFVBQVU7SUFDMUMsSUFBSyxJQUFJbFMsSUFBSSxHQUFHQSxJQUFJaVMsTUFBTWxiLE1BQU0sRUFBRWlKLElBQUs7UUFDbkMsSUFBSTFILE9BQU8yWixLQUFLLENBQUNqUyxFQUFFLEVBQUVtUyxXQUFXN1osS0FBS0QsR0FBRztRQUN4QyxJQUFJOFosU0FBU2xjLFVBQVUsSUFBSTRRLFdBQVc7WUFDbEMsTUFBT3NMLFlBQVk5WixJQUFLO2dCQUNwQkEsTUFBTStaLEdBQUcvWjtnQkFDVDZaLFVBQVU7WUFDZDtZQUNBN1osTUFBTUEsSUFBSStJLFdBQVc7UUFDekIsT0FDSztZQUNEOFEsVUFBVTtZQUNWckwsVUFBVXdMLFlBQVksQ0FBQ0YsVUFBVTlaO1FBQ3JDO1FBQ0EsSUFBSUMsZ0JBQWdCdVUsY0FBYztZQUM5QixJQUFJNVMsTUFBTTVCLE1BQU1BLElBQUlyQyxlQUFlLEdBQUc2USxVQUFVekQsU0FBUztZQUN6RDhNLFlBQVk1WCxLQUFLSSxVQUFVLEVBQUVKLEtBQUt5UCxRQUFRLEVBQUVwSztZQUM1Q3RGLE1BQU00QixNQUFNQSxJQUFJbUgsV0FBVyxHQUFHeUYsVUFBVTNGLFVBQVU7UUFDdEQ7SUFDSjtJQUNBLE1BQU83SSxJQUFLO1FBQ1JBLE1BQU0rWixHQUFHL1o7UUFDVDZaLFVBQVU7SUFDZDtJQUNBLElBQUlBLFdBQVd2VSxLQUFLa1UsV0FBVyxJQUFJaEwsV0FDL0JsSixLQUFLa1UsV0FBVyxHQUFHO0FBQzNCO0FBQ0EsTUFBTVMsaUJBQWlCLFNBQVUxYSxRQUFRO0lBQ3JDLElBQUlBLFVBQ0EsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO0FBQ3hCO0FBQ0EwYSxlQUFldk8sU0FBUyxHQUFHd08sT0FBT3pGLE1BQU0sQ0FBQztBQUN6QyxNQUFNMEYsU0FBUztJQUFDLElBQUlGO0NBQWU7QUFDbkMsU0FBU25CLGlCQUFpQjdJLFNBQVMsRUFBRXhTLElBQUksRUFBRWtiLFNBQVM7SUFDaEQsSUFBSTFJLFVBQVV2UixNQUFNLElBQUksR0FDcEIsT0FBT3liO0lBQ1gsSUFBSTdWLE1BQU1xVSxZQUFZd0IsTUFBTSxDQUFDLEVBQUUsR0FBRyxJQUFJRixnQkFBZ0JwTCxTQUFTO1FBQUN2SztLQUFJO0lBQ3BFLElBQUssSUFBSXFELElBQUksR0FBR0EsSUFBSXNJLFVBQVV2UixNQUFNLEVBQUVpSixJQUFLO1FBQ3ZDLElBQUlvTixRQUFROUUsU0FBUyxDQUFDdEksRUFBRSxDQUFDb0wsSUFBSSxDQUFDZ0MsS0FBSztRQUNuQyxJQUFJLENBQUNBLE9BQ0Q7UUFDSixJQUFJQSxNQUFNeFYsUUFBUSxFQUNkc1AsT0FBT3ZILElBQUksQ0FBQ2hELE1BQU0sSUFBSTJWLGVBQWVsRixNQUFNeFYsUUFBUTtRQUN2RCxJQUFLLElBQUlzVixRQUFRRSxNQUFPO1lBQ3BCLElBQUlxRixNQUFNckYsS0FBSyxDQUFDRixLQUFLO1lBQ3JCLElBQUl1RixPQUFPLE1BQ1A7WUFDSixJQUFJekIsYUFBYTlKLE9BQU9uUSxNQUFNLElBQUksR0FDOUJtUSxPQUFPdkgsSUFBSSxDQUFDaEQsTUFBTSxJQUFJMlYsZUFBZXhjLEtBQUs0YyxRQUFRLEdBQUcsU0FBUztZQUNsRSxJQUFJeEYsUUFBUSxTQUNSdlEsSUFBSWdXLEtBQUssR0FBRyxDQUFDaFcsSUFBSWdXLEtBQUssR0FBR2hXLElBQUlnVyxLQUFLLEdBQUcsTUFBTSxFQUFDLElBQUtGO2lCQUNoRCxJQUFJdkYsUUFBUSxTQUNidlEsSUFBSVQsS0FBSyxHQUFHLENBQUNTLElBQUlULEtBQUssR0FBR1MsSUFBSVQsS0FBSyxHQUFHLE1BQU0sRUFBQyxJQUFLdVc7aUJBQ2hELElBQUl2RixRQUFRLFlBQ2J2USxHQUFHLENBQUN1USxLQUFLLEdBQUd1RjtRQUNwQjtJQUNKO0lBQ0EsT0FBT3ZMO0FBQ1g7QUFDQSxTQUFTZ0ssZUFBZTBCLFFBQVEsRUFBRXZKLE9BQU8sRUFBRXdKLFlBQVksRUFBRUMsV0FBVztJQUNoRSw0QkFBNEI7SUFDNUIsSUFBSUQsZ0JBQWdCTCxVQUFVTSxlQUFlTixRQUN6QyxPQUFPbko7SUFDWCxJQUFJMEosU0FBUzFKO0lBQ2IsSUFBSyxJQUFJckosSUFBSSxHQUFHQSxJQUFJOFMsWUFBWS9iLE1BQU0sRUFBRWlKLElBQUs7UUFDekMsSUFBSWdULE9BQU9GLFdBQVcsQ0FBQzlTLEVBQUUsRUFBRW1ELE9BQU8wUCxZQUFZLENBQUM3UyxFQUFFO1FBQ2pELElBQUlBLEdBQUc7WUFDSCxJQUFJOUo7WUFDSixJQUFJaU4sUUFBUUEsS0FBS3ZMLFFBQVEsSUFBSW9iLEtBQUtwYixRQUFRLElBQUltYixVQUFVSCxZQUNuRDFjLENBQUFBLFNBQVM2YyxPQUFPOWMsVUFBVSxLQUFLQyxPQUFPMEIsUUFBUSxDQUFDcWIsV0FBVyxNQUFNRCxLQUFLcGIsUUFBUSxFQUFFO2dCQUNoRm1iLFNBQVM3YztZQUNiLE9BQ0s7Z0JBQ0RBLFNBQVNTLFNBQVNzVixhQUFhLENBQUMrRyxLQUFLcGIsUUFBUTtnQkFDN0MxQixPQUFPeWIsUUFBUSxHQUFHO2dCQUNsQnpiLE9BQU9nVyxXQUFXLENBQUM2RztnQkFDbkI1UCxPQUFPcVAsTUFBTSxDQUFDLEVBQUU7Z0JBQ2hCTyxTQUFTN2M7WUFDYjtRQUNKO1FBQ0FnZCxnQkFBZ0JILFFBQVE1UCxRQUFRcVAsTUFBTSxDQUFDLEVBQUUsRUFBRVE7SUFDL0M7SUFDQSxPQUFPRDtBQUNYO0FBQ0EsU0FBU0csZ0JBQWdCN2EsR0FBRyxFQUFFOEssSUFBSSxFQUFFNUssR0FBRztJQUNuQyxJQUFLLElBQUkyVSxRQUFRL0osS0FDYixJQUFJK0osUUFBUSxXQUFXQSxRQUFRLFdBQVdBLFFBQVEsY0FBYyxDQUFFQSxDQUFBQSxRQUFRM1UsR0FBRSxHQUN4RUYsSUFBSWtaLGVBQWUsQ0FBQ3JFO0lBQzVCLElBQUssSUFBSUEsUUFBUTNVLElBQ2IsSUFBSTJVLFFBQVEsV0FBV0EsUUFBUSxXQUFXQSxRQUFRLGNBQWMzVSxHQUFHLENBQUMyVSxLQUFLLElBQUkvSixJQUFJLENBQUMrSixLQUFLLEVBQ25GN1UsSUFBSThhLFlBQVksQ0FBQ2pHLE1BQU0zVSxHQUFHLENBQUMyVSxLQUFLO0lBQ3hDLElBQUkvSixLQUFLd1AsS0FBSyxJQUFJcGEsSUFBSW9hLEtBQUssRUFBRTtRQUN6QixJQUFJUyxXQUFXalEsS0FBS3dQLEtBQUssR0FBR3hQLEtBQUt3UCxLQUFLLENBQUNVLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDLFdBQVcsRUFBRTtRQUN0RSxJQUFJQyxVQUFVamIsSUFBSW9hLEtBQUssR0FBR3BhLElBQUlvYSxLQUFLLENBQUNVLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDLFdBQVcsRUFBRTtRQUNuRSxJQUFLLElBQUl2VCxJQUFJLEdBQUdBLElBQUlvVCxTQUFTcmMsTUFBTSxFQUFFaUosSUFDakMsSUFBSXdULFFBQVFDLE9BQU8sQ0FBQ0wsUUFBUSxDQUFDcFQsRUFBRSxLQUFLLENBQUMsR0FDakMzSCxJQUFJOFQsU0FBUyxDQUFDbUYsTUFBTSxDQUFDOEIsUUFBUSxDQUFDcFQsRUFBRTtRQUN4QyxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSXdULFFBQVF6YyxNQUFNLEVBQUVpSixJQUNoQyxJQUFJb1QsU0FBU0ssT0FBTyxDQUFDRCxPQUFPLENBQUN4VCxFQUFFLEtBQUssQ0FBQyxHQUNqQzNILElBQUk4VCxTQUFTLENBQUNDLEdBQUcsQ0FBQ29ILE9BQU8sQ0FBQ3hULEVBQUU7UUFDcEMsSUFBSTNILElBQUk4VCxTQUFTLENBQUNwVixNQUFNLElBQUksR0FDeEJzQixJQUFJa1osZUFBZSxDQUFDO0lBQzVCO0lBQ0EsSUFBSXBPLEtBQUtqSCxLQUFLLElBQUkzRCxJQUFJMkQsS0FBSyxFQUFFO1FBQ3pCLElBQUlpSCxLQUFLakgsS0FBSyxFQUFFO1lBQ1osSUFBSXdYLE9BQU8saUZBQWlGQztZQUM1RixNQUFPQSxJQUFJRCxLQUFLNVksSUFBSSxDQUFDcUksS0FBS2pILEtBQUssRUFDM0I3RCxJQUFJNkQsS0FBSyxDQUFDMFgsY0FBYyxDQUFDRCxDQUFDLENBQUMsRUFBRTtRQUNyQztRQUNBLElBQUlwYixJQUFJMkQsS0FBSyxFQUNUN0QsSUFBSTZELEtBQUssQ0FBQzJYLE9BQU8sSUFBSXRiLElBQUkyRCxLQUFLO0lBQ3RDO0FBQ0o7QUFDQSxTQUFTNlIsZUFBZTFWLEdBQUcsRUFBRTJhLElBQUksRUFBRWxkLElBQUk7SUFDbkMsT0FBT29iLGVBQWU3WSxLQUFLQSxLQUFLbWEsUUFBUXJCLGlCQUFpQjZCLE1BQU1sZCxNQUFNdUMsSUFBSWpDLFFBQVEsSUFBSTtBQUN6RjtBQUNBLFNBQVNtWSxjQUFjdUYsQ0FBQyxFQUFFQyxDQUFDO0lBQ3ZCLElBQUlELEVBQUUvYyxNQUFNLElBQUlnZCxFQUFFaGQsTUFBTSxFQUNwQixPQUFPO0lBQ1gsSUFBSyxJQUFJaUosSUFBSSxHQUFHQSxJQUFJOFQsRUFBRS9jLE1BQU0sRUFBRWlKLElBQzFCLElBQUksQ0FBQzhULENBQUMsQ0FBQzlULEVBQUUsQ0FBQ29MLElBQUksQ0FBQ2lCLEVBQUUsQ0FBQzBILENBQUMsQ0FBQy9ULEVBQUUsQ0FBQ29MLElBQUksR0FDdkIsT0FBTztJQUNmLE9BQU87QUFDWDtBQUNBLGlEQUFpRDtBQUNqRCxTQUFTZ0gsR0FBRy9aLEdBQUc7SUFDWCxJQUFJNkssT0FBTzdLLElBQUkrSSxXQUFXO0lBQzFCL0ksSUFBSXBDLFVBQVUsQ0FBQ3lhLFdBQVcsQ0FBQ3JZO0lBQzNCLE9BQU82SztBQUNYO0FBQ0EsbUVBQW1FO0FBQ25FLDRDQUE0QztBQUM1QyxNQUFNOEw7SUFDRmxILFlBQVluTCxHQUFHLEVBQUVxWCxJQUFJLEVBQUVyVyxJQUFJLENBQUU7UUFDekIsSUFBSSxDQUFDcVcsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ3JXLElBQUksR0FBR0E7UUFDWiw4REFBOEQ7UUFDOUQsbUJBQW1CO1FBQ25CLElBQUksQ0FBQzVILEtBQUssR0FBRztRQUNiLDZEQUE2RDtRQUM3RCxhQUFhO1FBQ2IsSUFBSSxDQUFDMEosS0FBSyxHQUFHLEVBQUU7UUFDZixzQ0FBc0M7UUFDdEMsSUFBSSxDQUFDdVEsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDclQsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ3NYLFFBQVEsR0FBR0EsU0FBU3RYLElBQUk3RyxJQUFJLENBQUN3TixPQUFPLEVBQUUzRztJQUMvQztJQUNBLCtEQUErRDtJQUMvRCxjQUFjO0lBQ2R1WCxlQUFlOU4sS0FBSyxFQUFFQyxHQUFHLEVBQUU7UUFDdkIsSUFBSUQsU0FBU0MsS0FDVDtRQUNKLElBQUssSUFBSXJHLElBQUlvRyxPQUFPcEcsSUFBSXFHLEtBQUtyRyxJQUN6QixJQUFJLENBQUNyRCxHQUFHLENBQUNvTCxRQUFRLENBQUMvSCxFQUFFLENBQUMySSxPQUFPO1FBQ2hDLElBQUksQ0FBQ2hNLEdBQUcsQ0FBQ29MLFFBQVEsQ0FBQ29NLE1BQU0sQ0FBQy9OLE9BQU9DLE1BQU1EO1FBQ3RDLElBQUksQ0FBQzRKLE9BQU8sR0FBRztJQUNuQjtJQUNBLGdEQUFnRDtJQUNoREQsY0FBYztRQUNWLElBQUksQ0FBQ21FLGNBQWMsQ0FBQyxJQUFJLENBQUNuZSxLQUFLLEVBQUUsSUFBSSxDQUFDNEcsR0FBRyxDQUFDb0wsUUFBUSxDQUFDaFIsTUFBTTtJQUM1RDtJQUNBLCtEQUErRDtJQUMvRCxvREFBb0Q7SUFDcERxWSxZQUFZRCxLQUFLLEVBQUVwQyxNQUFNLEVBQUVwUCxJQUFJLEVBQUU7UUFDN0IsSUFBSXlXLE9BQU8sR0FBR3ROLFFBQVEsSUFBSSxDQUFDckgsS0FBSyxDQUFDMUksTUFBTSxJQUFJO1FBQzNDLElBQUlzZCxVQUFVbGEsS0FBS0MsR0FBRyxDQUFDME0sT0FBT3FJLE1BQU1wWSxNQUFNO1FBQzFDLE1BQU9xZCxPQUFPQyxXQUNWLENBQUNELFFBQVF0TixRQUFRLElBQUksSUFBSSxDQUFDbkssR0FBRyxHQUFHLElBQUksQ0FBQzhDLEtBQUssQ0FBQyxPQUFRLEtBQU0sRUFBRSxFQUN0RDBJLFdBQVcsQ0FBQ2dILEtBQUssQ0FBQ2lGLEtBQUssS0FBS2pGLEtBQUssQ0FBQ2lGLEtBQUssQ0FBQ2hKLElBQUksQ0FBQ1UsSUFBSSxDQUFDd0ksUUFBUSxLQUFLLE1BQ3BFRjtRQUNKLE1BQU9BLE9BQU90TixNQUFPO1lBQ2pCLElBQUksQ0FBQ2lKLFdBQVc7WUFDaEIsSUFBSSxDQUFDcFQsR0FBRyxDQUFDcUwsS0FBSyxHQUFHUDtZQUNqQixJQUFJLENBQUMxUixLQUFLLEdBQUcsSUFBSSxDQUFDMEosS0FBSyxDQUFDOFUsR0FBRztZQUMzQixJQUFJLENBQUM1WCxHQUFHLEdBQUcsSUFBSSxDQUFDOEMsS0FBSyxDQUFDOFUsR0FBRztZQUN6QnpOO1FBQ0o7UUFDQSxNQUFPQSxRQUFRcUksTUFBTXBZLE1BQU0sQ0FBRTtZQUN6QixJQUFJLENBQUMwSSxLQUFLLENBQUNFLElBQUksQ0FBQyxJQUFJLENBQUNoRCxHQUFHLEVBQUUsSUFBSSxDQUFDNUcsS0FBSyxHQUFHO1lBQ3ZDLElBQUl5ZSxRQUFRLENBQUM7WUFDYixJQUFLLElBQUl4VSxJQUFJLElBQUksQ0FBQ2pLLEtBQUssRUFBRWlLLElBQUk3RixLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDckUsS0FBSyxHQUFHLEdBQUcsSUFBSSxDQUFDNEcsR0FBRyxDQUFDb0wsUUFBUSxDQUFDaFIsTUFBTSxHQUFHaUosSUFBSztnQkFDbEYsSUFBSWtELE9BQU8sSUFBSSxDQUFDdkcsR0FBRyxDQUFDb0wsUUFBUSxDQUFDL0gsRUFBRTtnQkFDL0IsSUFBSWtELEtBQUtpRixXQUFXLENBQUNnSCxLQUFLLENBQUNySSxNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMyTixRQUFRLENBQUN2UixLQUFLN0ssR0FBRyxHQUFHO29CQUM1RG1jLFFBQVF4VTtvQkFDUjtnQkFDSjtZQUNKO1lBQ0EsSUFBSXdVLFFBQVEsQ0FBQyxHQUFHO2dCQUNaLElBQUlBLFFBQVEsSUFBSSxDQUFDemUsS0FBSyxFQUFFO29CQUNwQixJQUFJLENBQUNpYSxPQUFPLEdBQUc7b0JBQ2YsSUFBSSxDQUFDa0UsY0FBYyxDQUFDLElBQUksQ0FBQ25lLEtBQUssRUFBRXllO2dCQUNwQztnQkFDQSxJQUFJLENBQUM3WCxHQUFHLEdBQUcsSUFBSSxDQUFDQSxHQUFHLENBQUNvTCxRQUFRLENBQUMsSUFBSSxDQUFDaFMsS0FBSyxDQUFDO1lBQzVDLE9BQ0s7Z0JBQ0QsSUFBSTJlLFdBQVc3SCxhQUFhQyxNQUFNLENBQUMsSUFBSSxDQUFDblEsR0FBRyxFQUFFd1MsS0FBSyxDQUFDckksTUFBTSxFQUFFaUcsUUFBUXBQO2dCQUNuRSxJQUFJLENBQUNoQixHQUFHLENBQUNvTCxRQUFRLENBQUNvTSxNQUFNLENBQUMsSUFBSSxDQUFDcGUsS0FBSyxFQUFFLEdBQUcyZTtnQkFDeEMsSUFBSSxDQUFDL1gsR0FBRyxHQUFHK1g7Z0JBQ1gsSUFBSSxDQUFDMUUsT0FBTyxHQUFHO1lBQ25CO1lBQ0EsSUFBSSxDQUFDamEsS0FBSyxHQUFHO1lBQ2IrUTtRQUNKO0lBQ0o7SUFDQSxvRUFBb0U7SUFDcEUsK0JBQStCO0lBQy9CMkksY0FBYzNaLElBQUksRUFBRXdTLFNBQVMsRUFBRUMsU0FBUyxFQUFFeFMsS0FBSyxFQUFFO1FBQzdDLElBQUl5ZSxRQUFRLENBQUMsR0FBR0c7UUFDaEIsSUFBSTVlLFNBQVMsSUFBSSxDQUFDa2UsUUFBUSxDQUFDbGUsS0FBSyxJQUM1QixDQUFDNGUsYUFBYSxJQUFJLENBQUNWLFFBQVEsQ0FBQ1csT0FBTyxDQUFDN2UsUUFBUSxJQUFJLENBQUNrZSxRQUFRLENBQUNsZSxLQUFLLENBQUMsRUFBRUcsTUFBTSxJQUFJLElBQUksQ0FBQ3lHLEdBQUcsSUFDcEZnWSxXQUFXdE0sV0FBVyxDQUFDdlMsTUFBTXdTLFdBQVdDLFlBQVk7WUFDcERpTSxRQUFRLElBQUksQ0FBQzdYLEdBQUcsQ0FBQ29MLFFBQVEsQ0FBQzBMLE9BQU8sQ0FBQ2tCLFlBQVksSUFBSSxDQUFDNWUsS0FBSztRQUM1RCxPQUNLO1lBQ0QsSUFBSyxJQUFJaUssSUFBSSxJQUFJLENBQUNqSyxLQUFLLEVBQUU4ZSxJQUFJMWEsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQ3VDLEdBQUcsQ0FBQ29MLFFBQVEsQ0FBQ2hSLE1BQU0sRUFBRWlKLElBQUksSUFBSUEsSUFBSTZVLEdBQUc3VSxJQUFLO2dCQUNoRixJQUFJaUIsUUFBUSxJQUFJLENBQUN0RSxHQUFHLENBQUNvTCxRQUFRLENBQUMvSCxFQUFFO2dCQUNoQyxJQUFJaUIsTUFBTW9ILFdBQVcsQ0FBQ3ZTLE1BQU13UyxXQUFXQyxjQUFjLENBQUMsSUFBSSxDQUFDMEwsUUFBUSxDQUFDYSxPQUFPLENBQUNDLEdBQUcsQ0FBQzlULFFBQVE7b0JBQ3BGdVQsUUFBUXhVO29CQUNSO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLElBQUl3VSxRQUFRLEdBQ1IsT0FBTztRQUNYLElBQUksQ0FBQ04sY0FBYyxDQUFDLElBQUksQ0FBQ25lLEtBQUssRUFBRXllO1FBQ2hDLElBQUksQ0FBQ3plLEtBQUs7UUFDVixPQUFPO0lBQ1g7SUFDQTRaLGFBQWE3WixJQUFJLEVBQUV3UyxTQUFTLEVBQUVDLFNBQVMsRUFBRXhTLEtBQUssRUFBRTRILElBQUksRUFBRTtRQUNsRCxJQUFJc0QsUUFBUSxJQUFJLENBQUN0RSxHQUFHLENBQUNvTCxRQUFRLENBQUNoUyxNQUFNO1FBQ3BDLElBQUlrTCxNQUFNK0csS0FBSyxJQUFJSixjQUFjM0csTUFBTTVJLEdBQUcsSUFBSTRJLE1BQU12SSxVQUFVLEVBQzFEdUksTUFBTStHLEtBQUssR0FBR0w7UUFDbEIsSUFBSSxDQUFDMUcsTUFBTTJQLE1BQU0sQ0FBQzlhLE1BQU13UyxXQUFXQyxXQUFXNUssT0FDMUMsT0FBTztRQUNYLElBQUksQ0FBQ3VXLGNBQWMsQ0FBQyxJQUFJLENBQUNuZSxLQUFLLEVBQUVBO1FBQ2hDLElBQUksQ0FBQ0EsS0FBSztRQUNWLE9BQU87SUFDWDtJQUNBMlosbUJBQW1Cc0YsT0FBTyxFQUFFO1FBQ3hCLE9BQVM7WUFDTCxJQUFJOWUsU0FBUzhlLFFBQVEvZSxVQUFVO1lBQy9CLElBQUksQ0FBQ0MsUUFDRCxPQUFPLENBQUM7WUFDWixJQUFJQSxVQUFVLElBQUksQ0FBQ3lHLEdBQUcsQ0FBQ2pFLFVBQVUsRUFBRTtnQkFDL0IsSUFBSUosT0FBTzBjLFFBQVF4YyxVQUFVO2dCQUM3QixJQUFJRixNQUNBLElBQUssSUFBSTBILElBQUksSUFBSSxDQUFDakssS0FBSyxFQUFFaUssSUFBSSxJQUFJLENBQUNyRCxHQUFHLENBQUNvTCxRQUFRLENBQUNoUixNQUFNLEVBQUVpSixJQUFLO29CQUN4RCxJQUFJLElBQUksQ0FBQ3JELEdBQUcsQ0FBQ29MLFFBQVEsQ0FBQy9ILEVBQUUsSUFBSTFILE1BQ3hCLE9BQU8wSDtnQkFDZjtnQkFDSixPQUFPLENBQUM7WUFDWjtZQUNBZ1YsVUFBVTllO1FBQ2Q7SUFDSjtJQUNBLGlFQUFpRTtJQUNqRSxtRUFBbUU7SUFDbkUwWixlQUFlOVosSUFBSSxFQUFFd1MsU0FBUyxFQUFFQyxTQUFTLEVBQUU1SyxJQUFJLEVBQUU1SCxLQUFLLEVBQUVrRSxHQUFHLEVBQUU7UUFDekQsSUFBSyxJQUFJK0YsSUFBSSxJQUFJLENBQUNqSyxLQUFLLEVBQUVpSyxJQUFJLElBQUksQ0FBQ3JELEdBQUcsQ0FBQ29MLFFBQVEsQ0FBQ2hSLE1BQU0sRUFBRWlKLElBQUs7WUFDeEQsSUFBSWtELE9BQU8sSUFBSSxDQUFDdkcsR0FBRyxDQUFDb0wsUUFBUSxDQUFDL0gsRUFBRTtZQUMvQixJQUFJa0QsZ0JBQWdCeUssY0FBYztnQkFDOUIsSUFBSXNHLFdBQVcsSUFBSSxDQUFDQSxRQUFRLENBQUNhLE9BQU8sQ0FBQ0csR0FBRyxDQUFDL1I7Z0JBQ3pDLElBQUkrUSxZQUFZLFFBQVFBLFlBQVlsZSxPQUNoQyxPQUFPO2dCQUNYLElBQUltZixVQUFVaFMsS0FBSzdLLEdBQUcsRUFBRThjO2dCQUN4Qiw4REFBOEQ7Z0JBQzlELDhEQUE4RDtnQkFDOUQsNENBQTRDO2dCQUM1QyxJQUFJQyxTQUFTLElBQUksQ0FBQ1gsUUFBUSxDQUFDUyxZQUN2QixDQUFFcGYsQ0FBQUEsS0FBS3lNLE1BQU0sSUFBSVcsS0FBS3BOLElBQUksSUFBSW9OLEtBQUtwTixJQUFJLENBQUN5TSxNQUFNLElBQUlXLEtBQUttRyxPQUFPLENBQUN2UyxTQUFTLElBQUloQixLQUFLNlYsSUFBSSxJQUNqRnpJLEtBQUs4RSxLQUFLLElBQUlKLGNBQWMyRyxjQUFjakcsV0FBV3BGLEtBQUtvRixTQUFTO2dCQUMzRSxJQUFJLENBQUM4TSxVQUFVbFMsS0FBSzBOLE1BQU0sQ0FBQzlhLE1BQU13UyxXQUFXQyxXQUFXNUssT0FBTztvQkFDMUQsSUFBSSxDQUFDdVcsY0FBYyxDQUFDLElBQUksQ0FBQ25lLEtBQUssRUFBRWlLO29CQUNoQyxJQUFJa0QsS0FBSzdLLEdBQUcsSUFBSTZjLFNBQ1osSUFBSSxDQUFDbEYsT0FBTyxHQUFHO29CQUNuQixJQUFJLENBQUNqYSxLQUFLO29CQUNWLE9BQU87Z0JBQ1gsT0FDSyxJQUFJLENBQUNxZixVQUFXRCxDQUFBQSxVQUFVLElBQUksQ0FBQ0UsZUFBZSxDQUFDblMsTUFBTXBOLE1BQU13UyxXQUFXQyxXQUFXNUssTUFBTTFELElBQUcsR0FBSTtvQkFDL0YsSUFBSSxDQUFDaWEsY0FBYyxDQUFDLElBQUksQ0FBQ25lLEtBQUssRUFBRWlLO29CQUNoQyxJQUFJLENBQUNyRCxHQUFHLENBQUNvTCxRQUFRLENBQUMsSUFBSSxDQUFDaFMsS0FBSyxDQUFDLEdBQUdvZjtvQkFDaEMsSUFBSUEsUUFBUXpjLFVBQVUsRUFBRTt3QkFDcEJ5YyxRQUFRbk4sS0FBSyxHQUFHTDt3QkFDaEJ3TixRQUFRMUcsY0FBYyxDQUFDOVEsTUFBTTFELE1BQU07d0JBQ25Da2IsUUFBUW5OLEtBQUssR0FBR1A7b0JBQ3BCO29CQUNBLElBQUksQ0FBQ3VJLE9BQU8sR0FBRztvQkFDZixJQUFJLENBQUNqYSxLQUFLO29CQUNWLE9BQU87Z0JBQ1g7Z0JBQ0E7WUFDSjtRQUNKO1FBQ0EsT0FBTztJQUNYO0lBQ0EsZ0VBQWdFO0lBQ2hFLDZDQUE2QztJQUM3Q3NmLGdCQUFnQm5TLElBQUksRUFBRXBOLElBQUksRUFBRXdTLFNBQVMsRUFBRUMsU0FBUyxFQUFFNUssSUFBSSxFQUFFMUQsR0FBRyxFQUFFO1FBQ3pELElBQUlpSixLQUFLOEUsS0FBSyxJQUFJbFMsS0FBSzBiLE1BQU0sSUFBSSxDQUFDdE8sS0FBSzZFLFFBQVEsQ0FBQ2hSLE1BQU0sSUFDbEQsQ0FBQ21NLEtBQUtwTixJQUFJLENBQUN3TixPQUFPLENBQUMrSSxFQUFFLENBQUN2VyxLQUFLd04sT0FBTyxLQUNsQyxDQUFDaUwsY0FBY2pHLFdBQVdwRixLQUFLb0YsU0FBUyxLQUFLLENBQUNDLFVBQVU4RCxFQUFFLENBQUNuSixLQUFLcUYsU0FBUyxHQUN6RSxPQUFPO1FBQ1gsSUFBSStNLFVBQVUzSCxhQUFhYixNQUFNLENBQUMsSUFBSSxDQUFDblEsR0FBRyxFQUFFN0csTUFBTXdTLFdBQVdDLFdBQVc1SyxNQUFNMUQ7UUFDOUUsSUFBSXFiLFFBQVE1YyxVQUFVLEVBQUU7WUFDcEI0YyxRQUFRdk4sUUFBUSxHQUFHN0UsS0FBSzZFLFFBQVE7WUFDaEM3RSxLQUFLNkUsUUFBUSxHQUFHLEVBQUU7WUFDbEIsS0FBSyxJQUFJd04sTUFBTUQsUUFBUXZOLFFBQVEsQ0FDM0J3TixHQUFHcmYsTUFBTSxHQUFHb2Y7UUFDcEI7UUFDQXBTLEtBQUt5RixPQUFPO1FBQ1osT0FBTzJNO0lBQ1g7SUFDQSxnREFBZ0Q7SUFDaER6RixRQUFRL1osSUFBSSxFQUFFd1MsU0FBUyxFQUFFQyxTQUFTLEVBQUU1SyxJQUFJLEVBQUUxRCxHQUFHLEVBQUU7UUFDM0MsSUFBSTNCLE9BQU9xVixhQUFhYixNQUFNLENBQUMsSUFBSSxDQUFDblEsR0FBRyxFQUFFN0csTUFBTXdTLFdBQVdDLFdBQVc1SyxNQUFNMUQ7UUFDM0UsSUFBSTNCLEtBQUtJLFVBQVUsRUFDZkosS0FBS21XLGNBQWMsQ0FBQzlRLE1BQU0xRCxNQUFNO1FBQ3BDLElBQUksQ0FBQzBDLEdBQUcsQ0FBQ29MLFFBQVEsQ0FBQ29NLE1BQU0sQ0FBQyxJQUFJLENBQUNwZSxLQUFLLElBQUksR0FBR3VDO1FBQzFDLElBQUksQ0FBQzBYLE9BQU8sR0FBRztJQUNuQjtJQUNBVCxZQUFZckgsTUFBTSxFQUFFdkssSUFBSSxFQUFFMUQsR0FBRyxFQUFFO1FBQzNCLElBQUlpSixPQUFPLElBQUksQ0FBQ25OLEtBQUssR0FBRyxJQUFJLENBQUM0RyxHQUFHLENBQUNvTCxRQUFRLENBQUNoUixNQUFNLEdBQUcsSUFBSSxDQUFDNEYsR0FBRyxDQUFDb0wsUUFBUSxDQUFDLElBQUksQ0FBQ2hTLEtBQUssQ0FBQyxHQUFHO1FBQ25GLElBQUltTixRQUFRQSxLQUFLK0UsYUFBYSxDQUFDQyxXQUMxQkEsQ0FBQUEsVUFBVWhGLEtBQUtnRixNQUFNLElBQUksQ0FBQ2hGLEtBQUtnRixNQUFNLENBQUNrRCxJQUFJLENBQUNTLEtBQUssQ0FBQzVWLFVBQVUsR0FBRztZQUMvRCxJQUFJLENBQUNGLEtBQUs7UUFDZCxPQUNLO1lBQ0QsSUFBSXVDLE9BQU8sSUFBSXFSLGVBQWUsSUFBSSxDQUFDaE4sR0FBRyxFQUFFdUwsUUFBUXZLLE1BQU0xRDtZQUN0RCxJQUFJLENBQUMwQyxHQUFHLENBQUNvTCxRQUFRLENBQUNvTSxNQUFNLENBQUMsSUFBSSxDQUFDcGUsS0FBSyxJQUFJLEdBQUd1QztZQUMxQyxJQUFJLENBQUMwWCxPQUFPLEdBQUc7UUFDbkI7SUFDSjtJQUNBLHVEQUF1RDtJQUN2RCxtQkFBbUI7SUFDbkJGLG9CQUFvQjtRQUNoQixJQUFJMU0sWUFBWSxJQUFJLENBQUN6RyxHQUFHLENBQUNvTCxRQUFRLENBQUMsSUFBSSxDQUFDaFMsS0FBSyxHQUFHLEVBQUUsRUFBRUcsU0FBUyxJQUFJLENBQUN5RyxHQUFHO1FBQ3BFLE1BQU95RyxxQkFBcUJ5SixhQUFjO1lBQ3RDM1csU0FBU2tOO1lBQ1RBLFlBQVlsTixPQUFPNlIsUUFBUSxDQUFDN1IsT0FBTzZSLFFBQVEsQ0FBQ2hSLE1BQU0sR0FBRyxFQUFFO1FBQzNEO1FBQ0EsSUFBSSxDQUFDcU0sYUFBYSxrQkFBa0I7UUFDaEMsQ0FBRUEsQ0FBQUEscUJBQXFCNkssWUFBVyxLQUNsQyxNQUFNdFcsSUFBSSxDQUFDeUwsVUFBVXROLElBQUksQ0FBQzZWLElBQUksS0FDN0IsSUFBSSxDQUFDaE8sSUFBSSxDQUFDNlgscUJBQXFCLElBQUksTUFBTTdkLElBQUksQ0FBQ3lMLFVBQVV0TixJQUFJLENBQUM2VixJQUFJLEdBQUk7WUFDdEUscUZBQXFGO1lBQ3JGLElBQUksQ0FBQ25RLFVBQVVGLE1BQUssS0FBTThILGFBQWFBLFVBQVUvSyxHQUFHLENBQUNSLGVBQWUsSUFBSSxTQUNwRSxJQUFJLENBQUM0ZCxXQUFXLENBQUMsT0FBT3ZmO1lBQzVCLElBQUksQ0FBQ3VmLFdBQVcsQ0FBQyxNQUFNLElBQUksQ0FBQzlZLEdBQUc7UUFDbkM7SUFDSjtJQUNBOFksWUFBWTdkLFFBQVEsRUFBRTFCLE1BQU0sRUFBRTtRQUMxQixJQUFJQSxVQUFVLElBQUksQ0FBQ3lHLEdBQUcsSUFBSSxJQUFJLENBQUM1RyxLQUFLLEdBQUdHLE9BQU82UixRQUFRLENBQUNoUixNQUFNLElBQUliLE9BQU82UixRQUFRLENBQUMsSUFBSSxDQUFDaFMsS0FBSyxDQUFDLENBQUN5UyxXQUFXLENBQUM1USxXQUFXO1lBQ2hILElBQUksQ0FBQzdCLEtBQUs7UUFDZCxPQUNLO1lBQ0QsSUFBSXNDLE1BQU0xQixTQUFTc1YsYUFBYSxDQUFDclU7WUFDakMsSUFBSUEsWUFBWSxPQUFPO2dCQUNuQlMsSUFBSXFkLFNBQVMsR0FBRztnQkFDaEJyZCxJQUFJc2QsR0FBRyxHQUFHO1lBQ2Q7WUFDQSxJQUFJL2QsWUFBWSxNQUNaUyxJQUFJcWQsU0FBUyxHQUFHO1lBQ3BCLElBQUlFLE9BQU8sSUFBSWxNLHFCQUFxQixJQUFJLENBQUMvTSxHQUFHLEVBQUUsRUFBRSxFQUFFdEUsS0FBSztZQUN2RCxJQUFJbkMsVUFBVSxJQUFJLENBQUN5RyxHQUFHLEVBQ2xCekcsT0FBTzZSLFFBQVEsQ0FBQ3BJLElBQUksQ0FBQ2lXO2lCQUVyQjFmLE9BQU82UixRQUFRLENBQUNvTSxNQUFNLENBQUMsSUFBSSxDQUFDcGUsS0FBSyxJQUFJLEdBQUc2ZjtZQUM1QyxJQUFJLENBQUM1RixPQUFPLEdBQUc7UUFDbkI7SUFDSjtJQUNBeUUsU0FBUzNlLElBQUksRUFBRTtRQUNYLE9BQU8sSUFBSSxDQUFDa2UsSUFBSSxJQUFLbGUsQ0FBQUEsUUFBUSxJQUFJLENBQUNrZSxJQUFJLElBQUlsZSxLQUFLTSxRQUFRLElBQUksS0FBS04sS0FBS3lKLFFBQVEsQ0FBQyxJQUFJLENBQUN5VSxJQUFJLENBQUMvZCxVQUFVO0lBQ3RHO0FBQ0o7QUFDQSxrRUFBa0U7QUFDbEUsc0VBQXNFO0FBQ3RFLHFFQUFxRTtBQUNyRSw2REFBNkQ7QUFDN0QsWUFBWTtBQUNaLFNBQVNnZSxTQUFTNEIsSUFBSSxFQUFFQyxVQUFVO0lBQzlCLElBQUlDLFVBQVVELFlBQVlFLFFBQVFELFFBQVFoTyxRQUFRLENBQUNoUixNQUFNO0lBQ3pELElBQUlrZixLQUFLSixLQUFLeEcsVUFBVSxFQUFFeUYsVUFBVSxJQUFJb0IsS0FBS3RCLFVBQVUsRUFBRTtJQUN6RHVCLE9BQU8sTUFBT0YsS0FBSyxFQUFHO1FBQ2xCLElBQUkzZDtRQUNKLE9BQVM7WUFDTCxJQUFJMGQsT0FBTztnQkFDUCxJQUFJOVMsT0FBTzZTLFFBQVFoTyxRQUFRLENBQUNpTyxRQUFRLEVBQUU7Z0JBQ3RDLElBQUk5UyxnQkFBZ0IySixjQUFjO29CQUM5QmtKLFVBQVU3UztvQkFDVjhTLFFBQVE5UyxLQUFLNkUsUUFBUSxDQUFDaFIsTUFBTTtnQkFDaEMsT0FDSztvQkFDRHVCLE9BQU80SztvQkFDUDhTO29CQUNBO2dCQUNKO1lBQ0osT0FDSyxJQUFJRCxXQUFXRCxZQUFZO2dCQUM1QixNQUFNSztZQUNWLE9BQ0s7Z0JBQ0QsUUFBUTtnQkFDUkgsUUFBUUQsUUFBUTdmLE1BQU0sQ0FBQzZSLFFBQVEsQ0FBQzBMLE9BQU8sQ0FBQ3NDO2dCQUN4Q0EsVUFBVUEsUUFBUTdmLE1BQU07WUFDNUI7UUFDSjtRQUNBLElBQUlKLE9BQU93QyxLQUFLeEMsSUFBSTtRQUNwQixJQUFJLENBQUNBLE1BQ0Q7UUFDSixJQUFJQSxRQUFRK2YsS0FBSzVVLEtBQUssQ0FBQ2dWLEtBQUssSUFDeEI7UUFDSixFQUFFQTtRQUNGbkIsUUFBUXNCLEdBQUcsQ0FBQzlkLE1BQU0yZDtRQUNsQnJCLFFBQVFqVixJQUFJLENBQUNySDtJQUNqQjtJQUNBLE9BQU87UUFBRXZDLE9BQU9rZ0I7UUFBSW5CO1FBQVNGLFNBQVNBLFFBQVF5QixPQUFPO0lBQUc7QUFDNUQ7QUFDQSxTQUFTQyxZQUFZeEMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3JCLE9BQU9ELEVBQUUxSSxJQUFJLENBQUNsTyxJQUFJLEdBQUc2VyxFQUFFM0ksSUFBSSxDQUFDbE8sSUFBSTtBQUNwQztBQUNBLHNFQUFzRTtBQUN0RSxxRUFBcUU7QUFDckUscUVBQXFFO0FBQ3JFLDhEQUE4RDtBQUM5RCxTQUFTK1IsU0FBUy9ZLE1BQU0sRUFBRThjLElBQUksRUFBRXVELFFBQVEsRUFBRUMsTUFBTTtJQUM1QyxJQUFJQyxTQUFTekQsS0FBS3lELE1BQU0sQ0FBQ3ZnQixTQUFTOEIsU0FBUztJQUMzQyxnRUFBZ0U7SUFDaEUsSUFBSXllLE9BQU8xZixNQUFNLElBQUksR0FBRztRQUNwQixJQUFLLElBQUlpSixJQUFJLEdBQUdBLElBQUk5SixPQUFPbVosVUFBVSxFQUFFclAsSUFBSztZQUN4QyxJQUFJaUIsUUFBUS9LLE9BQU8rSyxLQUFLLENBQUNqQjtZQUN6QndXLE9BQU92VixPQUFPd1YsUUFBUXpELEtBQUswRCxRQUFRLENBQUMxZSxRQUFRaUosUUFBUWpCO1lBQ3BEaEksVUFBVWlKLE1BQU14SixRQUFRO1FBQzVCO1FBQ0E7SUFDSjtJQUNBLElBQUlrZixZQUFZLEdBQUd2UixTQUFTLEVBQUUsRUFBRXdSLFdBQVc7SUFDM0MsSUFBSyxJQUFJQyxjQUFjLElBQUs7UUFDeEIsSUFBSTNPLFFBQVE0TztRQUNaLE1BQU9ILFlBQVlGLE9BQU8xZixNQUFNLElBQUkwZixNQUFNLENBQUNFLFVBQVUsQ0FBQ2xnQixFQUFFLElBQUl1QixPQUFRO1lBQ2hFLElBQUlrTCxPQUFPdVQsTUFBTSxDQUFDRSxZQUFZO1lBQzlCLElBQUl6VCxLQUFLZ0YsTUFBTSxFQUFFO2dCQUNiLElBQUksQ0FBQ0EsUUFDREEsU0FBU2hGO3FCQUVULENBQUM0VCxXQUFZQSxDQUFBQSxVQUFVO29CQUFDNU87aUJBQU8sR0FBR3ZJLElBQUksQ0FBQ3VEO1lBQy9DO1FBQ0o7UUFDQSxJQUFJZ0YsUUFBUTtZQUNSLElBQUk0TyxTQUFTO2dCQUNUQSxRQUFRQyxJQUFJLENBQUNUO2dCQUNiLElBQUssSUFBSXRXLElBQUksR0FBR0EsSUFBSThXLFFBQVEvZixNQUFNLEVBQUVpSixJQUNoQ3VXLFNBQVNPLE9BQU8sQ0FBQzlXLEVBQUUsRUFBRTZXLGFBQWEsQ0FBQyxDQUFDRDtZQUM1QyxPQUNLO2dCQUNETCxTQUFTck8sUUFBUTJPLGFBQWEsQ0FBQyxDQUFDRDtZQUNwQztRQUNKO1FBQ0EsSUFBSTNWLE9BQU9sTDtRQUNYLElBQUk2Z0IsVUFBVTtZQUNWN2dCLFFBQVEsQ0FBQztZQUNUa0wsUUFBUTJWO1lBQ1JBLFdBQVc7UUFDZixPQUNLLElBQUlDLGNBQWMzZ0IsT0FBT21aLFVBQVUsRUFBRTtZQUN0Q3RaLFFBQVE4Z0I7WUFDUjVWLFFBQVEvSyxPQUFPK0ssS0FBSyxDQUFDNFY7UUFDekIsT0FDSztZQUNEO1FBQ0o7UUFDQSxJQUFLLElBQUk3VyxJQUFJLEdBQUdBLElBQUlvRixPQUFPck8sTUFBTSxFQUFFaUosSUFDL0IsSUFBSW9GLE1BQU0sQ0FBQ3BGLEVBQUUsQ0FBQ3ZKLEVBQUUsSUFBSXVCLFFBQ2hCb04sT0FBTytPLE1BQU0sQ0FBQ25VLEtBQUs7UUFDM0IsTUFBTzJXLFlBQVlGLE9BQU8xZixNQUFNLElBQUkwZixNQUFNLENBQUNFLFVBQVUsQ0FBQ25nQixJQUFJLElBQUl3QixVQUFVeWUsTUFBTSxDQUFDRSxVQUFVLENBQUNsZ0IsRUFBRSxHQUFHdUIsT0FDM0ZvTixPQUFPekYsSUFBSSxDQUFDOFcsTUFBTSxDQUFDRSxZQUFZO1FBQ25DLElBQUl0USxNQUFNck8sU0FBU2lKLE1BQU14SixRQUFRO1FBQ2pDLElBQUl3SixNQUFNc0IsTUFBTSxFQUFFO1lBQ2QsSUFBSXlVLFFBQVEzUTtZQUNaLElBQUlzUSxZQUFZRixPQUFPMWYsTUFBTSxJQUFJMGYsTUFBTSxDQUFDRSxVQUFVLENBQUNuZ0IsSUFBSSxHQUFHd2dCLE9BQ3REQSxRQUFRUCxNQUFNLENBQUNFLFVBQVUsQ0FBQ25nQixJQUFJO1lBQ2xDLElBQUssSUFBSXdKLElBQUksR0FBR0EsSUFBSW9GLE9BQU9yTyxNQUFNLEVBQUVpSixJQUMvQixJQUFJb0YsTUFBTSxDQUFDcEYsRUFBRSxDQUFDdkosRUFBRSxHQUFHdWdCLE9BQ2ZBLFFBQVE1UixNQUFNLENBQUNwRixFQUFFLENBQUN2SixFQUFFO1lBQzVCLElBQUl1Z0IsUUFBUTNRLEtBQUs7Z0JBQ2J1USxXQUFXM1YsTUFBTThRLEdBQUcsQ0FBQ2lGLFFBQVFoZjtnQkFDN0JpSixRQUFRQSxNQUFNOFEsR0FBRyxDQUFDLEdBQUdpRixRQUFRaGY7Z0JBQzdCcU8sTUFBTTJRO2dCQUNOamhCLFFBQVEsQ0FBQztZQUNiO1FBQ0osT0FDSztZQUNELE1BQU80Z0IsWUFBWUYsT0FBTzFmLE1BQU0sSUFBSTBmLE1BQU0sQ0FBQ0UsVUFBVSxDQUFDbGdCLEVBQUUsR0FBRzRQLElBQ3ZEc1E7UUFDUjtRQUNBLElBQUlyTyxZQUFZckgsTUFBTXlSLFFBQVEsSUFBSSxDQUFDelIsTUFBTXVOLE1BQU0sR0FBR3BKLE9BQU9rTyxNQUFNLENBQUMyRCxDQUFBQSxJQUFLLENBQUNBLEVBQUVsSyxNQUFNLElBQUkzSCxPQUFPbUksS0FBSztRQUM5RmlKLE9BQU92VixPQUFPcUgsV0FBVzBLLEtBQUswRCxRQUFRLENBQUMxZSxRQUFRaUosUUFBUWxMO1FBQ3ZEaUMsU0FBU3FPO0lBQ2I7QUFDSjtBQUNBLDREQUE0RDtBQUM1RCxxQ0FBcUM7QUFDckMsU0FBUzhKLFNBQVM5WCxHQUFHO0lBQ2pCLElBQUlBLElBQUlULFFBQVEsSUFBSSxRQUFRUyxJQUFJVCxRQUFRLElBQUksTUFBTTtRQUM5QyxJQUFJc2YsU0FBUzdlLElBQUk2RCxLQUFLLENBQUMyWCxPQUFPO1FBQzlCeGIsSUFBSTZELEtBQUssQ0FBQzJYLE9BQU8sR0FBR3FELFNBQVM7UUFDN0JDLE9BQU90WSxnQkFBZ0IsQ0FBQ3hHLEtBQUsrZSxTQUFTO1FBQ3RDL2UsSUFBSTZELEtBQUssQ0FBQzJYLE9BQU8sR0FBR3FEO0lBQ3hCO0FBQ0o7QUFDQSxrRUFBa0U7QUFDbEUsU0FBUzFHLG1CQUFtQnFGLElBQUksRUFBRWxLLElBQUksRUFBRW5WLElBQUksRUFBRUMsRUFBRTtJQUM1QyxJQUFLLElBQUl1SixJQUFJLEdBQUcvRixNQUFNLEdBQUcrRixJQUFJNlYsS0FBS3hHLFVBQVUsSUFBSXBWLE9BQU94RCxJQUFLO1FBQ3hELElBQUl3SyxRQUFRNFUsS0FBSzVVLEtBQUssQ0FBQ2pCLE1BQU1xWCxhQUFhcGQ7UUFDMUNBLE9BQU9nSCxNQUFNeEosUUFBUTtRQUNyQixJQUFJLENBQUN3SixNQUFNc0IsTUFBTSxFQUNiO1FBQ0osSUFBSStVLE1BQU1yVyxNQUFNMEssSUFBSTtRQUNwQixNQUFPM0wsSUFBSTZWLEtBQUt4RyxVQUFVLENBQUU7WUFDeEIsSUFBSW5NLE9BQU8yUyxLQUFLNVUsS0FBSyxDQUFDakI7WUFDdEIvRixPQUFPaUosS0FBS3pMLFFBQVE7WUFDcEIsSUFBSSxDQUFDeUwsS0FBS1gsTUFBTSxFQUNaO1lBQ0orVSxPQUFPcFUsS0FBS3lJLElBQUk7UUFDcEI7UUFDQSxJQUFJMVIsT0FBT3pELE1BQU07WUFDYixJQUFJeUQsT0FBT3hELE1BQU02Z0IsSUFBSS9KLEtBQUssQ0FBQzlXLEtBQUtrVixLQUFLNVUsTUFBTSxHQUFHc2dCLFlBQVk1Z0IsS0FBSzRnQixlQUFlMUwsTUFDMUUsT0FBT2xWLEtBQUtrVixLQUFLNVUsTUFBTTtZQUMzQixJQUFJeWQsUUFBUTZDLGFBQWE1Z0IsS0FBSzZnQixJQUFJQyxXQUFXLENBQUM1TCxNQUFNbFYsS0FBSzRnQixhQUFhLEtBQUssQ0FBQztZQUM1RSxJQUFJN0MsU0FBUyxLQUFLQSxRQUFRN0ksS0FBSzVVLE1BQU0sR0FBR3NnQixjQUFjN2dCLE1BQ2xELE9BQU82Z0IsYUFBYTdDO1lBQ3hCLElBQUloZSxRQUFRQyxNQUFNNmdCLElBQUl2Z0IsTUFBTSxJQUFJLEtBQU00VSxLQUFLNVUsTUFBTSxHQUFJc2dCLGNBQ2pEQyxJQUFJL0osS0FBSyxDQUFDOVcsS0FBSzRnQixZQUFZNWdCLEtBQUs0Z0IsYUFBYTFMLEtBQUs1VSxNQUFNLEtBQUs0VSxNQUM3RCxPQUFPbFY7UUFDZjtJQUNKO0lBQ0EsT0FBTyxDQUFDO0FBQ1o7QUFDQSxtRUFBbUU7QUFDbkUsc0VBQXNFO0FBQ3RFLGlFQUFpRTtBQUNqRSw2REFBNkQ7QUFDN0Qsc0RBQXNEO0FBQ3RELFNBQVNpWCxhQUFhRCxLQUFLLEVBQUVqWCxJQUFJLEVBQUVDLEVBQUUsRUFBRWtILElBQUksRUFBRTZaLFdBQVc7SUFDcEQsSUFBSXRRLFNBQVMsRUFBRTtJQUNmLElBQUssSUFBSWxILElBQUksR0FBRzdJLE1BQU0sR0FBRzZJLElBQUl5TixNQUFNMVcsTUFBTSxFQUFFaUosSUFBSztRQUM1QyxJQUFJaUIsUUFBUXdNLEtBQUssQ0FBQ3pOLEVBQUUsRUFBRW9HLFFBQVFqUCxLQUFLa1AsTUFBTWxQLE9BQU84SixNQUFNc0MsSUFBSTtRQUMxRCxJQUFJNkMsU0FBUzNQLE1BQU00UCxPQUFPN1AsTUFBTTtZQUM1QjBRLE9BQU92SCxJQUFJLENBQUNzQjtRQUNoQixPQUNLO1lBQ0QsSUFBSW1GLFFBQVE1UCxNQUNSMFEsT0FBT3ZILElBQUksQ0FBQ3NCLE1BQU1zTSxLQUFLLENBQUMsR0FBRy9XLE9BQU80UCxPQUFPekk7WUFDN0MsSUFBSTZaLGFBQWE7Z0JBQ2J0USxPQUFPdkgsSUFBSSxDQUFDNlg7Z0JBQ1pBLGNBQWNqWDtZQUNsQjtZQUNBLElBQUk4RixNQUFNNVAsSUFDTnlRLE9BQU92SCxJQUFJLENBQUNzQixNQUFNc00sS0FBSyxDQUFDOVcsS0FBSzJQLE9BQU9uRixNQUFNc0MsSUFBSSxFQUFFNUY7UUFDeEQ7SUFDSjtJQUNBLE9BQU91SjtBQUNYO0FBRUEsU0FBU3VRLGlCQUFpQjlaLElBQUksRUFBRStaLFNBQVMsSUFBSTtJQUN6QyxJQUFJOWUsU0FBUytFLEtBQUsrSSxpQkFBaUIsSUFBSWpOLE1BQU1rRSxLQUFLMEYsS0FBSyxDQUFDNUosR0FBRztJQUMzRCxJQUFJLENBQUNiLE9BQU9DLFNBQVMsRUFDakIsT0FBTztJQUNYLElBQUl1SixjQUFjekUsS0FBS29FLE9BQU8sQ0FBQ0ssV0FBVyxDQUFDeEosT0FBT0MsU0FBUyxHQUFHOGUsV0FBV3ZWLGVBQWVBLFlBQVltQixJQUFJLElBQUk7SUFDNUcsSUFBSWdILE9BQU81TSxLQUFLb0UsT0FBTyxDQUFDQyxVQUFVLENBQUNwSixPQUFPQyxTQUFTLEVBQUVELE9BQU9FLFdBQVcsRUFBRTtJQUN6RSxJQUFJeVIsT0FBTyxHQUNQLE9BQU87SUFDWCxJQUFJdkUsUUFBUXZNLElBQUltTCxPQUFPLENBQUMyRixPQUFPRCxRQUFROUU7SUFDdkMsSUFBSTdNLG1CQUFtQkMsU0FBUztRQUM1QjBSLFNBQVNDO1FBQ1QsTUFBT25JLGVBQWUsQ0FBQ0EsWUFBWXRNLElBQUksQ0FDbkNzTSxjQUFjQSxZQUFZbE0sTUFBTTtRQUNwQyxJQUFJMGhCLGtCQUFrQnhWLFlBQVl0TSxJQUFJO1FBQ3RDLElBQUlzTSxlQUFld1YsZ0JBQWdCcEcsTUFBTSxJQUFJcGMsNERBQWFBLENBQUN5aUIsWUFBWSxDQUFDRCxvQkFBb0J4VixZQUFZbE0sTUFBTSxJQUN2RyxDQUFFMGhCLENBQUFBLGdCQUFnQmxGLFFBQVEsSUFBSXhhLFNBQVNVLE9BQU9DLFNBQVMsRUFBRUQsT0FBT0UsV0FBVyxFQUFFc0osWUFBWS9KLEdBQUcsSUFBSTtZQUNuRyxJQUFJNEIsTUFBTW1JLFlBQVlDLFNBQVM7WUFDL0JtRCxZQUFZLElBQUlwUSw0REFBYUEsQ0FBQ21WLFFBQVF0USxNQUFNK0wsUUFBUXZNLElBQUltTCxPQUFPLENBQUMzSztRQUNwRTtJQUNKLE9BQ0s7UUFDRCxJQUFJckIsa0JBQWtCK0UsS0FBS3RGLEdBQUcsQ0FBQzJGLGFBQWEsQ0FBQzFCLFdBQVcsQ0FBQ2hILFNBQVMsSUFBSXNELE9BQU9rZixVQUFVLEdBQUcsR0FBRztZQUN6RixJQUFJMWQsTUFBTW1RLE1BQU10TCxNQUFNc0w7WUFDdEIsSUFBSyxJQUFJdkssSUFBSSxHQUFHQSxJQUFJcEgsT0FBT2tmLFVBQVUsRUFBRTlYLElBQUs7Z0JBQ3hDLElBQUl0SixRQUFRa0MsT0FBT21mLFVBQVUsQ0FBQy9YO2dCQUM5QjVGLE1BQU1ELEtBQUtDLEdBQUcsQ0FBQ0EsS0FBS3VELEtBQUtvRSxPQUFPLENBQUNDLFVBQVUsQ0FBQ3RMLE1BQU02RCxjQUFjLEVBQUU3RCxNQUFNOEQsV0FBVyxFQUFFO2dCQUNyRnlFLE1BQU05RSxLQUFLOEUsR0FBRyxDQUFDQSxLQUFLdEIsS0FBS29FLE9BQU8sQ0FBQ0MsVUFBVSxDQUFDdEwsTUFBTXNoQixZQUFZLEVBQUV0aEIsTUFBTXVoQixTQUFTLEVBQUUsQ0FBQztZQUN0RjtZQUNBLElBQUk3ZCxNQUFNLEdBQ04sT0FBTztZQUNYLENBQUNrUSxRQUFRQyxLQUFLLEdBQUd0TCxPQUFPdEIsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQzhFLE1BQU0sR0FBRztnQkFBQ3JMO2dCQUFLN0U7YUFBSSxHQUFHO2dCQUFDQTtnQkFBSzZFO2FBQUk7WUFDN0UrRyxRQUFRdk0sSUFBSW1MLE9BQU8sQ0FBQzJGO1FBQ3hCLE9BQ0s7WUFDREQsU0FBUzNNLEtBQUtvRSxPQUFPLENBQUNDLFVBQVUsQ0FBQ3BKLE9BQU9HLFVBQVUsRUFBRUgsT0FBT0ksWUFBWSxFQUFFO1FBQzdFO1FBQ0EsSUFBSXNSLFNBQVMsR0FDVCxPQUFPO0lBQ2Y7SUFDQSxJQUFJNE4sVUFBVXplLElBQUltTCxPQUFPLENBQUMwRjtJQUMxQixJQUFJLENBQUM5RSxXQUFXO1FBQ1osSUFBSTFELE9BQU80VixVQUFVLGFBQWMvWixLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUyxDQUFDK0UsSUFBSSxHQUFHdkUsTUFBTS9MLEdBQUcsSUFBSSxDQUFDMGQsV0FBWSxJQUFJLENBQUM7UUFDOUZuUyxZQUFZMlMsaUJBQWlCeGEsTUFBTXVhLFNBQVNsUyxPQUFPbEU7SUFDdkQ7SUFDQSxPQUFPMEQ7QUFDWDtBQUNBLFNBQVM0UyxvQkFBb0J6YSxJQUFJO0lBQzdCLE9BQU9BLEtBQUswYSxRQUFRLEdBQUcxYSxLQUFLMmEsUUFBUSxLQUNoQ0MsYUFBYTVhLFNBQVNoSCxTQUFTZ0QsYUFBYSxJQUFJaEQsU0FBU2dELGFBQWEsQ0FBQzRGLFFBQVEsQ0FBQzVCLEtBQUt0RixHQUFHO0FBQ2hHO0FBQ0EsU0FBU21nQixlQUFlN2EsSUFBSSxFQUFFNk0sUUFBUSxLQUFLO0lBQ3ZDLElBQUlqRixNQUFNNUgsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVM7SUFDOUJpVCxrQkFBa0I5YSxNQUFNNEg7SUFDeEIsSUFBSSxDQUFDNlMsb0JBQW9CemEsT0FDckI7SUFDSixnRUFBZ0U7SUFDaEUsaUVBQWlFO0lBQ2pFLGdDQUFnQztJQUNoQyxJQUFJLENBQUM2TSxTQUFTN00sS0FBSzBTLEtBQUssQ0FBQ3FJLFNBQVMsSUFBSS9hLEtBQUswUyxLQUFLLENBQUNxSSxTQUFTLENBQUNDLFlBQVksSUFBSXJkLFFBQVE7UUFDL0UsSUFBSTFDLFNBQVMrRSxLQUFLK0ksaUJBQWlCLElBQUlrUyxTQUFTamIsS0FBS2tiLFdBQVcsQ0FBQ0MsZ0JBQWdCO1FBQ2pGLElBQUlsZ0IsT0FBT0csVUFBVSxJQUFJNmYsT0FBTzdmLFVBQVUsSUFDdEM3QixxQkFBcUIwQixPQUFPRyxVQUFVLEVBQUVILE9BQU9JLFlBQVksRUFBRTRmLE9BQU83ZixVQUFVLEVBQUU2ZixPQUFPNWYsWUFBWSxHQUFHO1lBQ3RHMkUsS0FBSzBTLEtBQUssQ0FBQ3FJLFNBQVMsQ0FBQ0ssb0JBQW9CLEdBQUc7WUFDNUNwYixLQUFLa2IsV0FBVyxDQUFDRyxlQUFlO1lBQ2hDO1FBQ0o7SUFDSjtJQUNBcmIsS0FBS2tiLFdBQVcsQ0FBQ0ksbUJBQW1CO0lBQ3BDLElBQUl0YixLQUFLdWIsYUFBYSxFQUFFO1FBQ3BCQyxvQkFBb0J4YjtJQUN4QixPQUNLO1FBQ0QsSUFBSSxFQUFFMk0sTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBR2hGLEtBQUs2VCxtQkFBbUJDO1FBQy9DLElBQUlDLGlDQUFpQyxDQUFFL1QsQ0FBQUEsZUFBZXBRLDREQUFZLEdBQUk7WUFDbEUsSUFBSSxDQUFDb1EsSUFBSUcsS0FBSyxDQUFDeFAsTUFBTSxDQUFDMk8sYUFBYSxFQUMvQnVVLG9CQUFvQkcsd0JBQXdCNWIsTUFBTTRILElBQUkvTyxJQUFJO1lBQzlELElBQUksQ0FBQytPLElBQUkrSSxLQUFLLElBQUksQ0FBQy9JLElBQUlHLEtBQUssQ0FBQ3hQLE1BQU0sQ0FBQzJPLGFBQWEsRUFDN0N3VSxrQkFBa0JFLHdCQUF3QjViLE1BQU00SCxJQUFJOU8sRUFBRTtRQUM5RDtRQUNBa0gsS0FBS29FLE9BQU8sQ0FBQ3NJLFlBQVksQ0FBQ0MsUUFBUUMsTUFBTTVNLE1BQU02TTtRQUM5QyxJQUFJOE8sK0JBQStCO1lBQy9CLElBQUlGLG1CQUNBSSxjQUFjSjtZQUNsQixJQUFJQyxpQkFDQUcsY0FBY0g7UUFDdEI7UUFDQSxJQUFJOVQsSUFBSWtVLE9BQU8sRUFBRTtZQUNiOWIsS0FBS3RGLEdBQUcsQ0FBQzhULFNBQVMsQ0FBQ21GLE1BQU0sQ0FBQztRQUM5QixPQUNLO1lBQ0QzVCxLQUFLdEYsR0FBRyxDQUFDOFQsU0FBUyxDQUFDQyxHQUFHLENBQUM7WUFDdkIsSUFBSSx1QkFBdUJ6VixVQUN2QitpQiw2QkFBNkIvYjtRQUNyQztJQUNKO0lBQ0FBLEtBQUtrYixXQUFXLENBQUNHLGVBQWU7SUFDaENyYixLQUFLa2IsV0FBVyxDQUFDYyxnQkFBZ0I7QUFDckM7QUFDQSxxRUFBcUU7QUFDckUsOERBQThEO0FBQzlELDZEQUE2RDtBQUM3RCxNQUFNTCxnQ0FBZ0M5ZCxVQUFVRixVQUFVQyxpQkFBaUI7QUFDM0UsU0FBU2dlLHdCQUF3QjViLElBQUksRUFBRTFELEdBQUc7SUFDdEMsSUFBSSxFQUFFbkUsSUFBSSxFQUFFa0MsTUFBTSxFQUFFLEdBQUcyRixLQUFLb0UsT0FBTyxDQUFDc0MsVUFBVSxDQUFDcEssS0FBSztJQUNwRCxJQUFJOEssUUFBUS9NLFNBQVNsQyxLQUFLZ0MsVUFBVSxDQUFDZixNQUFNLEdBQUdqQixLQUFLZ0MsVUFBVSxDQUFDRSxPQUFPLEdBQUc7SUFDeEUsSUFBSXdLLFNBQVN4SyxTQUFTbEMsS0FBS2dDLFVBQVUsQ0FBQ0UsU0FBUyxFQUFFLEdBQUc7SUFDcEQsSUFBSXdELFVBQVV1SixTQUFTQSxNQUFNbE4sZUFBZSxJQUFJLFNBQzVDLE9BQU8raEIsWUFBWTdVO0lBQ3ZCLElBQUksQ0FBQyxDQUFDQSxTQUFTQSxNQUFNbE4sZUFBZSxJQUFJLE9BQU0sS0FDekMsRUFBQzJLLFVBQVVBLE9BQU8zSyxlQUFlLElBQUksT0FBTSxHQUFJO1FBQ2hELElBQUlrTixPQUNBLE9BQU82VSxZQUFZN1U7YUFDbEIsSUFBSXZDLFFBQ0wsT0FBT29YLFlBQVlwWDtJQUMzQjtBQUNKO0FBQ0EsU0FBU29YLFlBQVluWCxPQUFPO0lBQ3hCQSxRQUFRNUssZUFBZSxHQUFHO0lBQzFCLElBQUkyRCxVQUFVaUgsUUFBUVEsU0FBUyxFQUFFO1FBQzdCUixRQUFRUSxTQUFTLEdBQUc7UUFDcEJSLFFBQVFvWCxZQUFZLEdBQUc7SUFDM0I7SUFDQSxPQUFPcFg7QUFDWDtBQUNBLFNBQVMrVyxjQUFjL1csT0FBTztJQUMxQkEsUUFBUTVLLGVBQWUsR0FBRztJQUMxQixJQUFJNEssUUFBUW9YLFlBQVksRUFBRTtRQUN0QnBYLFFBQVFRLFNBQVMsR0FBRztRQUNwQlIsUUFBUW9YLFlBQVksR0FBRztJQUMzQjtBQUNKO0FBQ0EsU0FBU0gsNkJBQTZCL2IsSUFBSTtJQUN0QyxJQUFJbEUsTUFBTWtFLEtBQUt0RixHQUFHLENBQUMyRixhQUFhO0lBQ2hDdkUsSUFBSXFnQixtQkFBbUIsQ0FBQyxtQkFBbUJuYyxLQUFLMFMsS0FBSyxDQUFDMEosa0JBQWtCO0lBQ3hFLElBQUluaEIsU0FBUytFLEtBQUsrSSxpQkFBaUI7SUFDbkMsSUFBSTVRLE9BQU84QyxPQUFPRyxVQUFVLEVBQUVmLFNBQVNZLE9BQU9JLFlBQVk7SUFDMURTLElBQUl1Z0IsZ0JBQWdCLENBQUMsbUJBQW1CcmMsS0FBSzBTLEtBQUssQ0FBQzBKLGtCQUFrQixHQUFHO1FBQ3BFLElBQUluaEIsT0FBT0csVUFBVSxJQUFJakQsUUFBUThDLE9BQU9JLFlBQVksSUFBSWhCLFFBQVE7WUFDNUR5QixJQUFJcWdCLG1CQUFtQixDQUFDLG1CQUFtQm5jLEtBQUswUyxLQUFLLENBQUMwSixrQkFBa0I7WUFDeEVFLFdBQVc7Z0JBQ1AsSUFBSSxDQUFDN0Isb0JBQW9CemEsU0FBU0EsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQ2lVLE9BQU8sRUFDMUQ5YixLQUFLdEYsR0FBRyxDQUFDOFQsU0FBUyxDQUFDbUYsTUFBTSxDQUFDO1lBQ2xDLEdBQUc7UUFDUDtJQUNKO0FBQ0o7QUFDQSxTQUFTNkgsb0JBQW9CeGIsSUFBSTtJQUM3QixJQUFJL0UsU0FBUytFLEtBQUt3SSxZQUFZLElBQUl6UCxRQUFRQyxTQUFTQyxXQUFXO0lBQzlELElBQUksQ0FBQ2dDLFFBQ0Q7SUFDSixJQUFJOUMsT0FBTzZILEtBQUt1YixhQUFhLENBQUM3Z0IsR0FBRyxFQUFFNmhCLE1BQU1wa0IsS0FBSzhCLFFBQVEsSUFBSTtJQUMxRCxJQUFJc2lCLEtBQ0F4akIsTUFBTU0sUUFBUSxDQUFDbEIsS0FBS0csVUFBVSxFQUFFSixTQUFTQyxRQUFRO1NBRWpEWSxNQUFNTSxRQUFRLENBQUNsQixNQUFNO0lBQ3pCWSxNQUFNeVEsUUFBUSxDQUFDO0lBQ2Z2TyxPQUFPb1MsZUFBZTtJQUN0QnBTLE9BQU9xUyxRQUFRLENBQUN2VTtJQUNoQiwrREFBK0Q7SUFDL0QsbUVBQW1FO0lBQ25FLCtEQUErRDtJQUMvRCw4REFBOEQ7SUFDOUQsbUJBQW1CO0lBQ25CLElBQUksQ0FBQ3dqQixPQUFPLENBQUN2YyxLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUyxDQUFDaVUsT0FBTyxJQUFJeGUsTUFBTUMsY0FBYyxJQUFJO1FBQ2pFcEYsS0FBS3FrQixRQUFRLEdBQUc7UUFDaEJya0IsS0FBS3FrQixRQUFRLEdBQUc7SUFDcEI7QUFDSjtBQUNBLFNBQVMxQixrQkFBa0I5YSxJQUFJLEVBQUU0SCxHQUFHO0lBQ2hDLElBQUlBLGVBQWVuUSw0REFBYUEsRUFBRTtRQUM5QixJQUFJa0QsT0FBT3FGLEtBQUtvRSxPQUFPLENBQUN3SCxNQUFNLENBQUNoRSxJQUFJL08sSUFBSTtRQUN2QyxJQUFJOEIsUUFBUXFGLEtBQUt5YyxvQkFBb0IsRUFBRTtZQUNuQ0MsbUJBQW1CMWM7WUFDbkIsSUFBSXJGLE1BQ0FBLEtBQUs4WSxVQUFVO1lBQ25CelQsS0FBS3ljLG9CQUFvQixHQUFHOWhCO1FBQ2hDO0lBQ0osT0FDSztRQUNEK2hCLG1CQUFtQjFjO0lBQ3ZCO0FBQ0o7QUFDQSx5REFBeUQ7QUFDekQsU0FBUzBjLG1CQUFtQjFjLElBQUk7SUFDNUIsSUFBSUEsS0FBS3ljLG9CQUFvQixFQUFFO1FBQzNCLElBQUl6YyxLQUFLeWMsb0JBQW9CLENBQUNsa0IsTUFBTSxFQUNoQ3lILEtBQUt5YyxvQkFBb0IsQ0FBQy9JLFlBQVk7UUFDMUMxVCxLQUFLeWMsb0JBQW9CLEdBQUc3WjtJQUNoQztBQUNKO0FBQ0EsU0FBUzRYLGlCQUFpQnhhLElBQUksRUFBRXVhLE9BQU8sRUFBRWxTLEtBQUssRUFBRWxFLElBQUk7SUFDaEQsT0FBT25FLEtBQUtHLFFBQVEsQ0FBQywwQkFBMEJvSCxDQUFBQSxJQUFLQSxFQUFFdkgsTUFBTXVhLFNBQVNsUyxXQUM5RDdRLDREQUFhQSxDQUFDbWxCLE9BQU8sQ0FBQ3BDLFNBQVNsUyxPQUFPbEU7QUFDakQ7QUFDQSxTQUFTeVkscUJBQXFCNWMsSUFBSTtJQUM5QixJQUFJQSxLQUFLMGEsUUFBUSxJQUFJLENBQUMxYSxLQUFLMmEsUUFBUSxJQUMvQixPQUFPO0lBQ1gsT0FBT0MsYUFBYTVhO0FBQ3hCO0FBQ0EsU0FBUzRhLGFBQWE1YSxJQUFJO0lBQ3RCLElBQUk0SCxNQUFNNUgsS0FBSytJLGlCQUFpQjtJQUNoQyxJQUFJLENBQUNuQixJQUFJeE0sVUFBVSxFQUNmLE9BQU87SUFDWCxJQUFJO1FBQ0EsK0RBQStEO1FBQy9ELDhEQUE4RDtRQUM5RCxXQUFXO1FBQ1gsT0FBTzRFLEtBQUt0RixHQUFHLENBQUNrSCxRQUFRLENBQUNnRyxJQUFJeE0sVUFBVSxDQUFDM0MsUUFBUSxJQUFJLElBQUltUCxJQUFJeE0sVUFBVSxDQUFDOUMsVUFBVSxHQUFHc1AsSUFBSXhNLFVBQVUsS0FDN0Y0RSxDQUFBQSxLQUFLMGEsUUFBUSxJQUFJMWEsS0FBS3RGLEdBQUcsQ0FBQ2tILFFBQVEsQ0FBQ2dHLElBQUkxTSxTQUFTLENBQUN6QyxRQUFRLElBQUksSUFBSW1QLElBQUkxTSxTQUFTLENBQUM1QyxVQUFVLEdBQUdzUCxJQUFJMU0sU0FBUztJQUNsSCxFQUNBLE9BQU93QixHQUFHO1FBQ04sT0FBTztJQUNYO0FBQ0o7QUFDQSxTQUFTbWdCLG1CQUFtQjdjLElBQUk7SUFDNUIsSUFBSThNLFlBQVk5TSxLQUFLb0UsT0FBTyxDQUFDc0MsVUFBVSxDQUFDMUcsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQzhFLE1BQU0sRUFBRTtJQUNyRSxJQUFJMVIsU0FBUytFLEtBQUsrSSxpQkFBaUI7SUFDbkMsT0FBT3hQLHFCQUFxQnVULFVBQVUzVSxJQUFJLEVBQUUyVSxVQUFVelMsTUFBTSxFQUFFWSxPQUFPRyxVQUFVLEVBQUVILE9BQU9JLFlBQVk7QUFDeEc7QUFFQSxTQUFTeWhCLG1CQUFtQnBYLEtBQUssRUFBRTdMLEdBQUc7SUFDbEMsSUFBSSxFQUFFMGdCLE9BQU8sRUFBRWxTLEtBQUssRUFBRSxHQUFHM0MsTUFBTW1DLFNBQVM7SUFDeEMsSUFBSWtWLFFBQVFsakIsTUFBTSxJQUFJMGdCLFFBQVFqWixHQUFHLENBQUMrRyxTQUFTa1MsUUFBUTlkLEdBQUcsQ0FBQzRMO0lBQ3ZELElBQUkyVSxTQUFTLENBQUNELE1BQU14a0IsTUFBTSxDQUFDMk8sYUFBYSxHQUFHNlYsUUFBUUEsTUFBTTVULEtBQUssR0FBR3pELE1BQU01SixHQUFHLENBQUNtTCxPQUFPLENBQUNwTixNQUFNLElBQUlrakIsTUFBTTNWLEtBQUssS0FBSzJWLE1BQU1sWSxNQUFNLE1BQU07SUFDL0gsT0FBT21ZLFVBQVVybEIsd0RBQVNBLENBQUNzbEIsUUFBUSxDQUFDRCxRQUFRbmpCO0FBQ2hEO0FBQ0EsU0FBU3FqQixNQUFNbGQsSUFBSSxFQUFFNEgsR0FBRztJQUNwQjVILEtBQUttZCxRQUFRLENBQUNuZCxLQUFLMEYsS0FBSyxDQUFDMFgsRUFBRSxDQUFDMVEsWUFBWSxDQUFDOUUsS0FBS3lWLGNBQWM7SUFDNUQsT0FBTztBQUNYO0FBQ0EsU0FBU0MsbUJBQW1CdGQsSUFBSSxFQUFFbkcsR0FBRyxFQUFFMGpCLElBQUk7SUFDdkMsSUFBSTNWLE1BQU01SCxLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUztJQUM5QixJQUFJRCxlQUFlcFEsNERBQWFBLEVBQUU7UUFDOUIsSUFBSStsQixLQUFLekgsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHO1lBQ3hCLElBQUksRUFBRXpOLEtBQUssRUFBRSxHQUFHVCxLQUFLelAsT0FBT2tRLE1BQU1tVixVQUFVLEdBQUcsT0FBTzNqQixNQUFNLElBQUl3TyxNQUFNb1YsVUFBVSxHQUFHcFYsTUFBTXFWLFNBQVM7WUFDbEcsSUFBSSxDQUFDdmxCLFFBQVFBLEtBQUt5TSxNQUFNLElBQUksQ0FBQ3pNLEtBQUswWSxNQUFNLEVBQ3BDLE9BQU87WUFDWCxJQUFJOE0sV0FBVzNkLEtBQUswRixLQUFLLENBQUM1SixHQUFHLENBQUNtTCxPQUFPLENBQUNvQixNQUFNL0wsR0FBRyxHQUFHbkUsS0FBSzJCLFFBQVEsR0FBSUQsQ0FBQUEsTUFBTSxJQUFJLENBQUMsSUFBSTtZQUNsRixPQUFPcWpCLE1BQU1sZCxNQUFNLElBQUl4SSw0REFBYUEsQ0FBQ29RLElBQUkyUyxPQUFPLEVBQUVvRDtRQUN0RCxPQUNLLElBQUksQ0FBQy9WLElBQUkrSSxLQUFLLEVBQUU7WUFDakIsT0FBTztRQUNYLE9BQ0ssSUFBSTNRLEtBQUs2SixjQUFjLENBQUNoUSxNQUFNLElBQUksWUFBWSxhQUFhO1lBQzVELElBQUkwTCxPQUFPdVgsbUJBQW1COWMsS0FBSzBGLEtBQUssRUFBRTdMO1lBQzFDLElBQUkwTCxRQUFTQSxnQkFBZ0I5Tiw0REFBYUEsRUFDdEMsT0FBT3lsQixNQUFNbGQsTUFBTXVGO1lBQ3ZCLE9BQU87UUFDWCxPQUNLLElBQUksQ0FBRXRILENBQUFBLE9BQU9zZixLQUFLekgsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJO1lBQ3ZDLElBQUl6TixRQUFRVCxJQUFJUyxLQUFLLEVBQUVsUSxPQUFPa1EsTUFBTW1WLFVBQVUsR0FBRyxPQUFPM2pCLE1BQU0sSUFBSXdPLE1BQU1vVixVQUFVLEdBQUdwVixNQUFNcVYsU0FBUyxFQUFFL2lCO1lBQ3RHLElBQUksQ0FBQ3hDLFFBQVFBLEtBQUt5TSxNQUFNLEVBQ3BCLE9BQU87WUFDWCxJQUFJZ1osVUFBVS9qQixNQUFNLElBQUl3TyxNQUFNL0wsR0FBRyxHQUFHbkUsS0FBSzJCLFFBQVEsR0FBR3VPLE1BQU0vTCxHQUFHO1lBQzdELElBQUksQ0FBRW5FLENBQUFBLEtBQUswYixNQUFNLElBQUksQ0FBQ2xaLE9BQU9xRixLQUFLb0UsT0FBTyxDQUFDd0gsTUFBTSxDQUFDZ1MsUUFBTyxLQUFNLENBQUNqakIsS0FBS0ksVUFBVSxHQUMxRSxPQUFPO1lBQ1gsSUFBSXRELDREQUFhQSxDQUFDeWlCLFlBQVksQ0FBQy9oQixPQUFPO2dCQUNsQyxPQUFPK2tCLE1BQU1sZCxNQUFNLElBQUl2SSw0REFBYUEsQ0FBQ29DLE1BQU0sSUFBSW1HLEtBQUswRixLQUFLLENBQUM1SixHQUFHLENBQUNtTCxPQUFPLENBQUNvQixNQUFNL0wsR0FBRyxHQUFHbkUsS0FBSzJCLFFBQVEsSUFBSXVPO1lBQ3ZHLE9BQ0ssSUFBSWhLLFFBQVE7Z0JBQ2IsMERBQTBEO2dCQUMxRCwwREFBMEQ7Z0JBQzFELGlEQUFpRDtnQkFDakQsT0FBTzZlLE1BQU1sZCxNQUFNLElBQUl4SSw0REFBYUEsQ0FBQ3dJLEtBQUswRixLQUFLLENBQUM1SixHQUFHLENBQUNtTCxPQUFPLENBQUNwTixNQUFNLElBQUkrakIsVUFBVUEsVUFBVXpsQixLQUFLMkIsUUFBUTtZQUMzRyxPQUNLO2dCQUNELE9BQU87WUFDWDtRQUNKO0lBQ0osT0FDSyxJQUFJOE4sZUFBZW5RLDREQUFhQSxJQUFJbVEsSUFBSXpQLElBQUksQ0FBQzRjLFFBQVEsRUFBRTtRQUN4RCxPQUFPbUksTUFBTWxkLE1BQU0sSUFBSXhJLDREQUFhQSxDQUFDcUMsTUFBTSxJQUFJK04sSUFBSUksR0FBRyxHQUFHSixJQUFJRyxLQUFLO0lBQ3RFLE9BQ0s7UUFDRCxJQUFJeEMsT0FBT3VYLG1CQUFtQjljLEtBQUswRixLQUFLLEVBQUU3TDtRQUMxQyxJQUFJMEwsTUFDQSxPQUFPMlgsTUFBTWxkLE1BQU11RjtRQUN2QixPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNzWSxRQUFRMWxCLElBQUk7SUFDakIsT0FBT0EsS0FBS00sUUFBUSxJQUFJLElBQUlOLEtBQUtnQixTQUFTLENBQUNDLE1BQU0sR0FBR2pCLEtBQUtnQyxVQUFVLENBQUNmLE1BQU07QUFDOUU7QUFDQSxTQUFTMGtCLFlBQVlwakIsR0FBRyxFQUFFYixHQUFHO0lBQ3pCLElBQUljLE9BQU9ELElBQUlHLFVBQVU7SUFDekIsT0FBT0YsUUFBUUEsS0FBS2lMLElBQUksSUFBSSxLQUFNL0wsQ0FBQUEsTUFBTSxLQUFLYSxJQUFJK0ksV0FBVyxJQUFJL0ksSUFBSVQsUUFBUSxJQUFJLElBQUc7QUFDdkY7QUFDQSxTQUFTOGpCLGlCQUFpQi9kLElBQUksRUFBRW5HLEdBQUc7SUFDL0IsT0FBT0EsTUFBTSxJQUFJbWtCLHVCQUF1QmhlLFFBQVFpZSxzQkFBc0JqZTtBQUMxRTtBQUNBLGdFQUFnRTtBQUNoRSwrREFBK0Q7QUFDL0QsU0FBU2dlLHVCQUF1QmhlLElBQUk7SUFDaEMsSUFBSTRILE1BQU01SCxLQUFLK0ksaUJBQWlCO0lBQ2hDLElBQUk1USxPQUFPeVAsSUFBSTFNLFNBQVMsRUFBRWIsU0FBU3VOLElBQUl6TSxXQUFXO0lBQ2xELElBQUksQ0FBQ2hELE1BQ0Q7SUFDSixJQUFJK2xCLFVBQVVDLFlBQVl0UixRQUFRO0lBQ2xDLG1FQUFtRTtJQUNuRSxpRUFBaUU7SUFDakUsdURBQXVEO0lBQ3ZELElBQUlwUCxTQUFTdEYsS0FBS00sUUFBUSxJQUFJLEtBQUs0QixTQUFTd2pCLFFBQVExbEIsU0FBUzJsQixZQUFZM2xCLEtBQUtnQyxVQUFVLENBQUNFLE9BQU8sRUFBRSxDQUFDLElBQy9Gd1MsUUFBUTtJQUNaLE9BQVM7UUFDTCxJQUFJeFMsU0FBUyxHQUFHO1lBQ1osSUFBSWxDLEtBQUtNLFFBQVEsSUFBSSxHQUFHO2dCQUNwQjtZQUNKLE9BQ0s7Z0JBQ0QsSUFBSW9NLFNBQVMxTSxLQUFLZ0MsVUFBVSxDQUFDRSxTQUFTLEVBQUU7Z0JBQ3hDLElBQUl5akIsWUFBWWpaLFFBQVEsQ0FBQyxJQUFJO29CQUN6QnFaLFdBQVcvbEI7b0JBQ1hnbUIsYUFBYSxFQUFFOWpCO2dCQUNuQixPQUNLLElBQUl3SyxPQUFPcE0sUUFBUSxJQUFJLEdBQUc7b0JBQzNCTixPQUFPME07b0JBQ1B4SyxTQUFTbEMsS0FBS2dCLFNBQVMsQ0FBQ0MsTUFBTTtnQkFDbEMsT0FFSTtZQUNSO1FBQ0osT0FDSyxJQUFJZ2xCLFlBQVlqbUIsT0FBTztZQUN4QjtRQUNKLE9BQ0s7WUFDRCxJQUFJcU4sT0FBT3JOLEtBQUtFLGVBQWU7WUFDL0IsTUFBT21OLFFBQVFzWSxZQUFZdFksTUFBTSxDQUFDLEdBQUk7Z0JBQ2xDMFksV0FBVy9sQixLQUFLRyxVQUFVO2dCQUMxQjZsQixhQUFham1CLFNBQVNzTjtnQkFDdEJBLE9BQU9BLEtBQUtuTixlQUFlO1lBQy9CO1lBQ0EsSUFBSSxDQUFDbU4sTUFBTTtnQkFDUHJOLE9BQU9BLEtBQUtHLFVBQVU7Z0JBQ3RCLElBQUlILFFBQVE2SCxLQUFLdEYsR0FBRyxFQUNoQjtnQkFDSkwsU0FBUztZQUNiLE9BQ0s7Z0JBQ0RsQyxPQUFPcU47Z0JBQ1BuTCxTQUFTd2pCLFFBQVExbEI7WUFDckI7UUFDSjtJQUNKO0lBQ0EsSUFBSTBVLE9BQ0F3UixZQUFZcmUsTUFBTTdILE1BQU1rQztTQUN2QixJQUFJNmpCLFVBQ0xHLFlBQVlyZSxNQUFNa2UsVUFBVUM7QUFDcEM7QUFDQSxpRUFBaUU7QUFDakUsU0FBUztBQUNULFNBQVNGLHNCQUFzQmplLElBQUk7SUFDL0IsSUFBSTRILE1BQU01SCxLQUFLK0ksaUJBQWlCO0lBQ2hDLElBQUk1USxPQUFPeVAsSUFBSTFNLFNBQVMsRUFBRWIsU0FBU3VOLElBQUl6TSxXQUFXO0lBQ2xELElBQUksQ0FBQ2hELE1BQ0Q7SUFDSixJQUFJMkwsTUFBTStaLFFBQVExbEI7SUFDbEIsSUFBSStsQixVQUFVQztJQUNkLE9BQVM7UUFDTCxJQUFJOWpCLFNBQVN5SixLQUFLO1lBQ2QsSUFBSTNMLEtBQUtNLFFBQVEsSUFBSSxHQUNqQjtZQUNKLElBQUkyTyxRQUFRalAsS0FBS2dDLFVBQVUsQ0FBQ0UsT0FBTztZQUNuQyxJQUFJeWpCLFlBQVkxVyxPQUFPLElBQUk7Z0JBQ3ZCOFcsV0FBVy9sQjtnQkFDWGdtQixhQUFhLEVBQUU5akI7WUFDbkIsT0FFSTtRQUNSLE9BQ0ssSUFBSStqQixZQUFZam1CLE9BQU87WUFDeEI7UUFDSixPQUNLO1lBQ0QsSUFBSW9OLE9BQU9wTixLQUFLc0wsV0FBVztZQUMzQixNQUFPOEIsUUFBUXVZLFlBQVl2WSxNQUFNLEdBQUk7Z0JBQ2pDMlksV0FBVzNZLEtBQUtqTixVQUFVO2dCQUMxQjZsQixhQUFham1CLFNBQVNxTixRQUFRO2dCQUM5QkEsT0FBT0EsS0FBSzlCLFdBQVc7WUFDM0I7WUFDQSxJQUFJLENBQUM4QixNQUFNO2dCQUNQcE4sT0FBT0EsS0FBS0csVUFBVTtnQkFDdEIsSUFBSUgsUUFBUTZILEtBQUt0RixHQUFHLEVBQ2hCO2dCQUNKTCxTQUFTeUosTUFBTTtZQUNuQixPQUNLO2dCQUNEM0wsT0FBT29OO2dCQUNQbEwsU0FBUztnQkFDVHlKLE1BQU0rWixRQUFRMWxCO1lBQ2xCO1FBQ0o7SUFDSjtJQUNBLElBQUkrbEIsVUFDQUcsWUFBWXJlLE1BQU1rZSxVQUFVQztBQUNwQztBQUNBLFNBQVNDLFlBQVkxakIsR0FBRztJQUNwQixJQUFJQyxPQUFPRCxJQUFJRyxVQUFVO0lBQ3pCLE9BQU9GLFFBQVFBLEtBQUt4QyxJQUFJLElBQUl3QyxLQUFLeEMsSUFBSSxDQUFDMkMsT0FBTztBQUNqRDtBQUNBLFNBQVN3akIsY0FBY25tQixJQUFJLEVBQUVrQyxNQUFNO0lBQy9CLE1BQU9sQyxRQUFRa0MsVUFBVWxDLEtBQUtnQyxVQUFVLENBQUNmLE1BQU0sSUFBSSxDQUFDVyxhQUFhNUIsTUFBTztRQUNwRWtDLFNBQVNuQyxTQUFTQyxRQUFRO1FBQzFCQSxPQUFPQSxLQUFLRyxVQUFVO0lBQzFCO0lBQ0EsTUFBT0gsUUFBUWtDLFNBQVNsQyxLQUFLZ0MsVUFBVSxDQUFDZixNQUFNLENBQUU7UUFDNUMsSUFBSW1NLE9BQU9wTixLQUFLZ0MsVUFBVSxDQUFDRSxPQUFPO1FBQ2xDLElBQUlrTCxLQUFLOU0sUUFBUSxJQUFJLEdBQ2pCLE9BQU84TTtRQUNYLElBQUlBLEtBQUs5TSxRQUFRLElBQUksS0FBSzhNLEtBQUtyTCxlQUFlLElBQUksU0FDOUM7UUFDSi9CLE9BQU9vTjtRQUNQbEwsU0FBUztJQUNiO0FBQ0o7QUFDQSxTQUFTa2tCLGVBQWVwbUIsSUFBSSxFQUFFa0MsTUFBTTtJQUNoQyxNQUFPbEMsUUFBUSxDQUFDa0MsVUFBVSxDQUFDTixhQUFhNUIsTUFBTztRQUMzQ2tDLFNBQVNuQyxTQUFTQztRQUNsQkEsT0FBT0EsS0FBS0csVUFBVTtJQUMxQjtJQUNBLE1BQU9ILFFBQVFrQyxPQUFRO1FBQ25CLElBQUlrTCxPQUFPcE4sS0FBS2dDLFVBQVUsQ0FBQ0UsU0FBUyxFQUFFO1FBQ3RDLElBQUlrTCxLQUFLOU0sUUFBUSxJQUFJLEdBQ2pCLE9BQU84TTtRQUNYLElBQUlBLEtBQUs5TSxRQUFRLElBQUksS0FBSzhNLEtBQUtyTCxlQUFlLElBQUksU0FDOUM7UUFDSi9CLE9BQU9vTjtRQUNQbEwsU0FBU2xDLEtBQUtnQyxVQUFVLENBQUNmLE1BQU07SUFDbkM7QUFDSjtBQUNBLFNBQVNpbEIsWUFBWXJlLElBQUksRUFBRTdILElBQUksRUFBRWtDLE1BQU07SUFDbkMsSUFBSWxDLEtBQUtNLFFBQVEsSUFBSSxHQUFHO1FBQ3BCLElBQUlvTSxRQUFRdUM7UUFDWixJQUFJQSxRQUFRa1gsY0FBY25tQixNQUFNa0MsU0FBUztZQUNyQ2xDLE9BQU9pUDtZQUNQL00sU0FBUztRQUNiLE9BQ0ssSUFBSXdLLFNBQVMwWixlQUFlcG1CLE1BQU1rQyxTQUFTO1lBQzVDbEMsT0FBTzBNO1lBQ1B4SyxTQUFTd0ssT0FBTzFMLFNBQVMsQ0FBQ0MsTUFBTTtRQUNwQztJQUNKO0lBQ0EsSUFBSXdPLE1BQU01SCxLQUFLd0ksWUFBWTtJQUMzQixJQUFJLENBQUNaLEtBQ0Q7SUFDSixJQUFJNU0sbUJBQW1CNE0sTUFBTTtRQUN6QixJQUFJN08sUUFBUUMsU0FBU0MsV0FBVztRQUNoQ0YsTUFBTUcsTUFBTSxDQUFDZixNQUFNa0M7UUFDbkJ0QixNQUFNTSxRQUFRLENBQUNsQixNQUFNa0M7UUFDckJ1TixJQUFJeUYsZUFBZTtRQUNuQnpGLElBQUkwRixRQUFRLENBQUN2VTtJQUNqQixPQUNLLElBQUk2TyxJQUFJNkIsTUFBTSxFQUFFO1FBQ2pCN0IsSUFBSTZCLE1BQU0sQ0FBQ3RSLE1BQU1rQztJQUNyQjtJQUNBMkYsS0FBS2tiLFdBQVcsQ0FBQ0csZUFBZTtJQUNoQyxJQUFJLEVBQUUzVixLQUFLLEVBQUUsR0FBRzFGO0lBQ2hCLDZEQUE2RDtJQUM3RHNjLFdBQVc7UUFDUCxJQUFJdGMsS0FBSzBGLEtBQUssSUFBSUEsT0FDZG1WLGVBQWU3YTtJQUN2QixHQUFHO0FBQ1A7QUFDQSxTQUFTd2UsY0FBY3hlLElBQUksRUFBRTFELEdBQUc7SUFDNUIsSUFBSXdMLE9BQU85SCxLQUFLMEYsS0FBSyxDQUFDNUosR0FBRyxDQUFDbUwsT0FBTyxDQUFDM0s7SUFDbEMsSUFBSSxDQUFFcUIsQ0FBQUEsVUFBVVEsT0FBTSxLQUFNMkosS0FBS3ZQLE1BQU0sQ0FBQzJPLGFBQWEsRUFBRTtRQUNuRCxJQUFJcEUsU0FBUzlDLEtBQUt3RyxXQUFXLENBQUNsSztRQUM5QixJQUFJQSxNQUFNd0wsS0FBS1csS0FBSyxJQUFJO1lBQ3BCLElBQUk1RCxTQUFTN0UsS0FBS3dHLFdBQVcsQ0FBQ2xLLE1BQU07WUFDcEMsSUFBSW1pQixNQUFNLENBQUM1WixPQUFPN0YsR0FBRyxHQUFHNkYsT0FBTzVGLE1BQU0sSUFBSTtZQUN6QyxJQUFJd2YsTUFBTTNiLE9BQU85RCxHQUFHLElBQUl5ZixNQUFNM2IsT0FBTzdELE1BQU0sSUFBSXpDLEtBQUtraUIsR0FBRyxDQUFDN1osT0FBT2hHLElBQUksR0FBR2lFLE9BQU9qRSxJQUFJLElBQUksR0FDakYsT0FBT2dHLE9BQU9oRyxJQUFJLEdBQUdpRSxPQUFPakUsSUFBSSxHQUFHLFFBQVE7UUFDbkQ7UUFDQSxJQUFJdkMsTUFBTXdMLEtBQUtZLEdBQUcsSUFBSTtZQUNsQixJQUFJdEIsUUFBUXBILEtBQUt3RyxXQUFXLENBQUNsSyxNQUFNO1lBQ25DLElBQUltaUIsTUFBTSxDQUFDclgsTUFBTXBJLEdBQUcsR0FBR29JLE1BQU1uSSxNQUFNLElBQUk7WUFDdkMsSUFBSXdmLE1BQU0zYixPQUFPOUQsR0FBRyxJQUFJeWYsTUFBTTNiLE9BQU83RCxNQUFNLElBQUl6QyxLQUFLa2lCLEdBQUcsQ0FBQ3RYLE1BQU12SSxJQUFJLEdBQUdpRSxPQUFPakUsSUFBSSxJQUFJLEdBQ2hGLE9BQU91SSxNQUFNdkksSUFBSSxHQUFHaUUsT0FBT2pFLElBQUksR0FBRyxRQUFRO1FBQ2xEO0lBQ0o7SUFDQSxJQUFJOGYsV0FBV3pkLGlCQUFpQmxCLEtBQUt0RixHQUFHLEVBQUVra0IsU0FBUztJQUNuRCxPQUFPRCxZQUFZLFFBQVEsUUFBUTtBQUN2QztBQUNBLDZEQUE2RDtBQUM3RCxpRUFBaUU7QUFDakUsV0FBVztBQUNYLFNBQVNFLGlCQUFpQjdlLElBQUksRUFBRW5HLEdBQUcsRUFBRTBqQixJQUFJO0lBQ3JDLElBQUkzVixNQUFNNUgsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVM7SUFDOUIsSUFBSUQsZUFBZXBRLDREQUFhQSxJQUFJLENBQUNvUSxJQUFJK0ksS0FBSyxJQUFJNE0sS0FBS3pILE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FDbkUsT0FBTztJQUNYLElBQUk3WCxPQUFPc2YsS0FBS3pILE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FDNUIsT0FBTztJQUNYLElBQUksRUFBRS9OLEtBQUssRUFBRUMsR0FBRyxFQUFFLEdBQUdKO0lBQ3JCLElBQUksQ0FBQ0csTUFBTXhQLE1BQU0sQ0FBQzJPLGFBQWEsSUFBSWxILEtBQUs2SixjQUFjLENBQUNoUSxNQUFNLElBQUksT0FBTyxTQUFTO1FBQzdFLElBQUkwTCxPQUFPdVgsbUJBQW1COWMsS0FBSzBGLEtBQUssRUFBRTdMO1FBQzFDLElBQUkwTCxRQUFTQSxnQkFBZ0I5Tiw0REFBYUEsRUFDdEMsT0FBT3lsQixNQUFNbGQsTUFBTXVGO0lBQzNCO0lBQ0EsSUFBSSxDQUFDd0MsTUFBTXhQLE1BQU0sQ0FBQzJPLGFBQWEsRUFBRTtRQUM3QixJQUFJM0gsT0FBTzFGLE1BQU0sSUFBSWtPLFFBQVFDO1FBQzdCLElBQUk4VyxTQUFTbFgsZUFBZWxRLDJEQUFZQSxHQUFHQyx3REFBU0EsQ0FBQ29uQixJQUFJLENBQUN4ZixNQUFNMUYsT0FBT2xDLHdEQUFTQSxDQUFDc2xCLFFBQVEsQ0FBQzFkLE1BQU0xRjtRQUNoRyxPQUFPaWxCLFNBQVM1QixNQUFNbGQsTUFBTThlLFVBQVU7SUFDMUM7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTRSwyQkFBMkJoZixJQUFJLEVBQUVuRyxHQUFHO0lBQ3pDLElBQUksQ0FBRW1HLENBQUFBLEtBQUswRixLQUFLLENBQUNtQyxTQUFTLFlBQVlyUSw0REFBWSxHQUM5QyxPQUFPO0lBQ1gsSUFBSSxFQUFFNlEsS0FBSyxFQUFFa1MsT0FBTyxFQUFFNUosS0FBSyxFQUFFLEdBQUczUSxLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUztJQUNwRCxJQUFJLENBQUNRLE1BQU00VyxVQUFVLENBQUMxRSxVQUNsQixPQUFPO0lBQ1gsSUFBSSxDQUFDNUosT0FDRCxPQUFPO0lBQ1gsSUFBSTNRLEtBQUs2SixjQUFjLENBQUNoUSxNQUFNLElBQUksWUFBWSxhQUMxQyxPQUFPO0lBQ1gsSUFBSXFsQixXQUFXLENBQUM3VyxNQUFNbVYsVUFBVSxJQUFLM2pCLENBQUFBLE1BQU0sSUFBSXdPLE1BQU1vVixVQUFVLEdBQUdwVixNQUFNcVYsU0FBUztJQUNqRixJQUFJd0IsWUFBWSxDQUFDQSxTQUFTdGEsTUFBTSxFQUFFO1FBQzlCLElBQUl3WSxLQUFLcGQsS0FBSzBGLEtBQUssQ0FBQzBYLEVBQUU7UUFDdEIsSUFBSXZqQixNQUFNLEdBQ051akIsR0FBRytCLE1BQU0sQ0FBQzlXLE1BQU0vTCxHQUFHLEdBQUc0aUIsU0FBU3BsQixRQUFRLEVBQUV1TyxNQUFNL0wsR0FBRzthQUVsRDhnQixHQUFHK0IsTUFBTSxDQUFDOVcsTUFBTS9MLEdBQUcsRUFBRStMLE1BQU0vTCxHQUFHLEdBQUc0aUIsU0FBU3BsQixRQUFRO1FBQ3REa0csS0FBS21kLFFBQVEsQ0FBQ0M7UUFDZCxPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTZ0MsZUFBZXBmLElBQUksRUFBRTdILElBQUksRUFBRXVOLEtBQUs7SUFDckMxRixLQUFLa2IsV0FBVyxDQUFDdE0sSUFBSTtJQUNyQnpXLEtBQUsrQixlQUFlLEdBQUd3TDtJQUN2QjFGLEtBQUtrYixXQUFXLENBQUN6UyxLQUFLO0FBQzFCO0FBQ0Esb0ZBQW9GO0FBQ3BGLHNFQUFzRTtBQUN0RSxpRUFBaUU7QUFDakUsa0VBQWtFO0FBQ2xFLFdBQVc7QUFDWCxTQUFTNFcsbUJBQW1CcmYsSUFBSTtJQUM1QixJQUFJLENBQUNuQyxVQUFVbUMsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQ1EsS0FBSyxDQUFDRSxZQUFZLEdBQUcsR0FDckQsT0FBTztJQUNYLElBQUksRUFBRXJOLFNBQVMsRUFBRUMsV0FBVyxFQUFFLEdBQUc2RSxLQUFLK0ksaUJBQWlCO0lBQ3ZELElBQUk3TixhQUFhQSxVQUFVekMsUUFBUSxJQUFJLEtBQUswQyxlQUFlLEtBQ3ZERCxVQUFVcUksVUFBVSxJQUFJckksVUFBVXFJLFVBQVUsQ0FBQ3JKLGVBQWUsSUFBSSxTQUFTO1FBQ3pFLElBQUlvSixRQUFRcEksVUFBVXFJLFVBQVU7UUFDaEM2YixlQUFlcGYsTUFBTXNELE9BQU87UUFDNUJnWixXQUFXLElBQU04QyxlQUFlcGYsTUFBTXNELE9BQU8sVUFBVTtJQUMzRDtJQUNBLE9BQU87QUFDWDtBQUNBLG1FQUFtRTtBQUNuRSxzRUFBc0U7QUFDdEUsa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSxrRUFBa0U7QUFDbEUsb0JBQW9CO0FBQ3BCLFNBQVNnYyxRQUFRN2pCLEtBQUs7SUFDbEIsSUFBSThOLFNBQVM7SUFDYixJQUFJOU4sTUFBTThqQixPQUFPLEVBQ2JoVyxVQUFVO0lBQ2QsSUFBSTlOLE1BQU0rakIsT0FBTyxFQUNialcsVUFBVTtJQUNkLElBQUk5TixNQUFNZ2tCLE1BQU0sRUFDWmxXLFVBQVU7SUFDZCxJQUFJOU4sTUFBTWlrQixRQUFRLEVBQ2RuVyxVQUFVO0lBQ2QsT0FBT0E7QUFDWDtBQUNBLFNBQVNvVyxlQUFlM2YsSUFBSSxFQUFFdkUsS0FBSztJQUMvQixJQUFJRyxPQUFPSCxNQUFNRixPQUFPLEVBQUVnaUIsT0FBTytCLFFBQVE3akI7SUFDekMsSUFBSUcsUUFBUSxLQUFNcUMsT0FBT3JDLFFBQVEsTUFBTTJoQixRQUFRLEtBQU07UUFDakQsT0FBT3lCLDJCQUEyQmhmLE1BQU0sQ0FBQyxNQUFNK2QsaUJBQWlCL2QsTUFBTSxDQUFDO0lBQzNFLE9BQ0ssSUFBSSxRQUFTLE1BQU0sQ0FBQ3ZFLE1BQU1pa0IsUUFBUSxJQUFNemhCLE9BQU9yQyxRQUFRLE1BQU0yaEIsUUFBUSxLQUFNO1FBQzVFLE9BQU95QiwyQkFBMkJoZixNQUFNLE1BQU0rZCxpQkFBaUIvZCxNQUFNO0lBQ3pFLE9BQ0ssSUFBSXBFLFFBQVEsTUFBTUEsUUFBUSxJQUFJO1FBQy9CLE9BQU87SUFDWCxPQUNLLElBQUlBLFFBQVEsTUFBT3FDLE9BQU9yQyxRQUFRLE1BQU0yaEIsUUFBUSxLQUFNO1FBQ3ZELElBQUkxakIsTUFBTStCLFFBQVEsS0FBTTRpQixjQUFjeGUsTUFBTUEsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQ2hQLElBQUksS0FBSyxRQUFRLENBQUMsSUFBSSxJQUFLLENBQUM7UUFDN0YsT0FBT3lrQixtQkFBbUJ0ZCxNQUFNbkcsS0FBSzBqQixTQUFTUSxpQkFBaUIvZCxNQUFNbkc7SUFDekUsT0FDSyxJQUFJK0IsUUFBUSxNQUFPcUMsT0FBT3JDLFFBQVEsTUFBTTJoQixRQUFRLEtBQU07UUFDdkQsSUFBSTFqQixNQUFNK0IsUUFBUSxLQUFNNGlCLGNBQWN4ZSxNQUFNQSxLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUyxDQUFDaFAsSUFBSSxLQUFLLFFBQVEsSUFBSSxDQUFDLElBQUs7UUFDNUYsT0FBT3lrQixtQkFBbUJ0ZCxNQUFNbkcsS0FBSzBqQixTQUFTUSxpQkFBaUIvZCxNQUFNbkc7SUFDekUsT0FDSyxJQUFJK0IsUUFBUSxNQUFPcUMsT0FBT3JDLFFBQVEsTUFBTTJoQixRQUFRLEtBQU07UUFDdkQsT0FBT3NCLGlCQUFpQjdlLE1BQU0sQ0FBQyxHQUFHdWQsU0FBU1EsaUJBQWlCL2QsTUFBTSxDQUFDO0lBQ3ZFLE9BQ0ssSUFBSXBFLFFBQVEsTUFBT3FDLE9BQU9yQyxRQUFRLE1BQU0yaEIsUUFBUSxLQUFNO1FBQ3ZELE9BQU84QixtQkFBbUJyZixTQUFTNmUsaUJBQWlCN2UsTUFBTSxHQUFHdWQsU0FBU1EsaUJBQWlCL2QsTUFBTTtJQUNqRyxPQUNLLElBQUl1ZCxRQUFTdGYsQ0FBQUEsTUFBTSxNQUFNLEdBQUUsS0FDM0JyQyxDQUFBQSxRQUFRLE1BQU1BLFFBQVEsTUFBTUEsUUFBUSxNQUFNQSxRQUFRLEVBQUMsR0FBSTtRQUN4RCxPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFFQSxTQUFTZ2tCLHNCQUFzQjVmLElBQUksRUFBRTRQLEtBQUs7SUFDdEM1UCxLQUFLRyxRQUFRLENBQUMsbUJBQW1Cb0gsQ0FBQUE7UUFBT3FJLFFBQVFySSxFQUFFcUksT0FBTzVQO0lBQU87SUFDaEUsSUFBSTZmLFVBQVUsRUFBRSxFQUFFLEVBQUVsYSxPQUFPLEVBQUVtYSxTQUFTLEVBQUVDLE9BQU8sRUFBRSxHQUFHblE7SUFDcEQsTUFBT2tRLFlBQVksS0FBS0MsVUFBVSxLQUFLcGEsUUFBUStMLFVBQVUsSUFBSSxLQUFLL0wsUUFBUXBDLFVBQVUsQ0FBQ21PLFVBQVUsSUFBSSxFQUFHO1FBQ2xHb087UUFDQUM7UUFDQSxJQUFJNW5CLE9BQU93TixRQUFRcEMsVUFBVTtRQUM3QnNjLFFBQVE3ZCxJQUFJLENBQUM3SixLQUFLc1YsSUFBSSxDQUFDOEIsSUFBSSxFQUFFcFgsS0FBS3NYLEtBQUssSUFBSXRYLEtBQUtzVixJQUFJLENBQUN1UyxZQUFZLEdBQUc3bkIsS0FBS3NYLEtBQUssR0FBRztRQUNqRjlKLFVBQVV4TixLQUFLd04sT0FBTztJQUMxQjtJQUNBLElBQUlzYSxhQUFhamdCLEtBQUtHLFFBQVEsQ0FBQywwQkFBMEJ2SSw0REFBYUEsQ0FBQ3NvQixVQUFVLENBQUNsZ0IsS0FBSzBGLEtBQUssQ0FBQ3lhLE1BQU07SUFDbkcsSUFBSXJrQixNQUFNc2tCLGVBQWUvUixPQUFPdlMsSUFBSXdTLGFBQWEsQ0FBQztJQUNsREQsS0FBS0UsV0FBVyxDQUFDMFIsV0FBV0ksaUJBQWlCLENBQUMxYSxTQUFTO1FBQUUzTSxVQUFVOEM7SUFBSTtJQUN2RSxJQUFJeUgsYUFBYThLLEtBQUs5SyxVQUFVLEVBQUU4UCxXQUFXaU4sV0FBVztJQUN4RCxNQUFPL2MsY0FBY0EsV0FBVzlLLFFBQVEsSUFBSSxLQUFNNGEsQ0FBQUEsWUFBWWtOLE9BQU8sQ0FBQ2hkLFdBQVd0SixRQUFRLENBQUNxYixXQUFXLEdBQUcsRUFBRztRQUN2RyxJQUFLLElBQUlqVCxJQUFJZ1IsVUFBVWphLE1BQU0sR0FBRyxHQUFHaUosS0FBSyxHQUFHQSxJQUFLO1lBQzVDLElBQUlzVixVQUFVN2IsSUFBSXdTLGFBQWEsQ0FBQytFLFNBQVMsQ0FBQ2hSLEVBQUU7WUFDNUMsTUFBT2dNLEtBQUs5SyxVQUFVLENBQ2xCb1UsUUFBUXBKLFdBQVcsQ0FBQ0YsS0FBSzlLLFVBQVU7WUFDdkM4SyxLQUFLRSxXQUFXLENBQUNvSjtZQUNqQjJJO1FBQ0o7UUFDQS9jLGFBQWE4SyxLQUFLOUssVUFBVTtJQUNoQztJQUNBLElBQUlBLGNBQWNBLFdBQVc5SyxRQUFRLElBQUksR0FDckM4SyxXQUFXaVMsWUFBWSxDQUFDLGlCQUFpQixDQUFDLEVBQUVzSyxVQUFVLENBQUMsRUFBRUMsUUFBUSxFQUFFTyxXQUFXLENBQUMsRUFBRSxFQUFFQSxTQUFTLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRUUsS0FBS0MsU0FBUyxDQUFDWixTQUFTLENBQUM7SUFDbkksSUFBSTdSLE9BQU9oTyxLQUFLRyxRQUFRLENBQUMsMkJBQTJCb0gsQ0FBQUEsSUFBS0EsRUFBRXFJLE9BQU81UCxVQUM5RDRQLE1BQU1qSyxPQUFPLENBQUMrYSxXQUFXLENBQUMsR0FBRzlRLE1BQU1qSyxPQUFPLENBQUNDLElBQUksRUFBRTtJQUNyRCxPQUFPO1FBQUVsTCxLQUFLMlQ7UUFBTUw7UUFBTTRCO0lBQU07QUFDcEM7QUFDQSw2REFBNkQ7QUFDN0QsU0FBUytRLG1CQUFtQjNnQixJQUFJLEVBQUVnTyxJQUFJLEVBQUU0UyxJQUFJLEVBQUVDLFNBQVMsRUFBRUMsUUFBUTtJQUM3RCxJQUFJQyxTQUFTRCxTQUFTdm9CLE1BQU0sQ0FBQ2tWLElBQUksQ0FBQ1UsSUFBSSxDQUFDdlMsSUFBSTtJQUMzQyxJQUFJbEIsS0FBS2tWO0lBQ1QsSUFBSSxDQUFDZ1IsUUFBUSxDQUFDNVMsTUFDVixPQUFPO0lBQ1gsSUFBSWdULFNBQVNoVCxRQUFTNlMsQ0FBQUEsYUFBYUUsVUFBVSxDQUFDSCxJQUFHO0lBQ2pELElBQUlJLFFBQVE7UUFDUmhoQixLQUFLRyxRQUFRLENBQUMsdUJBQXVCb0gsQ0FBQUE7WUFBT3lHLE9BQU96RyxFQUFFeUcsTUFBTStTLFVBQVVGLFdBQVc3Z0I7UUFBTztRQUN2RixJQUFJK2dCLFFBQ0EsT0FBTy9TLE9BQU8sSUFBSWpXLG9EQUFLQSxDQUFDRix1REFBUUEsQ0FBQ2dCLElBQUksQ0FBQ21ILEtBQUswRixLQUFLLENBQUN5YSxNQUFNLENBQUNuUyxJQUFJLENBQUNBLEtBQUtpVCxPQUFPLENBQUMsVUFBVSxTQUFTLEdBQUcsS0FBS2xwQixvREFBS0EsQ0FBQzRZLEtBQUs7UUFDcEgsSUFBSXVRLFNBQVNsaEIsS0FBS0csUUFBUSxDQUFDLHVCQUF1Qm9ILENBQUFBLElBQUtBLEVBQUV5RyxNQUFNOFMsVUFBVUQsV0FBVzdnQjtRQUNwRixJQUFJa2hCLFFBQVE7WUFDUnRSLFFBQVFzUjtRQUNaLE9BQ0s7WUFDRCxJQUFJMVAsUUFBUXNQLFNBQVN0UCxLQUFLO1lBQzFCLElBQUksRUFBRTJPLE1BQU0sRUFBRSxHQUFHbmdCLEtBQUswRixLQUFLLEVBQUV1YSxhQUFhcm9CLDREQUFhQSxDQUFDc29CLFVBQVUsQ0FBQ0M7WUFDbkV6bEIsTUFBTTFCLFNBQVNzVixhQUFhLENBQUM7WUFDN0JOLEtBQUswSCxLQUFLLENBQUMsaUJBQWlCeUwsT0FBTyxDQUFDQyxDQUFBQTtnQkFDaEMsSUFBSS9iLElBQUkzSyxJQUFJNlQsV0FBVyxDQUFDdlYsU0FBU3NWLGFBQWEsQ0FBQztnQkFDL0MsSUFBSThTLE9BQ0EvYixFQUFFa0osV0FBVyxDQUFDMFIsV0FBV29CLGFBQWEsQ0FBQ2xCLE9BQU9uUyxJQUFJLENBQUNvVCxPQUFPNVA7WUFDbEU7UUFDSjtJQUNKLE9BQ0s7UUFDRHhSLEtBQUtHLFFBQVEsQ0FBQyx1QkFBdUJvSCxDQUFBQTtZQUFPcVosT0FBT3JaLEVBQUVxWixNQUFNNWdCO1FBQU87UUFDbEV0RixNQUFNNG1CLFNBQVNWO1FBQ2YsSUFBSXZpQixRQUNBa2pCLHNCQUFzQjdtQjtJQUM5QjtJQUNBLElBQUk4bUIsY0FBYzltQixPQUFPQSxJQUFJK21CLGFBQWEsQ0FBQztJQUMzQyxJQUFJQyxZQUFZRixlQUFlLGdDQUFnQ3JrQixJQUFJLENBQUNxa0IsWUFBWUcsWUFBWSxDQUFDLG9CQUFvQjtJQUNqSCxJQUFJRCxhQUFhQSxTQUFTLENBQUMsRUFBRSxFQUN6QixJQUFLLElBQUlyZixJQUFJLENBQUNxZixTQUFTLENBQUMsRUFBRSxFQUFFcmYsSUFBSSxHQUFHQSxJQUFLO1FBQ3BDLElBQUlpQixRQUFRNUksSUFBSTZJLFVBQVU7UUFDMUIsTUFBT0QsU0FBU0EsTUFBTTdLLFFBQVEsSUFBSSxFQUM5QjZLLFFBQVFBLE1BQU1HLFdBQVc7UUFDN0IsSUFBSSxDQUFDSCxPQUNEO1FBQ0o1SSxNQUFNNEk7SUFDVjtJQUNKLElBQUksQ0FBQ3NNLE9BQU87UUFDUixJQUFJZ1MsU0FBUzVoQixLQUFLRyxRQUFRLENBQUMsc0JBQXNCSCxLQUFLRyxRQUFRLENBQUMsZ0JBQWdCbkksd0RBQVNBLENBQUNrb0IsVUFBVSxDQUFDbGdCLEtBQUswRixLQUFLLENBQUN5YSxNQUFNO1FBQ3JIdlEsUUFBUWdTLE9BQU9DLFVBQVUsQ0FBQ25uQixLQUFLO1lBQzNCK1Ysb0JBQW9CLENBQUMsQ0FBRXVRLENBQUFBLFVBQVVVLFNBQVE7WUFDekM3QixTQUFTaUI7WUFDVGdCLGNBQWFwbkIsR0FBRztnQkFDWixJQUFJQSxJQUFJVCxRQUFRLElBQUksUUFBUSxDQUFDUyxJQUFJK0ksV0FBVyxJQUN4Qy9JLElBQUlwQyxVQUFVLElBQUksQ0FBQ3lwQixjQUFjL25CLElBQUksQ0FBQ1UsSUFBSXBDLFVBQVUsQ0FBQzJCLFFBQVEsR0FDN0QsT0FBTztvQkFBRTBVLFFBQVE7Z0JBQUs7Z0JBQzFCLE9BQU87WUFDWDtRQUNKO0lBQ0o7SUFDQSxJQUFJK1MsV0FBVztRQUNYOVIsUUFBUW9TLFdBQVdDLFdBQVdyUyxPQUFPLENBQUM4UixTQUFTLENBQUMsRUFBRSxFQUFFLENBQUNBLFNBQVMsQ0FBQyxFQUFFLEdBQUdBLFNBQVMsQ0FBQyxFQUFFO0lBQ3BGLE9BQ0s7UUFDRDlSLFFBQVE3WCxvREFBS0EsQ0FBQ21xQixPQUFPLENBQUNDLGtCQUFrQnZTLE1BQU1qSyxPQUFPLEVBQUVtYixXQUFXO1FBQ2xFLElBQUlsUixNQUFNa1EsU0FBUyxJQUFJbFEsTUFBTW1RLE9BQU8sRUFBRTtZQUNsQyxJQUFJRCxZQUFZLEdBQUdDLFVBQVU7WUFDN0IsSUFBSyxJQUFJNW5CLE9BQU95WCxNQUFNakssT0FBTyxDQUFDcEMsVUFBVSxFQUFFdWMsWUFBWWxRLE1BQU1rUSxTQUFTLElBQUksQ0FBQzNuQixLQUFLc1YsSUFBSSxDQUFDVSxJQUFJLENBQUNpVSxTQUFTLEVBQUV0QyxhQUFhM25CLE9BQU9BLEtBQUtvTCxVQUFVLENBQUUsQ0FBRTtZQUMzSSxJQUFLLElBQUlwTCxPQUFPeVgsTUFBTWpLLE9BQU8sQ0FBQ0YsU0FBUyxFQUFFc2EsVUFBVW5RLE1BQU1tUSxPQUFPLElBQUksQ0FBQzVuQixLQUFLc1YsSUFBSSxDQUFDVSxJQUFJLENBQUNpVSxTQUFTLEVBQUVyQyxXQUFXNW5CLE9BQU9BLEtBQUtzTixTQUFTLENBQUUsQ0FBRTtZQUNuSW1LLFFBQVFxUyxXQUFXclMsT0FBT2tRLFdBQVdDO1FBQ3pDO0lBQ0o7SUFDQS9mLEtBQUtHLFFBQVEsQ0FBQyxtQkFBbUJvSCxDQUFBQTtRQUFPcUksUUFBUXJJLEVBQUVxSSxPQUFPNVA7SUFBTztJQUNoRSxPQUFPNFA7QUFDWDtBQUNBLE1BQU1tUyxnQkFBZ0I7QUFDdEIsc0VBQXNFO0FBQ3RFLGtFQUFrRTtBQUNsRSxzRUFBc0U7QUFDdEUsMEVBQTBFO0FBQzFFLEVBQUU7QUFDRiw4REFBOEQ7QUFDOUQsc0VBQXNFO0FBQ3RFLDhCQUE4QjtBQUM5QixTQUFTSSxrQkFBa0JFLFFBQVEsRUFBRXZCLFFBQVE7SUFDekMsSUFBSXVCLFNBQVMzUSxVQUFVLEdBQUcsR0FDdEIsT0FBTzJRO0lBQ1gsSUFBSyxJQUFJL0ksSUFBSXdILFNBQVMzWCxLQUFLLEVBQUVtUSxLQUFLLEdBQUdBLElBQUs7UUFDdEMsSUFBSS9nQixTQUFTdW9CLFNBQVMzb0IsSUFBSSxDQUFDbWhCO1FBQzNCLElBQUlnSixRQUFRL3BCLE9BQU9ncUIsY0FBYyxDQUFDekIsU0FBUzFvQixLQUFLLENBQUNraEI7UUFDakQsSUFBSWtKLFVBQVVqWixTQUFTLEVBQUU7UUFDekI4WSxTQUFTbEIsT0FBTyxDQUFDaHBCLENBQUFBO1lBQ2IsSUFBSSxDQUFDb1IsUUFDRDtZQUNKLElBQUk4RSxPQUFPaVUsTUFBTUcsWUFBWSxDQUFDdHFCLEtBQUtzVixJQUFJLEdBQUdpVjtZQUMxQyxJQUFJLENBQUNyVSxNQUNELE9BQU85RSxTQUFTO1lBQ3BCLElBQUltWixTQUFTblosT0FBT25RLE1BQU0sSUFBSW9wQixTQUFTcHBCLE1BQU0sSUFBSXVwQixhQUFhdFUsTUFBTW1VLFVBQVVycUIsTUFBTW9SLE1BQU0sQ0FBQ0EsT0FBT25RLE1BQU0sR0FBRyxFQUFFLEVBQUUsSUFBSTtnQkFDL0dtUSxNQUFNLENBQUNBLE9BQU9uUSxNQUFNLEdBQUcsRUFBRSxHQUFHc3BCO1lBQ2hDLE9BQ0s7Z0JBQ0QsSUFBSW5aLE9BQU9uUSxNQUFNLEVBQ2JtUSxNQUFNLENBQUNBLE9BQU9uUSxNQUFNLEdBQUcsRUFBRSxHQUFHd3BCLFdBQVdyWixNQUFNLENBQUNBLE9BQU9uUSxNQUFNLEdBQUcsRUFBRSxFQUFFb3BCLFNBQVNwcEIsTUFBTTtnQkFDckYsSUFBSXlwQixVQUFVQyxhQUFhM3FCLE1BQU1rVztnQkFDakM5RSxPQUFPdkgsSUFBSSxDQUFDNmdCO2dCQUNaUCxRQUFRQSxNQUFNUyxTQUFTLENBQUNGLFFBQVFwVixJQUFJO2dCQUNwQytVLFdBQVduVTtZQUNmO1FBQ0o7UUFDQSxJQUFJOUUsUUFDQSxPQUFPMVIsdURBQVFBLENBQUNnQixJQUFJLENBQUMwUTtJQUM3QjtJQUNBLE9BQU84WTtBQUNYO0FBQ0EsU0FBU1MsYUFBYTNxQixJQUFJLEVBQUVrVyxJQUFJLEVBQUV4VixPQUFPLENBQUM7SUFDdEMsSUFBSyxJQUFJd0osSUFBSWdNLEtBQUtqVixNQUFNLEdBQUcsR0FBR2lKLEtBQUt4SixNQUFNd0osSUFDckNsSyxPQUFPa1csSUFBSSxDQUFDaE0sRUFBRSxDQUFDOE0sTUFBTSxDQUFDLE1BQU10WCx1REFBUUEsQ0FBQ2dCLElBQUksQ0FBQ1Y7SUFDOUMsT0FBT0E7QUFDWDtBQUNBLDZEQUE2RDtBQUM3RCw4Q0FBOEM7QUFDOUMsU0FBU3dxQixhQUFhdFUsSUFBSSxFQUFFbVUsUUFBUSxFQUFFcnFCLElBQUksRUFBRTZxQixPQUFPLEVBQUU3WixLQUFLO0lBQ3RELElBQUlBLFFBQVFrRixLQUFLalYsTUFBTSxJQUFJK1AsUUFBUXFaLFNBQVNwcEIsTUFBTSxJQUFJaVYsSUFBSSxDQUFDbEYsTUFBTSxJQUFJcVosUUFBUSxDQUFDclosTUFBTSxFQUFFO1FBQ2xGLElBQUkwQyxRQUFROFcsYUFBYXRVLE1BQU1tVSxVQUFVcnFCLE1BQU02cUIsUUFBUXZkLFNBQVMsRUFBRTBELFFBQVE7UUFDMUUsSUFBSTBDLE9BQ0EsT0FBT21YLFFBQVFuVCxJQUFJLENBQUNtVCxRQUFRcmQsT0FBTyxDQUFDc2QsWUFBWSxDQUFDRCxRQUFRdFIsVUFBVSxHQUFHLEdBQUc3RjtRQUM3RSxJQUFJeVcsUUFBUVUsUUFBUVQsY0FBYyxDQUFDUyxRQUFRdFIsVUFBVTtRQUNyRCxJQUFJNFEsTUFBTVMsU0FBUyxDQUFDNVosU0FBU2tGLEtBQUtqVixNQUFNLEdBQUcsSUFBSWpCLEtBQUtzVixJQUFJLEdBQUdZLElBQUksQ0FBQ2xGLFFBQVEsRUFBRSxHQUN0RSxPQUFPNlosUUFBUW5ULElBQUksQ0FBQ21ULFFBQVFyZCxPQUFPLENBQUN1ZCxNQUFNLENBQUNyckIsdURBQVFBLENBQUNnQixJQUFJLENBQUNpcUIsYUFBYTNxQixNQUFNa1csTUFBTWxGLFFBQVE7SUFDbEc7QUFDSjtBQUNBLFNBQVN5WixXQUFXenFCLElBQUksRUFBRWdSLEtBQUs7SUFDM0IsSUFBSUEsU0FBUyxHQUNULE9BQU9oUjtJQUNYLElBQUlrcUIsV0FBV2xxQixLQUFLd04sT0FBTyxDQUFDc2QsWUFBWSxDQUFDOXFCLEtBQUt1WixVQUFVLEdBQUcsR0FBR2tSLFdBQVd6cUIsS0FBS3NOLFNBQVMsRUFBRTBELFFBQVE7SUFDakcsSUFBSWdhLE9BQU9ockIsS0FBS29xQixjQUFjLENBQUNwcUIsS0FBS3VaLFVBQVUsRUFBRTBSLFVBQVUsQ0FBQ3ZyQix1REFBUUEsQ0FBQzhZLEtBQUssRUFBRTtJQUMzRSxPQUFPeFksS0FBSzBYLElBQUksQ0FBQ3dTLFNBQVNhLE1BQU0sQ0FBQ0M7QUFDckM7QUFDQSxTQUFTRSxXQUFXaEIsUUFBUSxFQUFFOWlCLElBQUksRUFBRTFHLElBQUksRUFBRUMsRUFBRSxFQUFFcVEsS0FBSyxFQUFFNFcsT0FBTztJQUN4RCxJQUFJNW5CLE9BQU9vSCxPQUFPLElBQUk4aUIsU0FBUzllLFVBQVUsR0FBRzhlLFNBQVM1YyxTQUFTLEVBQUVvRyxRQUFRMVQsS0FBS3dOLE9BQU87SUFDcEYsSUFBSTBjLFNBQVMzUSxVQUFVLEdBQUcsR0FDdEJxTyxVQUFVO0lBQ2QsSUFBSTVXLFFBQVFyUSxLQUFLLEdBQ2IrUyxRQUFRd1gsV0FBV3hYLE9BQU90TSxNQUFNMUcsTUFBTUMsSUFBSXFRLFFBQVEsR0FBRzRXO0lBQ3pELElBQUk1VyxTQUFTdFEsTUFDVGdULFFBQVF0TSxPQUFPLElBQUlwSCxLQUFLb3FCLGNBQWMsQ0FBQyxHQUFHYSxVQUFVLENBQUN2WCxPQUFPa1UsV0FBVzVXLE9BQU8rWixNQUFNLENBQUNyWCxTQUMvRUEsTUFBTXFYLE1BQU0sQ0FBQy9xQixLQUFLb3FCLGNBQWMsQ0FBQ3BxQixLQUFLdVosVUFBVSxFQUFFMFIsVUFBVSxDQUFDdnJCLHVEQUFRQSxDQUFDOFksS0FBSyxFQUFFO0lBQ3ZGLE9BQU8wUixTQUFTWSxZQUFZLENBQUMxakIsT0FBTyxJQUFJLElBQUk4aUIsU0FBUzNRLFVBQVUsR0FBRyxHQUFHdlosS0FBSzBYLElBQUksQ0FBQ2hFO0FBQ25GO0FBQ0EsU0FBU29XLFdBQVdyUyxLQUFLLEVBQUVrUSxTQUFTLEVBQUVDLE9BQU87SUFDekMsSUFBSUQsWUFBWWxRLE1BQU1rUSxTQUFTLEVBQzNCbFEsUUFBUSxJQUFJN1gsb0RBQUtBLENBQUNzckIsV0FBV3pULE1BQU1qSyxPQUFPLEVBQUUsQ0FBQyxHQUFHbWEsV0FBV2xRLE1BQU1rUSxTQUFTLEVBQUUsR0FBR2xRLE1BQU1tUSxPQUFPLEdBQUdELFdBQVdsUSxNQUFNbVEsT0FBTztJQUMzSCxJQUFJQSxVQUFVblEsTUFBTW1RLE9BQU8sRUFDdkJuUSxRQUFRLElBQUk3WCxvREFBS0EsQ0FBQ3NyQixXQUFXelQsTUFBTWpLLE9BQU8sRUFBRSxHQUFHb2EsU0FBU25RLE1BQU1tUSxPQUFPLEVBQUUsR0FBRyxJQUFJblEsTUFBTWtRLFNBQVMsRUFBRUM7SUFDbkcsT0FBT25RO0FBQ1g7QUFDQSw4REFBOEQ7QUFDOUQsa0VBQWtFO0FBQ2xFLDhDQUE4QztBQUM5QyxNQUFNMlEsVUFBVTtJQUNaK0MsT0FBTztRQUFDO0tBQVE7SUFDaEJDLE9BQU87UUFBQztLQUFRO0lBQ2hCQyxPQUFPO1FBQUM7S0FBUTtJQUNoQkMsU0FBUztRQUFDO0tBQVE7SUFDbEJDLFVBQVU7UUFBQztLQUFRO0lBQ25CQyxLQUFLO1FBQUM7UUFBUztLQUFXO0lBQzFCdkcsSUFBSTtRQUFDO1FBQVM7S0FBUTtJQUN0QndHLElBQUk7UUFBQztRQUFTO1FBQVM7S0FBSztJQUM1QkMsSUFBSTtRQUFDO1FBQVM7UUFBUztLQUFLO0FBQ2hDO0FBQ0EsSUFBSUMsZUFBZTtBQUNuQixTQUFTMUQ7SUFDTCxPQUFPMEQsZ0JBQWlCQSxDQUFBQSxlQUFlOXFCLFNBQVMrcUIsY0FBYyxDQUFDQyxrQkFBa0IsQ0FBQyxRQUFPO0FBQzdGO0FBQ0EsSUFBSUMsVUFBVTtBQUNkLFNBQVNDLGlCQUFpQnRELElBQUk7SUFDMUIsSUFBSXVELGVBQWUzSyxPQUFPMkssWUFBWTtJQUN0QyxJQUFJLENBQUNBLGNBQ0QsT0FBT3ZEO0lBQ1gsNERBQTREO0lBQzVELG1FQUFtRTtJQUNuRSxpRUFBaUU7SUFDakUsSUFBSSxDQUFDcUQsU0FDREEsVUFBVUUsYUFBYUMsWUFBWSxDQUFDLHdCQUF3QjtRQUFFQyxZQUFZLENBQUNDLElBQU1BO0lBQUU7SUFDdkYsT0FBT0wsUUFBUUksVUFBVSxDQUFDekQ7QUFDOUI7QUFDQSxTQUFTVSxTQUFTVixJQUFJO0lBQ2xCLElBQUkyRCxRQUFRLHNCQUFzQnBuQixJQUFJLENBQUN5akI7SUFDdkMsSUFBSTJELE9BQ0EzRCxPQUFPQSxLQUFLaFIsS0FBSyxDQUFDMlUsS0FBSyxDQUFDLEVBQUUsQ0FBQ25yQixNQUFNO0lBQ3JDLElBQUkyQyxNQUFNcWtCLGNBQWM5UixhQUFhLENBQUM7SUFDdEMsSUFBSWtXLFdBQVcsbUJBQW1Ccm5CLElBQUksQ0FBQ3lqQixPQUFPdlM7SUFDOUMsSUFBSUEsT0FBT21XLFlBQVlqRSxPQUFPLENBQUNpRSxRQUFRLENBQUMsRUFBRSxDQUFDbFAsV0FBVyxHQUFHLEVBQ3JEc0wsT0FBT3ZTLEtBQUtvVyxHQUFHLENBQUN0USxDQUFBQSxJQUFLLE1BQU1BLElBQUksS0FBS3VRLElBQUksQ0FBQyxNQUFNOUQsT0FBT3ZTLEtBQUtvVyxHQUFHLENBQUN0USxDQUFBQSxJQUFLLE9BQU9BLElBQUksS0FBS3VFLE9BQU8sR0FBR2dNLElBQUksQ0FBQztJQUN2RzNvQixJQUFJNG9CLFNBQVMsR0FBR1QsaUJBQWlCdEQ7SUFDakMsSUFBSXZTLE1BQ0EsSUFBSyxJQUFJaE0sSUFBSSxHQUFHQSxJQUFJZ00sS0FBS2pWLE1BQU0sRUFBRWlKLElBQzdCdEcsTUFBTUEsSUFBSTBsQixhQUFhLENBQUNwVCxJQUFJLENBQUNoTSxFQUFFLEtBQUt0RztJQUM1QyxPQUFPQTtBQUNYO0FBQ0EsaUVBQWlFO0FBQ2pFLDhEQUE4RDtBQUM5RCxtRUFBbUU7QUFDbkUsK0RBQStEO0FBQy9ELDJEQUEyRDtBQUMzRCxTQUFTd2xCLHNCQUFzQjdtQixHQUFHO0lBQzlCLElBQUlvVixRQUFRcFYsSUFBSWtxQixnQkFBZ0IsQ0FBQ2puQixTQUFTLG1DQUFtQztJQUM3RSxJQUFLLElBQUkwRSxJQUFJLEdBQUdBLElBQUl5TixNQUFNMVcsTUFBTSxFQUFFaUosSUFBSztRQUNuQyxJQUFJbEssT0FBTzJYLEtBQUssQ0FBQ3pOLEVBQUU7UUFDbkIsSUFBSWxLLEtBQUtnQyxVQUFVLENBQUNmLE1BQU0sSUFBSSxLQUFLakIsS0FBS3dRLFdBQVcsSUFBSSxVQUFZeFEsS0FBS0csVUFBVSxFQUM5RUgsS0FBS0csVUFBVSxDQUFDMnFCLFlBQVksQ0FBQ3ZvQixJQUFJMkYsYUFBYSxDQUFDNlAsY0FBYyxDQUFDLE1BQU0vWDtJQUM1RTtBQUNKO0FBQ0EsU0FBUzZwQixXQUFXcFMsS0FBSyxFQUFFaVEsT0FBTztJQUM5QixJQUFJLENBQUNqUSxNQUFNaEssSUFBSSxFQUNYLE9BQU9nSztJQUNYLElBQUl1USxTQUFTdlEsTUFBTWpLLE9BQU8sQ0FBQ3BDLFVBQVUsQ0FBQ2tLLElBQUksQ0FBQzBTLE1BQU0sRUFBRTBFO0lBQ25ELElBQUk7UUFDQUEsUUFBUXJFLEtBQUtzRSxLQUFLLENBQUNqRjtJQUN2QixFQUNBLE9BQU8zSSxHQUFHO1FBQ04sT0FBT3RIO0lBQ1g7SUFDQSxJQUFJLEVBQUVqSyxPQUFPLEVBQUVtYSxTQUFTLEVBQUVDLE9BQU8sRUFBRSxHQUFHblE7SUFDdEMsSUFBSyxJQUFJdk4sSUFBSXdpQixNQUFNenJCLE1BQU0sR0FBRyxHQUFHaUosS0FBSyxHQUFHQSxLQUFLLEVBQUc7UUFDM0MsSUFBSW9MLE9BQU8wUyxPQUFPclEsS0FBSyxDQUFDK1UsS0FBSyxDQUFDeGlCLEVBQUUsQ0FBQztRQUNqQyxJQUFJLENBQUNvTCxRQUFRQSxLQUFLc1gsZ0JBQWdCLElBQzlCO1FBQ0pwZixVQUFVOU4sdURBQVFBLENBQUNnQixJQUFJLENBQUM0VSxLQUFLMEIsTUFBTSxDQUFDMFYsS0FBSyxDQUFDeGlCLElBQUksRUFBRSxFQUFFc0Q7UUFDbERtYTtRQUNBQztJQUNKO0lBQ0EsT0FBTyxJQUFJaG9CLG9EQUFLQSxDQUFDNE4sU0FBU21hLFdBQVdDO0FBQ3pDO0FBRUEsa0ZBQWtGO0FBQ2xGLGtDQUFrQztBQUNsQyxNQUFNaUYsV0FBVyxDQUFDO0FBQ2xCLE1BQU1DLGVBQWUsQ0FBQztBQUN0QixNQUFNQyxrQkFBa0I7SUFBRUMsWUFBWTtJQUFNQyxXQUFXO0FBQUs7QUFDNUQsTUFBTUM7SUFDRmxiLGFBQWM7UUFDVixJQUFJLENBQUN1VixRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDM0UsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ3VLLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNDLFNBQVMsR0FBRztZQUFFQyxNQUFNO1lBQUd0cEIsR0FBRztZQUFHQyxHQUFHO1lBQUdxUixNQUFNO1FBQUc7UUFDakQsSUFBSSxDQUFDaVksbUJBQW1CLEdBQUc7UUFDM0IsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLDJCQUEyQixHQUFHLENBQUM7UUFDcEMsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNoVixTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDMkIsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ3NULGdCQUFnQixHQUFHLENBQUM7UUFDekIsSUFBSSxDQUFDalQsZ0JBQWdCLEdBQUcsRUFBRTtRQUMxQixJQUFJLENBQUNrVCxrQkFBa0IsR0FBRyxDQUFDO1FBQzNCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLDJFQUEyRTtRQUMzRSxJQUFJLENBQUNDLHlCQUF5QixHQUFHO1FBQ2pDLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsYUFBYSxHQUFHMVIsT0FBT3pGLE1BQU0sQ0FBQztRQUNuQyxJQUFJLENBQUNpTixrQkFBa0IsR0FBRztJQUM5QjtBQUNKO0FBQ0EsU0FBU21LLFVBQVV2bUIsSUFBSTtJQUNuQixJQUFLLElBQUl2RSxTQUFTdXBCLFNBQVU7UUFDeEIsSUFBSXdCLFVBQVV4QixRQUFRLENBQUN2cEIsTUFBTTtRQUM3QnVFLEtBQUt0RixHQUFHLENBQUMyaEIsZ0JBQWdCLENBQUM1Z0IsT0FBT3VFLEtBQUswUyxLQUFLLENBQUM0VCxhQUFhLENBQUM3cUIsTUFBTSxHQUFHLENBQUNBO1lBQ2hFLElBQUlnckIsbUJBQW1Cem1CLE1BQU12RSxVQUFVLENBQUNpckIsaUJBQWlCMW1CLE1BQU12RSxVQUMxRHVFLENBQUFBLEtBQUswYSxRQUFRLElBQUksQ0FBRWpmLENBQUFBLE1BQU1nUyxJQUFJLElBQUl3WCxZQUFXLENBQUMsR0FDOUN1QixRQUFReG1CLE1BQU12RTtRQUN0QixHQUFHeXBCLGVBQWUsQ0FBQ3pwQixNQUFNLEdBQUc7WUFBRWtyQixTQUFTO1FBQUssSUFBSS9qQjtJQUNwRDtJQUNBLGtFQUFrRTtJQUNsRSxtRUFBbUU7SUFDbkUsMkJBQTJCO0lBQzNCLElBQUkvRSxRQUNBbUMsS0FBS3RGLEdBQUcsQ0FBQzJoQixnQkFBZ0IsQ0FBQyxTQUFTLElBQU07SUFDN0N1SyxnQkFBZ0I1bUI7QUFDcEI7QUFDQSxTQUFTNm1CLG1CQUFtQjdtQixJQUFJLEVBQUUrWixNQUFNO0lBQ3BDL1osS0FBSzBTLEtBQUssQ0FBQ2dULG1CQUFtQixHQUFHM0w7SUFDakMvWixLQUFLMFMsS0FBSyxDQUFDaVQsaUJBQWlCLEdBQUdtQixLQUFLQyxHQUFHO0FBQzNDO0FBQ0EsU0FBU0MsYUFBYWhuQixJQUFJO0lBQ3RCQSxLQUFLa2IsV0FBVyxDQUFDdE0sSUFBSTtJQUNyQixJQUFLLElBQUluQixRQUFRek4sS0FBSzBTLEtBQUssQ0FBQzRULGFBQWEsQ0FDckN0bUIsS0FBS3RGLEdBQUcsQ0FBQ3loQixtQkFBbUIsQ0FBQzFPLE1BQU16TixLQUFLMFMsS0FBSyxDQUFDNFQsYUFBYSxDQUFDN1ksS0FBSztJQUNyRXdaLGFBQWFqbkIsS0FBSzBTLEtBQUssQ0FBQ3VULGdCQUFnQjtJQUN4Q2dCLGFBQWFqbkIsS0FBSzBTLEtBQUssQ0FBQ21ULDJCQUEyQjtBQUN2RDtBQUNBLFNBQVNlLGdCQUFnQjVtQixJQUFJO0lBQ3pCQSxLQUFLRyxRQUFRLENBQUMsbUJBQW1CK21CLENBQUFBO1FBQzdCLElBQUssSUFBSXpaLFFBQVF5WixnQkFDYixJQUFJLENBQUNsbkIsS0FBSzBTLEtBQUssQ0FBQzRULGFBQWEsQ0FBQzdZLEtBQUssRUFDL0J6TixLQUFLdEYsR0FBRyxDQUFDMmhCLGdCQUFnQixDQUFDNU8sTUFBTXpOLEtBQUswUyxLQUFLLENBQUM0VCxhQUFhLENBQUM3WSxLQUFLLEdBQUdoUyxDQUFBQSxRQUFTaXJCLGlCQUFpQjFtQixNQUFNdkU7SUFDN0c7QUFDSjtBQUNBLFNBQVNpckIsaUJBQWlCMW1CLElBQUksRUFBRXZFLEtBQUs7SUFDakMsT0FBT3VFLEtBQUtHLFFBQVEsQ0FBQyxtQkFBbUI2a0IsQ0FBQUE7UUFDcEMsSUFBSXdCLFVBQVV4QixRQUFRLENBQUN2cEIsTUFBTWdTLElBQUksQ0FBQztRQUNsQyxPQUFPK1ksVUFBVUEsUUFBUXhtQixNQUFNdkUsVUFBVUEsTUFBTTByQixnQkFBZ0IsR0FBRztJQUN0RTtBQUNKO0FBQ0EsU0FBU1YsbUJBQW1Cem1CLElBQUksRUFBRXZFLEtBQUs7SUFDbkMsSUFBSSxDQUFDQSxNQUFNMnJCLE9BQU8sRUFDZCxPQUFPO0lBQ1gsSUFBSTNyQixNQUFNMHJCLGdCQUFnQixFQUN0QixPQUFPO0lBQ1gsSUFBSyxJQUFJaHZCLE9BQU9zRCxNQUFNd0ssTUFBTSxFQUFFOU4sUUFBUTZILEtBQUt0RixHQUFHLEVBQUV2QyxPQUFPQSxLQUFLRyxVQUFVLENBQ2xFLElBQUksQ0FBQ0gsUUFBUUEsS0FBS00sUUFBUSxJQUFJLE1BQ3pCTixLQUFLMEMsVUFBVSxJQUFJMUMsS0FBSzBDLFVBQVUsQ0FBQ2tRLFNBQVMsQ0FBQ3RQLFFBQzlDLE9BQU87SUFDZixPQUFPO0FBQ1g7QUFDQSxTQUFTNHJCLGNBQWNybkIsSUFBSSxFQUFFdkUsS0FBSztJQUM5QixJQUFJLENBQUNpckIsaUJBQWlCMW1CLE1BQU12RSxVQUFVdXBCLFFBQVEsQ0FBQ3ZwQixNQUFNZ1MsSUFBSSxDQUFDLElBQ3JEek4sQ0FBQUEsS0FBSzBhLFFBQVEsSUFBSSxDQUFFamYsQ0FBQUEsTUFBTWdTLElBQUksSUFBSXdYLFlBQVcsQ0FBQyxHQUM5Q0QsUUFBUSxDQUFDdnBCLE1BQU1nUyxJQUFJLENBQUMsQ0FBQ3pOLE1BQU12RTtBQUNuQztBQUNBd3BCLGFBQWFxQyxPQUFPLEdBQUcsQ0FBQ3RuQixNQUFNdW5CO0lBQzFCLElBQUk5ckIsUUFBUThyQjtJQUNadm5CLEtBQUswUyxLQUFLLENBQUNnTixRQUFRLEdBQUdqa0IsTUFBTUYsT0FBTyxJQUFJLE1BQU1FLE1BQU1pa0IsUUFBUTtJQUMzRCxJQUFJOEgsb0JBQW9CeG5CLE1BQU12RSxRQUMxQjtJQUNKdUUsS0FBSzBTLEtBQUssQ0FBQzRTLFdBQVcsR0FBRzdwQixNQUFNRixPQUFPO0lBQ3RDeUUsS0FBSzBTLEtBQUssQ0FBQzZTLGVBQWUsR0FBR3VCLEtBQUtDLEdBQUc7SUFDckMsa0VBQWtFO0lBQ2xFLGlFQUFpRTtJQUNqRSx3REFBd0Q7SUFDeEQsSUFBSTNvQixXQUFXVCxVQUFVbEMsTUFBTUYsT0FBTyxJQUFJLElBQ3RDO0lBQ0osSUFBSUUsTUFBTUYsT0FBTyxJQUFJLEtBQ2pCeUUsS0FBS2tiLFdBQVcsQ0FBQ3VNLFVBQVU7SUFDL0IsOERBQThEO0lBQzlELGlFQUFpRTtJQUNqRSxvRUFBb0U7SUFDcEUscURBQXFEO0lBQ3JELElBQUkxcEIsT0FBT3RDLE1BQU1GLE9BQU8sSUFBSSxNQUFNLENBQUNFLE1BQU04akIsT0FBTyxJQUFJLENBQUM5akIsTUFBTWdrQixNQUFNLElBQUksQ0FBQ2hrQixNQUFNK2pCLE9BQU8sRUFBRTtRQUNqRixJQUFJdUgsTUFBTUQsS0FBS0MsR0FBRztRQUNsQi9tQixLQUFLMFMsS0FBSyxDQUFDa1QsWUFBWSxHQUFHbUI7UUFDMUIvbUIsS0FBSzBTLEtBQUssQ0FBQ21ULDJCQUEyQixHQUFHdkosV0FBVztZQUNoRCxJQUFJdGMsS0FBSzBTLEtBQUssQ0FBQ2tULFlBQVksSUFBSW1CLEtBQUs7Z0JBQ2hDL21CLEtBQUtHLFFBQVEsQ0FBQyxpQkFBaUJvSCxDQUFBQSxJQUFLQSxFQUFFdkgsTUFBTTFFLFNBQVMsSUFBSTtnQkFDekQwRSxLQUFLMFMsS0FBSyxDQUFDa1QsWUFBWSxHQUFHO1lBQzlCO1FBQ0osR0FBRztJQUNQLE9BQ0ssSUFBSTVsQixLQUFLRyxRQUFRLENBQUMsaUJBQWlCb0gsQ0FBQUEsSUFBS0EsRUFBRXZILE1BQU12RSxXQUFXa2tCLGVBQWUzZixNQUFNdkUsUUFBUTtRQUN6RkEsTUFBTWlzQixjQUFjO0lBQ3hCLE9BQ0s7UUFDRGIsbUJBQW1CN21CLE1BQU07SUFDN0I7QUFDSjtBQUNBaWxCLGFBQWEwQyxLQUFLLEdBQUcsQ0FBQzNuQixNQUFNdkU7SUFDeEIsSUFBSUEsTUFBTUYsT0FBTyxJQUFJLElBQ2pCeUUsS0FBSzBTLEtBQUssQ0FBQ2dOLFFBQVEsR0FBRztBQUM5QjtBQUNBdUYsYUFBYTJDLFFBQVEsR0FBRyxDQUFDNW5CLE1BQU11bkI7SUFDM0IsSUFBSTlyQixRQUFROHJCO0lBQ1osSUFBSUMsb0JBQW9CeG5CLE1BQU12RSxVQUFVLENBQUNBLE1BQU1vc0IsUUFBUSxJQUNuRHBzQixNQUFNOGpCLE9BQU8sSUFBSSxDQUFDOWpCLE1BQU1na0IsTUFBTSxJQUFJeGhCLE9BQU94QyxNQUFNK2pCLE9BQU8sRUFDdEQ7SUFDSixJQUFJeGYsS0FBS0csUUFBUSxDQUFDLGtCQUFrQm9ILENBQUFBLElBQUtBLEVBQUV2SCxNQUFNdkUsU0FBUztRQUN0REEsTUFBTWlzQixjQUFjO1FBQ3BCO0lBQ0o7SUFDQSxJQUFJOWYsTUFBTTVILEtBQUswRixLQUFLLENBQUNtQyxTQUFTO0lBQzlCLElBQUksQ0FBRUQsQ0FBQUEsZUFBZXBRLDREQUFZLEtBQU0sQ0FBQ29RLElBQUlHLEtBQUssQ0FBQ2tYLFVBQVUsQ0FBQ3JYLElBQUlJLEdBQUcsR0FBRztRQUNuRSxJQUFJZ0csT0FBTzhaLE9BQU9DLFlBQVksQ0FBQ3RzQixNQUFNb3NCLFFBQVE7UUFDN0MsSUFBSSxDQUFDLFNBQVM3dEIsSUFBSSxDQUFDZ1UsU0FBUyxDQUFDaE8sS0FBS0csUUFBUSxDQUFDLG1CQUFtQm9ILENBQUFBLElBQUtBLEVBQUV2SCxNQUFNNEgsSUFBSUcsS0FBSyxDQUFDekwsR0FBRyxFQUFFc0wsSUFBSUksR0FBRyxDQUFDMUwsR0FBRyxFQUFFMFIsUUFDbkdoTyxLQUFLbWQsUUFBUSxDQUFDbmQsS0FBSzBGLEtBQUssQ0FBQzBYLEVBQUUsQ0FBQzRLLFVBQVUsQ0FBQ2hhLE1BQU1xUCxjQUFjO1FBQy9ENWhCLE1BQU1pc0IsY0FBYztJQUN4QjtBQUNKO0FBQ0EsU0FBU08sWUFBWXhzQixLQUFLO0lBQUksT0FBTztRQUFFb0QsTUFBTXBELE1BQU15c0IsT0FBTztRQUFFbHBCLEtBQUt2RCxNQUFNMHNCLE9BQU87SUFBQztBQUFHO0FBQ2xGLFNBQVNDLE9BQU8zc0IsS0FBSyxFQUFFNHNCLEtBQUs7SUFDeEIsSUFBSXprQixLQUFLeWtCLE1BQU1sc0IsQ0FBQyxHQUFHVixNQUFNeXNCLE9BQU8sRUFBRUksS0FBS0QsTUFBTWpzQixDQUFDLEdBQUdYLE1BQU0wc0IsT0FBTztJQUM5RCxPQUFPdmtCLEtBQUtBLEtBQUswa0IsS0FBS0EsS0FBSztBQUMvQjtBQUNBLFNBQVNDLG9CQUFvQnZvQixJQUFJLEVBQUV3b0IsUUFBUSxFQUFFbHNCLEdBQUcsRUFBRXVKLE1BQU0sRUFBRXBLLEtBQUs7SUFDM0QsSUFBSW9LLFVBQVUsQ0FBQyxHQUNYLE9BQU87SUFDWCxJQUFJaUMsT0FBTzlILEtBQUswRixLQUFLLENBQUM1SixHQUFHLENBQUNtTCxPQUFPLENBQUNwQjtJQUNsQyxJQUFLLElBQUl4RCxJQUFJeUYsS0FBS3FCLEtBQUssR0FBRyxHQUFHOUcsSUFBSSxHQUFHQSxJQUFLO1FBQ3JDLElBQUlyQyxLQUFLRyxRQUFRLENBQUNxb0IsVUFBVWpoQixDQUFBQSxJQUFLbEYsSUFBSXlGLEtBQUtxQixLQUFLLEdBQUc1QixFQUFFdkgsTUFBTTFELEtBQUt3TCxLQUFLNFYsU0FBUyxFQUFFNVYsS0FBS2pELE1BQU0sQ0FBQ3hDLElBQUk1RyxPQUFPLFFBQ2hHOEwsRUFBRXZILE1BQU0xRCxLQUFLd0wsS0FBSzNQLElBQUksQ0FBQ2tLLElBQUl5RixLQUFLakQsTUFBTSxDQUFDeEMsSUFBSTVHLE9BQU8sU0FDcEQsT0FBTztJQUNmO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBU2d0QixnQkFBZ0J6b0IsSUFBSSxFQUFFNkgsU0FBUyxFQUFFa1MsTUFBTTtJQUM1QyxJQUFJLENBQUMvWixLQUFLMG9CLE9BQU8sRUFDYjFvQixLQUFLeUMsS0FBSztJQUNkLElBQUl6QyxLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUyxDQUFDNkcsRUFBRSxDQUFDN0csWUFDeEI7SUFDSixJQUFJdVYsS0FBS3BkLEtBQUswRixLQUFLLENBQUMwWCxFQUFFLENBQUMxUSxZQUFZLENBQUM3RTtJQUNwQyxJQUFJa1MsVUFBVSxXQUNWcUQsR0FBR3VMLE9BQU8sQ0FBQyxXQUFXO0lBQzFCM29CLEtBQUttZCxRQUFRLENBQUNDO0FBQ2xCO0FBQ0EsU0FBU3dMLGtCQUFrQjVvQixJQUFJLEVBQUU2RixNQUFNO0lBQ25DLElBQUlBLFVBQVUsQ0FBQyxHQUNYLE9BQU87SUFDWCxJQUFJaUMsT0FBTzlILEtBQUswRixLQUFLLENBQUM1SixHQUFHLENBQUNtTCxPQUFPLENBQUNwQixTQUFTMU4sT0FBTzJQLEtBQUs0VixTQUFTO0lBQ2hFLElBQUl2bEIsUUFBUUEsS0FBSzBiLE1BQU0sSUFBSXBjLDREQUFhQSxDQUFDeWlCLFlBQVksQ0FBQy9oQixPQUFPO1FBQ3pEc3dCLGdCQUFnQnpvQixNQUFNLElBQUl2SSw0REFBYUEsQ0FBQ3FRLE9BQU87UUFDL0MsT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBUytnQixrQkFBa0I3b0IsSUFBSSxFQUFFNkYsTUFBTTtJQUNuQyxJQUFJQSxVQUFVLENBQUMsR0FDWCxPQUFPO0lBQ1gsSUFBSStCLE1BQU01SCxLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUyxFQUFFaWhCLGNBQWNDO0lBQzlDLElBQUluaEIsZUFBZW5RLDREQUFhQSxFQUM1QnF4QixlQUFlbGhCLElBQUl6UCxJQUFJO0lBQzNCLElBQUkyUCxPQUFPOUgsS0FBSzBGLEtBQUssQ0FBQzVKLEdBQUcsQ0FBQ21MLE9BQU8sQ0FBQ3BCO0lBQ2xDLElBQUssSUFBSXhELElBQUl5RixLQUFLcUIsS0FBSyxHQUFHLEdBQUc5RyxJQUFJLEdBQUdBLElBQUs7UUFDckMsSUFBSWxLLE9BQU9rSyxJQUFJeUYsS0FBS3FCLEtBQUssR0FBR3JCLEtBQUs0VixTQUFTLEdBQUc1VixLQUFLM1AsSUFBSSxDQUFDa0s7UUFDdkQsSUFBSTVLLDREQUFhQSxDQUFDeWlCLFlBQVksQ0FBQy9oQixPQUFPO1lBQ2xDLElBQUkyd0IsZ0JBQWdCbGhCLElBQUlHLEtBQUssQ0FBQ29CLEtBQUssR0FBRyxLQUNsQzlHLEtBQUt1RixJQUFJRyxLQUFLLENBQUNvQixLQUFLLElBQUlyQixLQUFLakQsTUFBTSxDQUFDK0MsSUFBSUcsS0FBSyxDQUFDb0IsS0FBSyxHQUFHLE1BQU12QixJQUFJRyxLQUFLLENBQUN6TCxHQUFHLEVBQ3pFeXNCLFdBQVdqaEIsS0FBS2pELE1BQU0sQ0FBQytDLElBQUlHLEtBQUssQ0FBQ29CLEtBQUs7aUJBRXRDNGYsV0FBV2poQixLQUFLakQsTUFBTSxDQUFDeEM7WUFDM0I7UUFDSjtJQUNKO0lBQ0EsSUFBSTBtQixZQUFZLE1BQU07UUFDbEJOLGdCQUFnQnpvQixNQUFNdkksNERBQWFBLENBQUMwWCxNQUFNLENBQUNuUCxLQUFLMEYsS0FBSyxDQUFDNUosR0FBRyxFQUFFaXRCLFdBQVc7UUFDdEUsT0FBTztJQUNYLE9BQ0s7UUFDRCxPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNDLGtCQUFrQmhwQixJQUFJLEVBQUUxRCxHQUFHLEVBQUV1SixNQUFNLEVBQUVwSyxLQUFLLEVBQUVnWSxVQUFVO0lBQzNELE9BQU84VSxvQkFBb0J2b0IsTUFBTSxpQkFBaUIxRCxLQUFLdUosUUFBUXBLLFVBQzNEdUUsS0FBS0csUUFBUSxDQUFDLGVBQWVvSCxDQUFBQSxJQUFLQSxFQUFFdkgsTUFBTTFELEtBQUtiLFdBQzlDZ1ksQ0FBQUEsYUFBYW9WLGtCQUFrQjdvQixNQUFNNkYsVUFBVStpQixrQkFBa0I1b0IsTUFBTTZGLE9BQU07QUFDdEY7QUFDQSxTQUFTb2pCLGtCQUFrQmpwQixJQUFJLEVBQUUxRCxHQUFHLEVBQUV1SixNQUFNLEVBQUVwSyxLQUFLO0lBQy9DLE9BQU84c0Isb0JBQW9Cdm9CLE1BQU0sdUJBQXVCMUQsS0FBS3VKLFFBQVFwSyxVQUNqRXVFLEtBQUtHLFFBQVEsQ0FBQyxxQkFBcUJvSCxDQUFBQSxJQUFLQSxFQUFFdkgsTUFBTTFELEtBQUtiO0FBQzdEO0FBQ0EsU0FBU3l0QixrQkFBa0JscEIsSUFBSSxFQUFFMUQsR0FBRyxFQUFFdUosTUFBTSxFQUFFcEssS0FBSztJQUMvQyxPQUFPOHNCLG9CQUFvQnZvQixNQUFNLHVCQUF1QjFELEtBQUt1SixRQUFRcEssVUFDakV1RSxLQUFLRyxRQUFRLENBQUMscUJBQXFCb0gsQ0FBQUEsSUFBS0EsRUFBRXZILE1BQU0xRCxLQUFLYixXQUNyRDB0QixtQkFBbUJucEIsTUFBTTZGLFFBQVFwSztBQUN6QztBQUNBLFNBQVMwdEIsbUJBQW1CbnBCLElBQUksRUFBRTZGLE1BQU0sRUFBRXBLLEtBQUs7SUFDM0MsSUFBSUEsTUFBTTJ0QixNQUFNLElBQUksR0FDaEIsT0FBTztJQUNYLElBQUl0dEIsTUFBTWtFLEtBQUswRixLQUFLLENBQUM1SixHQUFHO0lBQ3hCLElBQUkrSixVQUFVLENBQUMsR0FBRztRQUNkLElBQUkvSixJQUFJb0wsYUFBYSxFQUFFO1lBQ25CdWhCLGdCQUFnQnpvQixNQUFNeEksNERBQWFBLENBQUMyWCxNQUFNLENBQUNyVCxLQUFLLEdBQUdBLElBQUk2SixPQUFPLENBQUNDLElBQUksR0FBRztZQUN0RSxPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQSxJQUFJa0MsT0FBT2hNLElBQUltTCxPQUFPLENBQUNwQjtJQUN2QixJQUFLLElBQUl4RCxJQUFJeUYsS0FBS3FCLEtBQUssR0FBRyxHQUFHOUcsSUFBSSxHQUFHQSxJQUFLO1FBQ3JDLElBQUlsSyxPQUFPa0ssSUFBSXlGLEtBQUtxQixLQUFLLEdBQUdyQixLQUFLNFYsU0FBUyxHQUFHNVYsS0FBSzNQLElBQUksQ0FBQ2tLO1FBQ3ZELElBQUl1YixVQUFVOVYsS0FBS2pELE1BQU0sQ0FBQ3hDO1FBQzFCLElBQUlsSyxLQUFLK08sYUFBYSxFQUNsQnVoQixnQkFBZ0J6b0IsTUFBTXhJLDREQUFhQSxDQUFDMlgsTUFBTSxDQUFDclQsS0FBSzhoQixVQUFVLEdBQUdBLFVBQVUsSUFBSXpsQixLQUFLd04sT0FBTyxDQUFDQyxJQUFJLEdBQUc7YUFDOUYsSUFBSW5PLDREQUFhQSxDQUFDeWlCLFlBQVksQ0FBQy9oQixPQUNoQ3N3QixnQkFBZ0J6b0IsTUFBTXZJLDREQUFhQSxDQUFDMFgsTUFBTSxDQUFDclQsS0FBSzhoQixVQUFVO2FBRTFEO1FBQ0osT0FBTztJQUNYO0FBQ0o7QUFDQSxTQUFTeUwsY0FBY3JwQixJQUFJO0lBQ3ZCLE9BQU9zcEIsZUFBZXRwQjtBQUMxQjtBQUNBLE1BQU11cEIscUJBQXFCdHJCLE1BQU0sWUFBWTtBQUM3QyttQixTQUFTd0UsU0FBUyxHQUFHLENBQUN4cEIsTUFBTXVuQjtJQUN4QixJQUFJOXJCLFFBQVE4ckI7SUFDWnZuQixLQUFLMFMsS0FBSyxDQUFDZ04sUUFBUSxHQUFHamtCLE1BQU1pa0IsUUFBUTtJQUNwQyxJQUFJK0osVUFBVUosY0FBY3JwQjtJQUM1QixJQUFJK21CLE1BQU1ELEtBQUtDLEdBQUcsSUFBSXRaLE9BQU87SUFDN0IsSUFBSXNaLE1BQU0vbUIsS0FBSzBTLEtBQUssQ0FBQzhTLFNBQVMsQ0FBQ0MsSUFBSSxHQUFHLE9BQU8yQyxPQUFPM3NCLE9BQU91RSxLQUFLMFMsS0FBSyxDQUFDOFMsU0FBUyxLQUFLLENBQUMvcEIsS0FBSyxDQUFDOHRCLG1CQUFtQixFQUFFO1FBQzVHLElBQUl2cEIsS0FBSzBTLEtBQUssQ0FBQzhTLFNBQVMsQ0FBQy9YLElBQUksSUFBSSxlQUM3QkEsT0FBTzthQUNOLElBQUl6TixLQUFLMFMsS0FBSyxDQUFDOFMsU0FBUyxDQUFDL1gsSUFBSSxJQUFJLGVBQ2xDQSxPQUFPO0lBQ2Y7SUFDQXpOLEtBQUswUyxLQUFLLENBQUM4UyxTQUFTLEdBQUc7UUFBRUMsTUFBTXNCO1FBQUs1cUIsR0FBR1YsTUFBTXlzQixPQUFPO1FBQUU5ckIsR0FBR1gsTUFBTTBzQixPQUFPO1FBQUUxYTtJQUFLO0lBQzdFLElBQUluUixNQUFNMEQsS0FBS21GLFdBQVcsQ0FBQzhpQixZQUFZeHNCO0lBQ3ZDLElBQUksQ0FBQ2EsS0FDRDtJQUNKLElBQUltUixRQUFRLGVBQWU7UUFDdkIsSUFBSXpOLEtBQUswUyxLQUFLLENBQUNxSSxTQUFTLEVBQ3BCL2EsS0FBSzBTLEtBQUssQ0FBQ3FJLFNBQVMsQ0FBQzJPLElBQUk7UUFDN0IxcEIsS0FBSzBTLEtBQUssQ0FBQ3FJLFNBQVMsR0FBRyxJQUFJNE8sVUFBVTNwQixNQUFNMUQsS0FBS2IsT0FBTyxDQUFDLENBQUNndUI7SUFDN0QsT0FDSyxJQUFJLENBQUNoYyxRQUFRLGdCQUFnQndiLG9CQUFvQkMsaUJBQWdCLEVBQUdscEIsTUFBTTFELElBQUlBLEdBQUcsRUFBRUEsSUFBSXVKLE1BQU0sRUFBRXBLLFFBQVE7UUFDeEdBLE1BQU1pc0IsY0FBYztJQUN4QixPQUNLO1FBQ0RiLG1CQUFtQjdtQixNQUFNO0lBQzdCO0FBQ0o7QUFDQSxNQUFNMnBCO0lBQ0Z4ZixZQUFZbkssSUFBSSxFQUFFMUQsR0FBRyxFQUFFYixLQUFLLEVBQUVndUIsT0FBTyxDQUFFO1FBQ25DLElBQUksQ0FBQ3pwQixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDMUQsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ2IsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ2d1QixPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDck8sb0JBQW9CLEdBQUc7UUFDNUIsSUFBSSxDQUFDd08sU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsUUFBUSxHQUFHN3BCLEtBQUswRixLQUFLLENBQUM1SixHQUFHO1FBQzlCLElBQUksQ0FBQzJYLFVBQVUsR0FBRyxDQUFDLENBQUNoWSxLQUFLLENBQUM4dEIsbUJBQW1CO1FBQzdDLElBQUksQ0FBQ3ZPLFlBQVksR0FBR3ZmLE1BQU1pa0IsUUFBUTtRQUNsQyxJQUFJam1CLFlBQVlxd0I7UUFDaEIsSUFBSXh0QixJQUFJdUosTUFBTSxHQUFHLENBQUMsR0FBRztZQUNqQnBNLGFBQWF1RyxLQUFLMEYsS0FBSyxDQUFDNUosR0FBRyxDQUFDaXVCLE1BQU0sQ0FBQ3p0QixJQUFJdUosTUFBTTtZQUM3Q2lrQixZQUFZeHRCLElBQUl1SixNQUFNO1FBQzFCLE9BQ0s7WUFDRCxJQUFJaUMsT0FBTzlILEtBQUswRixLQUFLLENBQUM1SixHQUFHLENBQUNtTCxPQUFPLENBQUMzSyxJQUFJQSxHQUFHO1lBQ3pDN0MsYUFBYXFPLEtBQUt2UCxNQUFNO1lBQ3hCdXhCLFlBQVloaUIsS0FBS3FCLEtBQUssR0FBR3JCLEtBQUtqRCxNQUFNLEtBQUs7UUFDN0M7UUFDQSxNQUFNb0IsU0FBU3dqQixVQUFVLE9BQU9odUIsTUFBTXdLLE1BQU07UUFDNUMsTUFBTStRLGFBQWEvUSxTQUFTakcsS0FBS29FLE9BQU8sQ0FBQ0ssV0FBVyxDQUFDd0IsUUFBUSxRQUFRO1FBQ3JFLElBQUksQ0FBQ0EsTUFBTSxHQUFHK1EsY0FBY0EsV0FBV3RjLEdBQUcsQ0FBQ2pDLFFBQVEsSUFBSSxJQUFJdWUsV0FBV3RjLEdBQUcsR0FBRztRQUM1RSxJQUFJLEVBQUVtTixTQUFTLEVBQUUsR0FBRzdILEtBQUswRixLQUFLO1FBQzlCLElBQUlqSyxNQUFNMnRCLE1BQU0sSUFBSSxLQUNoQjN2QixXQUFXZ1UsSUFBSSxDQUFDVSxJQUFJLENBQUM3SSxTQUFTLElBQUk3TCxXQUFXZ1UsSUFBSSxDQUFDVSxJQUFJLENBQUM2YixVQUFVLEtBQUssU0FDdEVuaUIscUJBQXFCcFEsNERBQWFBLElBQUlvUSxVQUFVaFAsSUFBSSxJQUFJaXhCLGFBQWFqaUIsVUFBVS9PLEVBQUUsR0FBR2d4QixXQUNwRixJQUFJLENBQUNGLFNBQVMsR0FBRztZQUNienhCLE1BQU1zQjtZQUNONkMsS0FBS3d0QjtZQUNMRyxTQUFTLENBQUMsQ0FBRSxLQUFJLENBQUNoa0IsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDQSxNQUFNLENBQUNYLFNBQVM7WUFDakQ0a0IsZUFBZSxDQUFDLENBQUUsS0FBSSxDQUFDamtCLE1BQU0sSUFBSXhJLFNBQVMsQ0FBQyxJQUFJLENBQUN3SSxNQUFNLENBQUNrSyxZQUFZLENBQUMsa0JBQWlCO1FBQ3pGO1FBQ0osSUFBSSxJQUFJLENBQUNsSyxNQUFNLElBQUksSUFBSSxDQUFDMmpCLFNBQVMsSUFBSyxLQUFJLENBQUNBLFNBQVMsQ0FBQ0ssT0FBTyxJQUFJLElBQUksQ0FBQ0wsU0FBUyxDQUFDTSxhQUFhLEdBQUc7WUFDM0YsSUFBSSxDQUFDbHFCLElBQUksQ0FBQ2tiLFdBQVcsQ0FBQ3RNLElBQUk7WUFDMUIsSUFBSSxJQUFJLENBQUNnYixTQUFTLENBQUNLLE9BQU8sRUFDdEIsSUFBSSxDQUFDaGtCLE1BQU0sQ0FBQ1gsU0FBUyxHQUFHO1lBQzVCLElBQUksSUFBSSxDQUFDc2tCLFNBQVMsQ0FBQ00sYUFBYSxFQUM1QjVOLFdBQVc7Z0JBQ1AsSUFBSSxJQUFJLENBQUN0YyxJQUFJLENBQUMwUyxLQUFLLENBQUNxSSxTQUFTLElBQUksSUFBSSxFQUNqQyxJQUFJLENBQUM5VSxNQUFNLENBQUN1UCxZQUFZLENBQUMsbUJBQW1CO1lBQ3BELEdBQUc7WUFDUCxJQUFJLENBQUN4VixJQUFJLENBQUNrYixXQUFXLENBQUN6UyxLQUFLO1FBQy9CO1FBQ0F6SSxLQUFLMEIsSUFBSSxDQUFDMmEsZ0JBQWdCLENBQUMsV0FBVyxJQUFJLENBQUM4TixFQUFFLEdBQUcsSUFBSSxDQUFDQSxFQUFFLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQ2pFcHFCLEtBQUswQixJQUFJLENBQUMyYSxnQkFBZ0IsQ0FBQyxhQUFhLElBQUksQ0FBQ2dPLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUksQ0FBQ0QsSUFBSSxDQUFDLElBQUk7UUFDdkV2RCxtQkFBbUI3bUIsTUFBTTtJQUM3QjtJQUNBMHBCLE9BQU87UUFDSCxJQUFJLENBQUMxcEIsSUFBSSxDQUFDMEIsSUFBSSxDQUFDeWEsbUJBQW1CLENBQUMsV0FBVyxJQUFJLENBQUNnTyxFQUFFO1FBQ3JELElBQUksQ0FBQ25xQixJQUFJLENBQUMwQixJQUFJLENBQUN5YSxtQkFBbUIsQ0FBQyxhQUFhLElBQUksQ0FBQ2tPLElBQUk7UUFDekQsSUFBSSxJQUFJLENBQUNULFNBQVMsSUFBSSxJQUFJLENBQUMzakIsTUFBTSxFQUFFO1lBQy9CLElBQUksQ0FBQ2pHLElBQUksQ0FBQ2tiLFdBQVcsQ0FBQ3RNLElBQUk7WUFDMUIsSUFBSSxJQUFJLENBQUNnYixTQUFTLENBQUNLLE9BQU8sRUFDdEIsSUFBSSxDQUFDaGtCLE1BQU0sQ0FBQzJOLGVBQWUsQ0FBQztZQUNoQyxJQUFJLElBQUksQ0FBQ2dXLFNBQVMsQ0FBQ00sYUFBYSxFQUM1QixJQUFJLENBQUNqa0IsTUFBTSxDQUFDMk4sZUFBZSxDQUFDO1lBQ2hDLElBQUksQ0FBQzVULElBQUksQ0FBQ2tiLFdBQVcsQ0FBQ3pTLEtBQUs7UUFDL0I7UUFDQSxJQUFJLElBQUksQ0FBQzJTLG9CQUFvQixFQUN6QmtCLFdBQVcsSUFBTXpCLGVBQWUsSUFBSSxDQUFDN2EsSUFBSTtRQUM3QyxJQUFJLENBQUNBLElBQUksQ0FBQzBTLEtBQUssQ0FBQ3FJLFNBQVMsR0FBRztJQUNoQztJQUNBb1AsR0FBRzF1QixLQUFLLEVBQUU7UUFDTixJQUFJLENBQUNpdUIsSUFBSTtRQUNULElBQUksQ0FBQyxJQUFJLENBQUMxcEIsSUFBSSxDQUFDdEYsR0FBRyxDQUFDa0gsUUFBUSxDQUFDbkcsTUFBTXdLLE1BQU0sR0FDcEM7UUFDSixJQUFJM0osTUFBTSxJQUFJLENBQUNBLEdBQUc7UUFDbEIsSUFBSSxJQUFJLENBQUMwRCxJQUFJLENBQUMwRixLQUFLLENBQUM1SixHQUFHLElBQUksSUFBSSxDQUFDK3RCLFFBQVEsRUFDcEN2dEIsTUFBTSxJQUFJLENBQUMwRCxJQUFJLENBQUNtRixXQUFXLENBQUM4aUIsWUFBWXhzQjtRQUM1QyxJQUFJLENBQUM2dUIsa0JBQWtCLENBQUM3dUI7UUFDeEIsSUFBSSxJQUFJLENBQUN1ZixZQUFZLElBQUksQ0FBQzFlLEtBQUs7WUFDM0J1cUIsbUJBQW1CLElBQUksQ0FBQzdtQixJQUFJLEVBQUU7UUFDbEMsT0FDSyxJQUFJZ3BCLGtCQUFrQixJQUFJLENBQUNocEIsSUFBSSxFQUFFMUQsSUFBSUEsR0FBRyxFQUFFQSxJQUFJdUosTUFBTSxFQUFFcEssT0FBTyxJQUFJLENBQUNnWSxVQUFVLEdBQUc7WUFDaEZoWSxNQUFNaXNCLGNBQWM7UUFDeEIsT0FDSyxJQUFJanNCLE1BQU0ydEIsTUFBTSxJQUFJLEtBQ3BCLEtBQUksQ0FBQ0ssT0FBTyxJQUNULDhDQUE4QztRQUM3QzVyQixVQUFVLElBQUksQ0FBQytyQixTQUFTLElBQUksQ0FBQyxJQUFJLENBQUNBLFNBQVMsQ0FBQ3p4QixJQUFJLENBQUMwYixNQUFNLElBQ3hELG9EQUFvRDtRQUNwRCxxREFBcUQ7UUFDckQscURBQXFEO1FBQ3JELG1EQUFtRDtRQUNuRCx1REFBdUQ7UUFDdkQscURBQXFEO1FBQ3JELHFCQUFxQjtRQUNwQmxXLFVBQVUsQ0FBQyxJQUFJLENBQUNxQyxJQUFJLENBQUMwRixLQUFLLENBQUNtQyxTQUFTLENBQUNpVSxPQUFPLElBQ3pDdGYsS0FBS0MsR0FBRyxDQUFDRCxLQUFLa2lCLEdBQUcsQ0FBQ3BpQixJQUFJQSxHQUFHLEdBQUcsSUFBSSxDQUFDMEQsSUFBSSxDQUFDMEYsS0FBSyxDQUFDbUMsU0FBUyxDQUFDaFAsSUFBSSxHQUFHMkQsS0FBS2tpQixHQUFHLENBQUNwaUIsSUFBSUEsR0FBRyxHQUFHLElBQUksQ0FBQzBELElBQUksQ0FBQzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQy9PLEVBQUUsTUFBTSxDQUFDLEdBQUk7WUFDL0gydkIsZ0JBQWdCLElBQUksQ0FBQ3pvQixJQUFJLEVBQUVySSx3REFBU0EsQ0FBQ29uQixJQUFJLENBQUMsSUFBSSxDQUFDL2UsSUFBSSxDQUFDMEYsS0FBSyxDQUFDNUosR0FBRyxDQUFDbUwsT0FBTyxDQUFDM0ssSUFBSUEsR0FBRyxJQUFJO1lBQ2pGYixNQUFNaXNCLGNBQWM7UUFDeEIsT0FDSztZQUNEYixtQkFBbUIsSUFBSSxDQUFDN21CLElBQUksRUFBRTtRQUNsQztJQUNKO0lBQ0FxcUIsS0FBSzV1QixLQUFLLEVBQUU7UUFDUixJQUFJLENBQUM2dUIsa0JBQWtCLENBQUM3dUI7UUFDeEJvckIsbUJBQW1CLElBQUksQ0FBQzdtQixJQUFJLEVBQUU7UUFDOUIsSUFBSXZFLE1BQU04dUIsT0FBTyxJQUFJLEdBQ2pCLElBQUksQ0FBQ2IsSUFBSTtJQUNqQjtJQUNBWSxtQkFBbUI3dUIsS0FBSyxFQUFFO1FBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUN1ZixZQUFZLElBQUt4ZSxDQUFBQSxLQUFLa2lCLEdBQUcsQ0FBQyxJQUFJLENBQUNqakIsS0FBSyxDQUFDVSxDQUFDLEdBQUdWLE1BQU15c0IsT0FBTyxJQUFJLEtBQ2hFMXJCLEtBQUtraUIsR0FBRyxDQUFDLElBQUksQ0FBQ2pqQixLQUFLLENBQUNXLENBQUMsR0FBR1gsTUFBTTBzQixPQUFPLElBQUksSUFDekMsSUFBSSxDQUFDbk4sWUFBWSxHQUFHO0lBQzVCO0FBQ0o7QUFDQWdLLFNBQVNHLFVBQVUsR0FBR25sQixDQUFBQTtJQUNsQkEsS0FBSzBTLEtBQUssQ0FBQ3FULFNBQVMsR0FBR2UsS0FBS0MsR0FBRztJQUMvQnNDLGNBQWNycEI7SUFDZDZtQixtQkFBbUI3bUIsTUFBTTtBQUM3QjtBQUNBZ2xCLFNBQVNJLFNBQVMsR0FBR3BsQixDQUFBQTtJQUNqQkEsS0FBSzBTLEtBQUssQ0FBQ3FULFNBQVMsR0FBR2UsS0FBS0MsR0FBRztJQUMvQkYsbUJBQW1CN21CLE1BQU07QUFDN0I7QUFDQWdsQixTQUFTd0YsV0FBVyxHQUFHeHFCLENBQUFBLE9BQVFxcEIsY0FBY3JwQjtBQUM3QyxTQUFTd25CLG9CQUFvQnhuQixJQUFJLEVBQUV2RSxLQUFLO0lBQ3BDLElBQUl1RSxLQUFLZ1IsU0FBUyxFQUNkLE9BQU87SUFDWCx5RUFBeUU7SUFDekUsc0ZBQXNGO0lBQ3RGLHFGQUFxRjtJQUNyRiw4RUFBOEU7SUFDOUUsbUVBQW1FO0lBQ25FLHFGQUFxRjtJQUNyRiw4RkFBOEY7SUFDOUYsc0ZBQXNGO0lBQ3RGLHFGQUFxRjtJQUNyRix5RUFBeUU7SUFDekUsSUFBSW5ULFVBQVVyQixLQUFLa2lCLEdBQUcsQ0FBQ2pqQixNQUFNZ3ZCLFNBQVMsR0FBR3pxQixLQUFLMFMsS0FBSyxDQUFDd1Qsa0JBQWtCLElBQUksS0FBSztRQUMzRWxtQixLQUFLMFMsS0FBSyxDQUFDd1Qsa0JBQWtCLEdBQUcsQ0FBQztRQUNqQyxPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFDQSxtRUFBbUU7QUFDbkUsTUFBTXdFLHFCQUFxQnRzQixVQUFVLE9BQU8sQ0FBQztBQUM3QzZtQixhQUFhMEYsZ0JBQWdCLEdBQUcxRixhQUFhMkYsaUJBQWlCLEdBQUc1cUIsQ0FBQUE7SUFDN0QsSUFBSSxDQUFDQSxLQUFLZ1IsU0FBUyxFQUFFO1FBQ2pCaFIsS0FBS2tiLFdBQVcsQ0FBQzJQLEtBQUs7UUFDdEIsSUFBSSxFQUFFbmxCLEtBQUssRUFBRSxHQUFHMUYsTUFBTThILE9BQU9wQyxNQUFNbUMsU0FBUyxDQUFDRyxHQUFHO1FBQ2hELElBQUl0QyxNQUFNbUMsU0FBUyxZQUFZclEsNERBQWFBLElBQ3ZDa08sQ0FBQUEsTUFBTW9sQixXQUFXLElBQ2IsQ0FBQ2hqQixLQUFLMFYsVUFBVSxJQUFJMVYsS0FBS1MsWUFBWSxJQUFJVCxLQUFLMlYsVUFBVSxDQUFDak0sS0FBSyxDQUFDdVosSUFBSSxDQUFDL1UsQ0FBQUEsSUFBS0EsRUFBRXZJLElBQUksQ0FBQ1UsSUFBSSxDQUFDNmMsU0FBUyxLQUFLLE1BQU0sR0FBSTtZQUNsSCxtRkFBbUY7WUFDbkZockIsS0FBS2lyQixVQUFVLEdBQUdqckIsS0FBSzBGLEtBQUssQ0FBQ29sQixXQUFXLElBQUloakIsS0FBSzBKLEtBQUs7WUFDdEQ4WCxlQUFldHBCLE1BQU07WUFDckJBLEtBQUtpckIsVUFBVSxHQUFHO1FBQ3RCLE9BQ0s7WUFDRDNCLGVBQWV0cEIsTUFBTSxDQUFDMEYsTUFBTW1DLFNBQVMsQ0FBQzhJLEtBQUs7WUFDM0MsZ0VBQWdFO1lBQ2hFLDhEQUE4RDtZQUM5RCx1QkFBdUI7WUFDdkIsSUFBSWxULFNBQVNpSSxNQUFNbUMsU0FBUyxDQUFDOEksS0FBSyxJQUFJN0ksS0FBS1MsWUFBWSxJQUFJLENBQUNULEtBQUswVixVQUFVLElBQUkxVixLQUFLMlYsVUFBVSxDQUFDak0sS0FBSyxDQUFDcFksTUFBTSxFQUFFO2dCQUN6RyxJQUFJd08sTUFBTTVILEtBQUsrSSxpQkFBaUI7Z0JBQ2hDLElBQUssSUFBSTVRLE9BQU95UCxJQUFJMU0sU0FBUyxFQUFFYixTQUFTdU4sSUFBSXpNLFdBQVcsRUFBRWhELFFBQVFBLEtBQUtNLFFBQVEsSUFBSSxLQUFLNEIsVUFBVSxHQUFJO29CQUNqRyxJQUFJd0ssU0FBU3hLLFNBQVMsSUFBSWxDLEtBQUtzTixTQUFTLEdBQUd0TixLQUFLZ0MsVUFBVSxDQUFDRSxTQUFTLEVBQUU7b0JBQ3RFLElBQUksQ0FBQ3dLLFFBQ0Q7b0JBQ0osSUFBSUEsT0FBT3BNLFFBQVEsSUFBSSxHQUFHO3dCQUN0QixJQUFJbVAsTUFBTTVILEtBQUt3SSxZQUFZO3dCQUMzQixJQUFJWixLQUNBQSxJQUFJNEIsUUFBUSxDQUFDM0UsUUFBUUEsT0FBTzFMLFNBQVMsQ0FBQ0MsTUFBTTt3QkFDaEQ7b0JBQ0osT0FDSzt3QkFDRGpCLE9BQU8wTTt3QkFDUHhLLFNBQVMsQ0FBQztvQkFDZDtnQkFDSjtZQUNKO1FBQ0o7UUFDQTJGLEtBQUswUyxLQUFLLENBQUMxQixTQUFTLEdBQUc7SUFDM0I7SUFDQWthLG1CQUFtQmxyQixNQUFNMHFCO0FBQzdCO0FBQ0F6RixhQUFha0csY0FBYyxHQUFHLENBQUNuckIsTUFBTXZFO0lBQ2pDLElBQUl1RSxLQUFLZ1IsU0FBUyxFQUFFO1FBQ2hCaFIsS0FBSzBTLEtBQUssQ0FBQzFCLFNBQVMsR0FBRztRQUN2QmhSLEtBQUswUyxLQUFLLENBQUN3VCxrQkFBa0IsR0FBR3pxQixNQUFNZ3ZCLFNBQVM7UUFDL0N6cUIsS0FBSzBTLEtBQUssQ0FBQzBULHlCQUF5QixHQUFHcG1CLEtBQUtrYixXQUFXLENBQUNrUSxjQUFjLEdBQUdoeUIsTUFBTSxHQUFHNEcsS0FBSzBTLEtBQUssQ0FBQ3lULGFBQWEsR0FBRztRQUM3R25tQixLQUFLMFMsS0FBSyxDQUFDQyxlQUFlLEdBQUc7UUFDN0IsSUFBSTNTLEtBQUswUyxLQUFLLENBQUMwVCx5QkFBeUIsRUFDcENpRixRQUFRcGtCLE9BQU8sR0FBR3FrQixJQUFJLENBQUMsSUFBTXRyQixLQUFLa2IsV0FBVyxDQUFDMlAsS0FBSztRQUN2RDdxQixLQUFLMFMsS0FBSyxDQUFDeVQsYUFBYTtRQUN4QitFLG1CQUFtQmxyQixNQUFNO0lBQzdCO0FBQ0o7QUFDQSxTQUFTa3JCLG1CQUFtQmxyQixJQUFJLEVBQUV1ckIsS0FBSztJQUNuQ3RFLGFBQWFqbkIsS0FBSzBTLEtBQUssQ0FBQ3VULGdCQUFnQjtJQUN4QyxJQUFJc0YsUUFBUSxDQUFDLEdBQ1R2ckIsS0FBSzBTLEtBQUssQ0FBQ3VULGdCQUFnQixHQUFHM0osV0FBVyxJQUFNZ04sZUFBZXRwQixPQUFPdXJCO0FBQzdFO0FBQ0EsU0FBU0MsaUJBQWlCeHJCLElBQUk7SUFDMUIsSUFBSUEsS0FBS2dSLFNBQVMsRUFBRTtRQUNoQmhSLEtBQUswUyxLQUFLLENBQUMxQixTQUFTLEdBQUc7UUFDdkJoUixLQUFLMFMsS0FBSyxDQUFDd1Qsa0JBQWtCLEdBQUd1RjtJQUNwQztJQUNBLE1BQU96ckIsS0FBSzBTLEtBQUssQ0FBQ00sZ0JBQWdCLENBQUM1WixNQUFNLEdBQUcsRUFDeEM0RyxLQUFLMFMsS0FBSyxDQUFDTSxnQkFBZ0IsQ0FBQzRELEdBQUcsR0FBRzlJLGdCQUFnQjtBQUMxRDtBQUNBLFNBQVM0ZCxvQkFBb0IxckIsSUFBSTtJQUM3QixJQUFJNEgsTUFBTTVILEtBQUsrSSxpQkFBaUI7SUFDaEMsSUFBSSxDQUFDbkIsSUFBSTFNLFNBQVMsRUFDZCxPQUFPO0lBQ1gsSUFBSXl3QixhQUFhdnhCLGlCQUFpQndOLElBQUkxTSxTQUFTLEVBQUUwTSxJQUFJek0sV0FBVztJQUNoRSxJQUFJeXdCLFlBQVl0eEIsZ0JBQWdCc04sSUFBSTFNLFNBQVMsRUFBRTBNLElBQUl6TSxXQUFXO0lBQzlELElBQUl3d0IsY0FBY0MsYUFBYUQsY0FBY0MsV0FBVztRQUNwRCxJQUFJQyxZQUFZRCxVQUFVL3dCLFVBQVUsRUFBRWl4QixjQUFjOXJCLEtBQUtrYixXQUFXLENBQUM2USxtQkFBbUI7UUFDeEYsSUFBSUosY0FBY0csZUFBZUYsYUFBYUUsYUFDMUMsT0FBT0E7UUFDWCxJQUFJLENBQUNELGFBQWEsQ0FBQ0EsVUFBVWpuQixNQUFNLENBQUNnbkIsVUFBVXp5QixTQUFTLEdBQUc7WUFDdEQsT0FBT3l5QjtRQUNYLE9BQ0ssSUFBSTVyQixLQUFLMFMsS0FBSyxDQUFDQyxlQUFlLElBQUlpWixXQUFXO1lBQzlDLElBQUlJLGFBQWFMLFdBQVc5d0IsVUFBVTtZQUN0QyxJQUFJLENBQUUsRUFBQ214QixjQUFjLENBQUNBLFdBQVdwbkIsTUFBTSxDQUFDK21CLFdBQVd4eUIsU0FBUyxJQUN4RCxPQUFPeXlCO1FBQ2Y7SUFDSjtJQUNBLE9BQU9ELGNBQWNDO0FBQ3pCO0FBQ0EsU0FBU0g7SUFDTCxJQUFJaHdCLFFBQVF6QyxTQUFTMEMsV0FBVyxDQUFDO0lBQ2pDRCxNQUFNRSxTQUFTLENBQUMsU0FBUyxNQUFNO0lBQy9CLE9BQU9GLE1BQU1ndkIsU0FBUztBQUMxQjtBQUNBOztBQUVBLEdBQ0EsU0FBU25CLGVBQWV0cEIsSUFBSSxFQUFFaXNCLGFBQWEsS0FBSztJQUM1QyxJQUFJN3RCLFdBQVc0QixLQUFLa2IsV0FBVyxDQUFDZ1IsWUFBWSxJQUFJLEdBQzVDO0lBQ0psc0IsS0FBS2tiLFdBQVcsQ0FBQ3VNLFVBQVU7SUFDM0IrRCxpQkFBaUJ4ckI7SUFDakIsSUFBSWlzQixjQUFjanNCLEtBQUtvRSxPQUFPLElBQUlwRSxLQUFLb0UsT0FBTyxDQUFDaUcsS0FBSyxFQUFFO1FBQ2xELElBQUl6QyxNQUFNa1MsaUJBQWlCOVo7UUFDM0IsSUFBSTRILE9BQU8sQ0FBQ0EsSUFBSThHLEVBQUUsQ0FBQzFPLEtBQUswRixLQUFLLENBQUNtQyxTQUFTLEdBQ25DN0gsS0FBS21kLFFBQVEsQ0FBQ25kLEtBQUswRixLQUFLLENBQUMwWCxFQUFFLENBQUMxUSxZQUFZLENBQUM5RTthQUN4QyxJQUFJLENBQUM1SCxLQUFLaXJCLFVBQVUsSUFBSWdCLFVBQVMsS0FBTSxDQUFDanNCLEtBQUswRixLQUFLLENBQUNtQyxTQUFTLENBQUM4SSxLQUFLLEVBQ25FM1EsS0FBS21kLFFBQVEsQ0FBQ25kLEtBQUswRixLQUFLLENBQUMwWCxFQUFFLENBQUMrTyxlQUFlO2FBRTNDbnNCLEtBQUswSCxXQUFXLENBQUMxSCxLQUFLMEYsS0FBSztRQUMvQixPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTMG1CLFlBQVlwc0IsSUFBSSxFQUFFdEYsR0FBRztJQUMxQixtRUFBbUU7SUFDbkUsK0RBQStEO0lBQy9ELElBQUksQ0FBQ3NGLEtBQUt0RixHQUFHLENBQUNwQyxVQUFVLEVBQ3BCO0lBQ0osSUFBSStWLE9BQU9yTyxLQUFLdEYsR0FBRyxDQUFDcEMsVUFBVSxDQUFDaVcsV0FBVyxDQUFDdlYsU0FBU3NWLGFBQWEsQ0FBQztJQUNsRUQsS0FBS0UsV0FBVyxDQUFDN1Q7SUFDakIyVCxLQUFLOVAsS0FBSyxDQUFDMlgsT0FBTyxHQUFHO0lBQ3JCLElBQUl0TyxNQUFNb0YsZ0JBQWdCalUsUUFBUUMsU0FBU0MsV0FBVztJQUN0REYsTUFBTXN6QixrQkFBa0IsQ0FBQzN4QjtJQUN6QixtRUFBbUU7SUFDbkUsbUVBQW1FO0lBQ25FLCtEQUErRDtJQUMvRHNGLEtBQUt0RixHQUFHLENBQUM0eEIsSUFBSTtJQUNiMWtCLElBQUl5RixlQUFlO0lBQ25CekYsSUFBSTBGLFFBQVEsQ0FBQ3ZVO0lBQ2J1akIsV0FBVztRQUNQLElBQUlqTyxLQUFLL1YsVUFBVSxFQUNmK1YsS0FBSy9WLFVBQVUsQ0FBQ3lhLFdBQVcsQ0FBQzFFO1FBQ2hDck8sS0FBS3lDLEtBQUs7SUFDZCxHQUFHO0FBQ1A7QUFDQSxzRUFBc0U7QUFDdEUsaUVBQWlFO0FBQ2pFLDBEQUEwRDtBQUMxRCxNQUFNOHBCLHFCQUFxQixNQUFPaHZCLGFBQWEsTUFDMUNRLE9BQU9TLGlCQUFpQjtBQUM3QndtQixTQUFTblYsSUFBSSxHQUFHb1YsYUFBYTdRLEdBQUcsR0FBRyxDQUFDcFUsTUFBTXVuQjtJQUN0QyxJQUFJOXJCLFFBQVE4ckI7SUFDWixJQUFJM2YsTUFBTTVILEtBQUswRixLQUFLLENBQUNtQyxTQUFTLEVBQUV1TSxNQUFNM1ksTUFBTWdTLElBQUksSUFBSTtJQUNwRCxJQUFJN0YsSUFBSStJLEtBQUssRUFDVDtJQUNKLHlEQUF5RDtJQUN6RCxJQUFJNmIsT0FBT0QscUJBQXFCLE9BQU85d0IsTUFBTWd4QixhQUFhO0lBQzFELElBQUk3YyxRQUFRaEksSUFBSWpDLE9BQU8sSUFBSSxFQUFFakwsR0FBRyxFQUFFc1QsSUFBSSxFQUFFLEdBQUc0UixzQkFBc0I1ZixNQUFNNFA7SUFDdkUsSUFBSTRjLE1BQU07UUFDTi93QixNQUFNaXNCLGNBQWM7UUFDcEI4RSxLQUFLRSxTQUFTO1FBQ2RGLEtBQUtHLE9BQU8sQ0FBQyxhQUFhanlCLElBQUlpcUIsU0FBUztRQUN2QzZILEtBQUtHLE9BQU8sQ0FBQyxjQUFjM2U7SUFDL0IsT0FDSztRQUNEb2UsWUFBWXBzQixNQUFNdEY7SUFDdEI7SUFDQSxJQUFJMFosS0FDQXBVLEtBQUttZCxRQUFRLENBQUNuZCxLQUFLMEYsS0FBSyxDQUFDMFgsRUFBRSxDQUFDK08sZUFBZSxHQUFHOU8sY0FBYyxHQUFHc0wsT0FBTyxDQUFDLFdBQVc7QUFDMUY7QUFDQSxTQUFTaUUsZ0JBQWdCaGQsS0FBSztJQUMxQixPQUFPQSxNQUFNa1EsU0FBUyxJQUFJLEtBQUtsUSxNQUFNbVEsT0FBTyxJQUFJLEtBQUtuUSxNQUFNakssT0FBTyxDQUFDK0wsVUFBVSxJQUFJLElBQUk5QixNQUFNakssT0FBTyxDQUFDcEMsVUFBVSxHQUFHO0FBQ3BIO0FBQ0EsU0FBU3NwQixhQUFhN3NCLElBQUksRUFBRXZFLEtBQUs7SUFDN0IsSUFBSSxDQUFDdUUsS0FBS3RGLEdBQUcsQ0FBQ3BDLFVBQVUsRUFDcEI7SUFDSixJQUFJdW9CLFlBQVk3Z0IsS0FBSzBTLEtBQUssQ0FBQ2dOLFFBQVEsSUFBSTFmLEtBQUswRixLQUFLLENBQUNtQyxTQUFTLENBQUNFLEtBQUssQ0FBQ3hQLE1BQU0sQ0FBQ2tWLElBQUksQ0FBQ1UsSUFBSSxDQUFDdlMsSUFBSTtJQUN2RixJQUFJcUssU0FBU2pHLEtBQUt0RixHQUFHLENBQUNwQyxVQUFVLENBQUNpVyxXQUFXLENBQUN2VixTQUFTc1YsYUFBYSxDQUFDdVMsWUFBWSxhQUFhO0lBQzdGLElBQUksQ0FBQ0EsV0FDRDVhLE9BQU8vTCxlQUFlLEdBQUc7SUFDN0IrTCxPQUFPMUgsS0FBSyxDQUFDMlgsT0FBTyxHQUFHO0lBQ3ZCalEsT0FBT3hELEtBQUs7SUFDWixJQUFJcXFCLFFBQVE5c0IsS0FBSzBTLEtBQUssQ0FBQ2dOLFFBQVEsSUFBSTFmLEtBQUswUyxLQUFLLENBQUM0UyxXQUFXLElBQUk7SUFDN0RoSixXQUFXO1FBQ1B0YyxLQUFLeUMsS0FBSztRQUNWLElBQUl3RCxPQUFPM04sVUFBVSxFQUNqQjJOLE9BQU8zTixVQUFVLENBQUN5YSxXQUFXLENBQUM5TTtRQUNsQyxJQUFJNGEsV0FDQWtNLFFBQVEvc0IsTUFBTWlHLE9BQU8zRyxLQUFLLEVBQUUsTUFBTXd0QixPQUFPcnhCO2FBRXpDc3hCLFFBQVEvc0IsTUFBTWlHLE9BQU8wQyxXQUFXLEVBQUUxQyxPQUFPMGUsU0FBUyxFQUFFbUksT0FBT3J4QjtJQUNuRSxHQUFHO0FBQ1A7QUFDQSxTQUFTc3hCLFFBQVEvc0IsSUFBSSxFQUFFZ08sSUFBSSxFQUFFNFMsSUFBSSxFQUFFb00sV0FBVyxFQUFFdnhCLEtBQUs7SUFDakQsSUFBSW1VLFFBQVErUSxtQkFBbUIzZ0IsTUFBTWdPLE1BQU00UyxNQUFNb00sYUFBYWh0QixLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUyxDQUFDRSxLQUFLO0lBQ3hGLElBQUkvSCxLQUFLRyxRQUFRLENBQUMsZUFBZW9ILENBQUFBLElBQUtBLEVBQUV2SCxNQUFNdkUsT0FBT21VLFNBQVM3WCxvREFBS0EsQ0FBQzRZLEtBQUssSUFDckUsT0FBTztJQUNYLElBQUksQ0FBQ2YsT0FDRCxPQUFPO0lBQ1gsSUFBSXFkLGFBQWFMLGdCQUFnQmhkO0lBQ2pDLElBQUl3TixLQUFLNlAsYUFDSGp0QixLQUFLMEYsS0FBSyxDQUFDMFgsRUFBRSxDQUFDOFAsb0JBQW9CLENBQUNELFlBQVlELGVBQy9DaHRCLEtBQUswRixLQUFLLENBQUMwWCxFQUFFLENBQUMrUCxnQkFBZ0IsQ0FBQ3ZkO0lBQ3JDNVAsS0FBS21kLFFBQVEsQ0FBQ0MsR0FBR0MsY0FBYyxHQUFHc0wsT0FBTyxDQUFDLFNBQVMsTUFBTUEsT0FBTyxDQUFDLFdBQVc7SUFDNUUsT0FBTztBQUNYO0FBQ0EsU0FBU3lFLFFBQVFYLGFBQWE7SUFDMUIsSUFBSXplLE9BQU95ZSxjQUFjWSxPQUFPLENBQUMsaUJBQWlCWixjQUFjWSxPQUFPLENBQUM7SUFDeEUsSUFBSXJmLE1BQ0EsT0FBT0E7SUFDWCxJQUFJc2YsT0FBT2IsY0FBY1ksT0FBTyxDQUFDO0lBQ2pDLE9BQU9DLE9BQU9BLEtBQUtyTSxPQUFPLENBQUMsVUFBVSxPQUFPO0FBQ2hEO0FBQ0FnRSxhQUFhc0ksS0FBSyxHQUFHLENBQUN2dEIsTUFBTXVuQjtJQUN4QixJQUFJOXJCLFFBQVE4ckI7SUFDWixtRUFBbUU7SUFDbkUsb0VBQW9FO0lBQ3BFLGdFQUFnRTtJQUNoRSwrQ0FBK0M7SUFDL0MsSUFBSXZuQixLQUFLZ1IsU0FBUyxJQUFJLENBQUM1UyxTQUNuQjtJQUNKLElBQUlvdUIsT0FBT0QscUJBQXFCLE9BQU85d0IsTUFBTWd4QixhQUFhO0lBQzFELElBQUlLLFFBQVE5c0IsS0FBSzBTLEtBQUssQ0FBQ2dOLFFBQVEsSUFBSTFmLEtBQUswUyxLQUFLLENBQUM0UyxXQUFXLElBQUk7SUFDN0QsSUFBSWtILFFBQVFPLFFBQVEvc0IsTUFBTW90QixRQUFRWixPQUFPQSxLQUFLYSxPQUFPLENBQUMsY0FBY1AsT0FBT3J4QixRQUN2RUEsTUFBTWlzQixjQUFjO1NBRXBCbUYsYUFBYTdzQixNQUFNdkU7QUFDM0I7QUFDQSxNQUFNK3hCO0lBQ0ZyakIsWUFBWXlGLEtBQUssRUFBRXlhLElBQUksRUFBRWx5QixJQUFJLENBQUU7UUFDM0IsSUFBSSxDQUFDeVgsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3lhLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNseUIsSUFBSSxHQUFHQTtJQUNoQjtBQUNKO0FBQ0EsTUFBTXMxQixtQkFBbUJ4dkIsTUFBTSxXQUFXO0FBQzFDLFNBQVN5dkIsVUFBVTF0QixJQUFJLEVBQUV2RSxLQUFLO0lBQzFCLElBQUlreUIsUUFBUTN0QixLQUFLRyxRQUFRLENBQUMsY0FBY25HLENBQUFBLE9BQVEsQ0FBQ0EsS0FBS3lCO0lBQ3RELE9BQU9reUIsU0FBUyxPQUFPQSxRQUFRLENBQUNseUIsS0FBSyxDQUFDZ3lCLGlCQUFpQjtBQUMzRDtBQUNBekksU0FBUzRJLFNBQVMsR0FBRyxDQUFDNXRCLE1BQU11bkI7SUFDeEIsSUFBSTlyQixRQUFROHJCO0lBQ1osSUFBSXhNLFlBQVkvYSxLQUFLMFMsS0FBSyxDQUFDcUksU0FBUztJQUNwQyxJQUFJQSxXQUNBQSxVQUFVMk8sSUFBSTtJQUNsQixJQUFJLENBQUNqdUIsTUFBTW95QixZQUFZLEVBQ25CO0lBQ0osSUFBSWptQixNQUFNNUgsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVM7SUFDOUIsSUFBSXZMLE1BQU1zTCxJQUFJK0ksS0FBSyxHQUFHLE9BQU8zUSxLQUFLbUYsV0FBVyxDQUFDOGlCLFlBQVl4c0I7SUFDMUQsSUFBSXREO0lBQ0osSUFBSW1FLE9BQU9BLElBQUlBLEdBQUcsSUFBSXNMLElBQUkvTyxJQUFJLElBQUl5RCxJQUFJQSxHQUFHLElBQUtzTCxDQUFBQSxlQUFlblEsNERBQWFBLEdBQUdtUSxJQUFJOU8sRUFBRSxHQUFHLElBQUk4TyxJQUFJOU8sRUFBRTtTQUMzRixJQUFJaWlCLGFBQWFBLFVBQVU2TyxTQUFTLEVBQUU7UUFDdkN6eEIsT0FBT1YsNERBQWFBLENBQUMwWCxNQUFNLENBQUNuUCxLQUFLMEYsS0FBSyxDQUFDNUosR0FBRyxFQUFFaWYsVUFBVTZPLFNBQVMsQ0FBQ3R0QixHQUFHO0lBQ3ZFLE9BQ0ssSUFBSWIsTUFBTXdLLE1BQU0sSUFBSXhLLE1BQU13SyxNQUFNLENBQUN4TixRQUFRLElBQUksR0FBRztRQUNqRCxJQUFJa0MsT0FBT3FGLEtBQUtvRSxPQUFPLENBQUNLLFdBQVcsQ0FBQ2hKLE1BQU13SyxNQUFNLEVBQUU7UUFDbEQsSUFBSXRMLFFBQVFBLEtBQUt4QyxJQUFJLENBQUNzVixJQUFJLENBQUNVLElBQUksQ0FBQzdJLFNBQVMsSUFBSTNLLFFBQVFxRixLQUFLb0UsT0FBTyxFQUM3RGpNLE9BQU9WLDREQUFhQSxDQUFDMFgsTUFBTSxDQUFDblAsS0FBSzBGLEtBQUssQ0FBQzVKLEdBQUcsRUFBRW5CLEtBQUsrSixTQUFTO0lBQ2xFO0lBQ0EsSUFBSW9wQixlQUFlLENBQUMzMUIsUUFBUTZILEtBQUswRixLQUFLLENBQUNtQyxTQUFTLEVBQUVsQyxPQUFPO0lBQ3pELElBQUksRUFBRWpMLEdBQUcsRUFBRXNULElBQUksRUFBRTRCLEtBQUssRUFBRSxHQUFHZ1Esc0JBQXNCNWYsTUFBTTh0QjtJQUN2RCx1RUFBdUU7SUFDdkUsSUFBSSxDQUFDcnlCLE1BQU1veUIsWUFBWSxDQUFDRSxLQUFLLENBQUMzMEIsTUFBTSxJQUFJLENBQUN1RSxVQUFVQyxpQkFBaUIsS0FDaEVuQyxNQUFNb3lCLFlBQVksQ0FBQ25CLFNBQVM7SUFDaENqeEIsTUFBTW95QixZQUFZLENBQUNsQixPQUFPLENBQUNKLHFCQUFxQixTQUFTLGFBQWE3eEIsSUFBSWlxQixTQUFTO0lBQ25GLDZEQUE2RDtJQUM3RGxwQixNQUFNb3lCLFlBQVksQ0FBQ0csYUFBYSxHQUFHO0lBQ25DLElBQUksQ0FBQ3pCLG9CQUNEOXdCLE1BQU1veUIsWUFBWSxDQUFDbEIsT0FBTyxDQUFDLGNBQWMzZTtJQUM3Q2hPLEtBQUtpdUIsUUFBUSxHQUFHLElBQUlULFNBQVM1ZCxPQUFPOGQsVUFBVTF0QixNQUFNdkUsUUFBUXREO0FBQ2hFO0FBQ0E2c0IsU0FBU2tKLE9BQU8sR0FBR2x1QixDQUFBQTtJQUNmLElBQUlpdUIsV0FBV2p1QixLQUFLaXVCLFFBQVE7SUFDNUJ6VSxPQUFPOEMsVUFBVSxDQUFDO1FBQ2QsSUFBSXRjLEtBQUtpdUIsUUFBUSxJQUFJQSxVQUNqQmp1QixLQUFLaXVCLFFBQVEsR0FBRztJQUN4QixHQUFHO0FBQ1A7QUFDQWhKLGFBQWFrSixRQUFRLEdBQUdsSixhQUFhbUosU0FBUyxHQUFHLENBQUMxeEIsR0FBR3dhLElBQU1BLEVBQUV3USxjQUFjO0FBQzNFekMsYUFBYW9KLElBQUksR0FBRyxDQUFDcnVCLE1BQU11bkI7SUFDdkIsSUFBSTlyQixRQUFROHJCO0lBQ1osSUFBSTBHLFdBQVdqdUIsS0FBS2l1QixRQUFRO0lBQzVCanVCLEtBQUtpdUIsUUFBUSxHQUFHO0lBQ2hCLElBQUksQ0FBQ3h5QixNQUFNb3lCLFlBQVksRUFDbkI7SUFDSixJQUFJUyxXQUFXdHVCLEtBQUttRixXQUFXLENBQUM4aUIsWUFBWXhzQjtJQUM1QyxJQUFJLENBQUM2eUIsVUFDRDtJQUNKLElBQUlDLFNBQVN2dUIsS0FBSzBGLEtBQUssQ0FBQzVKLEdBQUcsQ0FBQ21MLE9BQU8sQ0FBQ3FuQixTQUFTaHlCLEdBQUc7SUFDaEQsSUFBSXNULFFBQVFxZSxZQUFZQSxTQUFTcmUsS0FBSztJQUN0QyxJQUFJQSxPQUFPO1FBQ1A1UCxLQUFLRyxRQUFRLENBQUMsbUJBQW1Cb0gsQ0FBQUE7WUFBT3FJLFFBQVFySSxFQUFFcUksT0FBTzVQO1FBQU87SUFDcEUsT0FDSztRQUNENFAsUUFBUStRLG1CQUFtQjNnQixNQUFNb3RCLFFBQVEzeEIsTUFBTW95QixZQUFZLEdBQUd0QixxQkFBcUIsT0FBTzl3QixNQUFNb3lCLFlBQVksQ0FBQ1IsT0FBTyxDQUFDLGNBQWMsT0FBT2tCO0lBQzlJO0lBQ0EsSUFBSWxFLE9BQU8sQ0FBQyxDQUFFNEQsQ0FBQUEsWUFBWVAsVUFBVTF0QixNQUFNdkUsTUFBSztJQUMvQyxJQUFJdUUsS0FBS0csUUFBUSxDQUFDLGNBQWNvSCxDQUFBQSxJQUFLQSxFQUFFdkgsTUFBTXZFLE9BQU9tVSxTQUFTN1gsb0RBQUtBLENBQUM0WSxLQUFLLEVBQUUwWixRQUFRO1FBQzlFNXVCLE1BQU1pc0IsY0FBYztRQUNwQjtJQUNKO0lBQ0EsSUFBSSxDQUFDOVgsT0FDRDtJQUNKblUsTUFBTWlzQixjQUFjO0lBQ3BCLElBQUk4RyxZQUFZNWUsUUFBUTNYLGdFQUFTQSxDQUFDK0gsS0FBSzBGLEtBQUssQ0FBQzVKLEdBQUcsRUFBRXl5QixPQUFPanlCLEdBQUcsRUFBRXNULFNBQVMyZSxPQUFPanlCLEdBQUc7SUFDakYsSUFBSWt5QixhQUFhLE1BQ2JBLFlBQVlELE9BQU9qeUIsR0FBRztJQUMxQixJQUFJOGdCLEtBQUtwZCxLQUFLMEYsS0FBSyxDQUFDMFgsRUFBRTtJQUN0QixJQUFJaU4sTUFBTTtRQUNOLElBQUksRUFBRWx5QixJQUFJLEVBQUUsR0FBRzgxQjtRQUNmLElBQUk5MUIsTUFDQUEsS0FBSzhvQixPQUFPLENBQUM3RDthQUViQSxHQUFHK08sZUFBZTtJQUMxQjtJQUNBLElBQUk3dkIsTUFBTThnQixHQUFHcVIsT0FBTyxDQUFDaEssR0FBRyxDQUFDK0o7SUFDekIsSUFBSUUsU0FBUzllLE1BQU1rUSxTQUFTLElBQUksS0FBS2xRLE1BQU1tUSxPQUFPLElBQUksS0FBS25RLE1BQU1qSyxPQUFPLENBQUMrTCxVQUFVLElBQUk7SUFDdkYsSUFBSWlkLGVBQWV2UixHQUFHdGhCLEdBQUc7SUFDekIsSUFBSTR5QixRQUNBdFIsR0FBR3dSLGdCQUFnQixDQUFDdHlCLEtBQUtBLEtBQUtzVCxNQUFNakssT0FBTyxDQUFDcEMsVUFBVTtTQUV0RDZaLEdBQUd5UixZQUFZLENBQUN2eUIsS0FBS0EsS0FBS3NUO0lBQzlCLElBQUl3TixHQUFHdGhCLEdBQUcsQ0FBQzRTLEVBQUUsQ0FBQ2lnQixlQUNWO0lBQ0osSUFBSTdtQixPQUFPc1YsR0FBR3RoQixHQUFHLENBQUNtTCxPQUFPLENBQUMzSztJQUMxQixJQUFJb3lCLFVBQVVqM0IsNERBQWFBLENBQUN5aUIsWUFBWSxDQUFDdEssTUFBTWpLLE9BQU8sQ0FBQ3BDLFVBQVUsS0FDN0R1RSxLQUFLNFYsU0FBUyxJQUFJNVYsS0FBSzRWLFNBQVMsQ0FBQ3hLLFVBQVUsQ0FBQ3RELE1BQU1qSyxPQUFPLENBQUNwQyxVQUFVLEdBQUc7UUFDdkU2WixHQUFHMVEsWUFBWSxDQUFDLElBQUlqViw0REFBYUEsQ0FBQ3FRO0lBQ3RDLE9BQ0s7UUFDRCxJQUFJWSxNQUFNMFUsR0FBR3FSLE9BQU8sQ0FBQ2hLLEdBQUcsQ0FBQytKO1FBQ3pCcFIsR0FBR3FSLE9BQU8sQ0FBQ0ssSUFBSSxDQUFDMVIsR0FBR3FSLE9BQU8sQ0FBQ0ssSUFBSSxDQUFDMTFCLE1BQU0sR0FBRyxFQUFFLENBQUMrbkIsT0FBTyxDQUFDLENBQUM0TixPQUFPQyxLQUFLQyxVQUFVQyxRQUFVeG1CLE1BQU13bUI7UUFDM0Y5UixHQUFHMVEsWUFBWSxDQUFDOE4saUJBQWlCeGEsTUFBTThILE1BQU1zVixHQUFHdGhCLEdBQUcsQ0FBQ21MLE9BQU8sQ0FBQ3lCO0lBQ2hFO0lBQ0ExSSxLQUFLeUMsS0FBSztJQUNWekMsS0FBS21kLFFBQVEsQ0FBQ0MsR0FBR3VMLE9BQU8sQ0FBQyxXQUFXO0FBQ3hDO0FBQ0EzRCxTQUFTdmlCLEtBQUssR0FBR3pDLENBQUFBO0lBQ2JBLEtBQUswUyxLQUFLLENBQUNvVCxTQUFTLEdBQUdnQixLQUFLQyxHQUFHO0lBQy9CLElBQUksQ0FBQy9tQixLQUFLMG9CLE9BQU8sRUFBRTtRQUNmMW9CLEtBQUtrYixXQUFXLENBQUN0TSxJQUFJO1FBQ3JCNU8sS0FBS3RGLEdBQUcsQ0FBQzhULFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQ3ZCek8sS0FBS2tiLFdBQVcsQ0FBQ3pTLEtBQUs7UUFDdEJ6SSxLQUFLMG9CLE9BQU8sR0FBRztRQUNmcE0sV0FBVztZQUNQLElBQUl0YyxLQUFLb0UsT0FBTyxJQUFJcEUsS0FBSzJhLFFBQVEsTUFBTSxDQUFDM2EsS0FBS2tiLFdBQVcsQ0FBQ0MsZ0JBQWdCLENBQUN6TSxFQUFFLENBQUMxTyxLQUFLK0ksaUJBQWlCLEtBQy9GOFIsZUFBZTdhO1FBQ3ZCLEdBQUc7SUFDUDtBQUNKO0FBQ0FnbEIsU0FBU3NILElBQUksR0FBRyxDQUFDdHNCLE1BQU11bkI7SUFDbkIsSUFBSTlyQixRQUFROHJCO0lBQ1osSUFBSXZuQixLQUFLMG9CLE9BQU8sRUFBRTtRQUNkMW9CLEtBQUtrYixXQUFXLENBQUN0TSxJQUFJO1FBQ3JCNU8sS0FBS3RGLEdBQUcsQ0FBQzhULFNBQVMsQ0FBQ21GLE1BQU0sQ0FBQztRQUMxQjNULEtBQUtrYixXQUFXLENBQUN6UyxLQUFLO1FBQ3RCLElBQUloTixNQUFNMHpCLGFBQWEsSUFBSW52QixLQUFLdEYsR0FBRyxDQUFDa0gsUUFBUSxDQUFDbkcsTUFBTTB6QixhQUFhLEdBQzVEbnZCLEtBQUtrYixXQUFXLENBQUNDLGdCQUFnQixDQUFDaVUsS0FBSztRQUMzQ3B2QixLQUFLMG9CLE9BQU8sR0FBRztJQUNuQjtBQUNKO0FBQ0ExRCxTQUFTcUssV0FBVyxHQUFHLENBQUNydkIsTUFBTXVuQjtJQUMxQixJQUFJOXJCLFFBQVE4ckI7SUFDWixrRUFBa0U7SUFDbEUsbUVBQW1FO0lBQ25FLGlFQUFpRTtJQUNqRSxnREFBZ0Q7SUFDaEQsSUFBSTVwQixVQUFVUyxXQUFXM0MsTUFBTTZ6QixTQUFTLElBQUkseUJBQXlCO1FBQ2pFdHZCLEtBQUtrYixXQUFXLENBQUNxVSxTQUFTO1FBQzFCLElBQUksRUFBRWxKLGNBQWMsRUFBRSxHQUFHcm1CLEtBQUswUyxLQUFLO1FBQ25DNEosV0FBVztZQUNQLElBQUl0YyxLQUFLMFMsS0FBSyxDQUFDMlQsY0FBYyxJQUFJQSxnQkFDN0IsUUFBUSxnQ0FBZ0M7WUFDNUMsOERBQThEO1lBQzlEcm1CLEtBQUt0RixHQUFHLENBQUM0eEIsSUFBSTtZQUNidHNCLEtBQUt5QyxLQUFLO1lBQ1YsSUFBSXpDLEtBQUtHLFFBQVEsQ0FBQyxpQkFBaUJvSCxDQUFBQSxJQUFLQSxFQUFFdkgsTUFBTTFFLFNBQVMsR0FBRyxnQkFDeEQ7WUFDSixJQUFJLEVBQUVrMEIsT0FBTyxFQUFFLEdBQUd4dkIsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVM7WUFDdEMsdUVBQXVFO1lBQ3ZFLElBQUkybkIsV0FBV0EsUUFBUWx6QixHQUFHLEdBQUcsR0FDekIwRCxLQUFLbWQsUUFBUSxDQUFDbmQsS0FBSzBGLEtBQUssQ0FBQzBYLEVBQUUsQ0FBQytCLE1BQU0sQ0FBQ3FRLFFBQVFsekIsR0FBRyxHQUFHLEdBQUdrekIsUUFBUWx6QixHQUFHLEVBQUUrZ0IsY0FBYztRQUN2RixHQUFHO0lBQ1A7QUFDSjtBQUNBLHdDQUF3QztBQUN4QyxJQUFLLElBQUl0SCxRQUFRa1AsYUFDYkQsUUFBUSxDQUFDalAsS0FBSyxHQUFHa1AsWUFBWSxDQUFDbFAsS0FBSztBQUV2QyxTQUFTMFosWUFBWXRaLENBQUMsRUFBRUMsQ0FBQztJQUNyQixJQUFJRCxLQUFLQyxHQUNMLE9BQU87SUFDWCxJQUFLLElBQUkvUSxLQUFLOFEsRUFDVixJQUFJQSxDQUFDLENBQUM5USxFQUFFLEtBQUsrUSxDQUFDLENBQUMvUSxFQUFFLEVBQ2IsT0FBTztJQUNmLElBQUssSUFBSUEsS0FBSytRLEVBQ1YsSUFBSSxDQUFFL1EsQ0FBQUEsS0FBSzhRLENBQUFBLEdBQ1AsT0FBTztJQUNmLE9BQU87QUFDWDtBQUNBLE1BQU11WjtJQUNGdmxCLFlBQVkrRCxLQUFLLEVBQUVDLElBQUksQ0FBRTtRQUNyQixJQUFJLENBQUNELEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLElBQUksR0FBR0EsUUFBUXdoQjtRQUNwQixJQUFJLENBQUNwd0IsSUFBSSxHQUFHLElBQUksQ0FBQzRPLElBQUksQ0FBQzVPLElBQUksSUFBSTtJQUNsQztJQUNBa2xCLElBQUlnSyxPQUFPLEVBQUVtQixJQUFJLEVBQUV2MUIsTUFBTSxFQUFFdzFCLFNBQVMsRUFBRTtRQUNsQyxJQUFJLEVBQUV2ekIsR0FBRyxFQUFFd3pCLE9BQU8sRUFBRSxHQUFHckIsUUFBUXNCLFNBQVMsQ0FBQ0gsS0FBSy8yQixJQUFJLEdBQUdnM0IsV0FBVyxJQUFJLENBQUN0d0IsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJO1FBQ3JGLE9BQU91d0IsVUFBVSxPQUFPLElBQUlFLFdBQVcxekIsTUFBTWpDLFFBQVFpQyxNQUFNakMsUUFBUSxJQUFJO0lBQzNFO0lBQ0E0MUIsUUFBUTtRQUFFLE9BQU87SUFBTTtJQUN2QnZoQixHQUFHd2hCLEtBQUssRUFBRTtRQUNOLE9BQU8sSUFBSSxJQUFJQSxTQUNWQSxpQkFBaUJSLGNBQ2IsS0FBSSxDQUFDdmhCLElBQUksQ0FBQzNTLEdBQUcsSUFBSSxJQUFJLENBQUMyUyxJQUFJLENBQUMzUyxHQUFHLElBQUkwMEIsTUFBTS9oQixJQUFJLENBQUMzUyxHQUFHLElBQzdDLElBQUksQ0FBQzBTLEtBQUssSUFBSWdpQixNQUFNaGlCLEtBQUssSUFBSXVoQixZQUFZLElBQUksQ0FBQ3RoQixJQUFJLEVBQUUraEIsTUFBTS9oQixJQUFJO0lBQzlFO0lBQ0FuRCxRQUFRN1MsSUFBSSxFQUFFO1FBQ1YsSUFBSSxJQUFJLENBQUNnVyxJQUFJLENBQUNuRCxPQUFPLEVBQ2pCLElBQUksQ0FBQ21ELElBQUksQ0FBQ25ELE9BQU8sQ0FBQzdTO0lBQzFCO0FBQ0o7QUFDQSxNQUFNZzRCO0lBQ0ZobUIsWUFBWXNGLEtBQUssRUFBRXRCLElBQUksQ0FBRTtRQUNyQixJQUFJLENBQUNzQixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDdEIsSUFBSSxHQUFHQSxRQUFRd2hCO0lBQ3hCO0lBQ0FsTCxJQUFJZ0ssT0FBTyxFQUFFbUIsSUFBSSxFQUFFdjFCLE1BQU0sRUFBRXcxQixTQUFTLEVBQUU7UUFDbEMsSUFBSWgzQixPQUFPNDFCLFFBQVFoSyxHQUFHLENBQUNtTCxLQUFLLzJCLElBQUksR0FBR2czQixXQUFXLElBQUksQ0FBQzFoQixJQUFJLENBQUNpaUIsY0FBYyxHQUFHLENBQUMsSUFBSSxLQUFLLzFCO1FBQ25GLElBQUl2QixLQUFLMjFCLFFBQVFoSyxHQUFHLENBQUNtTCxLQUFLOTJCLEVBQUUsR0FBRysyQixXQUFXLElBQUksQ0FBQzFoQixJQUFJLENBQUNraUIsWUFBWSxHQUFHLElBQUksQ0FBQyxLQUFLaDJCO1FBQzdFLE9BQU94QixRQUFRQyxLQUFLLE9BQU8sSUFBSWszQixXQUFXbjNCLE1BQU1DLElBQUksSUFBSTtJQUM1RDtJQUNBbTNCLE1BQU12ekIsQ0FBQyxFQUFFa3pCLElBQUksRUFBRTtRQUFFLE9BQU9BLEtBQUsvMkIsSUFBSSxHQUFHKzJCLEtBQUs5MkIsRUFBRTtJQUFFO0lBQzdDNFYsR0FBR3doQixLQUFLLEVBQUU7UUFDTixPQUFPLElBQUksSUFBSUEsU0FDVkEsaUJBQWlCQyxjQUFjVixZQUFZLElBQUksQ0FBQ2hnQixLQUFLLEVBQUV5Z0IsTUFBTXpnQixLQUFLLEtBQy9EZ2dCLFlBQVksSUFBSSxDQUFDdGhCLElBQUksRUFBRStoQixNQUFNL2hCLElBQUk7SUFDN0M7SUFDQSxPQUFPbWlCLEdBQUdWLElBQUksRUFBRTtRQUFFLE9BQU9BLEtBQUtuaUIsSUFBSSxZQUFZMGlCO0lBQVk7SUFDMURubEIsVUFBVSxDQUFFO0FBQ2hCO0FBQ0EsTUFBTXVsQjtJQUNGcG1CLFlBQVlzRixLQUFLLEVBQUV0QixJQUFJLENBQUU7UUFDckIsSUFBSSxDQUFDc0IsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3RCLElBQUksR0FBR0EsUUFBUXdoQjtJQUN4QjtJQUNBbEwsSUFBSWdLLE9BQU8sRUFBRW1CLElBQUksRUFBRXYxQixNQUFNLEVBQUV3MUIsU0FBUyxFQUFFO1FBQ2xDLElBQUloM0IsT0FBTzQxQixRQUFRc0IsU0FBUyxDQUFDSCxLQUFLLzJCLElBQUksR0FBR2czQixXQUFXO1FBQ3BELElBQUloM0IsS0FBS2kzQixPQUFPLEVBQ1osT0FBTztRQUNYLElBQUloM0IsS0FBSzIxQixRQUFRc0IsU0FBUyxDQUFDSCxLQUFLOTJCLEVBQUUsR0FBRysyQixXQUFXLENBQUM7UUFDakQsSUFBSS8yQixHQUFHZzNCLE9BQU8sSUFBSWgzQixHQUFHd0QsR0FBRyxJQUFJekQsS0FBS3lELEdBQUcsRUFDaEMsT0FBTztRQUNYLE9BQU8sSUFBSTB6QixXQUFXbjNCLEtBQUt5RCxHQUFHLEdBQUdqQyxRQUFRdkIsR0FBR3dELEdBQUcsR0FBR2pDLFFBQVEsSUFBSTtJQUNsRTtJQUNBNDFCLE1BQU05M0IsSUFBSSxFQUFFeTNCLElBQUksRUFBRTtRQUNkLElBQUksRUFBRXgzQixLQUFLLEVBQUVpQyxNQUFNLEVBQUUsR0FBR2xDLEtBQUt3TixPQUFPLENBQUM2cUIsU0FBUyxDQUFDWixLQUFLLzJCLElBQUksR0FBR3lLO1FBQzNELE9BQU9qSixVQUFVdTFCLEtBQUsvMkIsSUFBSSxJQUFJLENBQUMsQ0FBQ3lLLFFBQVFuTCxLQUFLbUwsS0FBSyxDQUFDbEwsTUFBSyxFQUFHd00sTUFBTSxJQUFJdkssU0FBU2lKLE1BQU14SixRQUFRLElBQUk4MUIsS0FBSzkyQixFQUFFO0lBQzNHO0lBQ0E0VixHQUFHd2hCLEtBQUssRUFBRTtRQUNOLE9BQU8sSUFBSSxJQUFJQSxTQUNWQSxpQkFBaUJLLFlBQVlkLFlBQVksSUFBSSxDQUFDaGdCLEtBQUssRUFBRXlnQixNQUFNemdCLEtBQUssS0FDN0RnZ0IsWUFBWSxJQUFJLENBQUN0aEIsSUFBSSxFQUFFK2hCLE1BQU0vaEIsSUFBSTtJQUM3QztJQUNBbkQsVUFBVSxDQUFFO0FBQ2hCO0FBQ0E7Ozs7QUFJQSxHQUNBLE1BQU1nbEI7SUFDRjs7SUFFQSxHQUNBN2xCLFlBQ0E7O0lBRUEsR0FDQXRSLElBQUksRUFDSjs7O0lBR0EsR0FDQUMsRUFBRSxFQUNGOztJQUVBLEdBQ0EyVSxJQUFJLENBQUU7UUFDRixJQUFJLENBQUM1VSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDMlUsSUFBSSxHQUFHQTtJQUNoQjtJQUNBOztJQUVBLEdBQ0FvQyxLQUFLaFgsSUFBSSxFQUFFQyxFQUFFLEVBQUU7UUFDWCxPQUFPLElBQUlrM0IsV0FBV24zQixNQUFNQyxJQUFJLElBQUksQ0FBQzJVLElBQUk7SUFDN0M7SUFDQTs7SUFFQSxHQUNBaUIsR0FBR3doQixLQUFLLEVBQUU3MUIsU0FBUyxDQUFDLEVBQUU7UUFDbEIsT0FBTyxJQUFJLENBQUNvVCxJQUFJLENBQUNpQixFQUFFLENBQUN3aEIsTUFBTXppQixJQUFJLEtBQUssSUFBSSxDQUFDNVUsSUFBSSxHQUFHd0IsVUFBVTYxQixNQUFNcjNCLElBQUksSUFBSSxJQUFJLENBQUNDLEVBQUUsR0FBR3VCLFVBQVU2MUIsTUFBTXAzQixFQUFFO0lBQ3ZHO0lBQ0E7O0lBRUEsR0FDQTJyQixJQUFJZ0ssT0FBTyxFQUFFcDBCLE1BQU0sRUFBRXcxQixTQUFTLEVBQUU7UUFDNUIsT0FBTyxJQUFJLENBQUNwaUIsSUFBSSxDQUFDZ1gsR0FBRyxDQUFDZ0ssU0FBUyxJQUFJLEVBQUVwMEIsUUFBUXcxQjtJQUNoRDtJQUNBOzs7Ozs7O0lBT0EsR0FDQSxPQUFPdGxCLE9BQU9qTyxHQUFHLEVBQUU0UixLQUFLLEVBQUVDLElBQUksRUFBRTtRQUM1QixPQUFPLElBQUk2aEIsV0FBVzF6QixLQUFLQSxLQUFLLElBQUlvekIsV0FBV3hoQixPQUFPQztJQUMxRDtJQUNBOzs7SUFHQSxHQUNBLE9BQU9pQixPQUFPdlcsSUFBSSxFQUFFQyxFQUFFLEVBQUUyVyxLQUFLLEVBQUV0QixJQUFJLEVBQUU7UUFDakMsT0FBTyxJQUFJNmhCLFdBQVduM0IsTUFBTUMsSUFBSSxJQUFJcTNCLFdBQVcxZ0IsT0FBT3RCO0lBQzFEO0lBQ0E7Ozs7SUFJQSxHQUNBLE9BQU9oVyxLQUFLVSxJQUFJLEVBQUVDLEVBQUUsRUFBRTJXLEtBQUssRUFBRXRCLElBQUksRUFBRTtRQUMvQixPQUFPLElBQUk2aEIsV0FBV24zQixNQUFNQyxJQUFJLElBQUl5M0IsU0FBUzlnQixPQUFPdEI7SUFDeEQ7SUFDQTs7O0lBR0EsR0FDQSxJQUFJQSxPQUFPO1FBQUUsT0FBTyxJQUFJLENBQUNWLElBQUksQ0FBQ1UsSUFBSTtJQUFFO0lBQ3BDOztJQUVBLEdBQ0EsSUFBSWlCLFNBQVM7UUFBRSxPQUFPLElBQUksQ0FBQzNCLElBQUksWUFBWTBpQjtJQUFZO0lBQ3ZEOztJQUVBLEdBQ0EsSUFBSTVsQixTQUFTO1FBQUUsT0FBTyxJQUFJLENBQUNrRCxJQUFJLFlBQVlpaUI7SUFBWTtBQUMzRDtBQUNBLE1BQU0vZCxPQUFPLEVBQUUsRUFBRWdlLFNBQVMsQ0FBQztBQUMzQjs7Ozs7QUFLQSxHQUNBLE1BQU1jO0lBQ0Y7O0lBRUEsR0FDQXRtQixZQUFZdW1CLEtBQUssRUFBRXRtQixRQUFRLENBQUU7UUFDekIsSUFBSSxDQUFDc21CLEtBQUssR0FBR0EsTUFBTXQzQixNQUFNLEdBQUdzM0IsUUFBUS9lO1FBQ3BDLElBQUksQ0FBQ3ZILFFBQVEsR0FBR0EsU0FBU2hSLE1BQU0sR0FBR2dSLFdBQVd1SDtJQUNqRDtJQUNBOzs7O0lBSUEsR0FDQSxPQUFPeEMsT0FBT3JULEdBQUcsRUFBRTYwQixXQUFXLEVBQUU7UUFDNUIsT0FBT0EsWUFBWXYzQixNQUFNLEdBQUd3M0IsVUFBVUQsYUFBYTcwQixLQUFLLEdBQUc2ekIsVUFBVWhmO0lBQ3pFO0lBQ0E7Ozs7Ozs7SUFPQSxHQUNBdEssS0FBS29DLEtBQUssRUFBRUMsR0FBRyxFQUFFbW9CLFNBQVMsRUFBRTtRQUN4QixJQUFJdG5CLFNBQVMsRUFBRTtRQUNmLElBQUksQ0FBQ3VuQixTQUFTLENBQUNyb0IsU0FBUyxPQUFPLElBQUlBLE9BQU9DLE9BQU8sT0FBTyxNQUFNQSxLQUFLYSxRQUFRLEdBQUdzbkI7UUFDOUUsT0FBT3RuQjtJQUNYO0lBQ0F1bkIsVUFBVXJvQixLQUFLLEVBQUVDLEdBQUcsRUFBRWEsTUFBTSxFQUFFbFAsTUFBTSxFQUFFdzJCLFNBQVMsRUFBRTtRQUM3QyxJQUFLLElBQUl4dUIsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3F1QixLQUFLLENBQUN0M0IsTUFBTSxFQUFFaUosSUFBSztZQUN4QyxJQUFJdXRCLE9BQU8sSUFBSSxDQUFDYyxLQUFLLENBQUNydUIsRUFBRTtZQUN4QixJQUFJdXRCLEtBQUsvMkIsSUFBSSxJQUFJNlAsT0FBT2tuQixLQUFLOTJCLEVBQUUsSUFBSTJQLFNBQVUsRUFBQ29vQixhQUFhQSxVQUFVakIsS0FBS3poQixJQUFJLElBQzFFNUUsT0FBT3ZILElBQUksQ0FBQzR0QixLQUFLL2YsSUFBSSxDQUFDK2YsS0FBSy8yQixJQUFJLEdBQUd3QixRQUFRdTFCLEtBQUs5MkIsRUFBRSxHQUFHdUI7UUFDNUQ7UUFDQSxJQUFLLElBQUlnSSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDK0gsUUFBUSxDQUFDaFIsTUFBTSxFQUFFaUosS0FBSyxFQUFHO1lBQzlDLElBQUksSUFBSSxDQUFDK0gsUUFBUSxDQUFDL0gsRUFBRSxHQUFHcUcsT0FBTyxJQUFJLENBQUMwQixRQUFRLENBQUMvSCxJQUFJLEVBQUUsR0FBR29HLE9BQU87Z0JBQ3hELElBQUlzb0IsV0FBVyxJQUFJLENBQUMzbUIsUUFBUSxDQUFDL0gsRUFBRSxHQUFHO2dCQUNsQyxJQUFJLENBQUMrSCxRQUFRLENBQUMvSCxJQUFJLEVBQUUsQ0FBQ3l1QixTQUFTLENBQUNyb0IsUUFBUXNvQixVQUFVcm9CLE1BQU1xb0IsVUFBVXhuQixRQUFRbFAsU0FBUzAyQixVQUFVRjtZQUNoRztRQUNKO0lBQ0o7SUFDQTs7O0lBR0EsR0FDQXBNLElBQUlnSyxPQUFPLEVBQUUzeUIsR0FBRyxFQUFFazFCLE9BQU8sRUFBRTtRQUN2QixJQUFJLElBQUksSUFBSXJnQixTQUFTOGQsUUFBUUssSUFBSSxDQUFDMTFCLE1BQU0sSUFBSSxHQUN4QyxPQUFPLElBQUk7UUFDZixPQUFPLElBQUksQ0FBQzYzQixRQUFRLENBQUN4QyxTQUFTM3lCLEtBQUssR0FBRyxHQUFHazFCLFdBQVdyQjtJQUN4RDtJQUNBOztJQUVBLEdBQ0FzQixTQUFTeEMsT0FBTyxFQUFFdDJCLElBQUksRUFBRWtDLE1BQU0sRUFBRXcxQixTQUFTLEVBQUVtQixPQUFPLEVBQUU7UUFDaEQsSUFBSUU7UUFDSixJQUFLLElBQUk3dUIsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3F1QixLQUFLLENBQUN0M0IsTUFBTSxFQUFFaUosSUFBSztZQUN4QyxJQUFJOHVCLFNBQVMsSUFBSSxDQUFDVCxLQUFLLENBQUNydUIsRUFBRSxDQUFDb2lCLEdBQUcsQ0FBQ2dLLFNBQVNwMEIsUUFBUXcxQjtZQUNoRCxJQUFJc0IsVUFBVUEsT0FBTzFqQixJQUFJLENBQUN3aUIsS0FBSyxDQUFDOTNCLE1BQU1nNUIsU0FDbEMsQ0FBQ0QsWUFBYUEsQ0FBQUEsV0FBVyxFQUFFLEdBQUdsdkIsSUFBSSxDQUFDbXZCO2lCQUNsQyxJQUFJSCxRQUFRSSxRQUFRLEVBQ3JCSixRQUFRSSxRQUFRLENBQUMsSUFBSSxDQUFDVixLQUFLLENBQUNydUIsRUFBRSxDQUFDOEwsSUFBSTtRQUMzQztRQUNBLElBQUksSUFBSSxDQUFDL0QsUUFBUSxDQUFDaFIsTUFBTSxFQUNwQixPQUFPaTRCLFlBQVksSUFBSSxDQUFDam5CLFFBQVEsRUFBRThtQixZQUFZLEVBQUUsRUFBRXpDLFNBQVN0MkIsTUFBTWtDLFFBQVF3MUIsV0FBV21CO2FBRXBGLE9BQU9FLFdBQVcsSUFBSVQsY0FBY1MsU0FBUzlYLElBQUksQ0FBQ2tZLFFBQVEzZixRQUFRaEI7SUFDMUU7SUFDQTs7Ozs7SUFLQSxHQUNBbEMsSUFBSTNTLEdBQUcsRUFBRTYwQixXQUFXLEVBQUU7UUFDbEIsSUFBSSxDQUFDQSxZQUFZdjNCLE1BQU0sRUFDbkIsT0FBTyxJQUFJO1FBQ2YsSUFBSSxJQUFJLElBQUl1WCxPQUNSLE9BQU84ZixjQUFjdGhCLE1BQU0sQ0FBQ3JULEtBQUs2MEI7UUFDckMsT0FBTyxJQUFJLENBQUNZLFFBQVEsQ0FBQ3oxQixLQUFLNjBCLGFBQWE7SUFDM0M7SUFDQVksU0FBU3oxQixHQUFHLEVBQUU2MEIsV0FBVyxFQUFFdDJCLE1BQU0sRUFBRTtRQUMvQixJQUFJK1AsVUFBVTVHLGFBQWE7UUFDM0IxSCxJQUFJcWxCLE9BQU8sQ0FBQyxDQUFDcVEsV0FBV0M7WUFDcEIsSUFBSUMsYUFBYUQsY0FBY3AzQixRQUFRd2M7WUFDdkMsSUFBSSxDQUFFQSxDQUFBQSxRQUFROGEsaUJBQWlCaEIsYUFBYWEsV0FBV0UsV0FBVSxHQUM3RDtZQUNKLElBQUksQ0FBQ3RuQixVQUNEQSxXQUFXLElBQUksQ0FBQ0EsUUFBUSxDQUFDd0YsS0FBSztZQUNsQyxNQUFPcE0sYUFBYTRHLFNBQVNoUixNQUFNLElBQUlnUixRQUFRLENBQUM1RyxXQUFXLEdBQUdpdUIsWUFDMURqdUIsY0FBYztZQUNsQixJQUFJNEcsUUFBUSxDQUFDNUcsV0FBVyxJQUFJaXVCLGFBQ3hCcm5CLFFBQVEsQ0FBQzVHLGFBQWEsRUFBRSxHQUFHNEcsUUFBUSxDQUFDNUcsYUFBYSxFQUFFLENBQUMrdEIsUUFBUSxDQUFDQyxXQUFXM2EsT0FBTzZhLGFBQWE7aUJBRTVGdG5CLFNBQVNvTSxNQUFNLENBQUNoVCxZQUFZLEdBQUdpdUIsYUFBYUEsY0FBY0QsVUFBVTEzQixRQUFRLEVBQUU4MkIsVUFBVS9aLE9BQU8yYSxXQUFXRSxhQUFhLEdBQUcvQjtZQUM5SG5zQixjQUFjO1FBQ2xCO1FBQ0EsSUFBSWt0QixRQUFRa0IsVUFBVXB1QixhQUFhcXVCLGFBQWFsQixlQUFlQSxhQUFhLENBQUN0MkI7UUFDN0UsSUFBSyxJQUFJZ0ksSUFBSSxHQUFHQSxJQUFJcXVCLE1BQU10M0IsTUFBTSxFQUFFaUosSUFDOUIsSUFBSSxDQUFDcXVCLEtBQUssQ0FBQ3J1QixFQUFFLENBQUNvTCxJQUFJLENBQUN3aUIsS0FBSyxDQUFDbjBCLEtBQUs0MEIsS0FBSyxDQUFDcnVCLEVBQUUsR0FDbENxdUIsTUFBTWxhLE1BQU0sQ0FBQ25VLEtBQUs7UUFDMUIsT0FBTyxJQUFJb3VCLGNBQWNDLE1BQU10M0IsTUFBTSxHQUFHLElBQUksQ0FBQ3MzQixLQUFLLENBQUNvQixNQUFNLENBQUNwQixPQUFPdFgsSUFBSSxDQUFDa1ksU0FBUyxJQUFJLENBQUNaLEtBQUssRUFBRXRtQixZQUFZLElBQUksQ0FBQ0EsUUFBUTtJQUN4SDtJQUNBOzs7SUFHQSxHQUNBdUosT0FBT2dkLFdBQVcsRUFBRTtRQUNoQixJQUFJQSxZQUFZdjNCLE1BQU0sSUFBSSxLQUFLLElBQUksSUFBSXVYLE9BQ25DLE9BQU8sSUFBSTtRQUNmLE9BQU8sSUFBSSxDQUFDb2hCLFdBQVcsQ0FBQ3BCLGFBQWE7SUFDekM7SUFDQW9CLFlBQVlwQixXQUFXLEVBQUV0MkIsTUFBTSxFQUFFO1FBQzdCLElBQUkrUCxXQUFXLElBQUksQ0FBQ0EsUUFBUSxFQUFFc21CLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ2hELElBQUssSUFBSXJ1QixJQUFJLEdBQUdBLElBQUkrSCxTQUFTaFIsTUFBTSxFQUFFaUosS0FBSyxFQUFHO1lBQ3pDLElBQUl3VTtZQUNKLElBQUloZSxPQUFPdVIsUUFBUSxDQUFDL0gsRUFBRSxHQUFHaEksUUFBUXZCLEtBQUtzUixRQUFRLENBQUMvSCxJQUFJLEVBQUUsR0FBR2hJO1lBQ3hELElBQUssSUFBSTZLLElBQUksR0FBRzBxQixNQUFNMXFCLElBQUl5ckIsWUFBWXYzQixNQUFNLEVBQUU4TCxJQUMxQyxJQUFJMHFCLE9BQU9lLFdBQVcsQ0FBQ3pyQixFQUFFLEVBQUU7Z0JBQ3ZCLElBQUkwcUIsS0FBSy8yQixJQUFJLEdBQUdBLFFBQVErMkIsS0FBSzkyQixFQUFFLEdBQUdBLElBQUk7b0JBQ2xDNjNCLFdBQVcsQ0FBQ3pyQixFQUFFLEdBQUc7b0JBQ2hCMlIsQ0FBQUEsU0FBVUEsQ0FBQUEsUUFBUSxFQUFFLEdBQUc3VSxJQUFJLENBQUM0dEI7Z0JBQ2pDO1lBQ0o7WUFDSixJQUFJLENBQUMvWSxPQUNEO1lBQ0osSUFBSXpNLFlBQVksSUFBSSxDQUFDQSxRQUFRLEVBQ3pCQSxXQUFXLElBQUksQ0FBQ0EsUUFBUSxDQUFDd0YsS0FBSztZQUNsQyxJQUFJb2lCLFVBQVU1bkIsUUFBUSxDQUFDL0gsSUFBSSxFQUFFLENBQUMwdkIsV0FBVyxDQUFDbGIsT0FBT2hlLE9BQU87WUFDeEQsSUFBSW01QixXQUFXcmhCLE9BQU87Z0JBQ2xCdkcsUUFBUSxDQUFDL0gsSUFBSSxFQUFFLEdBQUcydkI7WUFDdEIsT0FDSztnQkFDRDVuQixTQUFTb00sTUFBTSxDQUFDblUsR0FBRztnQkFDbkJBLEtBQUs7WUFDVDtRQUNKO1FBQ0EsSUFBSXF1QixNQUFNdDNCLE1BQU0sRUFDWjtZQUFBLElBQUssSUFBSWlKLElBQUksR0FBR3V0QixNQUFNdnRCLElBQUlzdUIsWUFBWXYzQixNQUFNLEVBQUVpSixJQUMxQyxJQUFJdXRCLE9BQU9lLFdBQVcsQ0FBQ3R1QixFQUFFLEVBQUU7Z0JBQ3ZCLElBQUssSUFBSTZDLElBQUksR0FBR0EsSUFBSXdyQixNQUFNdDNCLE1BQU0sRUFBRThMLElBQzlCLElBQUl3ckIsS0FBSyxDQUFDeHJCLEVBQUUsQ0FBQ3dKLEVBQUUsQ0FBQ2toQixNQUFNdjFCLFNBQVM7b0JBQzNCLElBQUlxMkIsU0FBUyxJQUFJLENBQUNBLEtBQUssRUFDbkJBLFFBQVEsSUFBSSxDQUFDQSxLQUFLLENBQUM5Z0IsS0FBSztvQkFDNUI4Z0IsTUFBTWxhLE1BQU0sQ0FBQ3RSLEtBQUs7Z0JBQ3RCO1lBQ1I7UUFBQTtRQUNSLElBQUlrRixZQUFZLElBQUksQ0FBQ0EsUUFBUSxJQUFJc21CLFNBQVMsSUFBSSxDQUFDQSxLQUFLLEVBQ2hELE9BQU8sSUFBSTtRQUNmLE9BQU9BLE1BQU10M0IsTUFBTSxJQUFJZ1IsU0FBU2hSLE1BQU0sR0FBRyxJQUFJcTNCLGNBQWNDLE9BQU90bUIsWUFBWXVHO0lBQ2xGO0lBQ0FvSSxTQUFTMWUsTUFBTSxFQUFFbEMsSUFBSSxFQUFFO1FBQ25CLElBQUksSUFBSSxJQUFJd1ksT0FDUixPQUFPLElBQUk7UUFDZixJQUFJeFksS0FBSzBZLE1BQU0sRUFDWCxPQUFPNGYsY0FBYzlmLEtBQUs7UUFDOUIsSUFBSXJOLE9BQU9vdEI7UUFDWCxJQUFLLElBQUlydUIsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQytILFFBQVEsQ0FBQ2hSLE1BQU0sRUFBRWlKLEtBQUssRUFDM0MsSUFBSSxJQUFJLENBQUMrSCxRQUFRLENBQUMvSCxFQUFFLElBQUloSSxRQUFRO1lBQzVCLElBQUksSUFBSSxDQUFDK1AsUUFBUSxDQUFDL0gsRUFBRSxJQUFJaEksUUFDcEJpSixRQUFRLElBQUksQ0FBQzhHLFFBQVEsQ0FBQy9ILElBQUksRUFBRTtZQUNoQztRQUNKO1FBQ0osSUFBSW9HLFFBQVFwTyxTQUFTLEdBQUdxTyxNQUFNRCxRQUFRdFEsS0FBS3dOLE9BQU8sQ0FBQ0MsSUFBSTtRQUN2RCxJQUFLLElBQUl2RCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDcXVCLEtBQUssQ0FBQ3QzQixNQUFNLEVBQUVpSixJQUFLO1lBQ3hDLElBQUk0dkIsTUFBTSxJQUFJLENBQUN2QixLQUFLLENBQUNydUIsRUFBRTtZQUN2QixJQUFJNHZCLElBQUlwNUIsSUFBSSxHQUFHNlAsT0FBT3VwQixJQUFJbjVCLEVBQUUsR0FBRzJQLFNBQVV3cEIsSUFBSXhrQixJQUFJLFlBQVkwaUIsWUFBYTtnQkFDdEUsSUFBSXQzQixPQUFPMkQsS0FBSzhFLEdBQUcsQ0FBQ21ILE9BQU93cEIsSUFBSXA1QixJQUFJLElBQUk0UCxPQUFPM1AsS0FBSzBELEtBQUtDLEdBQUcsQ0FBQ2lNLEtBQUt1cEIsSUFBSW41QixFQUFFLElBQUkyUDtnQkFDM0UsSUFBSTVQLE9BQU9DLElBQ1AsQ0FBQzQzQixTQUFVQSxDQUFBQSxRQUFRLEVBQUUsR0FBRzF1QixJQUFJLENBQUNpd0IsSUFBSXBpQixJQUFJLENBQUNoWCxNQUFNQztZQUNwRDtRQUNKO1FBQ0EsSUFBSTQzQixPQUFPO1lBQ1AsSUFBSXdCLFdBQVcsSUFBSXpCLGNBQWNDLE1BQU10WCxJQUFJLENBQUNrWSxRQUFRM2Y7WUFDcEQsT0FBT3JPLFFBQVEsSUFBSTZ1QixnQkFBZ0I7Z0JBQUNEO2dCQUFVNXVCO2FBQU0sSUFBSTR1QjtRQUM1RDtRQUNBLE9BQU81dUIsU0FBU3FOO0lBQ3BCO0lBQ0E7O0lBRUEsR0FDQWpDLEdBQUd3aEIsS0FBSyxFQUFFO1FBQ04sSUFBSSxJQUFJLElBQUlBLE9BQ1IsT0FBTztRQUNYLElBQUksQ0FBRUEsQ0FBQUEsaUJBQWlCTyxhQUFZLEtBQy9CLElBQUksQ0FBQ0MsS0FBSyxDQUFDdDNCLE1BQU0sSUFBSTgyQixNQUFNUSxLQUFLLENBQUN0M0IsTUFBTSxJQUN2QyxJQUFJLENBQUNnUixRQUFRLENBQUNoUixNQUFNLElBQUk4MkIsTUFBTTlsQixRQUFRLENBQUNoUixNQUFNLEVBQzdDLE9BQU87UUFDWCxJQUFLLElBQUlpSixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDcXVCLEtBQUssQ0FBQ3QzQixNQUFNLEVBQUVpSixJQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDcXVCLEtBQUssQ0FBQ3J1QixFQUFFLENBQUNxTSxFQUFFLENBQUN3aEIsTUFBTVEsS0FBSyxDQUFDcnVCLEVBQUUsR0FDaEMsT0FBTztRQUNmLElBQUssSUFBSUEsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQytILFFBQVEsQ0FBQ2hSLE1BQU0sRUFBRWlKLEtBQUssRUFDM0MsSUFBSSxJQUFJLENBQUMrSCxRQUFRLENBQUMvSCxFQUFFLElBQUk2dEIsTUFBTTlsQixRQUFRLENBQUMvSCxFQUFFLElBQ3JDLElBQUksQ0FBQytILFFBQVEsQ0FBQy9ILElBQUksRUFBRSxJQUFJNnRCLE1BQU05bEIsUUFBUSxDQUFDL0gsSUFBSSxFQUFFLElBQzdDLENBQUMsSUFBSSxDQUFDK0gsUUFBUSxDQUFDL0gsSUFBSSxFQUFFLENBQUNxTSxFQUFFLENBQUN3aEIsTUFBTTlsQixRQUFRLENBQUMvSCxJQUFJLEVBQUUsR0FDOUMsT0FBTztRQUNmLE9BQU87SUFDWDtJQUNBOztJQUVBLEdBQ0F5VyxPQUFPM2dCLElBQUksRUFBRTtRQUNULE9BQU9pNkIsY0FBYyxJQUFJLENBQUNDLFdBQVcsQ0FBQ2w2QjtJQUMxQztJQUNBOztJQUVBLEdBQ0FrNkIsWUFBWWw2QixJQUFJLEVBQUU7UUFDZCxJQUFJLElBQUksSUFBSXdZLE9BQ1IsT0FBT2dCO1FBQ1gsSUFBSXhaLEtBQUsrTyxhQUFhLElBQUksQ0FBQyxJQUFJLENBQUN3cEIsS0FBSyxDQUFDM0YsSUFBSSxDQUFDb0YsV0FBV0csRUFBRSxHQUNwRCxPQUFPLElBQUksQ0FBQ0ksS0FBSztRQUNyQixJQUFJbm5CLFNBQVMsRUFBRTtRQUNmLElBQUssSUFBSWxILElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNxdUIsS0FBSyxDQUFDdDNCLE1BQU0sRUFBRWlKLElBQUs7WUFDeEMsSUFBSSxDQUFFLEtBQUksQ0FBQ3F1QixLQUFLLENBQUNydUIsRUFBRSxDQUFDb0wsSUFBSSxZQUFZMGlCLFVBQVMsR0FDekM1bUIsT0FBT3ZILElBQUksQ0FBQyxJQUFJLENBQUMwdUIsS0FBSyxDQUFDcnVCLEVBQUU7UUFDakM7UUFDQSxPQUFPa0g7SUFDWDtJQUNBK29CLFdBQVcvcUIsQ0FBQyxFQUFFO1FBQUVBLEVBQUUsSUFBSTtJQUFHO0FBQzdCO0FBQ0E7O0FBRUEsR0FDQWtwQixjQUFjOWYsS0FBSyxHQUFHLElBQUk4ZixjQUFjLEVBQUUsRUFBRSxFQUFFO0FBQzlDOztBQUVBLEdBQ0FBLGNBQWMyQixhQUFhLEdBQUdBO0FBQzlCLE1BQU16aEIsUUFBUThmLGNBQWM5ZixLQUFLO0FBQ2pDLGtFQUFrRTtBQUNsRSxxRUFBcUU7QUFDckUseUNBQXlDO0FBQ3pDLE1BQU13aEI7SUFDRmhvQixZQUFZb29CLE9BQU8sQ0FBRTtRQUNqQixJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDbkI7SUFDQTlOLElBQUlnSyxPQUFPLEVBQUUzeUIsR0FBRyxFQUFFO1FBQ2QsTUFBTTAyQixjQUFjLElBQUksQ0FBQ0QsT0FBTyxDQUFDOU4sR0FBRyxDQUFDZ08sQ0FBQUEsU0FBVUEsT0FBT2hPLEdBQUcsQ0FBQ2dLLFNBQVMzeUIsS0FBSzZ6QjtRQUN4RSxPQUFPd0MsZ0JBQWdCdDVCLElBQUksQ0FBQzI1QjtJQUNoQztJQUNBelosU0FBUzFlLE1BQU0sRUFBRWlKLEtBQUssRUFBRTtRQUNwQixJQUFJQSxNQUFNdU4sTUFBTSxFQUNaLE9BQU80ZixjQUFjOWYsS0FBSztRQUM5QixJQUFJa0csUUFBUSxFQUFFO1FBQ2QsSUFBSyxJQUFJeFUsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2t3QixPQUFPLENBQUNuNUIsTUFBTSxFQUFFaUosSUFBSztZQUMxQyxJQUFJa0gsU0FBUyxJQUFJLENBQUNncEIsT0FBTyxDQUFDbHdCLEVBQUUsQ0FBQzBXLFFBQVEsQ0FBQzFlLFFBQVFpSjtZQUM5QyxJQUFJaUcsVUFBVW9ILE9BQ1Y7WUFDSixJQUFJcEgsa0JBQWtCNG9CLGlCQUNsQnRiLFFBQVFBLE1BQU1pYixNQUFNLENBQUN2b0IsT0FBT2dwQixPQUFPO2lCQUVuQzFiLE1BQU03VSxJQUFJLENBQUN1SDtRQUNuQjtRQUNBLE9BQU80b0IsZ0JBQWdCdDVCLElBQUksQ0FBQ2dlO0lBQ2hDO0lBQ0FuSSxHQUFHd2hCLEtBQUssRUFBRTtRQUNOLElBQUksQ0FBRUEsQ0FBQUEsaUJBQWlCaUMsZUFBYyxLQUNqQ2pDLE1BQU1xQyxPQUFPLENBQUNuNUIsTUFBTSxJQUFJLElBQUksQ0FBQ201QixPQUFPLENBQUNuNUIsTUFBTSxFQUMzQyxPQUFPO1FBQ1gsSUFBSyxJQUFJaUosSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2t3QixPQUFPLENBQUNuNUIsTUFBTSxFQUFFaUosSUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQ2t3QixPQUFPLENBQUNsd0IsRUFBRSxDQUFDcU0sRUFBRSxDQUFDd2hCLE1BQU1xQyxPQUFPLENBQUNsd0IsRUFBRSxHQUNwQyxPQUFPO1FBQ2YsT0FBTztJQUNYO0lBQ0F5VyxPQUFPM2dCLElBQUksRUFBRTtRQUNULElBQUlvUixRQUFRbXBCLFNBQVM7UUFDckIsSUFBSyxJQUFJcndCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNrd0IsT0FBTyxDQUFDbjVCLE1BQU0sRUFBRWlKLElBQUs7WUFDMUMsSUFBSXlXLFNBQVMsSUFBSSxDQUFDeVosT0FBTyxDQUFDbHdCLEVBQUUsQ0FBQ2d3QixXQUFXLENBQUNsNkI7WUFDekMsSUFBSSxDQUFDMmdCLE9BQU8xZixNQUFNLEVBQ2Q7WUFDSixJQUFJLENBQUNtUSxRQUFRO2dCQUNUQSxTQUFTdVA7WUFDYixPQUNLO2dCQUNELElBQUk0WixRQUFRO29CQUNSbnBCLFNBQVNBLE9BQU9xRyxLQUFLO29CQUNyQjhpQixTQUFTO2dCQUNiO2dCQUNBLElBQUssSUFBSXh0QixJQUFJLEdBQUdBLElBQUk0VCxPQUFPMWYsTUFBTSxFQUFFOEwsSUFDL0JxRSxPQUFPdkgsSUFBSSxDQUFDOFcsTUFBTSxDQUFDNVQsRUFBRTtZQUM3QjtRQUNKO1FBQ0EsT0FBT3FFLFNBQVM2b0IsY0FBY00sU0FBU25wQixTQUFTQSxPQUFPNlAsSUFBSSxDQUFDa1ksVUFBVTNmO0lBQzFFO0lBQ0EsbUVBQW1FO0lBQ25FLDhCQUE4QjtJQUM5QixPQUFPOVksS0FBSzA1QixPQUFPLEVBQUU7UUFDakIsT0FBUUEsUUFBUW41QixNQUFNO1lBQ2xCLEtBQUs7Z0JBQUcsT0FBT3VYO1lBQ2YsS0FBSztnQkFBRyxPQUFPNGhCLE9BQU8sQ0FBQyxFQUFFO1lBQ3pCO2dCQUFTLE9BQU8sSUFBSUosZ0JBQWdCSSxRQUFRSSxLQUFLLENBQUMzYyxDQUFBQSxJQUFLQSxhQUFheWEsaUJBQWlCOEIsVUFDakZBLFFBQVFLLE1BQU0sQ0FBQyxDQUFDQyxHQUFHN2MsSUFBTTZjLEVBQUVmLE1BQU0sQ0FBQzliLGFBQWF5YSxnQkFBZ0J6YSxJQUFJQSxFQUFFdWMsT0FBTyxHQUFHLEVBQUU7UUFDekY7SUFDSjtJQUNBRCxXQUFXL3FCLENBQUMsRUFBRTtRQUNWLElBQUssSUFBSWxGLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNrd0IsT0FBTyxDQUFDbjVCLE1BQU0sRUFBRWlKLElBQ3JDLElBQUksQ0FBQ2t3QixPQUFPLENBQUNsd0IsRUFBRSxDQUFDaXdCLFVBQVUsQ0FBQy9xQjtJQUNuQztBQUNKO0FBQ0EsU0FBUzhwQixZQUFZeUIsV0FBVyxFQUFFNUIsUUFBUSxFQUFFekMsT0FBTyxFQUFFdDJCLElBQUksRUFBRWtDLE1BQU0sRUFBRXcxQixTQUFTLEVBQUVtQixPQUFPO0lBQ2pGLElBQUk1bUIsV0FBVzBvQixZQUFZbGpCLEtBQUs7SUFDaEMsOERBQThEO0lBQzlELHlDQUF5QztJQUN6QyxJQUFLLElBQUl2TixJQUFJLEdBQUdxdkIsYUFBYTdCLFdBQVd4dEIsSUFBSW9zQixRQUFRSyxJQUFJLENBQUMxMUIsTUFBTSxFQUFFaUosSUFBSztRQUNsRSxJQUFJMHdCLFFBQVE7UUFDWnRFLFFBQVFLLElBQUksQ0FBQ3pzQixFQUFFLENBQUM4ZSxPQUFPLENBQUMsQ0FBQzZSLFVBQVVDLFFBQVFDLFVBQVVDO1lBQ2pELElBQUlDLFFBQVEsU0FBVUYsV0FBYUQsQ0FBQUEsU0FBU0QsUUFBTztZQUNuRCxJQUFLLElBQUkzd0IsSUFBSSxHQUFHQSxJQUFJK0gsU0FBU2hSLE1BQU0sRUFBRWlKLEtBQUssRUFBRztnQkFDekMsSUFBSXFHLE1BQU0wQixRQUFRLENBQUMvSCxJQUFJLEVBQUU7Z0JBQ3pCLElBQUlxRyxNQUFNLEtBQUtzcUIsV0FBV3RxQixNQUFNZ3BCLGFBQWFxQixPQUN6QztnQkFDSixJQUFJdHFCLFFBQVEyQixRQUFRLENBQUMvSCxFQUFFLEdBQUdxdkIsYUFBYXFCO2dCQUN2QyxJQUFJRSxVQUFVeHFCLE9BQU87b0JBQ2pCMkIsUUFBUSxDQUFDL0gsSUFBSSxFQUFFLEdBQUcyd0IsWUFBWXZxQixRQUFRLENBQUMsSUFBSSxDQUFDO2dCQUNoRCxPQUNLLElBQUl1cUIsWUFBWXRCLGNBQWMwQixPQUFPO29CQUN0Q2hwQixRQUFRLENBQUMvSCxFQUFFLElBQUkrd0I7b0JBQ2ZocEIsUUFBUSxDQUFDL0gsSUFBSSxFQUFFLElBQUkrd0I7Z0JBQ3ZCO1lBQ0o7WUFDQUwsU0FBU0s7UUFDYjtRQUNBMUIsYUFBYWpELFFBQVFLLElBQUksQ0FBQ3pzQixFQUFFLENBQUNvaUIsR0FBRyxDQUFDaU4sWUFBWSxDQUFDO0lBQ2xEO0lBQ0EsK0RBQStEO0lBQy9ELGdFQUFnRTtJQUNoRSxJQUFJMkIsY0FBYztJQUNsQixJQUFLLElBQUloeEIsSUFBSSxHQUFHQSxJQUFJK0gsU0FBU2hSLE1BQU0sRUFBRWlKLEtBQUssRUFDdEMsSUFBSStILFFBQVEsQ0FBQy9ILElBQUksRUFBRSxHQUFHLEdBQUc7UUFDckIsSUFBSStILFFBQVEsQ0FBQy9ILElBQUksRUFBRSxJQUFJLENBQUMsR0FBRztZQUN2Qmd4QixjQUFjO1lBQ2RqcEIsUUFBUSxDQUFDL0gsSUFBSSxFQUFFLEdBQUcsQ0FBQztZQUNuQjtRQUNKO1FBQ0EsSUFBSXhKLE9BQU80MUIsUUFBUWhLLEdBQUcsQ0FBQ3FPLFdBQVcsQ0FBQ3p3QixFQUFFLEdBQUd3dEIsWUFBWXlELFlBQVl6NkIsT0FBT3dCO1FBQ3ZFLElBQUlpNUIsWUFBWSxLQUFLQSxhQUFhbjdCLEtBQUt3TixPQUFPLENBQUNDLElBQUksRUFBRTtZQUNqRHl0QixjQUFjO1lBQ2Q7UUFDSjtRQUNBLDREQUE0RDtRQUM1RCxJQUFJdjZCLEtBQUsyMUIsUUFBUWhLLEdBQUcsQ0FBQ3FPLFdBQVcsQ0FBQ3p3QixJQUFJLEVBQUUsR0FBR3d0QixXQUFXLENBQUMsSUFBSTBELFVBQVV6NkIsS0FBS3VCO1FBQ3pFLElBQUksRUFBRWpDLEtBQUssRUFBRWlDLFFBQVFvM0IsV0FBVyxFQUFFLEdBQUd0NUIsS0FBS3dOLE9BQU8sQ0FBQzZxQixTQUFTLENBQUM4QztRQUM1RCxJQUFJOUIsWUFBWXI1QixLQUFLcTdCLFVBQVUsQ0FBQ3A3QjtRQUNoQyxJQUFJbzVCLGFBQWFDLGVBQWU2QixhQUFhN0IsY0FBY0QsVUFBVTEzQixRQUFRLElBQUl5NUIsU0FBUztZQUN0RixJQUFJcEMsU0FBUy9tQixRQUFRLENBQUMvSCxJQUFJLEVBQUUsQ0FDdkI0dUIsUUFBUSxDQUFDeEMsU0FBUytDLFdBQVczNEIsT0FBTyxHQUFHaTZCLFdBQVcsQ0FBQ3p3QixFQUFFLEdBQUd3dEIsWUFBWSxHQUFHbUI7WUFDNUUsSUFBSUcsVUFBVXhnQixPQUFPO2dCQUNqQnZHLFFBQVEsQ0FBQy9ILEVBQUUsR0FBR2l4QjtnQkFDZGxwQixRQUFRLENBQUMvSCxJQUFJLEVBQUUsR0FBR2t4QjtnQkFDbEJucEIsUUFBUSxDQUFDL0gsSUFBSSxFQUFFLEdBQUc4dUI7WUFDdEIsT0FDSztnQkFDRC9tQixRQUFRLENBQUMvSCxJQUFJLEVBQUUsR0FBRyxDQUFDO2dCQUNuQmd4QixjQUFjO1lBQ2xCO1FBQ0osT0FDSztZQUNEQSxjQUFjO1FBQ2xCO0lBQ0o7SUFDSixrRkFBa0Y7SUFDbEYsSUFBSUEsYUFBYTtRQUNiLElBQUkxQyxjQUFjOEMsaUNBQWlDcnBCLFVBQVUwb0IsYUFBYTVCLFVBQVV6QyxTQUFTcDBCLFFBQVF3MUIsV0FBV21CO1FBQ2hILElBQUkwQyxRQUFROUMsVUFBVUQsYUFBYXg0QixNQUFNLEdBQUc2NEI7UUFDNUNFLFdBQVd3QyxNQUFNaEQsS0FBSztRQUN0QixJQUFLLElBQUlydUIsSUFBSSxHQUFHQSxJQUFJK0gsU0FBU2hSLE1BQU0sRUFBRWlKLEtBQUssRUFDdEMsSUFBSStILFFBQVEsQ0FBQy9ILElBQUksRUFBRSxHQUFHLEdBQUc7WUFDckIrSCxTQUFTb00sTUFBTSxDQUFDblUsR0FBRztZQUNuQkEsS0FBSztRQUNUO1FBQ0osSUFBSyxJQUFJQSxJQUFJLEdBQUc2QyxJQUFJLEdBQUc3QyxJQUFJcXhCLE1BQU10cEIsUUFBUSxDQUFDaFIsTUFBTSxFQUFFaUosS0FBSyxFQUFHO1lBQ3RELElBQUl4SixPQUFPNjZCLE1BQU10cEIsUUFBUSxDQUFDL0gsRUFBRTtZQUM1QixNQUFPNkMsSUFBSWtGLFNBQVNoUixNQUFNLElBQUlnUixRQUFRLENBQUNsRixFQUFFLEdBQUdyTSxLQUN4Q3FNLEtBQUs7WUFDVGtGLFNBQVNvTSxNQUFNLENBQUN0UixHQUFHLEdBQUd3dUIsTUFBTXRwQixRQUFRLENBQUMvSCxFQUFFLEVBQUVxeEIsTUFBTXRwQixRQUFRLENBQUMvSCxJQUFJLEVBQUUsRUFBRXF4QixNQUFNdHBCLFFBQVEsQ0FBQy9ILElBQUksRUFBRTtRQUN6RjtJQUNKO0lBQ0EsT0FBTyxJQUFJb3VCLGNBQWNTLFNBQVM5WCxJQUFJLENBQUNrWSxRQUFRbG5CO0FBQ25EO0FBQ0EsU0FBU3duQixVQUFVK0IsS0FBSyxFQUFFdDVCLE1BQU07SUFDNUIsSUFBSSxDQUFDQSxVQUFVLENBQUNzNUIsTUFBTXY2QixNQUFNLEVBQ3hCLE9BQU91NkI7SUFDWCxJQUFJcHFCLFNBQVMsRUFBRTtJQUNmLElBQUssSUFBSWxILElBQUksR0FBR0EsSUFBSXN4QixNQUFNdjZCLE1BQU0sRUFBRWlKLElBQUs7UUFDbkMsSUFBSXV0QixPQUFPK0QsS0FBSyxDQUFDdHhCLEVBQUU7UUFDbkJrSCxPQUFPdkgsSUFBSSxDQUFDLElBQUlndUIsV0FBV0osS0FBSy8yQixJQUFJLEdBQUd3QixRQUFRdTFCLEtBQUs5MkIsRUFBRSxHQUFHdUIsUUFBUXUxQixLQUFLbmlCLElBQUk7SUFDOUU7SUFDQSxPQUFPbEU7QUFDWDtBQUNBLFNBQVNrcUIsaUNBQWlDcnBCLFFBQVEsRUFBRTBvQixXQUFXLEVBQUVuQyxXQUFXLEVBQUVsQyxPQUFPLEVBQUVwMEIsTUFBTSxFQUFFdzFCLFNBQVMsRUFBRW1CLE9BQU87SUFDN0csNERBQTREO0lBQzVELFNBQVM0QyxPQUFPbmIsR0FBRyxFQUFFb1gsU0FBUztRQUMxQixJQUFLLElBQUl4dEIsSUFBSSxHQUFHQSxJQUFJb1csSUFBSWlZLEtBQUssQ0FBQ3QzQixNQUFNLEVBQUVpSixJQUFLO1lBQ3ZDLElBQUk4dUIsU0FBUzFZLElBQUlpWSxLQUFLLENBQUNydUIsRUFBRSxDQUFDb2lCLEdBQUcsQ0FBQ2dLLFNBQVNwMEIsUUFBUXcxQjtZQUMvQyxJQUFJc0IsUUFDQVIsWUFBWTN1QixJQUFJLENBQUNtdkI7aUJBQ2hCLElBQUlILFFBQVFJLFFBQVEsRUFDckJKLFFBQVFJLFFBQVEsQ0FBQzNZLElBQUlpWSxLQUFLLENBQUNydUIsRUFBRSxDQUFDOEwsSUFBSTtRQUMxQztRQUNBLElBQUssSUFBSTlMLElBQUksR0FBR0EsSUFBSW9XLElBQUlyTyxRQUFRLENBQUNoUixNQUFNLEVBQUVpSixLQUFLLEVBQzFDdXhCLE9BQU9uYixJQUFJck8sUUFBUSxDQUFDL0gsSUFBSSxFQUFFLEVBQUVvVyxJQUFJck8sUUFBUSxDQUFDL0gsRUFBRSxHQUFHd3RCLFlBQVk7SUFDbEU7SUFDQSxJQUFLLElBQUl4dEIsSUFBSSxHQUFHQSxJQUFJK0gsU0FBU2hSLE1BQU0sRUFBRWlKLEtBQUssRUFDdEMsSUFBSStILFFBQVEsQ0FBQy9ILElBQUksRUFBRSxJQUFJLENBQUMsR0FDcEJ1eEIsT0FBT3hwQixRQUFRLENBQUMvSCxJQUFJLEVBQUUsRUFBRXl3QixXQUFXLENBQUN6d0IsRUFBRSxHQUFHd3RCLFlBQVk7SUFDN0QsT0FBT2M7QUFDWDtBQUNBLFNBQVNnQixpQkFBaUJnQyxLQUFLLEVBQUV4N0IsSUFBSSxFQUFFa0MsTUFBTTtJQUN6QyxJQUFJbEMsS0FBSzBZLE1BQU0sRUFDWCxPQUFPO0lBQ1gsSUFBSW5JLE1BQU1yTyxTQUFTbEMsS0FBSzJCLFFBQVEsRUFBRStjLFFBQVE7SUFDMUMsSUFBSyxJQUFJeFUsSUFBSSxHQUFHdXRCLE1BQU12dEIsSUFBSXN4QixNQUFNdjZCLE1BQU0sRUFBRWlKLElBQUs7UUFDekMsSUFBSSxDQUFDdXRCLE9BQU8rRCxLQUFLLENBQUN0eEIsRUFBRSxLQUFLdXRCLEtBQUsvMkIsSUFBSSxHQUFHd0IsVUFBVXUxQixLQUFLOTJCLEVBQUUsR0FBRzRQLEtBQUs7WUFDekRtTyxDQUFBQSxTQUFVQSxDQUFBQSxRQUFRLEVBQUUsR0FBRzdVLElBQUksQ0FBQzR0QjtZQUM3QitELEtBQUssQ0FBQ3R4QixFQUFFLEdBQUc7UUFDZjtJQUNKO0lBQ0EsT0FBT3dVO0FBQ1g7QUFDQSxTQUFTZ2IsYUFBYWhOLEtBQUs7SUFDdkIsSUFBSXRiLFNBQVMsRUFBRTtJQUNmLElBQUssSUFBSWxILElBQUksR0FBR0EsSUFBSXdpQixNQUFNenJCLE1BQU0sRUFBRWlKLElBQzlCLElBQUl3aUIsS0FBSyxDQUFDeGlCLEVBQUUsSUFBSSxNQUNaa0gsT0FBT3ZILElBQUksQ0FBQzZpQixLQUFLLENBQUN4aUIsRUFBRTtJQUM1QixPQUFPa0g7QUFDWDtBQUNBLHFFQUFxRTtBQUNyRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLHdCQUF3QjtBQUN4QixTQUFTcW5CLFVBQVUrQyxLQUFLLEVBQUV4N0IsSUFBSSxFQUFFa0MsTUFBTSxFQUFFMjJCLE9BQU87SUFDM0MsSUFBSTVtQixXQUFXLEVBQUUsRUFBRXlwQixXQUFXO0lBQzlCMTdCLEtBQUtncEIsT0FBTyxDQUFDLENBQUNxUSxXQUFXc0M7UUFDckIsSUFBSWpkLFFBQVE4YSxpQkFBaUJnQyxPQUFPbkMsV0FBV3NDLGFBQWF6NUI7UUFDNUQsSUFBSXdjLE9BQU87WUFDUGdkLFdBQVc7WUFDWCxJQUFJRSxVQUFVbkQsVUFBVS9aLE9BQU8yYSxXQUFXbjNCLFNBQVN5NUIsYUFBYSxHQUFHOUM7WUFDbkUsSUFBSStDLFdBQVdwakIsT0FDWHZHLFNBQVNwSSxJQUFJLENBQUM4eEIsWUFBWUEsYUFBYXRDLFVBQVUxM0IsUUFBUSxFQUFFaTZCO1FBQ25FO0lBQ0o7SUFDQSxJQUFJamIsU0FBUzhZLFVBQVVpQyxXQUFXaEMsYUFBYThCLFNBQVNBLE9BQU8sQ0FBQ3Q1QixRQUFRK2UsSUFBSSxDQUFDa1k7SUFDN0UsSUFBSyxJQUFJanZCLElBQUksR0FBR0EsSUFBSXlXLE9BQU8xZixNQUFNLEVBQUVpSixJQUMvQixJQUFJLENBQUN5VyxNQUFNLENBQUN6VyxFQUFFLENBQUNvTCxJQUFJLENBQUN3aUIsS0FBSyxDQUFDOTNCLE1BQU0yZ0IsTUFBTSxDQUFDelcsRUFBRSxHQUFHO1FBQ3hDLElBQUkydUIsUUFBUUksUUFBUSxFQUNoQkosUUFBUUksUUFBUSxDQUFDdFksTUFBTSxDQUFDelcsRUFBRSxDQUFDOEwsSUFBSTtRQUNuQzJLLE9BQU90QyxNQUFNLENBQUNuVSxLQUFLO0lBQ3ZCO0lBQ0osT0FBT3lXLE9BQU8xZixNQUFNLElBQUlnUixTQUFTaFIsTUFBTSxHQUFHLElBQUlxM0IsY0FBYzNYLFFBQVExTyxZQUFZdUc7QUFDcEY7QUFDQSxrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDJDQUEyQztBQUMzQyxTQUFTMmdCLE1BQU1uYixDQUFDLEVBQUVDLENBQUM7SUFDZixPQUFPRCxFQUFFdGQsSUFBSSxHQUFHdWQsRUFBRXZkLElBQUksSUFBSXNkLEVBQUVyZCxFQUFFLEdBQUdzZCxFQUFFdGQsRUFBRTtBQUN6QztBQUNBLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsb0VBQW9FO0FBQ3BFLDhEQUE4RDtBQUM5RCxTQUFTczVCLGNBQWN1QixLQUFLO0lBQ3hCLElBQUlLLFVBQVVMO0lBQ2QsSUFBSyxJQUFJdHhCLElBQUksR0FBR0EsSUFBSTJ4QixRQUFRNTZCLE1BQU0sR0FBRyxHQUFHaUosSUFBSztRQUN6QyxJQUFJdXRCLE9BQU9vRSxPQUFPLENBQUMzeEIsRUFBRTtRQUNyQixJQUFJdXRCLEtBQUsvMkIsSUFBSSxJQUFJKzJCLEtBQUs5MkIsRUFBRSxFQUNwQixJQUFLLElBQUlvTSxJQUFJN0MsSUFBSSxHQUFHNkMsSUFBSTh1QixRQUFRNTZCLE1BQU0sRUFBRThMLElBQUs7WUFDekMsSUFBSUssT0FBT3l1QixPQUFPLENBQUM5dUIsRUFBRTtZQUNyQixJQUFJSyxLQUFLMU0sSUFBSSxJQUFJKzJCLEtBQUsvMkIsSUFBSSxFQUFFO2dCQUN4QixJQUFJME0sS0FBS3pNLEVBQUUsSUFBSTgyQixLQUFLOTJCLEVBQUUsRUFBRTtvQkFDcEIsSUFBSWs3QixXQUFXTCxPQUNYSyxVQUFVTCxNQUFNL2pCLEtBQUs7b0JBQ3pCLDhEQUE4RDtvQkFDOUQsUUFBUTtvQkFDUm9rQixPQUFPLENBQUM5dUIsRUFBRSxHQUFHSyxLQUFLc0ssSUFBSSxDQUFDdEssS0FBSzFNLElBQUksRUFBRSsyQixLQUFLOTJCLEVBQUU7b0JBQ3pDbTdCLFlBQVlELFNBQVM5dUIsSUFBSSxHQUFHSyxLQUFLc0ssSUFBSSxDQUFDK2YsS0FBSzkyQixFQUFFLEVBQUV5TSxLQUFLek0sRUFBRTtnQkFDMUQ7Z0JBQ0E7WUFDSixPQUNLO2dCQUNELElBQUl5TSxLQUFLMU0sSUFBSSxHQUFHKzJCLEtBQUs5MkIsRUFBRSxFQUFFO29CQUNyQixJQUFJazdCLFdBQVdMLE9BQ1hLLFVBQVVMLE1BQU0vakIsS0FBSztvQkFDekIsNkRBQTZEO29CQUM3RCxZQUFZO29CQUNab2tCLE9BQU8sQ0FBQzN4QixFQUFFLEdBQUd1dEIsS0FBSy9mLElBQUksQ0FBQytmLEtBQUsvMkIsSUFBSSxFQUFFME0sS0FBSzFNLElBQUk7b0JBQzNDbzdCLFlBQVlELFNBQVM5dUIsR0FBRzBxQixLQUFLL2YsSUFBSSxDQUFDdEssS0FBSzFNLElBQUksRUFBRSsyQixLQUFLOTJCLEVBQUU7Z0JBQ3hEO2dCQUNBO1lBQ0o7UUFDSjtJQUNSO0lBQ0EsT0FBT2s3QjtBQUNYO0FBQ0EsU0FBU0MsWUFBWXBQLEtBQUssRUFBRXhpQixDQUFDLEVBQUVnVCxJQUFJO0lBQy9CLE1BQU9oVCxJQUFJd2lCLE1BQU16ckIsTUFBTSxJQUFJazRCLE1BQU1qYyxNQUFNd1AsS0FBSyxDQUFDeGlCLEVBQUUsSUFBSSxFQUMvQ0E7SUFDSndpQixNQUFNck8sTUFBTSxDQUFDblUsR0FBRyxHQUFHZ1Q7QUFDdkI7QUFDQSxtRUFBbUU7QUFDbkUsU0FBUzZlLGdCQUFnQmwwQixJQUFJO0lBQ3pCLElBQUk2VyxRQUFRLEVBQUU7SUFDZDdXLEtBQUtHLFFBQVEsQ0FBQyxlQUFlb0gsQ0FBQUE7UUFDekIsSUFBSWdDLFNBQVNoQyxFQUFFdkgsS0FBSzBGLEtBQUs7UUFDekIsSUFBSTZELFVBQVVBLFVBQVVvSCxPQUNwQmtHLE1BQU03VSxJQUFJLENBQUN1SDtJQUNuQjtJQUNBLElBQUl2SixLQUFLdWIsYUFBYSxFQUNsQjFFLE1BQU03VSxJQUFJLENBQUN5dUIsY0FBY3RoQixNQUFNLENBQUNuUCxLQUFLMEYsS0FBSyxDQUFDNUosR0FBRyxFQUFFO1FBQUNrRSxLQUFLdWIsYUFBYSxDQUFDbEcsSUFBSTtLQUFDO0lBQzdFLE9BQU84YyxnQkFBZ0J0NUIsSUFBSSxDQUFDZ2U7QUFDaEM7QUFFQSxNQUFNc2QsaUJBQWlCO0lBQ25CQyxXQUFXO0lBQ1hDLGVBQWU7SUFDZkMsdUJBQXVCO0lBQ3ZCQyxZQUFZO0lBQ1pDLG1CQUFtQjtJQUNuQlQsU0FBUztBQUNiO0FBQ0EseUZBQXlGO0FBQ3pGLE1BQU1VLGNBQWNuM0IsTUFBTUMsY0FBYztBQUN4QyxNQUFNbTNCO0lBQ0Z2cUIsYUFBYztRQUNWLElBQUksQ0FBQy9PLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNILFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLFdBQVcsR0FBRztJQUN2QjtJQUNBc2QsSUFBSTdRLEdBQUcsRUFBRTtRQUNMLElBQUksQ0FBQ3hNLFVBQVUsR0FBR3dNLElBQUl4TSxVQUFVO1FBQ2hDLElBQUksQ0FBQ0MsWUFBWSxHQUFHdU0sSUFBSXZNLFlBQVk7UUFDcEMsSUFBSSxDQUFDSCxTQUFTLEdBQUcwTSxJQUFJMU0sU0FBUztRQUM5QixJQUFJLENBQUNDLFdBQVcsR0FBR3lNLElBQUl6TSxXQUFXO0lBQ3RDO0lBQ0FpMEIsUUFBUTtRQUNKLElBQUksQ0FBQ2gwQixVQUFVLEdBQUcsSUFBSSxDQUFDRixTQUFTLEdBQUc7SUFDdkM7SUFDQXdULEdBQUc5RyxHQUFHLEVBQUU7UUFDSixPQUFPQSxJQUFJeE0sVUFBVSxJQUFJLElBQUksQ0FBQ0EsVUFBVSxJQUFJd00sSUFBSXZNLFlBQVksSUFBSSxJQUFJLENBQUNBLFlBQVksSUFDN0V1TSxJQUFJMU0sU0FBUyxJQUFJLElBQUksQ0FBQ0EsU0FBUyxJQUFJME0sSUFBSXpNLFdBQVcsSUFBSSxJQUFJLENBQUNBLFdBQVc7SUFDOUU7QUFDSjtBQUNBLE1BQU13NUI7SUFDRnhxQixZQUFZbkssSUFBSSxFQUFFNDBCLGVBQWUsQ0FBRTtRQUMvQixJQUFJLENBQUM1MEIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQzQwQixlQUFlLEdBQUdBO1FBQ3ZCLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUMzSSxZQUFZLEdBQUcsQ0FBQztRQUNyQixJQUFJLENBQUM0SSxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDM1osZ0JBQWdCLEdBQUcsSUFBSXVaO1FBQzVCLElBQUksQ0FBQ0ssVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsMkJBQTJCLEdBQUc7UUFDbkMsSUFBSSxDQUFDakosbUJBQW1CLEdBQUc7UUFDM0IsSUFBSSxDQUFDK0ksUUFBUSxHQUFHdGIsT0FBT3liLGdCQUFnQixJQUNuQyxJQUFJemIsT0FBT3liLGdCQUFnQixDQUFDQyxDQUFBQTtZQUN4QixJQUFLLElBQUk3eUIsSUFBSSxHQUFHQSxJQUFJNnlCLFVBQVU5N0IsTUFBTSxFQUFFaUosSUFDbEMsSUFBSSxDQUFDd3lCLEtBQUssQ0FBQzd5QixJQUFJLENBQUNrekIsU0FBUyxDQUFDN3lCLEVBQUU7WUFDaEMsNkRBQTZEO1lBQzdELHdEQUF3RDtZQUN4RCxxREFBcUQ7WUFDckQsNENBQTRDO1lBQzVDLElBQUkvRSxNQUFNQyxjQUFjLE1BQU0yM0IsVUFBVW5LLElBQUksQ0FBQy9VLENBQUFBLElBQUtBLEVBQUV2SSxJQUFJLElBQUksZUFBZXVJLEVBQUVtZixZQUFZLENBQUMvN0IsTUFBTSxJQUM1RjRjLEVBQUV2SSxJQUFJLElBQUksbUJBQW1CdUksRUFBRS9HLFFBQVEsQ0FBQzdWLE1BQU0sR0FBRzRjLEVBQUUvUCxNQUFNLENBQUM5TSxTQUFTLENBQUNDLE1BQU0sR0FDMUUsSUFBSSxDQUFDbTJCLFNBQVM7aUJBRWQsSUFBSSxDQUFDMUUsS0FBSztRQUNsQjtRQUNKLElBQUk0SixhQUFhO1lBQ2IsSUFBSSxDQUFDTSxVQUFVLEdBQUc3ZCxDQUFBQTtnQkFDZCxJQUFJLENBQUMyZCxLQUFLLENBQUM3eUIsSUFBSSxDQUFDO29CQUFFaUUsUUFBUWlSLEVBQUVqUixNQUFNO29CQUFFd0gsTUFBTTtvQkFBaUJ3QixVQUFVaUksRUFBRWtlLFNBQVM7Z0JBQUM7Z0JBQ2pGLElBQUksQ0FBQzdGLFNBQVM7WUFDbEI7UUFDSjtRQUNBLElBQUksQ0FBQzhGLGlCQUFpQixHQUFHLElBQUksQ0FBQ0EsaUJBQWlCLENBQUNqTCxJQUFJLENBQUMsSUFBSTtJQUM3RDtJQUNBbUYsWUFBWTtRQUNSLElBQUksSUFBSSxDQUFDckQsWUFBWSxHQUFHLEdBQ3BCLElBQUksQ0FBQ0EsWUFBWSxHQUFHMVMsT0FBTzhDLFVBQVUsQ0FBQztZQUFRLElBQUksQ0FBQzRQLFlBQVksR0FBRyxDQUFDO1lBQUcsSUFBSSxDQUFDckIsS0FBSztRQUFJLEdBQUc7SUFDL0Y7SUFDQXBELGFBQWE7UUFDVCxJQUFJLElBQUksQ0FBQ3lFLFlBQVksR0FBRyxDQUFDLEdBQUc7WUFDeEIxUyxPQUFPeU4sWUFBWSxDQUFDLElBQUksQ0FBQ2lGLFlBQVk7WUFDckMsSUFBSSxDQUFDQSxZQUFZLEdBQUcsQ0FBQztZQUNyQixJQUFJLENBQUNyQixLQUFLO1FBQ2Q7SUFDSjtJQUNBcGlCLFFBQVE7UUFDSixJQUFJLElBQUksQ0FBQ3FzQixRQUFRLEVBQUU7WUFDZixJQUFJLENBQUNBLFFBQVEsQ0FBQ1EsV0FBVztZQUN6QixJQUFJLENBQUNSLFFBQVEsQ0FBQ1MsT0FBTyxDQUFDLElBQUksQ0FBQ3YxQixJQUFJLENBQUN0RixHQUFHLEVBQUV5NUI7UUFDekM7UUFDQSxJQUFJLElBQUksQ0FBQ1ksVUFBVSxFQUNmLElBQUksQ0FBQy8wQixJQUFJLENBQUN0RixHQUFHLENBQUMyaEIsZ0JBQWdCLENBQUMsNEJBQTRCLElBQUksQ0FBQzBZLFVBQVU7UUFDOUUsSUFBSSxDQUFDL1ksZ0JBQWdCO0lBQ3pCO0lBQ0FwTixPQUFPO1FBQ0gsSUFBSSxJQUFJLENBQUNrbUIsUUFBUSxFQUFFO1lBQ2YsSUFBSVUsT0FBTyxJQUFJLENBQUNWLFFBQVEsQ0FBQ1EsV0FBVztZQUNwQyxJQUFJRSxLQUFLcDhCLE1BQU0sRUFBRTtnQkFDYixJQUFLLElBQUlpSixJQUFJLEdBQUdBLElBQUltekIsS0FBS3A4QixNQUFNLEVBQUVpSixJQUM3QixJQUFJLENBQUN3eUIsS0FBSyxDQUFDN3lCLElBQUksQ0FBQ3d6QixJQUFJLENBQUNuekIsRUFBRTtnQkFDM0JtWCxPQUFPOEMsVUFBVSxDQUFDLElBQU0sSUFBSSxDQUFDdU8sS0FBSyxJQUFJO1lBQzFDO1lBQ0EsSUFBSSxDQUFDaUssUUFBUSxDQUFDVyxVQUFVO1FBQzVCO1FBQ0EsSUFBSSxJQUFJLENBQUNWLFVBQVUsRUFDZixJQUFJLENBQUMvMEIsSUFBSSxDQUFDdEYsR0FBRyxDQUFDeWhCLG1CQUFtQixDQUFDLDRCQUE0QixJQUFJLENBQUM0WSxVQUFVO1FBQ2pGLElBQUksQ0FBQ3paLG1CQUFtQjtJQUM1QjtJQUNBVSxtQkFBbUI7UUFDZixJQUFJLENBQUNoYyxJQUFJLENBQUN0RixHQUFHLENBQUMyRixhQUFhLENBQUNnYyxnQkFBZ0IsQ0FBQyxtQkFBbUIsSUFBSSxDQUFDZ1osaUJBQWlCO0lBQzFGO0lBQ0EvWixzQkFBc0I7UUFDbEIsSUFBSSxDQUFDdGIsSUFBSSxDQUFDdEYsR0FBRyxDQUFDMkYsYUFBYSxDQUFDOGIsbUJBQW1CLENBQUMsbUJBQW1CLElBQUksQ0FBQ2taLGlCQUFpQjtJQUM3RjtJQUNBSywyQkFBMkI7UUFDdkIsSUFBSSxDQUFDViwyQkFBMkIsR0FBRztRQUNuQzFZLFdBQVcsSUFBTSxJQUFJLENBQUMwWSwyQkFBMkIsR0FBRyxPQUFPO0lBQy9EO0lBQ0FLLG9CQUFvQjtRQUNoQixJQUFJLENBQUN6WSxxQkFBcUIsSUFBSSxDQUFDNWMsSUFBSSxHQUMvQjtRQUNKLElBQUksSUFBSSxDQUFDZzFCLDJCQUEyQixFQUNoQyxPQUFPbmEsZUFBZSxJQUFJLENBQUM3YSxJQUFJO1FBQ25DLGlFQUFpRTtRQUNqRSx5REFBeUQ7UUFDekQsWUFBWTtRQUNaLElBQUkxQyxNQUFNQyxjQUFjLE1BQU0sQ0FBQyxJQUFJLENBQUN5QyxJQUFJLENBQUMwRixLQUFLLENBQUNtQyxTQUFTLENBQUM4SSxLQUFLLEVBQUU7WUFDNUQsSUFBSS9JLE1BQU0sSUFBSSxDQUFDNUgsSUFBSSxDQUFDK0ksaUJBQWlCO1lBQ3JDLDZDQUE2QztZQUM3QyxJQUFJbkIsSUFBSTFNLFNBQVMsSUFBSTNCLHFCQUFxQnFPLElBQUkxTSxTQUFTLEVBQUUwTSxJQUFJek0sV0FBVyxFQUFFeU0sSUFBSXhNLFVBQVUsRUFBRXdNLElBQUl2TSxZQUFZLEdBQ3RHLE9BQU8sSUFBSSxDQUFDazBCLFNBQVM7UUFDN0I7UUFDQSxJQUFJLENBQUMxRSxLQUFLO0lBQ2Q7SUFDQXhQLGtCQUFrQjtRQUNkLElBQUksQ0FBQ0YsZ0JBQWdCLENBQUMxQyxHQUFHLENBQUMsSUFBSSxDQUFDelksSUFBSSxDQUFDK0ksaUJBQWlCO0lBQ3pEO0lBQ0E0c0Isc0JBQXNCL3RCLEdBQUcsRUFBRTtRQUN2QixJQUFJLENBQUNBLElBQUkxTSxTQUFTLEVBQ2QsT0FBTztRQUNYLElBQUkwNkIsWUFBWSxJQUFJQyxLQUFLQztRQUN6QixJQUFLLElBQUlucUIsT0FBTy9ELElBQUkxTSxTQUFTLEVBQUV5USxNQUFNQSxPQUFPclQsV0FBV3FULE1BQ25EaXFCLFVBQVVubkIsR0FBRyxDQUFDOUM7UUFDbEIsSUFBSyxJQUFJQSxPQUFPL0QsSUFBSXhNLFVBQVUsRUFBRXVRLE1BQU1BLE9BQU9yVCxXQUFXcVQsTUFDcEQsSUFBSWlxQixVQUFVeGUsR0FBRyxDQUFDekwsT0FBTztZQUNyQm1xQixZQUFZbnFCO1lBQ1o7UUFDSjtRQUNKLElBQUloUixPQUFPbTdCLGFBQWEsSUFBSSxDQUFDOTFCLElBQUksQ0FBQ29FLE9BQU8sQ0FBQ0ssV0FBVyxDQUFDcXhCO1FBQ3RELElBQUluN0IsUUFBUUEsS0FBSzRTLGNBQWMsQ0FBQztZQUM1QkUsTUFBTTtZQUNOeEgsUUFBUTZ2QixVQUFVcjlCLFFBQVEsSUFBSSxJQUFJcTlCLFVBQVV4OUIsVUFBVSxHQUFHdzlCO1FBQzdELElBQUk7WUFDQSxJQUFJLENBQUN6YSxlQUFlO1lBQ3BCLE9BQU87UUFDWDtJQUNKO0lBQ0ErUCxpQkFBaUI7UUFDYixJQUFJLElBQUksQ0FBQzBKLFFBQVEsRUFDYixLQUFLLElBQUk5bEIsT0FBTyxJQUFJLENBQUM4bEIsUUFBUSxDQUFDUSxXQUFXLEdBQ3JDLElBQUksQ0FBQ1QsS0FBSyxDQUFDN3lCLElBQUksQ0FBQ2dOO1FBQ3hCLE9BQU8sSUFBSSxDQUFDNmxCLEtBQUs7SUFDckI7SUFDQWhLLFFBQVE7UUFDSixJQUFJLEVBQUU3cUIsSUFBSSxFQUFFLEdBQUcsSUFBSTtRQUNuQixJQUFJLENBQUNBLEtBQUtvRSxPQUFPLElBQUksSUFBSSxDQUFDOG5CLFlBQVksR0FBRyxDQUFDLEdBQ3RDO1FBQ0osSUFBSWdKLFlBQVksSUFBSSxDQUFDOUosY0FBYztRQUNuQyxJQUFJOEosVUFBVTk3QixNQUFNLEVBQ2hCLElBQUksQ0FBQ3k3QixLQUFLLEdBQUcsRUFBRTtRQUNuQixJQUFJanRCLE1BQU01SCxLQUFLK0ksaUJBQWlCO1FBQ2hDLElBQUlndEIsU0FBUyxDQUFDLElBQUksQ0FBQ2YsMkJBQTJCLElBQUksQ0FBQyxJQUFJLENBQUM3WixnQkFBZ0IsQ0FBQ3pNLEVBQUUsQ0FBQzlHLFFBQVFnVixxQkFBcUI1YyxTQUFTLENBQUMsSUFBSSxDQUFDMjFCLHFCQUFxQixDQUFDL3RCO1FBQzlJLElBQUkvTyxPQUFPLENBQUMsR0FBR0MsS0FBSyxDQUFDLEdBQUdrOUIsV0FBVyxPQUFPQyxRQUFRLEVBQUU7UUFDcEQsSUFBSWoyQixLQUFLMGEsUUFBUSxFQUFFO1lBQ2YsSUFBSyxJQUFJclksSUFBSSxHQUFHQSxJQUFJNnlCLFVBQVU5N0IsTUFBTSxFQUFFaUosSUFBSztnQkFDdkMsSUFBSWtILFNBQVMsSUFBSSxDQUFDMnNCLGdCQUFnQixDQUFDaEIsU0FBUyxDQUFDN3lCLEVBQUUsRUFBRTR6QjtnQkFDakQsSUFBSTFzQixRQUFRO29CQUNSMVEsT0FBT0EsT0FBTyxJQUFJMFEsT0FBTzFRLElBQUksR0FBRzJELEtBQUtDLEdBQUcsQ0FBQzhNLE9BQU8xUSxJQUFJLEVBQUVBO29CQUN0REMsS0FBS0EsS0FBSyxJQUFJeVEsT0FBT3pRLEVBQUUsR0FBRzBELEtBQUs4RSxHQUFHLENBQUNpSSxPQUFPelEsRUFBRSxFQUFFQTtvQkFDOUMsSUFBSXlRLE9BQU95c0IsUUFBUSxFQUNmQSxXQUFXO2dCQUNuQjtZQUNKO1FBQ0o7UUFDQSxJQUFJdjRCLFNBQVN3NEIsTUFBTTc4QixNQUFNLEVBQUU7WUFDdkIsSUFBSSs4QixNQUFNRixNQUFNdGdCLE1BQU0sQ0FBQ3hCLENBQUFBLElBQUtBLEVBQUVsYSxRQUFRLElBQUk7WUFDMUMsSUFBSWs4QixJQUFJLzhCLE1BQU0sSUFBSSxHQUFHO2dCQUNqQixJQUFJLENBQUMrYyxHQUFHQyxFQUFFLEdBQUcrZjtnQkFDYixJQUFJaGdCLEVBQUU3ZCxVQUFVLElBQUk2ZCxFQUFFN2QsVUFBVSxDQUFDQSxVQUFVLElBQUk4ZCxFQUFFOWQsVUFBVSxFQUN2RDhkLEVBQUV6QyxNQUFNO3FCQUVSd0MsRUFBRXhDLE1BQU07WUFDaEIsT0FDSztnQkFDRCxJQUFJLEVBQUV6WSxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUNpZ0IsZ0JBQWdCO2dCQUN6QyxLQUFLLElBQUlpYixNQUFNRCxJQUFLO29CQUNoQixJQUFJNTlCLFNBQVM2OUIsR0FBRzk5QixVQUFVO29CQUMxQixJQUFJQyxVQUFVQSxPQUFPMEIsUUFBUSxJQUFJLFFBQVMsRUFBQ2lCLGFBQWFtN0IsWUFBWXIyQixNQUFNOUUsY0FBYzNDLE1BQUssR0FDekY2OUIsR0FBR3ppQixNQUFNO2dCQUNqQjtZQUNKO1FBQ0o7UUFDQSxJQUFJMmlCLFVBQVU7UUFDZCw4REFBOEQ7UUFDOUQsZ0VBQWdFO1FBQ2hFLFlBQVk7UUFDWixJQUFJejlCLE9BQU8sS0FBS2s5QixVQUFVLzFCLEtBQUswUyxLQUFLLENBQUNvVCxTQUFTLEdBQUdnQixLQUFLQyxHQUFHLEtBQUssT0FDMUR2cUIsS0FBSzhFLEdBQUcsQ0FBQ3RCLEtBQUswUyxLQUFLLENBQUNxVCxTQUFTLEVBQUUvbEIsS0FBSzBTLEtBQUssQ0FBQzhTLFNBQVMsQ0FBQ0MsSUFBSSxJQUFJcUIsS0FBS0MsR0FBRyxLQUFLLE9BQ3pFL3JCLG1CQUFtQjRNLFFBQVMwdUIsQ0FBQUEsVUFBVXhjLGlCQUFpQjlaLEtBQUksS0FDM0RzMkIsUUFBUTVuQixFQUFFLENBQUMvVyx3REFBU0EsQ0FBQ29uQixJQUFJLENBQUMvZSxLQUFLMEYsS0FBSyxDQUFDNUosR0FBRyxDQUFDbUwsT0FBTyxDQUFDLElBQUksS0FBSztZQUMxRGpILEtBQUswUyxLQUFLLENBQUNvVCxTQUFTLEdBQUc7WUFDdkJqTCxlQUFlN2E7WUFDZixJQUFJLENBQUNtYixnQkFBZ0IsQ0FBQzFDLEdBQUcsQ0FBQzdRO1lBQzFCNUgsS0FBS3UyQixpQkFBaUI7UUFDMUIsT0FDSyxJQUFJMTlCLE9BQU8sQ0FBQyxLQUFLazlCLFFBQVE7WUFDMUIsSUFBSWw5QixPQUFPLENBQUMsR0FBRztnQkFDWG1ILEtBQUtvRSxPQUFPLENBQUN1SixTQUFTLENBQUM5VSxNQUFNQztnQkFDN0IwOUIsU0FBU3gyQjtZQUNiO1lBQ0EsSUFBSSxDQUFDNDBCLGVBQWUsQ0FBQy83QixNQUFNQyxJQUFJazlCLFVBQVVDO1lBQ3pDLElBQUlqMkIsS0FBS29FLE9BQU8sSUFBSXBFLEtBQUtvRSxPQUFPLENBQUNpRyxLQUFLLEVBQ2xDckssS0FBSzBILFdBQVcsQ0FBQzFILEtBQUswRixLQUFLO2lCQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDeVYsZ0JBQWdCLENBQUN6TSxFQUFFLENBQUM5RyxNQUMvQmlULGVBQWU3YTtZQUNuQixJQUFJLENBQUNtYixnQkFBZ0IsQ0FBQzFDLEdBQUcsQ0FBQzdRO1FBQzlCO0lBQ0o7SUFDQXN1QixpQkFBaUJsbkIsR0FBRyxFQUFFaW5CLEtBQUssRUFBRTtRQUN6QixvRUFBb0U7UUFDcEUsSUFBSUEsTUFBTW5nQixPQUFPLENBQUM5RyxJQUFJL0ksTUFBTSxJQUFJLENBQUMsR0FDN0IsT0FBTztRQUNYLElBQUl0TCxPQUFPLElBQUksQ0FBQ3FGLElBQUksQ0FBQ29FLE9BQU8sQ0FBQ0ssV0FBVyxDQUFDdUssSUFBSS9JLE1BQU07UUFDbkQsSUFBSStJLElBQUl2QixJQUFJLElBQUksZ0JBQ1g5UyxDQUFBQSxRQUFRLElBQUksQ0FBQ3FGLElBQUksQ0FBQ29FLE9BQU8sSUFBSTRLLElBQUl5bkIsYUFBYSxJQUFJLHFCQUMvQyxnRUFBZ0U7UUFDL0R6bkIsSUFBSXluQixhQUFhLElBQUksV0FBVyxDQUFDem5CLElBQUlDLFFBQVEsSUFBSSxDQUFDRCxJQUFJL0ksTUFBTSxDQUFDMGIsWUFBWSxDQUFDLFFBQVEsR0FDdkYsT0FBTztRQUNYLElBQUksQ0FBQ2huQixRQUFRQSxLQUFLNFMsY0FBYyxDQUFDeUIsTUFDN0IsT0FBTztRQUNYLElBQUlBLElBQUl2QixJQUFJLElBQUksYUFBYTtZQUN6QixJQUFLLElBQUlwTCxJQUFJLEdBQUdBLElBQUkyTSxJQUFJMG5CLFVBQVUsQ0FBQ3Q5QixNQUFNLEVBQUVpSixJQUFLO2dCQUM1QyxJQUFJbEssT0FBTzZXLElBQUkwbkIsVUFBVSxDQUFDcjBCLEVBQUU7Z0JBQzVCNHpCLE1BQU1qMEIsSUFBSSxDQUFDN0o7Z0JBQ1gsSUFBSUEsS0FBS00sUUFBUSxJQUFJLEdBQ2pCLElBQUksQ0FBQ3N6QixtQkFBbUIsR0FBRzV6QjtZQUNuQztZQUNBLElBQUl3QyxLQUFLSSxVQUFVLElBQUlKLEtBQUtJLFVBQVUsSUFBSUosS0FBS0QsR0FBRyxJQUFJLENBQUNDLEtBQUtJLFVBQVUsQ0FBQzZHLFFBQVEsQ0FBQ29OLElBQUkvSSxNQUFNLEdBQ3RGLE9BQU87Z0JBQUVwTixNQUFNOEIsS0FBSytKLFNBQVM7Z0JBQUU1TCxJQUFJNkIsS0FBS2dLLFFBQVE7WUFBQztZQUNyRCxJQUFJYSxPQUFPd0osSUFBSTNXLGVBQWUsRUFBRWtOLE9BQU95SixJQUFJdkwsV0FBVztZQUN0RCxJQUFJbkcsTUFBTUMsY0FBYyxNQUFNeVIsSUFBSTBuQixVQUFVLENBQUN0OUIsTUFBTSxFQUFFO2dCQUNqRCxzREFBc0Q7Z0JBQ3RELDJEQUEyRDtnQkFDM0QsSUFBSyxJQUFJaUosSUFBSSxHQUFHQSxJQUFJMk0sSUFBSTBuQixVQUFVLENBQUN0OUIsTUFBTSxFQUFFaUosSUFBSztvQkFDNUMsSUFBSSxFQUFFaEssZUFBZSxFQUFFb0wsV0FBVyxFQUFFLEdBQUd1TCxJQUFJMG5CLFVBQVUsQ0FBQ3IwQixFQUFFO29CQUN4RCxJQUFJLENBQUNoSyxtQkFBbUI4TixNQUFNQyxTQUFTLENBQUMwUCxPQUFPLENBQUN4UCxJQUFJLENBQUMwSSxJQUFJMG5CLFVBQVUsRUFBRXIrQixtQkFBbUIsR0FDcEZtTixPQUFPbk47b0JBQ1gsSUFBSSxDQUFDb0wsZUFBZTBDLE1BQU1DLFNBQVMsQ0FBQzBQLE9BQU8sQ0FBQ3hQLElBQUksQ0FBQzBJLElBQUkwbkIsVUFBVSxFQUFFanpCLGVBQWUsR0FDNUU4QixPQUFPOUI7Z0JBQ2Y7WUFDSjtZQUNBLElBQUk0SSxhQUFhN0csUUFBUUEsS0FBS2xOLFVBQVUsSUFBSTBXLElBQUkvSSxNQUFNLEdBQ2hEL04sU0FBU3NOLFFBQVEsSUFBSTtZQUMzQixJQUFJM00sT0FBTzhCLEtBQUt3USxlQUFlLENBQUM2RCxJQUFJL0ksTUFBTSxFQUFFb0csWUFBWSxDQUFDO1lBQ3pELElBQUlDLFdBQVcvRyxRQUFRQSxLQUFLak4sVUFBVSxJQUFJMFcsSUFBSS9JLE1BQU0sR0FDOUMvTixTQUFTcU4sUUFBUXlKLElBQUkvSSxNQUFNLENBQUM5TCxVQUFVLENBQUNmLE1BQU07WUFDbkQsSUFBSU4sS0FBSzZCLEtBQUt3USxlQUFlLENBQUM2RCxJQUFJL0ksTUFBTSxFQUFFcUcsVUFBVTtZQUNwRCxPQUFPO2dCQUFFelQ7Z0JBQU1DO1lBQUc7UUFDdEIsT0FDSyxJQUFJa1csSUFBSXZCLElBQUksSUFBSSxjQUFjO1lBQy9CLE9BQU87Z0JBQUU1VSxNQUFNOEIsS0FBS21MLFVBQVUsR0FBR25MLEtBQUtvTCxNQUFNO2dCQUFFak4sSUFBSTZCLEtBQUt1USxRQUFRLEdBQUd2USxLQUFLb0wsTUFBTTtZQUFDO1FBQ2xGLE9BQ0s7WUFDRCxJQUFJLENBQUNnbUIsbUJBQW1CLEdBQUcvYyxJQUFJL0ksTUFBTTtZQUNyQyxPQUFPO2dCQUNIcE4sTUFBTThCLEtBQUttTCxVQUFVO2dCQUNyQmhOLElBQUk2QixLQUFLdVEsUUFBUTtnQkFDakIsOERBQThEO2dCQUM5RCw2REFBNkQ7Z0JBQzdELCtEQUErRDtnQkFDL0QsdUJBQXVCO2dCQUN2QjhxQixVQUFVaG5CLElBQUkvSSxNQUFNLENBQUM5TSxTQUFTLElBQUk2VixJQUFJQyxRQUFRO1lBQ2xEO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsSUFBSTBuQixhQUFhLElBQUlDO0FBQ3JCLElBQUlDLGlCQUFpQjtBQUNyQixTQUFTTCxTQUFTeDJCLElBQUk7SUFDbEIsSUFBSTIyQixXQUFXdmYsR0FBRyxDQUFDcFgsT0FDZjtJQUNKMjJCLFdBQVdsZSxHQUFHLENBQUN6WSxNQUFNO0lBQ3JCLElBQUk7UUFBQztRQUFVO1FBQVU7S0FBVyxDQUFDOFYsT0FBTyxDQUFDNVUsaUJBQWlCbEIsS0FBS3RGLEdBQUcsRUFBRW84QixVQUFVLE1BQU0sQ0FBQyxHQUFHO1FBQ3hGOTJCLEtBQUs2WCxxQkFBcUIsR0FBR3BhO1FBQzdCLElBQUlvNUIsZ0JBQ0E7UUFDSkUsT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUNoQkYsaUJBQWlCO0lBQ3JCO0FBQ0o7QUFDQSxTQUFTRyxzQkFBc0JoM0IsSUFBSSxFQUFFakgsS0FBSztJQUN0QyxJQUFJcUMsYUFBYXJDLE1BQU02RCxjQUFjLEVBQUV2QixlQUFldEMsTUFBTThELFdBQVc7SUFDdkUsSUFBSTNCLFlBQVluQyxNQUFNc2hCLFlBQVksRUFBRWxmLGNBQWNwQyxNQUFNdWhCLFNBQVM7SUFDakUsSUFBSTJjLGdCQUFnQmozQixLQUFLazNCLFFBQVEsQ0FBQ2wzQixLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUyxDQUFDOEUsTUFBTTtJQUM3RCxrRUFBa0U7SUFDbEUsOERBQThEO0lBQzlELGtCQUFrQjtJQUNsQixJQUFJcFQscUJBQXFCMDlCLGNBQWM5K0IsSUFBSSxFQUFFOCtCLGNBQWM1OEIsTUFBTSxFQUFFYSxXQUFXQyxjQUMxRSxDQUFDQyxZQUFZQyxjQUFjSCxXQUFXQyxZQUFZLEdBQUc7UUFBQ0Q7UUFBV0M7UUFBYUM7UUFBWUM7S0FBYTtJQUMzRyxPQUFPO1FBQUVEO1FBQVlDO1FBQWNIO1FBQVdDO0lBQVk7QUFDOUQ7QUFDQSx3REFBd0Q7QUFDeEQsNERBQTREO0FBQzVELFNBQVNnOEIsMkJBQTJCbjNCLElBQUksRUFBRTZILFNBQVM7SUFDL0MsSUFBSUEsVUFBVXV2QixpQkFBaUIsRUFBRTtRQUM3QixJQUFJcitCLFFBQVE4TyxVQUFVdXZCLGlCQUFpQixDQUFDcDNCLEtBQUswQixJQUFJLENBQUMsQ0FBQyxFQUFFO1FBQ3JELElBQUkzSSxPQUNBLE9BQU9pK0Isc0JBQXNCaDNCLE1BQU1qSDtJQUMzQztJQUNBLElBQUk4ZDtJQUNKLFNBQVN3Z0IsS0FBSzU3QixLQUFLO1FBQ2ZBLE1BQU1pc0IsY0FBYztRQUNwQmpzQixNQUFNNjdCLHdCQUF3QjtRQUM5QnpnQixRQUFRcGIsTUFBTTg3QixlQUFlLEVBQUUsQ0FBQyxFQUFFO0lBQ3RDO0lBQ0EsaUVBQWlFO0lBQ2pFLG9FQUFvRTtJQUNwRSxnRUFBZ0U7SUFDaEUsb0VBQW9FO0lBQ3BFLFNBQVM7SUFDVHYzQixLQUFLdEYsR0FBRyxDQUFDMmhCLGdCQUFnQixDQUFDLGVBQWVnYixNQUFNO0lBQy9DcitCLFNBQVN3K0IsV0FBVyxDQUFDO0lBQ3JCeDNCLEtBQUt0RixHQUFHLENBQUN5aEIsbUJBQW1CLENBQUMsZUFBZWtiLE1BQU07SUFDbEQsT0FBT3hnQixRQUFRbWdCLHNCQUFzQmgzQixNQUFNNlcsU0FBUztBQUN4RDtBQUNBLFNBQVN3ZixZQUFZcjJCLElBQUksRUFBRTdILElBQUk7SUFDM0IsSUFBSyxJQUFJa04sSUFBSWxOLEtBQUtHLFVBQVUsRUFBRStNLEtBQUtBLEtBQUtyRixLQUFLdEYsR0FBRyxFQUFFMkssSUFBSUEsRUFBRS9NLFVBQVUsQ0FBRTtRQUNoRSxJQUFJcUMsT0FBT3FGLEtBQUtvRSxPQUFPLENBQUNLLFdBQVcsQ0FBQ1ksR0FBRztRQUN2QyxJQUFJMUssUUFBUUEsS0FBS3hDLElBQUksQ0FBQzJDLE9BQU8sRUFDekIsT0FBT3VLO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFFQSx5REFBeUQ7QUFDekQsa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSxpRUFBaUU7QUFDakUsaUJBQWlCO0FBQ2pCLFNBQVNveUIsYUFBYXozQixJQUFJLEVBQUUwM0IsS0FBSyxFQUFFQyxHQUFHO0lBQ2xDLElBQUksRUFBRXgvQixNQUFNSSxNQUFNLEVBQUU4VCxVQUFVLEVBQUVDLFFBQVEsRUFBRXpULElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUdrSCxLQUFLb0UsT0FBTyxDQUFDK0gsVUFBVSxDQUFDdXJCLE9BQU9DO0lBQ3RGLElBQUkxOEIsU0FBUytFLEtBQUsrSSxpQkFBaUI7SUFDbkMsSUFBSTFDO0lBQ0osSUFBSXNHLFNBQVMxUixPQUFPRyxVQUFVO0lBQzlCLElBQUl1UixVQUFVM00sS0FBS3RGLEdBQUcsQ0FBQ2tILFFBQVEsQ0FBQytLLE9BQU9sVSxRQUFRLElBQUksSUFBSWtVLFNBQVNBLE9BQU9yVSxVQUFVLEdBQUc7UUFDaEYrTixPQUFPO1lBQUM7Z0JBQUVsTyxNQUFNd1U7Z0JBQVF0UyxRQUFRWSxPQUFPSSxZQUFZO1lBQUM7U0FBRTtRQUN0RCxJQUFJLENBQUNMLG1CQUFtQkMsU0FDcEJvTCxLQUFLckUsSUFBSSxDQUFDO1lBQUU3SixNQUFNOEMsT0FBT0MsU0FBUztZQUFFYixRQUFRWSxPQUFPRSxXQUFXO1FBQUM7SUFDdkU7SUFDQSxtRUFBbUU7SUFDbkUsZ0VBQWdFO0lBQ2hFLElBQUl3QyxVQUFVcUMsS0FBSzBTLEtBQUssQ0FBQzRTLFdBQVcsS0FBSyxHQUFHO1FBQ3hDLElBQUssSUFBSTlyQixNQUFNOFMsVUFBVTlTLE1BQU02UyxZQUFZN1MsTUFBTztZQUM5QyxJQUFJckIsT0FBT0ksT0FBTzRCLFVBQVUsQ0FBQ1gsTUFBTSxFQUFFLEVBQUVtQixPQUFPeEMsS0FBSzBDLFVBQVU7WUFDN0QsSUFBSTFDLEtBQUs4QixRQUFRLElBQUksUUFBUSxDQUFDVSxNQUFNO2dCQUNoQzJSLFdBQVc5UztnQkFDWDtZQUNKO1lBQ0EsSUFBSSxDQUFDbUIsUUFBUUEsS0FBS2lMLElBQUksRUFDbEI7UUFDUjtJQUNKO0lBQ0EsSUFBSWlrQixXQUFXN3BCLEtBQUswRixLQUFLLENBQUM1SixHQUFHO0lBQzdCLElBQUk4bEIsU0FBUzVoQixLQUFLRyxRQUFRLENBQUMsZ0JBQWdCbkksd0RBQVNBLENBQUNrb0IsVUFBVSxDQUFDbGdCLEtBQUswRixLQUFLLENBQUN5YSxNQUFNO0lBQ2pGLElBQUlwWSxRQUFROGhCLFNBQVM1aUIsT0FBTyxDQUFDcE87SUFDN0IsSUFBSStPLE1BQU0sTUFBTTlMLE1BQU04bEIsT0FBT2tELEtBQUssQ0FBQ3ZzQixRQUFRO1FBQ3ZDdWEsU0FBUy9LLE1BQU14UCxNQUFNO1FBQ3JCcS9CLFVBQVU3dkIsTUFBTXhQLE1BQU0sQ0FBQ2dxQixjQUFjLENBQUN4YSxNQUFNM1AsS0FBSztRQUNqRHkvQixTQUFTO1FBQ1RoL0IsTUFBTXdUO1FBQ052VCxJQUFJd1Q7UUFDSm1FLG9CQUFvQjFJLE1BQU14UCxNQUFNLENBQUNrVixJQUFJLENBQUMrQyxVQUFVLElBQUksUUFBUSxTQUFTO1FBQ3JFc25CLGVBQWV6eEI7UUFDZnliO1FBQ0FqQyxTQUFTOVg7SUFDYjtJQUNBLElBQUkxQixRQUFRQSxJQUFJLENBQUMsRUFBRSxDQUFDL0osR0FBRyxJQUFJLE1BQU07UUFDN0IsSUFBSXFRLFNBQVN0RyxJQUFJLENBQUMsRUFBRSxDQUFDL0osR0FBRyxFQUFFc1EsT0FBT3ZHLElBQUksQ0FBQyxFQUFFLElBQUlBLElBQUksQ0FBQyxFQUFFLENBQUMvSixHQUFHO1FBQ3ZELElBQUlzUSxRQUFRLE1BQ1JBLE9BQU9EO1FBQ1gvRSxNQUFNO1lBQUUrRSxRQUFRQSxTQUFTOVQ7WUFBTStULE1BQU1BLE9BQU8vVDtRQUFLO0lBQ3JEO0lBQ0EsT0FBTztRQUFFaUQ7UUFBSzhMO1FBQUsvTztRQUFNQztJQUFHO0FBQ2hDO0FBQ0EsU0FBU2dwQixhQUFhcG5CLEdBQUc7SUFDckIsSUFBSUMsT0FBT0QsSUFBSUcsVUFBVTtJQUN6QixJQUFJRixNQUFNO1FBQ04sT0FBT0EsS0FBS21RLFNBQVM7SUFDekIsT0FDSyxJQUFJcFEsSUFBSVQsUUFBUSxJQUFJLFFBQVFTLElBQUlwQyxVQUFVLEVBQUU7UUFDN0Msd0RBQXdEO1FBQ3hELHdEQUF3RDtRQUN4RCxzREFBc0Q7UUFDdEQsSUFBSXVGLFVBQVUsYUFBYTdELElBQUksQ0FBQ1UsSUFBSXBDLFVBQVUsQ0FBQzJCLFFBQVEsR0FBRztZQUN0RCxJQUFJOFosT0FBTy9hLFNBQVNzVixhQUFhLENBQUM7WUFDbEN5RixLQUFLeEYsV0FBVyxDQUFDdlYsU0FBU3NWLGFBQWEsQ0FBQztZQUN4QyxPQUFPO2dCQUFFeUY7WUFBSztRQUNsQixPQUNLLElBQUlyWixJQUFJcEMsVUFBVSxDQUFDbU4sU0FBUyxJQUFJL0ssT0FBT21ELFVBQVUsZ0JBQWdCN0QsSUFBSSxDQUFDVSxJQUFJcEMsVUFBVSxDQUFDMkIsUUFBUSxHQUFHO1lBQ2pHLE9BQU87Z0JBQUUwVSxRQUFRO1lBQUs7UUFDMUI7SUFDSixPQUNLLElBQUlqVSxJQUFJVCxRQUFRLElBQUksU0FBU1MsSUFBSWluQixZQUFZLENBQUMscUJBQXFCO1FBQ3BFLE9BQU87WUFBRWhULFFBQVE7UUFBSztJQUMxQjtJQUNBLE9BQU87QUFDWDtBQUNBLE1BQU1vRyxXQUFXO0FBQ2pCLFNBQVNnakIsY0FBYy8zQixJQUFJLEVBQUVuSCxJQUFJLEVBQUVDLEVBQUUsRUFBRWs5QixRQUFRLEVBQUVVLFVBQVU7SUFDdkQsSUFBSXZRLGdCQUFnQm5tQixLQUFLMFMsS0FBSyxDQUFDMFQseUJBQXlCLElBQUtwbUIsQ0FBQUEsS0FBS2dSLFNBQVMsR0FBR2hSLEtBQUswUyxLQUFLLENBQUN5VCxhQUFhLEdBQUc7SUFDekdubUIsS0FBSzBTLEtBQUssQ0FBQzBULHlCQUF5QixHQUFHO0lBQ3ZDLElBQUl2dEIsT0FBTyxHQUFHO1FBQ1YsSUFBSWtoQixTQUFTL1osS0FBSzBTLEtBQUssQ0FBQ2lULGlCQUFpQixHQUFHbUIsS0FBS0MsR0FBRyxLQUFLLEtBQUsvbUIsS0FBSzBTLEtBQUssQ0FBQ2dULG1CQUFtQixHQUFHO1FBQy9GLElBQUlxUSxTQUFTamMsaUJBQWlCOVosTUFBTStaO1FBQ3BDLElBQUlnYyxVQUFVLENBQUMvMUIsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQzZHLEVBQUUsQ0FBQ3FuQixTQUFTO1lBQzVDLElBQUlwNEIsVUFBVVMsV0FDVjRCLEtBQUswUyxLQUFLLENBQUM0UyxXQUFXLEtBQUssTUFBTXdCLEtBQUtDLEdBQUcsS0FBSyxNQUFNL21CLEtBQUswUyxLQUFLLENBQUM2UyxlQUFlLElBQzlFdmxCLEtBQUtHLFFBQVEsQ0FBQyxpQkFBaUJvSCxDQUFBQSxJQUFLQSxFQUFFdkgsTUFBTTFFLFNBQVMsSUFBSSxZQUN6RDtZQUNKLElBQUk4aEIsS0FBS3BkLEtBQUswRixLQUFLLENBQUMwWCxFQUFFLENBQUMxUSxZQUFZLENBQUNxcEI7WUFDcEMsSUFBSWhjLFVBQVUsV0FDVnFELEdBQUd1TCxPQUFPLENBQUMsV0FBVztpQkFDckIsSUFBSTVPLFVBQVUsT0FDZnFELEdBQUdDLGNBQWM7WUFDckIsSUFBSThJLGVBQ0EvSSxHQUFHdUwsT0FBTyxDQUFDLGVBQWV4QztZQUM5Qm5tQixLQUFLbWQsUUFBUSxDQUFDQztRQUNsQjtRQUNBO0lBQ0o7SUFDQSxJQUFJNGEsVUFBVWg0QixLQUFLMEYsS0FBSyxDQUFDNUosR0FBRyxDQUFDbUwsT0FBTyxDQUFDcE87SUFDckMsSUFBSW8vQixTQUFTRCxRQUFRRSxXQUFXLENBQUNwL0I7SUFDakNELE9BQU9tL0IsUUFBUW56QixNQUFNLENBQUNvekIsU0FBUztJQUMvQm4vQixLQUFLa0gsS0FBSzBGLEtBQUssQ0FBQzVKLEdBQUcsQ0FBQ21MLE9BQU8sQ0FBQ25PLElBQUlzTyxLQUFLLENBQUM2d0IsU0FBUztJQUMvQyxJQUFJcndCLE1BQU01SCxLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUztJQUM5QixJQUFJaWQsUUFBUTJTLGFBQWF6M0IsTUFBTW5ILE1BQU1DO0lBQ3JDLElBQUlnRCxNQUFNa0UsS0FBSzBGLEtBQUssQ0FBQzVKLEdBQUcsRUFBRXE4QixVQUFVcjhCLElBQUk4VCxLQUFLLENBQUNrVixNQUFNanNCLElBQUksRUFBRWlzQixNQUFNaHNCLEVBQUU7SUFDbEUsSUFBSXMvQixjQUFjQztJQUNsQixvREFBb0Q7SUFDcEQsSUFBSXI0QixLQUFLMFMsS0FBSyxDQUFDNFMsV0FBVyxLQUFLLEtBQUt3QixLQUFLQyxHQUFHLEtBQUssTUFBTS9tQixLQUFLMFMsS0FBSyxDQUFDNlMsZUFBZSxFQUFFO1FBQy9FNlMsZUFBZXA0QixLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUyxDQUFDL08sRUFBRTtRQUN0Q3UvQixnQkFBZ0I7SUFDcEIsT0FDSztRQUNERCxlQUFlcDRCLEtBQUswRixLQUFLLENBQUNtQyxTQUFTLENBQUNoUCxJQUFJO1FBQ3hDdy9CLGdCQUFnQjtJQUNwQjtJQUNBcjRCLEtBQUswUyxLQUFLLENBQUM0UyxXQUFXLEdBQUc7SUFDekIsSUFBSWdULFNBQVNDLFNBQVNKLFFBQVF4eUIsT0FBTyxFQUFFbWYsTUFBTWhwQixHQUFHLENBQUM2SixPQUFPLEVBQUVtZixNQUFNanNCLElBQUksRUFBRXUvQixjQUFjQztJQUNwRixJQUFJQyxRQUNBdDRCLEtBQUswUyxLQUFLLENBQUMyVCxjQUFjO0lBQzdCLElBQUksQ0FBQ3RvQixPQUFPaUMsS0FBSzBTLEtBQUssQ0FBQ2tULFlBQVksR0FBR2tCLEtBQUtDLEdBQUcsS0FBSyxPQUFPM29CLE9BQU0sS0FDNURzNEIsV0FBVzNMLElBQUksQ0FBQzVXLENBQUFBLElBQUtBLEVBQUUxYixRQUFRLElBQUksS0FBSyxDQUFDc2MsU0FBUy9hLElBQUksQ0FBQ21hLEVBQUVsYSxRQUFRLE1BQ2hFLEVBQUNxK0IsVUFBVUEsT0FBT0UsSUFBSSxJQUFJRixPQUFPRyxJQUFJLEtBQ3RDejRCLEtBQUtHLFFBQVEsQ0FBQyxpQkFBaUJvSCxDQUFBQSxJQUFLQSxFQUFFdkgsTUFBTTFFLFNBQVMsSUFBSSxZQUFZO1FBQ3JFMEUsS0FBSzBTLEtBQUssQ0FBQ2tULFlBQVksR0FBRztRQUMxQjtJQUNKO0lBQ0EsSUFBSSxDQUFDMFMsUUFBUTtRQUNULElBQUl0QyxZQUFZcHVCLGVBQWVwUSw0REFBYUEsSUFBSSxDQUFDb1EsSUFBSStJLEtBQUssSUFBSS9JLElBQUlTLEtBQUssQ0FBQzRXLFVBQVUsQ0FBQ3JYLElBQUkyUyxPQUFPLEtBQzFGLENBQUN2YSxLQUFLZ1IsU0FBUyxJQUFJLENBQUU4VCxDQUFBQSxNQUFNbGQsR0FBRyxJQUFJa2QsTUFBTWxkLEdBQUcsQ0FBQytFLE1BQU0sSUFBSW1ZLE1BQU1sZCxHQUFHLENBQUNnRixJQUFJLEdBQUc7WUFDdkUwckIsU0FBUztnQkFBRTd2QixPQUFPYixJQUFJL08sSUFBSTtnQkFBRTIvQixNQUFNNXdCLElBQUk5TyxFQUFFO2dCQUFFMi9CLE1BQU03d0IsSUFBSTlPLEVBQUU7WUFBQztRQUMzRCxPQUNLO1lBQ0QsSUFBSWdzQixNQUFNbGQsR0FBRyxFQUFFO2dCQUNYLElBQUlBLE1BQU04d0IsaUJBQWlCMTRCLE1BQU1BLEtBQUswRixLQUFLLENBQUM1SixHQUFHLEVBQUVncEIsTUFBTWxkLEdBQUc7Z0JBQzFELElBQUlBLE9BQU8sQ0FBQ0EsSUFBSThHLEVBQUUsQ0FBQzFPLEtBQUswRixLQUFLLENBQUNtQyxTQUFTLEdBQUc7b0JBQ3RDLElBQUl1VixLQUFLcGQsS0FBSzBGLEtBQUssQ0FBQzBYLEVBQUUsQ0FBQzFRLFlBQVksQ0FBQzlFO29CQUNwQyxJQUFJdWUsZUFDQS9JLEdBQUd1TCxPQUFPLENBQUMsZUFBZXhDO29CQUM5Qm5tQixLQUFLbWQsUUFBUSxDQUFDQztnQkFDbEI7WUFDSjtZQUNBO1FBQ0o7SUFDSjtJQUNBLGtFQUFrRTtJQUNsRSw4REFBOEQ7SUFDOUQscURBQXFEO0lBQ3JELElBQUlwZCxLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUyxDQUFDaFAsSUFBSSxHQUFHbUgsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQy9PLEVBQUUsSUFDbkR3L0IsT0FBTzd2QixLQUFLLElBQUk2dkIsT0FBT0csSUFBSSxJQUMzQno0QixLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUyxZQUFZclEsNERBQWFBLEVBQUU7UUFDL0MsSUFBSThnQyxPQUFPN3ZCLEtBQUssR0FBR3pJLEtBQUswRixLQUFLLENBQUNtQyxTQUFTLENBQUNoUCxJQUFJLElBQUl5L0IsT0FBTzd2QixLQUFLLElBQUl6SSxLQUFLMEYsS0FBSyxDQUFDbUMsU0FBUyxDQUFDaFAsSUFBSSxHQUFHLEtBQ3hGbUgsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQ2hQLElBQUksSUFBSWlzQixNQUFNanNCLElBQUksRUFBRTtZQUN6Q3kvQixPQUFPN3ZCLEtBQUssR0FBR3pJLEtBQUswRixLQUFLLENBQUNtQyxTQUFTLENBQUNoUCxJQUFJO1FBQzVDLE9BQ0ssSUFBSXkvQixPQUFPRSxJQUFJLEdBQUd4NEIsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQy9PLEVBQUUsSUFBSXcvQixPQUFPRSxJQUFJLElBQUl4NEIsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQy9PLEVBQUUsR0FBRyxLQUN2RmtILEtBQUswRixLQUFLLENBQUNtQyxTQUFTLENBQUMvTyxFQUFFLElBQUlnc0IsTUFBTWhzQixFQUFFLEVBQUU7WUFDckN3L0IsT0FBT0csSUFBSSxJQUFLejRCLEtBQUswRixLQUFLLENBQUNtQyxTQUFTLENBQUMvTyxFQUFFLEdBQUd3L0IsT0FBT0UsSUFBSTtZQUNyREYsT0FBT0UsSUFBSSxHQUFHeDRCLEtBQUswRixLQUFLLENBQUNtQyxTQUFTLENBQUMvTyxFQUFFO1FBQ3pDO0lBQ0o7SUFDQSxtRUFBbUU7SUFDbkUsa0VBQWtFO0lBQ2xFLCtEQUErRDtJQUMvRCxJQUFJd0UsTUFBTUMsY0FBYyxNQUFNKzZCLE9BQU9HLElBQUksSUFBSUgsT0FBTzd2QixLQUFLLEdBQUcsS0FDeEQ2dkIsT0FBT0UsSUFBSSxJQUFJRixPQUFPN3ZCLEtBQUssSUFBSTZ2QixPQUFPN3ZCLEtBQUssR0FBR3FjLE1BQU1qc0IsSUFBSSxJQUN4RGlzQixNQUFNaHBCLEdBQUcsQ0FBQzRrQixXQUFXLENBQUM0WCxPQUFPN3ZCLEtBQUssR0FBR3FjLE1BQU1qc0IsSUFBSSxHQUFHLEdBQUd5L0IsT0FBTzd2QixLQUFLLEdBQUdxYyxNQUFNanNCLElBQUksR0FBRyxNQUFNLFNBQVc7UUFDbEd5L0IsT0FBTzd2QixLQUFLO1FBQ1o2dkIsT0FBT0UsSUFBSTtRQUNYRixPQUFPRyxJQUFJO0lBQ2Y7SUFDQSxJQUFJMXdCLFFBQVErYyxNQUFNaHBCLEdBQUcsQ0FBQzY4QixjQUFjLENBQUNMLE9BQU83dkIsS0FBSyxHQUFHcWMsTUFBTWpzQixJQUFJO0lBQzlELElBQUltUCxNQUFNOGMsTUFBTWhwQixHQUFHLENBQUM2OEIsY0FBYyxDQUFDTCxPQUFPRyxJQUFJLEdBQUczVCxNQUFNanNCLElBQUk7SUFDM0QsSUFBSSsvQixTQUFTOThCLElBQUltTCxPQUFPLENBQUNxeEIsT0FBTzd2QixLQUFLO0lBQ3JDLElBQUlvd0IsZUFBZTl3QixNQUFNa1gsVUFBVSxDQUFDalgsUUFBUUQsTUFBTXhQLE1BQU0sQ0FBQzJPLGFBQWEsSUFBSTB4QixPQUFPbHdCLEdBQUcsTUFBTTR2QixPQUFPRSxJQUFJO0lBQ3JHLElBQUlNO0lBQ0osbUVBQW1FO0lBQ25FLG9FQUFvRTtJQUNwRSxJQUFJLENBQUMsT0FBUTk0QixLQUFLMFMsS0FBSyxDQUFDa1QsWUFBWSxHQUFHa0IsS0FBS0MsR0FBRyxLQUFLLE9BQy9DLEVBQUM4UixnQkFBZ0JuQyxXQUFXM0wsSUFBSSxDQUFDNVcsQ0FBQUEsSUFBS0EsRUFBRWxhLFFBQVEsSUFBSSxTQUFTa2EsRUFBRWxhLFFBQVEsSUFBSSxJQUFHLEtBQzlFLENBQUM0K0IsZ0JBQWdCOXdCLE1BQU16TCxHQUFHLEdBQUd3b0IsTUFBTWhwQixHQUFHLENBQUM2SixPQUFPLENBQUNDLElBQUksSUFDL0MsRUFBQ21DLE1BQU1rWCxVQUFVLENBQUNqWCxRQUFRLENBQUNELE1BQU14UCxNQUFNLENBQUMyTyxhQUFhLEtBQ3JENHhCLENBQUFBLFVBQVVuaEMsd0RBQVNBLENBQUNzbEIsUUFBUSxDQUFDNkgsTUFBTWhwQixHQUFHLENBQUNtTCxPQUFPLENBQUNjLE1BQU16TCxHQUFHLEdBQUcsSUFBSSxHQUFHLEtBQUksS0FDdkV3OEIsUUFBUWxzQixJQUFJLEdBQUc3RSxNQUFNekwsR0FBRyxLQUM1QjBELEtBQUtHLFFBQVEsQ0FBQyxpQkFBaUJvSCxDQUFBQSxJQUFLQSxFQUFFdkgsTUFBTTFFLFNBQVMsSUFBSSxZQUFZO1FBQ3JFMEUsS0FBSzBTLEtBQUssQ0FBQ2tULFlBQVksR0FBRztRQUMxQjtJQUNKO0lBQ0EscUJBQXFCO0lBQ3JCLElBQUk1bEIsS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQzhFLE1BQU0sR0FBRzJyQixPQUFPN3ZCLEtBQUssSUFDMUNzd0IsbUJBQW1CajlCLEtBQUt3OEIsT0FBTzd2QixLQUFLLEVBQUU2dkIsT0FBT0UsSUFBSSxFQUFFendCLE9BQU9DLFFBQzFEaEksS0FBS0csUUFBUSxDQUFDLGlCQUFpQm9ILENBQUFBLElBQUtBLEVBQUV2SCxNQUFNMUUsU0FBUyxHQUFHLGdCQUFnQjtRQUN4RSxJQUFJOEMsV0FBV1QsUUFDWHFDLEtBQUtrYixXQUFXLENBQUN3YSx3QkFBd0IsSUFBSSxPQUFPO1FBQ3hEO0lBQ0o7SUFDQSwyREFBMkQ7SUFDM0QsbUVBQW1FO0lBQ25FLGlDQUFpQztJQUNqQyxJQUFJLzNCLFVBQVUyNkIsT0FBT0csSUFBSSxJQUFJSCxPQUFPN3ZCLEtBQUssRUFDckN6SSxLQUFLMFMsS0FBSyxDQUFDc1QsZ0JBQWdCLEdBQUdjLEtBQUtDLEdBQUc7SUFDMUMsZ0RBQWdEO0lBQ2hELDhEQUE4RDtJQUM5RCxvRUFBb0U7SUFDcEUsbUVBQW1FO0lBQ25FLGdFQUFnRTtJQUNoRSxvRUFBb0U7SUFDcEUsa0VBQWtFO0lBQ2xFLHdCQUF3QjtJQUN4QixJQUFJM29CLFdBQVcsQ0FBQ3k2QixnQkFBZ0I5d0IsTUFBTVUsS0FBSyxNQUFNVCxJQUFJUyxLQUFLLE1BQU1ULElBQUlPLFlBQVksSUFBSSxLQUFLUixNQUFNb0IsS0FBSyxJQUFJbkIsSUFBSW1CLEtBQUssSUFDN0cyYixNQUFNbGQsR0FBRyxJQUFJa2QsTUFBTWxkLEdBQUcsQ0FBQytFLE1BQU0sSUFBSW1ZLE1BQU1sZCxHQUFHLENBQUNnRixJQUFJLElBQUlrWSxNQUFNbGQsR0FBRyxDQUFDZ0YsSUFBSSxJQUFJMHJCLE9BQU9FLElBQUksRUFBRTtRQUNsRkYsT0FBT0csSUFBSSxJQUFJO1FBQ2Z6d0IsTUFBTThjLE1BQU1ocEIsR0FBRyxDQUFDNjhCLGNBQWMsQ0FBQ0wsT0FBT0csSUFBSSxHQUFHM1QsTUFBTWpzQixJQUFJO1FBQ3ZEeWpCLFdBQVc7WUFDUHRjLEtBQUtHLFFBQVEsQ0FBQyxpQkFBaUIsU0FBVW9ILENBQUM7Z0JBQUksT0FBT0EsRUFBRXZILE1BQU0xRSxTQUFTLElBQUk7WUFBVztRQUN6RixHQUFHO0lBQ1A7SUFDQSxJQUFJMDlCLFNBQVNWLE9BQU83dkIsS0FBSyxFQUFFd3dCLE9BQU9YLE9BQU9FLElBQUk7SUFDN0MsSUFBSXBiLElBQUkwTixhQUFhb087SUFDckIsSUFBSUwsY0FBYztRQUNkLElBQUk5d0IsTUFBTXpMLEdBQUcsSUFBSTBMLElBQUkxTCxHQUFHLEVBQUU7WUFDdEIsOERBQThEO1lBQzlELG1EQUFtRDtZQUNuRCxJQUFJZ0IsTUFBTUMsY0FBYyxNQUFNd0ssTUFBTVEsWUFBWSxJQUFJLEdBQUc7Z0JBQ25EdkksS0FBS2tiLFdBQVcsQ0FBQ3dhLHdCQUF3QjtnQkFDekNwWixXQUFXLElBQU16QixlQUFlN2EsT0FBTztZQUMzQztZQUNBb2QsS0FBS3BkLEtBQUswRixLQUFLLENBQUMwWCxFQUFFLENBQUMrQixNQUFNLENBQUM2WixRQUFRQztZQUNsQ25PLGNBQWNodkIsSUFBSW1MLE9BQU8sQ0FBQ3F4QixPQUFPN3ZCLEtBQUssRUFBRTB3QixXQUFXLENBQUNyOUIsSUFBSW1MLE9BQU8sQ0FBQ3F4QixPQUFPRSxJQUFJO1FBQy9FLE9BQ0ssSUFDTEYsT0FBT0UsSUFBSSxJQUFJRixPQUFPRyxJQUFJLElBQ3JCUyxDQUFBQSxhQUFhRSxhQUFhcnhCLE1BQU14UCxNQUFNLENBQUNvTixPQUFPLENBQUN5TyxHQUFHLENBQUNyTSxNQUFNUSxZQUFZLEVBQUVQLElBQUlPLFlBQVksR0FBR3F3QixPQUFPcmdDLE1BQU0sQ0FBQ29OLE9BQU8sQ0FBQ3lPLEdBQUcsQ0FBQ3drQixPQUFPcndCLFlBQVksRUFBRSt2QixPQUFPRSxJQUFJLEdBQUdJLE9BQU9ud0IsS0FBSyxJQUFHLEdBQUk7WUFDM0syVSxLQUFLcGQsS0FBSzBGLEtBQUssQ0FBQzBYLEVBQUU7WUFDbEIsSUFBSThiLFdBQVd6ckIsSUFBSSxJQUFJLE9BQ25CMlAsR0FBR2ljLE9BQU8sQ0FBQ0wsUUFBUUMsTUFBTUMsV0FBV3p1QixJQUFJO2lCQUV4QzJTLEdBQUdrYyxVQUFVLENBQUNOLFFBQVFDLE1BQU1DLFdBQVd6dUIsSUFBSTtRQUNuRCxPQUNLLElBQUkxQyxNQUFNeFAsTUFBTSxDQUFDK0ssS0FBSyxDQUFDeUUsTUFBTTNQLEtBQUssSUFBSXdNLE1BQU0sSUFBSW1ELE1BQU0zUCxLQUFLLE1BQU00UCxJQUFJNVAsS0FBSyxLQUFNNFAsQ0FBQUEsSUFBSXdWLFVBQVUsR0FBRyxJQUFJLElBQUk7WUFDMUcsNkRBQTZEO1lBQzdELElBQUl4UCxPQUFPakcsTUFBTXhQLE1BQU0sQ0FBQ21vQixXQUFXLENBQUMzWSxNQUFNUSxZQUFZLEVBQUVQLElBQUlPLFlBQVk7WUFDeEUsSUFBSXZJLEtBQUtHLFFBQVEsQ0FBQyxtQkFBbUJvSCxDQUFBQSxJQUFLQSxFQUFFdkgsTUFBTWc1QixRQUFRQyxNQUFNanJCLFFBQzVEO1lBQ0pvUCxLQUFLcGQsS0FBSzBGLEtBQUssQ0FBQzBYLEVBQUUsQ0FBQzRLLFVBQVUsQ0FBQ2hhLE1BQU1nckIsUUFBUUM7UUFDaEQ7SUFDSjtJQUNBLElBQUksQ0FBQzdiLElBQ0RBLEtBQUtwZCxLQUFLMEYsS0FBSyxDQUFDMFgsRUFBRSxDQUFDNkQsT0FBTyxDQUFDK1gsUUFBUUMsTUFBTW5VLE1BQU1ocEIsR0FBRyxDQUFDOFQsS0FBSyxDQUFDMG9CLE9BQU83dkIsS0FBSyxHQUFHcWMsTUFBTWpzQixJQUFJLEVBQUV5L0IsT0FBT0csSUFBSSxHQUFHM1QsTUFBTWpzQixJQUFJO0lBQ2hILElBQUlpc0IsTUFBTWxkLEdBQUcsRUFBRTtRQUNYLElBQUlBLE1BQU04d0IsaUJBQWlCMTRCLE1BQU1vZCxHQUFHdGhCLEdBQUcsRUFBRWdwQixNQUFNbGQsR0FBRztRQUNsRCx3REFBd0Q7UUFDeEQseURBQXlEO1FBQ3pELHlDQUF5QztRQUN6QyxrRUFBa0U7UUFDbEUseUNBQXlDO1FBQ3pDLElBQUlBLE9BQU8sQ0FBRWpLLENBQUFBLFVBQVVxQyxLQUFLZ1IsU0FBUyxJQUFJcEosSUFBSStJLEtBQUssSUFDN0MybkIsQ0FBQUEsT0FBTzd2QixLQUFLLElBQUk2dkIsT0FBT0csSUFBSSxJQUFJejRCLEtBQUswUyxLQUFLLENBQUNzVCxnQkFBZ0IsR0FBR2MsS0FBS0MsR0FBRyxLQUFLLEdBQUUsS0FDNUVuZixDQUFBQSxJQUFJZ0YsSUFBSSxJQUFJb3NCLFVBQVVweEIsSUFBSWdGLElBQUksSUFBSXdRLEdBQUdxUixPQUFPLENBQUNoSyxHQUFHLENBQUN3VSxRQUFRLE1BQzFEMzdCLE1BQU1zSyxJQUFJK0ksS0FBSyxJQUFJL0ksSUFBSWdGLElBQUksSUFBSW9zQixNQUFLLEdBQ3BDNWIsR0FBRzFRLFlBQVksQ0FBQzlFO0lBQ3hCO0lBQ0EsSUFBSWtqQixhQUNBMU4sR0FBR21jLFdBQVcsQ0FBQ3pPO0lBQ25CLElBQUkzRSxlQUNBL0ksR0FBR3VMLE9BQU8sQ0FBQyxlQUFleEM7SUFDOUJubUIsS0FBS21kLFFBQVEsQ0FBQ0MsR0FBR0MsY0FBYztBQUNuQztBQUNBLFNBQVNxYixpQkFBaUIxNEIsSUFBSSxFQUFFbEUsR0FBRyxFQUFFMDlCLFNBQVM7SUFDMUMsSUFBSWg5QixLQUFLOEUsR0FBRyxDQUFDazRCLFVBQVU3c0IsTUFBTSxFQUFFNnNCLFVBQVU1c0IsSUFBSSxJQUFJOVEsSUFBSTZKLE9BQU8sQ0FBQ0MsSUFBSSxFQUM3RCxPQUFPO0lBQ1gsT0FBTzRVLGlCQUFpQnhhLE1BQU1sRSxJQUFJbUwsT0FBTyxDQUFDdXlCLFVBQVU3c0IsTUFBTSxHQUFHN1EsSUFBSW1MLE9BQU8sQ0FBQ3V5QixVQUFVNXNCLElBQUk7QUFDM0Y7QUFDQSxnRUFBZ0U7QUFDaEUsa0VBQWtFO0FBQ2xFLHlDQUF5QztBQUN6QyxTQUFTd3NCLGFBQWF4K0IsR0FBRyxFQUFFNEssSUFBSTtJQUMzQixJQUFJaTBCLFdBQVc3K0IsSUFBSTJJLFVBQVUsQ0FBQ2lPLEtBQUssRUFBRWtvQixZQUFZbDBCLEtBQUtqQyxVQUFVLENBQUNpTyxLQUFLO0lBQ3RFLElBQUl5a0IsUUFBUXdELFVBQVV6SCxVQUFVMEgsV0FBV2pzQixNQUFNaEQsTUFBTXdJO0lBQ3ZELElBQUssSUFBSTVRLElBQUksR0FBR0EsSUFBSXEzQixVQUFVdGdDLE1BQU0sRUFBRWlKLElBQ2xDNHpCLFFBQVF5RCxTQUFTLENBQUNyM0IsRUFBRSxDQUFDczNCLGFBQWEsQ0FBQzFEO0lBQ3ZDLElBQUssSUFBSTV6QixJQUFJLEdBQUdBLElBQUlvM0IsU0FBU3JnQyxNQUFNLEVBQUVpSixJQUNqQzJ2QixVQUFVeUgsUUFBUSxDQUFDcDNCLEVBQUUsQ0FBQ3MzQixhQUFhLENBQUMzSDtJQUN4QyxJQUFJaUUsTUFBTTc4QixNQUFNLElBQUksS0FBSzQ0QixRQUFRNTRCLE1BQU0sSUFBSSxHQUFHO1FBQzFDcVIsT0FBT3dyQixLQUFLLENBQUMsRUFBRTtRQUNmeG9CLE9BQU87UUFDUHdGLFNBQVMsQ0FBQzlhLE9BQVNBLEtBQUtzUyxJQUFJLENBQUNBLEtBQUttdkIsUUFBUSxDQUFDemhDLEtBQUtxWixLQUFLO0lBQ3pELE9BQ0ssSUFBSXlrQixNQUFNNzhCLE1BQU0sSUFBSSxLQUFLNDRCLFFBQVE1NEIsTUFBTSxJQUFJLEdBQUc7UUFDL0NxUixPQUFPdW5CLE9BQU8sQ0FBQyxFQUFFO1FBQ2pCdmtCLE9BQU87UUFDUHdGLFNBQVMsQ0FBQzlhLE9BQVNBLEtBQUtzUyxJQUFJLENBQUNBLEtBQUtrdkIsYUFBYSxDQUFDeGhDLEtBQUtxWixLQUFLO0lBQzlELE9BQ0s7UUFDRCxPQUFPO0lBQ1g7SUFDQSxJQUFJZ0csVUFBVSxFQUFFO0lBQ2hCLElBQUssSUFBSW5WLElBQUksR0FBR0EsSUFBSW1ELEtBQUtrTSxVQUFVLEVBQUVyUCxJQUNqQ21WLFFBQVF4VixJQUFJLENBQUNpUixPQUFPek4sS0FBS2xDLEtBQUssQ0FBQ2pCO0lBQ25DLElBQUl4Syx1REFBUUEsQ0FBQ2dCLElBQUksQ0FBQzJlLFNBQVM5SSxFQUFFLENBQUM5VCxNQUMxQixPQUFPO1FBQUU2UDtRQUFNZ0Q7SUFBSztBQUM1QjtBQUNBLFNBQVNzckIsbUJBQW1CYyxHQUFHLEVBQUVweEIsS0FBSyxFQUFFQyxHQUFHLEVBQUVveEIsU0FBUyxFQUFFQyxPQUFPO0lBQzNELElBQ0FyeEIsTUFBTUQsU0FBU3N4QixRQUFRejlCLEdBQUcsR0FBR3c5QixVQUFVeDlCLEdBQUcsSUFDdEMsd0ZBQXdGO0lBQ3hGMDlCLHNCQUFzQkYsV0FBVyxNQUFNLFNBQVNDLFFBQVF6OUIsR0FBRyxFQUMzRCxPQUFPO0lBQ1gsSUFBSTBnQixTQUFTNmMsSUFBSTV5QixPQUFPLENBQUN3QjtJQUN6Qiw2RkFBNkY7SUFDN0YsSUFBSSxDQUFDcXhCLFVBQVV2aEMsTUFBTSxDQUFDK1AsV0FBVyxFQUFFO1FBQy9CLElBQUlsQixRQUFRNFYsT0FBT1UsU0FBUztRQUM1QixPQUFPdFcsU0FBUyxRQUFRc0IsT0FBT0QsUUFBUXJCLE1BQU10TixRQUFRO0lBQ3pEO0lBQ0Esc0NBQXNDO0lBQ3RDLElBQUlrakIsT0FBT3pVLFlBQVksR0FBR3lVLE9BQU96a0IsTUFBTSxDQUFDb04sT0FBTyxDQUFDQyxJQUFJLElBQUksQ0FBQ29YLE9BQU96a0IsTUFBTSxDQUFDK1AsV0FBVyxFQUM5RSxPQUFPO0lBQ1gsSUFBSTJ4QixRQUFRSixJQUFJNXlCLE9BQU8sQ0FBQyt5QixzQkFBc0JoZCxRQUFRLE1BQU07SUFDNUQsMkRBQTJEO0lBQzNELElBQUksQ0FBQ2lkLE1BQU0xaEMsTUFBTSxDQUFDK1AsV0FBVyxJQUFJMnhCLE1BQU0zOUIsR0FBRyxHQUFHb00sT0FDekNzeEIsc0JBQXNCQyxPQUFPLE1BQU0sU0FBU3Z4QixLQUM1QyxPQUFPO0lBQ1gsZ0RBQWdEO0lBQ2hELE9BQU9veEIsVUFBVXZoQyxNQUFNLENBQUNvTixPQUFPLENBQUN5TyxHQUFHLENBQUMwbEIsVUFBVXZ4QixZQUFZLEVBQUVtRyxFQUFFLENBQUN1ckIsTUFBTTFoQyxNQUFNLENBQUNvTixPQUFPO0FBQ3ZGO0FBQ0EsU0FBU3EwQixzQkFBc0JseUIsSUFBSSxFQUFFb3lCLE9BQU8sRUFBRUMsT0FBTztJQUNqRCxJQUFJaHhCLFFBQVFyQixLQUFLcUIsS0FBSyxFQUFFVCxNQUFNd3hCLFVBQVVweUIsS0FBS1ksR0FBRyxLQUFLWixLQUFLeEwsR0FBRztJQUM3RCxNQUFPNk0sUUFBUSxLQUFNK3dCLENBQUFBLFdBQVdweUIsS0FBS3N5QixVQUFVLENBQUNqeEIsVUFBVXJCLEtBQUszUCxJQUFJLENBQUNnUixPQUFPdUksVUFBVSxFQUFHO1FBQ3BGdkk7UUFDQVQ7UUFDQXd4QixVQUFVO0lBQ2Q7SUFDQSxJQUFJQyxTQUFTO1FBQ1QsSUFBSTUwQixPQUFPdUMsS0FBSzNQLElBQUksQ0FBQ2dSLE9BQU9xcUIsVUFBVSxDQUFDMXJCLEtBQUtzeUIsVUFBVSxDQUFDanhCO1FBQ3ZELE1BQU81RCxRQUFRLENBQUNBLEtBQUtzTCxNQUFNLENBQUU7WUFDekJ0TCxPQUFPQSxLQUFLaEMsVUFBVTtZQUN0Qm1GO1FBQ0o7SUFDSjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTNnZCLFNBQVNwaUIsQ0FBQyxFQUFFQyxDQUFDLEVBQUU5WixHQUFHLEVBQUU4N0IsWUFBWSxFQUFFQyxhQUFhO0lBQ3BELElBQUk1dkIsUUFBUTBOLEVBQUVra0IsYUFBYSxDQUFDamtCLEdBQUc5WjtJQUMvQixJQUFJbU0sU0FBUyxNQUNULE9BQU87SUFDWCxJQUFJLEVBQUUwTixHQUFHcWlCLElBQUksRUFBRXBpQixHQUFHcWlCLElBQUksRUFBRSxHQUFHdGlCLEVBQUVta0IsV0FBVyxDQUFDbGtCLEdBQUc5WixNQUFNNlosRUFBRXZRLElBQUksRUFBRXRKLE1BQU04WixFQUFFeFEsSUFBSTtJQUN0RSxJQUFJeXlCLGlCQUFpQixPQUFPO1FBQ3hCLElBQUlrQyxTQUFTLzlCLEtBQUs4RSxHQUFHLENBQUMsR0FBR21ILFFBQVFqTSxLQUFLQyxHQUFHLENBQUMrN0IsTUFBTUM7UUFDaERMLGdCQUFnQkksT0FBTytCLFNBQVM5eEI7SUFDcEM7SUFDQSxJQUFJK3ZCLE9BQU8vdkIsU0FBUzBOLEVBQUV2USxJQUFJLEdBQUd3USxFQUFFeFEsSUFBSSxFQUFFO1FBQ2pDLElBQUl5a0IsT0FBTytOLGdCQUFnQjN2QixTQUFTMnZCLGdCQUFnQkksT0FBTy92QixRQUFRMnZCLGVBQWU7UUFDbEYzdkIsU0FBUzRoQjtRQUNULElBQUk1aEIsU0FBU0EsUUFBUTJOLEVBQUV4USxJQUFJLElBQUk0MEIsZ0JBQWdCcGtCLEVBQUVzSyxXQUFXLENBQUNqWSxRQUFRLEdBQUdBLFFBQVEsS0FDNUVBLFNBQVM0aEIsT0FBTyxJQUFJLENBQUM7UUFDekJvTyxPQUFPaHdCLFFBQVNnd0IsQ0FBQUEsT0FBT0QsSUFBRztRQUMxQkEsT0FBTy92QjtJQUNYLE9BQ0ssSUFBSWd3QixPQUFPaHdCLE9BQU87UUFDbkIsSUFBSTRoQixPQUFPK04sZ0JBQWdCM3ZCLFNBQVMydkIsZ0JBQWdCSyxPQUFPaHdCLFFBQVEydkIsZUFBZTtRQUNsRjN2QixTQUFTNGhCO1FBQ1QsSUFBSTVoQixTQUFTQSxRQUFRME4sRUFBRXZRLElBQUksSUFBSTQwQixnQkFBZ0Jya0IsRUFBRXVLLFdBQVcsQ0FBQ2pZLFFBQVEsR0FBR0EsUUFBUSxLQUM1RUEsU0FBUzRoQixPQUFPLElBQUksQ0FBQztRQUN6Qm1PLE9BQU8vdkIsUUFBUyt2QixDQUFBQSxPQUFPQyxJQUFHO1FBQzFCQSxPQUFPaHdCO0lBQ1g7SUFDQSxPQUFPO1FBQUVBO1FBQU8rdkI7UUFBTUM7SUFBSztBQUMvQjtBQUNBLFNBQVMrQixnQkFBZ0I3Z0IsR0FBRztJQUN4QixJQUFJQSxJQUFJdmdCLE1BQU0sSUFBSSxHQUNkLE9BQU87SUFDWCxJQUFJK2MsSUFBSXdELElBQUk4Z0IsVUFBVSxDQUFDLElBQUlya0IsSUFBSXVELElBQUk4Z0IsVUFBVSxDQUFDO0lBQzlDLE9BQU90a0IsS0FBSyxVQUFVQSxLQUFLLFVBQVVDLEtBQUssVUFBVUEsS0FBSztBQUM3RDtBQUVBOztBQUVBLEdBQ0EsTUFBTXNrQix1QkFBdUIvWjtBQUM3Qjs7QUFFQSxHQUNBLE1BQU1nYSxtQkFBbUJyUjtBQUN6Qjs7OztBQUlBLEdBQ0EsTUFBTXNSO0lBQ0Y7Ozs7OztJQU1BLEdBQ0F6d0IsWUFBWTB3QixLQUFLLEVBQUVDLEtBQUssQ0FBRTtRQUN0QixJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiOztRQUVBLEdBQ0EsSUFBSSxDQUFDclMsT0FBTyxHQUFHO1FBQ2Y7O1FBRUEsR0FDQSxJQUFJLENBQUN4VSxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDOG1CLE9BQU8sR0FBRztRQUNmOztRQUVBLEdBQ0EsSUFBSSxDQUFDL1AsVUFBVSxHQUFHO1FBQ2xCOztRQUVBLEdBQ0EsSUFBSSxDQUFDMVAsYUFBYSxHQUFHO1FBQ3JCOztRQUVBLEdBQ0EsSUFBSSxDQUFDa0Isb0JBQW9CLEdBQUc3WjtRQUM1Qjs7UUFFQSxHQUNBLElBQUksQ0FBQzhQLEtBQUssR0FBRyxJQUFJMlM7UUFDakIsSUFBSSxDQUFDNFYsaUJBQWlCLEdBQUcsRUFBRTtRQUMzQixJQUFJLENBQUNDLFdBQVcsR0FBRyxFQUFFO1FBQ3JCOzs7O1FBSUEsR0FDQSxJQUFJLENBQUNyakIscUJBQXFCLEdBQUc7UUFDN0I7Ozs7UUFJQSxHQUNBLElBQUksQ0FBQ29XLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNrTixNQUFNLEdBQUdMO1FBQ2QsSUFBSSxDQUFDcDFCLEtBQUssR0FBR28xQixNQUFNcDFCLEtBQUs7UUFDeEIsSUFBSSxDQUFDMDFCLGFBQWEsR0FBR04sTUFBTU8sT0FBTyxJQUFJLEVBQUU7UUFDeEMsSUFBSSxDQUFDRCxhQUFhLENBQUNqYSxPQUFPLENBQUNtYTtRQUMzQixJQUFJLENBQUNuZSxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRLENBQUNpTixJQUFJLENBQUMsSUFBSTtRQUN2QyxJQUFJLENBQUMxdkIsR0FBRyxHQUFHLFNBQVVtZ0MsTUFBTVUsS0FBSyxJQUFLdmlDLFNBQVNzVixhQUFhLENBQUM7UUFDNUQsSUFBSXVzQixPQUFPO1lBQ1AsSUFBSUEsTUFBTXRzQixXQUFXLEVBQ2pCc3NCLE1BQU10c0IsV0FBVyxDQUFDLElBQUksQ0FBQzdULEdBQUc7aUJBQ3pCLElBQUksT0FBT21nQyxTQUFTLFlBQ3JCQSxNQUFNLElBQUksQ0FBQ25nQyxHQUFHO2lCQUNiLElBQUltZ0MsTUFBTVUsS0FBSyxFQUNoQixJQUFJLENBQUNQLE9BQU8sR0FBRztRQUN2QjtRQUNBLElBQUksQ0FBQ3RnQixRQUFRLEdBQUc4Z0IsWUFBWSxJQUFJO1FBQ2hDQyxvQkFBb0IsSUFBSTtRQUN4QixJQUFJLENBQUNuc0IsU0FBUyxHQUFHb3NCLGVBQWUsSUFBSTtRQUNwQyxJQUFJLENBQUN0M0IsT0FBTyxHQUFHMFAsWUFBWSxJQUFJLENBQUNwTyxLQUFLLENBQUM1SixHQUFHLEVBQUU2L0IsZUFBZSxJQUFJLEdBQUd6SCxnQkFBZ0IsSUFBSSxHQUFHLElBQUksQ0FBQ3g1QixHQUFHLEVBQUUsSUFBSTtRQUN0RyxJQUFJLENBQUN3Z0IsV0FBVyxHQUFHLElBQUl5WixZQUFZLElBQUksRUFBRSxDQUFDOTdCLE1BQU1DLElBQUlrOUIsVUFBVUMsUUFBVThCLGNBQWMsSUFBSSxFQUFFbC9CLE1BQU1DLElBQUlrOUIsVUFBVUM7UUFDaEgsSUFBSSxDQUFDL2EsV0FBVyxDQUFDelMsS0FBSztRQUN0QjhkLFVBQVUsSUFBSTtRQUNkLElBQUksQ0FBQ3FWLGlCQUFpQjtJQUMxQjtJQUNBOzs7O0lBSUEsR0FDQSxJQUFJNXFCLFlBQVk7UUFBRSxPQUFPLElBQUksQ0FBQzBCLEtBQUssQ0FBQzFCLFNBQVM7SUFBRTtJQUMvQzs7SUFFQSxHQUNBLElBQUk4cEIsUUFBUTtRQUNSLElBQUksSUFBSSxDQUFDSyxNQUFNLENBQUN6MUIsS0FBSyxJQUFJLElBQUksQ0FBQ0EsS0FBSyxFQUFFO1lBQ2pDLElBQUlGLE9BQU8sSUFBSSxDQUFDMjFCLE1BQU07WUFDdEIsSUFBSSxDQUFDQSxNQUFNLEdBQUcsQ0FBQztZQUNmLElBQUssSUFBSTVyQixRQUFRL0osS0FDYixJQUFJLENBQUMyMUIsTUFBTSxDQUFDNXJCLEtBQUssR0FBRy9KLElBQUksQ0FBQytKLEtBQUs7WUFDbEMsSUFBSSxDQUFDNHJCLE1BQU0sQ0FBQ3oxQixLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLO1FBQ2xDO1FBQ0EsT0FBTyxJQUFJLENBQUN5MUIsTUFBTTtJQUN0QjtJQUNBOzs7SUFHQSxHQUNBbG9CLE9BQU82bkIsS0FBSyxFQUFFO1FBQ1YsSUFBSUEsTUFBTWUsZUFBZSxJQUFJLElBQUksQ0FBQ1YsTUFBTSxDQUFDVSxlQUFlLEVBQ3BEalYsZ0JBQWdCLElBQUk7UUFDeEIsSUFBSWtWLFlBQVksSUFBSSxDQUFDWCxNQUFNO1FBQzNCLElBQUksQ0FBQ0EsTUFBTSxHQUFHTDtRQUNkLElBQUlBLE1BQU1PLE9BQU8sRUFBRTtZQUNmUCxNQUFNTyxPQUFPLENBQUNsYSxPQUFPLENBQUNtYTtZQUN0QixJQUFJLENBQUNGLGFBQWEsR0FBR04sTUFBTU8sT0FBTztRQUN0QztRQUNBLElBQUksQ0FBQ1UsZ0JBQWdCLENBQUNqQixNQUFNcDFCLEtBQUssRUFBRW8yQjtJQUN2QztJQUNBOzs7O0lBSUEsR0FDQUUsU0FBU2xCLEtBQUssRUFBRTtRQUNaLElBQUl0akIsVUFBVSxDQUFDO1FBQ2YsSUFBSyxJQUFJakksUUFBUSxJQUFJLENBQUM0ckIsTUFBTSxDQUN4QjNqQixPQUFPLENBQUNqSSxLQUFLLEdBQUcsSUFBSSxDQUFDNHJCLE1BQU0sQ0FBQzVyQixLQUFLO1FBQ3JDaUksUUFBUTlSLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUs7UUFDMUIsSUFBSyxJQUFJNkosUUFBUXVyQixNQUNidGpCLE9BQU8sQ0FBQ2pJLEtBQUssR0FBR3VyQixLQUFLLENBQUN2ckIsS0FBSztRQUMvQixJQUFJLENBQUMwRCxNQUFNLENBQUN1RTtJQUNoQjtJQUNBOzs7SUFHQSxHQUNBOVAsWUFBWWhDLEtBQUssRUFBRTtRQUNmLElBQUksQ0FBQ3EyQixnQkFBZ0IsQ0FBQ3IyQixPQUFPLElBQUksQ0FBQ3kxQixNQUFNO0lBQzVDO0lBQ0FZLGlCQUFpQnIyQixLQUFLLEVBQUVvMkIsU0FBUyxFQUFFO1FBQy9CLElBQUlHO1FBQ0osSUFBSXoyQixPQUFPLElBQUksQ0FBQ0UsS0FBSyxFQUFFdzJCLFNBQVMsT0FBT0MsWUFBWTtRQUNuRCxrRUFBa0U7UUFDbEUsZ0JBQWdCO1FBQ2hCLElBQUl6MkIsTUFBTW9sQixXQUFXLElBQUksSUFBSSxDQUFDOVosU0FBUyxFQUFFO1lBQ3JDd2EsaUJBQWlCLElBQUk7WUFDckIyUSxZQUFZO1FBQ2hCO1FBQ0EsSUFBSSxDQUFDejJCLEtBQUssR0FBR0E7UUFDYixJQUFJMDJCLGlCQUFpQjUyQixLQUFLNjFCLE9BQU8sSUFBSTMxQixNQUFNMjFCLE9BQU8sSUFBSSxJQUFJLENBQUNGLE1BQU0sQ0FBQ0UsT0FBTyxJQUFJUyxVQUFVVCxPQUFPO1FBQzlGLElBQUllLGtCQUFrQixJQUFJLENBQUNqQixNQUFNLENBQUNFLE9BQU8sSUFBSVMsVUFBVVQsT0FBTyxJQUFJLElBQUksQ0FBQ0YsTUFBTSxDQUFDN3JCLFNBQVMsSUFBSXdzQixVQUFVeHNCLFNBQVMsRUFBRTtZQUM1RyxJQUFJQSxZQUFZb3NCLGVBQWUsSUFBSTtZQUNuQyxJQUFJVyxpQkFBaUIvc0IsV0FBVyxJQUFJLENBQUNBLFNBQVMsR0FBRztnQkFDN0MsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO2dCQUNqQjRzQixTQUFTO1lBQ2I7UUFDSjtRQUNBLElBQUlFLGtCQUFrQk4sVUFBVUQsZUFBZSxJQUFJLElBQUksQ0FBQ1YsTUFBTSxDQUFDVSxlQUFlLEVBQUU7WUFDNUVqVixnQkFBZ0IsSUFBSTtRQUN4QjtRQUNBLElBQUksQ0FBQ2xNLFFBQVEsR0FBRzhnQixZQUFZLElBQUk7UUFDaENDLG9CQUFvQixJQUFJO1FBQ3hCLElBQUk3d0IsWUFBWXNwQixnQkFBZ0IsSUFBSSxHQUFHdnBCLFlBQVlneEIsZUFBZSxJQUFJO1FBQ3RFLElBQUlXLFNBQVM5MkIsS0FBSzYxQixPQUFPLElBQUkzMUIsTUFBTTIxQixPQUFPLElBQUksQ0FBQzcxQixLQUFLMUosR0FBRyxDQUFDNFMsRUFBRSxDQUFDaEosTUFBTTVKLEdBQUcsSUFBSSxVQUNsRTRKLE1BQU02d0IsaUJBQWlCLEdBQUcvd0IsS0FBSyt3QixpQkFBaUIsR0FBRyxpQkFBaUI7UUFDMUUsSUFBSWdHLFlBQVlMLFVBQVUsQ0FBQyxJQUFJLENBQUM5M0IsT0FBTyxDQUFDc0csV0FBVyxDQUFDaEYsTUFBTTVKLEdBQUcsRUFBRTZPLFdBQVdDO1FBQzFFLElBQUkyeEIsYUFBYSxDQUFDNzJCLE1BQU1tQyxTQUFTLENBQUM2RyxFQUFFLENBQUNsSixLQUFLcUMsU0FBUyxHQUMvQ3MwQixZQUFZO1FBQ2hCLElBQUlLLGVBQWVGLFVBQVUsY0FBY0gsYUFBYSxJQUFJLENBQUN6aEMsR0FBRyxDQUFDNkQsS0FBSyxDQUFDaytCLGNBQWMsSUFBSSxRQUFRcDdCLGVBQWUsSUFBSTtRQUNwSCxJQUFJODZCLFdBQVc7WUFDWCxJQUFJLENBQUNqaEIsV0FBVyxDQUFDdE0sSUFBSTtZQUNyQiw4REFBOEQ7WUFDOUQsMkRBQTJEO1lBQzNELHVEQUF1RDtZQUN2RCwwREFBMEQ7WUFDMUQsd0JBQXdCO1lBQ3hCLElBQUk4dEIsaUJBQWlCSCxhQUFjai9CLENBQUFBLE1BQU1LLE1BQUssS0FBTSxDQUFDLElBQUksQ0FBQ3FULFNBQVMsSUFDL0QsQ0FBQ3hMLEtBQUtxQyxTQUFTLENBQUM4SSxLQUFLLElBQUksQ0FBQ2pMLE1BQU1tQyxTQUFTLENBQUM4SSxLQUFLLElBQUlnc0Isd0JBQXdCbjNCLEtBQUtxQyxTQUFTLEVBQUVuQyxNQUFNbUMsU0FBUztZQUM5RyxJQUFJMDBCLFdBQVc7Z0JBQ1gsNERBQTREO2dCQUM1RCw4REFBOEQ7Z0JBQzlELDJEQUEyRDtnQkFDM0QseUJBQXlCO2dCQUN6QixJQUFJSyxlQUFlai9CLFNBQVUsSUFBSSxDQUFDdVcsV0FBVyxHQUFHLElBQUksQ0FBQ25MLGlCQUFpQixHQUFHN04sU0FBUyxHQUFJO2dCQUN0RixJQUFJLElBQUksQ0FBQzhWLFNBQVMsRUFDZCxJQUFJLENBQUMwQixLQUFLLENBQUNDLGVBQWUsR0FBRytZLG9CQUFvQixJQUFJO2dCQUN6RCxJQUFJd1EsVUFBVSxDQUFDLElBQUksQ0FBQzkzQixPQUFPLENBQUM2TyxNQUFNLENBQUN2TixNQUFNNUosR0FBRyxFQUFFNk8sV0FBV0MsV0FBVyxJQUFJLEdBQUc7b0JBQ3ZFLElBQUksQ0FBQ3hHLE9BQU8sQ0FBQ2dQLGVBQWUsQ0FBQ3pJO29CQUM3QixJQUFJLENBQUN2RyxPQUFPLENBQUM0RyxPQUFPO29CQUNwQixJQUFJLENBQUM1RyxPQUFPLEdBQUcwUCxZQUFZcE8sTUFBTTVKLEdBQUcsRUFBRTZPLFdBQVdDLFdBQVcsSUFBSSxDQUFDbFEsR0FBRyxFQUFFLElBQUk7Z0JBQzlFO2dCQUNBLElBQUlraUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDMW9CLFdBQVcsRUFDakN3b0IsaUJBQWlCO1lBQ3pCO1lBQ0Esa0VBQWtFO1lBQ2xFLGdFQUFnRTtZQUNoRSw4REFBOEQ7WUFDOUQsa0JBQWtCO1lBQ2xCLElBQUlBLGtCQUNBLENBQUUsS0FBSSxDQUFDaHFCLEtBQUssQ0FBQ3FJLFNBQVMsSUFBSSxJQUFJLENBQUNHLFdBQVcsQ0FBQ0MsZ0JBQWdCLENBQUN6TSxFQUFFLENBQUMsSUFBSSxDQUFDM0YsaUJBQWlCLE9BQ2pGOFQsbUJBQW1CLElBQUksSUFBSTtnQkFDL0JoQyxlQUFlLElBQUksRUFBRTZoQjtZQUN6QixPQUNLO2dCQUNENWhCLGtCQUFrQixJQUFJLEVBQUVwVixNQUFNbUMsU0FBUztnQkFDdkMsSUFBSSxDQUFDcVQsV0FBVyxDQUFDRyxlQUFlO1lBQ3BDO1lBQ0EsSUFBSSxDQUFDSCxXQUFXLENBQUN6UyxLQUFLO1FBQzFCO1FBQ0EsSUFBSSxDQUFDbXpCLGlCQUFpQixDQUFDcDJCO1FBQ3ZCLElBQUksQ0FBQyxDQUFDeTJCLEtBQUssSUFBSSxDQUFDaE8sUUFBUSxNQUFNLFFBQVFnTyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc5akMsSUFBSSxLQUFLLENBQUNxTixLQUFLMUosR0FBRyxDQUFDNFMsRUFBRSxDQUFDaEosTUFBTTVKLEdBQUcsR0FDN0YsSUFBSSxDQUFDK2dDLGlCQUFpQixDQUFDLElBQUksQ0FBQzVPLFFBQVEsRUFBRXpvQjtRQUMxQyxJQUFJODJCLFVBQVUsU0FBUztZQUNuQixJQUFJLENBQUM1aEMsR0FBRyxDQUFDcUcsU0FBUyxHQUFHO1FBQ3pCLE9BQ0ssSUFBSXU3QixVQUFVLGdCQUFnQjtZQUMvQixJQUFJLENBQUMvRixpQkFBaUI7UUFDMUIsT0FDSyxJQUFJaUcsY0FBYztZQUNuQnY2QixlQUFldTZCO1FBQ25CO0lBQ0o7SUFDQTs7SUFFQSxHQUNBakcsb0JBQW9CO1FBQ2hCLElBQUl0MkIsV0FBVyxJQUFJLENBQUM4SSxpQkFBaUIsR0FBRzdOLFNBQVM7UUFDakQsSUFBSSxDQUFDK0UsWUFBWSxDQUFDLElBQUksQ0FBQ3ZGLEdBQUcsQ0FBQ2tILFFBQVEsQ0FBQzNCLFNBQVN4SCxRQUFRLElBQUksSUFBSXdILFdBQVdBLFNBQVMzSCxVQUFVO2FBQ3RGLElBQUksSUFBSSxDQUFDNkgsUUFBUSxDQUFDLDJCQUEyQm9ILENBQUFBLElBQUtBLEVBQUUsSUFBSTthQUN4RCxJQUFJLElBQUksQ0FBQzdCLEtBQUssQ0FBQ21DLFNBQVMsWUFBWXBRLDREQUFhQSxFQUFFO1lBQ3BELElBQUl3TyxTQUFTLElBQUksQ0FBQzdCLE9BQU8sQ0FBQ2dGLFdBQVcsQ0FBQyxJQUFJLENBQUMxRCxLQUFLLENBQUNtQyxTQUFTLENBQUNoUCxJQUFJO1lBQy9ELElBQUlvTixPQUFPeE4sUUFBUSxJQUFJLEdBQ25Cc0gsbUJBQW1CLElBQUksRUFBRWtHLE9BQU92RyxxQkFBcUIsSUFBSU87UUFDakUsT0FDSztZQUNERixtQkFBbUIsSUFBSSxFQUFFLElBQUksQ0FBQ3lHLFdBQVcsQ0FBQyxJQUFJLENBQUNkLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQytFLElBQUksRUFBRSxJQUFJM007UUFDN0U7SUFDSjtJQUNBNjhCLHFCQUFxQjtRQUNqQixJQUFJOThCO1FBQ0osTUFBT0EsT0FBTyxJQUFJLENBQUNrN0IsV0FBVyxDQUFDdGtCLEdBQUcsR0FDOUIsSUFBSTVXLEtBQUtnTCxPQUFPLEVBQ1poTCxLQUFLZ0wsT0FBTztJQUN4QjtJQUNBNHdCLGtCQUFrQm1CLFNBQVMsRUFBRTtRQUN6QixJQUFJLENBQUNBLGFBQWFBLFVBQVUxQixPQUFPLElBQUksSUFBSSxDQUFDMzFCLEtBQUssQ0FBQzIxQixPQUFPLElBQUksSUFBSSxDQUFDRCxhQUFhLElBQUksSUFBSSxDQUFDSCxpQkFBaUIsRUFBRTtZQUN2RyxJQUFJLENBQUNBLGlCQUFpQixHQUFHLElBQUksQ0FBQ0csYUFBYTtZQUMzQyxJQUFJLENBQUMwQixrQkFBa0I7WUFDdkIsSUFBSyxJQUFJejZCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUMrNEIsYUFBYSxDQUFDaGlDLE1BQU0sRUFBRWlKLElBQUs7Z0JBQ2hELElBQUkyNkIsU0FBUyxJQUFJLENBQUM1QixhQUFhLENBQUMvNEIsRUFBRTtnQkFDbEMsSUFBSTI2QixPQUFPN3VCLElBQUksQ0FBQ25PLElBQUksRUFDaEIsSUFBSSxDQUFDazdCLFdBQVcsQ0FBQ2w1QixJQUFJLENBQUNnN0IsT0FBTzd1QixJQUFJLENBQUNuTyxJQUFJLENBQUMsSUFBSTtZQUNuRDtZQUNBLElBQUssSUFBSXFDLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNxRCxLQUFLLENBQUMyMUIsT0FBTyxDQUFDamlDLE1BQU0sRUFBRWlKLElBQUs7Z0JBQ2hELElBQUkyNkIsU0FBUyxJQUFJLENBQUN0M0IsS0FBSyxDQUFDMjFCLE9BQU8sQ0FBQ2g1QixFQUFFO2dCQUNsQyxJQUFJMjZCLE9BQU83dUIsSUFBSSxDQUFDbk8sSUFBSSxFQUNoQixJQUFJLENBQUNrN0IsV0FBVyxDQUFDbDVCLElBQUksQ0FBQ2c3QixPQUFPN3VCLElBQUksQ0FBQ25PLElBQUksQ0FBQyxJQUFJO1lBQ25EO1FBQ0osT0FDSztZQUNELElBQUssSUFBSXFDLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM2NEIsV0FBVyxDQUFDOWhDLE1BQU0sRUFBRWlKLElBQUs7Z0JBQzlDLElBQUk0NkIsYUFBYSxJQUFJLENBQUMvQixXQUFXLENBQUM3NEIsRUFBRTtnQkFDcEMsSUFBSTQ2QixXQUFXaHFCLE1BQU0sRUFDakJncUIsV0FBV2hxQixNQUFNLENBQUMsSUFBSSxFQUFFOHBCO1lBQ2hDO1FBQ0o7SUFDSjtJQUNBRixrQkFBa0I1TyxRQUFRLEVBQUV6b0IsSUFBSSxFQUFFO1FBQzlCLElBQUlvQyxNQUFNcW1CLFNBQVM5MUIsSUFBSSxFQUFFMGUsUUFBUSxDQUFDO1FBQ2xDLElBQUksSUFBSSxDQUFDblIsS0FBSyxDQUFDNUosR0FBRyxDQUFDaXVCLE1BQU0sQ0FBQ25pQixJQUFJL08sSUFBSSxLQUFLK08sSUFBSXpQLElBQUksRUFBRTtZQUM3QzBlLFFBQVFqUCxJQUFJL08sSUFBSTtRQUNwQixPQUNLO1lBQ0QsSUFBSXFrQyxXQUFXdDFCLElBQUkvTyxJQUFJLEdBQUksS0FBSSxDQUFDNk0sS0FBSyxDQUFDNUosR0FBRyxDQUFDNkosT0FBTyxDQUFDQyxJQUFJLEdBQUdKLEtBQUsxSixHQUFHLENBQUM2SixPQUFPLENBQUNDLElBQUk7WUFDOUUsSUFBSW10QixRQUFRbUssV0FBVyxLQUFLLElBQUksQ0FBQ3gzQixLQUFLLENBQUM1SixHQUFHLENBQUNpdUIsTUFBTSxDQUFDbVQ7WUFDbEQsSUFBSW5LLFNBQVNuckIsSUFBSXpQLElBQUksRUFDakIwZSxRQUFRcW1CO1FBQ2hCO1FBQ0EsSUFBSSxDQUFDalAsUUFBUSxHQUFHLElBQUlULFNBQVNTLFNBQVNyZSxLQUFLLEVBQUVxZSxTQUFTNUQsSUFBSSxFQUFFeFQsUUFBUSxJQUFJalUsWUFBWW5MLDREQUFhQSxDQUFDMFgsTUFBTSxDQUFDLElBQUksQ0FBQ3pKLEtBQUssQ0FBQzVKLEdBQUcsRUFBRSthO0lBQzdIO0lBQ0ExVyxTQUFTcW9CLFFBQVEsRUFBRWpoQixDQUFDLEVBQUU7UUFDbEIsSUFBSXdPLE9BQU8sSUFBSSxDQUFDb2xCLE1BQU0sSUFBSSxJQUFJLENBQUNBLE1BQU0sQ0FBQzNTLFNBQVMsRUFBRWxwQjtRQUNqRCxJQUFJeVcsUUFBUSxRQUFTelcsQ0FBQUEsUUFBUWlJLElBQUlBLEVBQUV3TyxRQUFRQSxJQUFHLEdBQzFDLE9BQU96VztRQUNYLElBQUssSUFBSStDLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUMrNEIsYUFBYSxDQUFDaGlDLE1BQU0sRUFBRWlKLElBQUs7WUFDaEQsSUFBSTBULE9BQU8sSUFBSSxDQUFDcWxCLGFBQWEsQ0FBQy80QixFQUFFLENBQUN5NEIsS0FBSyxDQUFDdFMsU0FBUztZQUNoRCxJQUFJelMsUUFBUSxRQUFTelcsQ0FBQUEsUUFBUWlJLElBQUlBLEVBQUV3TyxRQUFRQSxJQUFHLEdBQzFDLE9BQU96VztRQUNmO1FBQ0EsSUFBSSs3QixVQUFVLElBQUksQ0FBQzMxQixLQUFLLENBQUMyMUIsT0FBTztRQUNoQyxJQUFJQSxTQUNBLElBQUssSUFBSWg1QixJQUFJLEdBQUdBLElBQUlnNUIsUUFBUWppQyxNQUFNLEVBQUVpSixJQUFLO1lBQ3JDLElBQUkwVCxPQUFPc2xCLE9BQU8sQ0FBQ2g1QixFQUFFLENBQUN5NEIsS0FBSyxDQUFDdFMsU0FBUztZQUNyQyxJQUFJelMsUUFBUSxRQUFTelcsQ0FBQUEsUUFBUWlJLElBQUlBLEVBQUV3TyxRQUFRQSxJQUFHLEdBQzFDLE9BQU96VztRQUNmO0lBQ1I7SUFDQTs7SUFFQSxHQUNBcWIsV0FBVztRQUNQLDJFQUEyRTtRQUMzRSx3RUFBd0U7UUFDeEUsNENBQTRDO1FBQzVDLElBQUlyZCxJQUFJO1lBQ0osdUVBQXVFO1lBQ3ZFLHNFQUFzRTtZQUN0RSxJQUFJbkYsT0FBTyxJQUFJLENBQUN1SixJQUFJLENBQUMxRixhQUFhO1lBQ2xDLElBQUk3RCxRQUFRLElBQUksQ0FBQ3VDLEdBQUcsRUFDaEIsT0FBTztZQUNYLElBQUksQ0FBQ3ZDLFFBQVEsQ0FBQyxJQUFJLENBQUN1QyxHQUFHLENBQUNrSCxRQUFRLENBQUN6SixPQUM1QixPQUFPO1lBQ1gsTUFBT0EsUUFBUSxJQUFJLENBQUN1QyxHQUFHLElBQUl2QyxRQUFRLElBQUksQ0FBQ3VDLEdBQUcsQ0FBQ2tILFFBQVEsQ0FBQ3pKLE1BQU87Z0JBQ3hELElBQUlBLEtBQUsrQixlQUFlLElBQUksU0FDeEIsT0FBTztnQkFDWC9CLE9BQU9BLEtBQUtnbEMsYUFBYTtZQUM3QjtZQUNBLE9BQU87UUFDWDtRQUNBLE9BQU8sSUFBSSxDQUFDejdCLElBQUksQ0FBQzFGLGFBQWEsSUFBSSxJQUFJLENBQUN0QixHQUFHO0lBQzlDO0lBQ0E7O0lBRUEsR0FDQStILFFBQVE7UUFDSixJQUFJLENBQUN5WSxXQUFXLENBQUN0TSxJQUFJO1FBQ3JCLElBQUksSUFBSSxDQUFDOEwsUUFBUSxFQUNiblksbUJBQW1CLElBQUksQ0FBQzdILEdBQUc7UUFDL0JtZ0IsZUFBZSxJQUFJO1FBQ25CLElBQUksQ0FBQ0ssV0FBVyxDQUFDelMsS0FBSztJQUMxQjtJQUNBOzs7OztJQUtBLEdBQ0EsSUFBSS9HLE9BQU87UUFDUCxJQUFJMDdCLFNBQVMsSUFBSSxDQUFDckMsS0FBSztRQUN2QixJQUFJcUMsVUFBVSxNQUNWLElBQUssSUFBSTd4QixTQUFTLElBQUksQ0FBQzdRLEdBQUcsQ0FBQ3BDLFVBQVUsRUFBRWlULFFBQVFBLFNBQVNBLE9BQU9qVCxVQUFVLENBQUU7WUFDdkUsSUFBSWlULE9BQU85UyxRQUFRLElBQUksS0FBTThTLE9BQU85UyxRQUFRLElBQUksTUFBTThTLE9BQU83UyxJQUFJLEVBQUc7Z0JBQ2hFLElBQUksQ0FBQzZTLE9BQU95QixZQUFZLEVBQ3BCNEgsT0FBT3lvQixjQUFjLENBQUM5eEIsUUFBUXlCLFlBQVksR0FBRyxJQUFNekIsT0FBT2xMLGFBQWEsQ0FBQzJNLFlBQVk7Z0JBQ3hGLE9BQU8sSUFBSSxDQUFDK3RCLEtBQUssR0FBR3h2QjtZQUN4QjtRQUNKO1FBQ0osT0FBTzZ4QixVQUFVcGtDO0lBQ3JCO0lBQ0E7OztJQUdBLEdBQ0Fza0MsYUFBYTtRQUNULElBQUksQ0FBQ3ZDLEtBQUssR0FBRztJQUNqQjtJQUNBOzs7Ozs7OztJQVFBLEdBQ0E1MUIsWUFBWXJDLE1BQU0sRUFBRTtRQUNoQixPQUFPcUMsWUFBWSxJQUFJLEVBQUVyQztJQUM3QjtJQUNBOzs7Ozs7O0lBT0EsR0FDQTBELFlBQVlsSyxHQUFHLEVBQUVpRCxPQUFPLENBQUMsRUFBRTtRQUN2QixPQUFPaUgsWUFBWSxJQUFJLEVBQUVsSyxLQUFLaUQ7SUFDbEM7SUFDQTs7Ozs7Ozs7O0lBU0EsR0FDQTIzQixTQUFTNTZCLEdBQUcsRUFBRWlELE9BQU8sQ0FBQyxFQUFFO1FBQ3BCLE9BQU8sSUFBSSxDQUFDNkUsT0FBTyxDQUFDc0MsVUFBVSxDQUFDcEssS0FBS2lEO0lBQ3hDO0lBQ0E7Ozs7Ozs7OztJQVNBLEdBQ0FtTSxRQUFRcFAsR0FBRyxFQUFFO1FBQ1QsSUFBSTNCLE9BQU8sSUFBSSxDQUFDeUosT0FBTyxDQUFDd0gsTUFBTSxDQUFDdFA7UUFDL0IsT0FBTzNCLE9BQU9BLEtBQUsrUSxPQUFPLEdBQUc7SUFDakM7SUFDQTs7Ozs7Ozs7O0lBU0EsR0FDQTZ4QixTQUFTcGxDLElBQUksRUFBRWtDLE1BQU0sRUFBRThKLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFDOUIsSUFBSTdILE1BQU0sSUFBSSxDQUFDOEgsT0FBTyxDQUFDQyxVQUFVLENBQUNsTSxNQUFNa0MsUUFBUThKO1FBQ2hELElBQUk3SCxPQUFPLE1BQ1AsTUFBTSxJQUFJbVEsV0FBVztRQUN6QixPQUFPblE7SUFDWDtJQUNBOzs7Ozs7O0lBT0EsR0FDQXVOLGVBQWVoUSxHQUFHLEVBQUU2TCxLQUFLLEVBQUU7UUFDdkIsT0FBT21FLGVBQWUsSUFBSSxFQUFFbkUsU0FBUyxJQUFJLENBQUNBLEtBQUssRUFBRTdMO0lBQ3JEO0lBQ0E7Ozs7SUFJQSxHQUNBMmpDLFVBQVU1YyxJQUFJLEVBQUVubEIsS0FBSyxFQUFFO1FBQ25CLE9BQU9zeEIsUUFBUSxJQUFJLEVBQUUsSUFBSW5NLE1BQU0sT0FBT25sQixTQUFTLElBQUlnaUMsZUFBZTtJQUN0RTtJQUNBOztJQUVBLEdBQ0FDLFVBQVUxdkIsSUFBSSxFQUFFdlMsS0FBSyxFQUFFO1FBQ25CLE9BQU9zeEIsUUFBUSxJQUFJLEVBQUUvZSxNQUFNLE1BQU0sTUFBTXZTLFNBQVMsSUFBSWdpQyxlQUFlO0lBQ3ZFO0lBQ0E7Ozs7Ozs7SUFPQSxHQUNBN2Qsc0JBQXNCaFEsS0FBSyxFQUFFO1FBQ3pCLE9BQU9nUSxzQkFBc0IsSUFBSSxFQUFFaFE7SUFDdkM7SUFDQTs7O0lBR0EsR0FDQTVFLFVBQVU7UUFDTixJQUFJLENBQUMsSUFBSSxDQUFDNUcsT0FBTyxFQUNiO1FBQ0o0aUIsYUFBYSxJQUFJO1FBQ2pCLElBQUksQ0FBQzhWLGtCQUFrQjtRQUN2QixJQUFJLElBQUksQ0FBQzlCLE9BQU8sRUFBRTtZQUNkLElBQUksQ0FBQzUyQixPQUFPLENBQUM2TyxNQUFNLENBQUMsSUFBSSxDQUFDdk4sS0FBSyxDQUFDNUosR0FBRyxFQUFFLEVBQUUsRUFBRW80QixnQkFBZ0IsSUFBSSxHQUFHLElBQUk7WUFDbkUsSUFBSSxDQUFDeDVCLEdBQUcsQ0FBQ2lPLFdBQVcsR0FBRztRQUMzQixPQUNLLElBQUksSUFBSSxDQUFDak8sR0FBRyxDQUFDcEMsVUFBVSxFQUFFO1lBQzFCLElBQUksQ0FBQ29DLEdBQUcsQ0FBQ3BDLFVBQVUsQ0FBQ3lhLFdBQVcsQ0FBQyxJQUFJLENBQUNyWSxHQUFHO1FBQzVDO1FBQ0EsSUFBSSxDQUFDMEosT0FBTyxDQUFDNEcsT0FBTztRQUNwQixJQUFJLENBQUM1RyxPQUFPLEdBQUc7UUFDZjlLO0lBQ0o7SUFDQTs7OztJQUlBLEdBQ0EsSUFBSXFrQyxjQUFjO1FBQ2QsT0FBTyxJQUFJLENBQUN2NUIsT0FBTyxJQUFJO0lBQzNCO0lBQ0E7O0lBRUEsR0FDQWlqQixjQUFjNXJCLEtBQUssRUFBRTtRQUNqQixPQUFPNHJCLGNBQWMsSUFBSSxFQUFFNXJCO0lBQy9CO0lBQ0E7Ozs7Ozs7O0lBUUEsR0FDQTBoQixTQUFTQyxFQUFFLEVBQUU7UUFDVCxJQUFJd2dCLHNCQUFzQixJQUFJLENBQUN6QyxNQUFNLENBQUN5QyxtQkFBbUI7UUFDekQsSUFBSUEscUJBQ0FBLG9CQUFvQnQzQixJQUFJLENBQUMsSUFBSSxFQUFFOFc7YUFFL0IsSUFBSSxDQUFDMVYsV0FBVyxDQUFDLElBQUksQ0FBQ2hDLEtBQUssQ0FBQ3dYLEtBQUssQ0FBQ0U7SUFDMUM7SUFDQTs7SUFFQSxHQUNBclUsb0JBQW9CO1FBQ2hCLElBQUluQixNQUFNLElBQUksQ0FBQ1ksWUFBWTtRQUMzQixJQUFJLENBQUNaLEtBQ0QsT0FBTztZQUFFMU0sV0FBVztZQUFNQyxhQUFhO1lBQUdDLFlBQVk7WUFBTUMsY0FBYztRQUFFO1FBQ2hGLE9BQU93QyxVQUFVLElBQUksQ0FBQzZELElBQUksQ0FBQ2pKLFFBQVEsS0FBSyxNQUNwQ29ELGtCQUFrQixJQUFJLENBQUNuQixHQUFHLENBQUMyRixhQUFhLEtBQUssSUFBSSxDQUFDM0YsR0FBRyxJQUFJeThCLDJCQUEyQixJQUFJLEVBQUV2dkIsUUFBUUE7SUFDMUc7SUFDQTs7SUFFQSxHQUNBWSxlQUFlO1FBQ1gsT0FBTyxJQUFJLENBQUM5RyxJQUFJLENBQUNzTCxZQUFZO0lBQ2pDO0FBQ0o7QUFDQSxTQUFTMnVCLGVBQWUzN0IsSUFBSTtJQUN4QixJQUFJeVAsUUFBUW1GLE9BQU96RixNQUFNLENBQUM7SUFDMUJNLE1BQU11RixLQUFLLEdBQUc7SUFDZHZGLE1BQU1vdUIsZUFBZSxHQUFHL1YsT0FBTzluQixLQUFLMGEsUUFBUTtJQUM1QzFhLEtBQUtHLFFBQVEsQ0FBQyxjQUFjYixDQUFBQTtRQUN4QixJQUFJLE9BQU9BLFNBQVMsWUFDaEJBLFFBQVFBLE1BQU1VLEtBQUswRixLQUFLO1FBQzVCLElBQUlwRyxPQUNBLElBQUssSUFBSXcrQixRQUFReCtCLE1BQU87WUFDcEIsSUFBSXcrQixRQUFRLFNBQ1JydUIsTUFBTXVGLEtBQUssSUFBSSxNQUFNMVYsS0FBSyxDQUFDdytCLEtBQUs7aUJBQy9CLElBQUlBLFFBQVEsU0FDYnJ1QixNQUFNbFIsS0FBSyxHQUFHLENBQUNrUixNQUFNbFIsS0FBSyxHQUFHa1IsTUFBTWxSLEtBQUssR0FBRyxNQUFNLEVBQUMsSUFBS2UsS0FBSyxDQUFDdytCLEtBQUs7aUJBQ2pFLElBQUksQ0FBQ3J1QixLQUFLLENBQUNxdUIsS0FBSyxJQUFJQSxRQUFRLHFCQUFxQkEsUUFBUSxZQUMxRHJ1QixLQUFLLENBQUNxdUIsS0FBSyxHQUFHaFcsT0FBT3hvQixLQUFLLENBQUN3K0IsS0FBSztRQUN4QztJQUNSO0lBQ0EsSUFBSSxDQUFDcnVCLE1BQU1zdUIsU0FBUyxFQUNoQnR1QixNQUFNc3VCLFNBQVMsR0FBRztJQUN0QixPQUFPO1FBQUMvTixXQUFXNzNCLElBQUksQ0FBQyxHQUFHNkgsS0FBSzBGLEtBQUssQ0FBQzVKLEdBQUcsQ0FBQzZKLE9BQU8sQ0FBQ0MsSUFBSSxFQUFFNko7S0FBTztBQUNuRTtBQUNBLFNBQVNnc0Isb0JBQW9CejdCLElBQUk7SUFDN0IsSUFBSUEsS0FBS2lyQixVQUFVLEVBQUU7UUFDakIsSUFBSXZ3QixNQUFNMUIsU0FBU3NWLGFBQWEsQ0FBQztRQUNqQzVULElBQUlxZCxTQUFTLEdBQUc7UUFDaEJyZCxJQUFJOGEsWUFBWSxDQUFDLG9CQUFvQjtRQUNyQzlhLElBQUk4YSxZQUFZLENBQUMsT0FBTztRQUN4QnhWLEtBQUt1YixhQUFhLEdBQUc7WUFBRTdnQjtZQUFLMmEsTUFBTTJhLFdBQVd6bEIsTUFBTSxDQUFDdkssS0FBSzBGLEtBQUssQ0FBQ21DLFNBQVMsQ0FBQ2hQLElBQUksRUFBRTZCLEtBQUs7Z0JBQUUwVCxLQUFLO2dCQUFNb0QsT0FBT3hSLEtBQUtpckIsVUFBVTtZQUFDO1FBQUc7SUFDL0gsT0FDSztRQUNEanJCLEtBQUt1YixhQUFhLEdBQUc7SUFDekI7QUFDSjtBQUNBLFNBQVNpZ0IsWUFBWXg3QixJQUFJO0lBQ3JCLE9BQU8sQ0FBQ0EsS0FBS0csUUFBUSxDQUFDLFlBQVliLENBQUFBLFFBQVNBLE1BQU1VLEtBQUswRixLQUFLLE1BQU07QUFDckU7QUFDQSxTQUFTaTNCLHdCQUF3QnFCLElBQUksRUFBRUMsSUFBSTtJQUN2QyxJQUFJOTBCLFFBQVEzTSxLQUFLQyxHQUFHLENBQUN1aEMsS0FBS3pqQixPQUFPLENBQUMyZCxXQUFXLENBQUM4RixLQUFLcHhCLElBQUksR0FBR3F4QixLQUFLMWpCLE9BQU8sQ0FBQzJkLFdBQVcsQ0FBQytGLEtBQUtyeEIsSUFBSTtJQUM1RixPQUFPb3hCLEtBQUt6akIsT0FBTyxDQUFDOVIsS0FBSyxDQUFDVSxVQUFVODBCLEtBQUsxakIsT0FBTyxDQUFDOVIsS0FBSyxDQUFDVTtBQUMzRDtBQUNBLFNBQVN1eUIsZUFBZTE3QixJQUFJO0lBQ3hCLElBQUl1SixTQUFTcUwsT0FBT3pGLE1BQU0sQ0FBQztJQUMzQixTQUFTVixJQUFJeXZCLEdBQUc7UUFDWixJQUFLLElBQUlub0IsUUFBUW1vQixJQUNiLElBQUksQ0FBQ3RwQixPQUFPeE8sU0FBUyxDQUFDKzNCLGNBQWMsQ0FBQzczQixJQUFJLENBQUNpRCxRQUFRd00sT0FDOUN4TSxNQUFNLENBQUN3TSxLQUFLLEdBQUdtb0IsR0FBRyxDQUFDbm9CLEtBQUs7SUFDcEM7SUFDQS9WLEtBQUtHLFFBQVEsQ0FBQyxhQUFhc087SUFDM0J6TyxLQUFLRyxRQUFRLENBQUMsYUFBYXNPO0lBQzNCLE9BQU9sRjtBQUNYO0FBQ0EsU0FBUzh5QixpQkFBaUJsbUIsQ0FBQyxFQUFFQyxDQUFDO0lBQzFCLElBQUlnb0IsS0FBSyxHQUFHQyxLQUFLO0lBQ2pCLElBQUssSUFBSXRvQixRQUFRSSxFQUFHO1FBQ2hCLElBQUlBLENBQUMsQ0FBQ0osS0FBSyxJQUFJSyxDQUFDLENBQUNMLEtBQUssRUFDbEIsT0FBTztRQUNYcW9CO0lBQ0o7SUFDQSxJQUFLLElBQUkxaEMsS0FBSzBaLEVBQ1Zpb0I7SUFDSixPQUFPRCxNQUFNQztBQUNqQjtBQUNBLFNBQVMvQyxvQkFBb0IwQixNQUFNO0lBQy9CLElBQUlBLE9BQU83dUIsSUFBSSxDQUFDekksS0FBSyxJQUFJczNCLE9BQU83dUIsSUFBSSxDQUFDbXdCLGlCQUFpQixJQUFJdEIsT0FBTzd1QixJQUFJLENBQUNvd0IsaUJBQWlCLEVBQ25GLE1BQU0sSUFBSTl4QixXQUFXO0FBQzdCO0FBRXlGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci12aWV3L2Rpc3QvaW5kZXguanM/NGUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24sIFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBTbGljZSwgRE9NUGFyc2VyIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgZHJvcFBvaW50IH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxuY29uc3QgZG9tSW5kZXggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufTtcbmNvbnN0IHBhcmVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGxldCBwYXJlbnQgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMTEgPyBwYXJlbnQuaG9zdCA6IHBhcmVudDtcbn07XG5sZXQgcmV1c2VkUmFuZ2UgPSBudWxsO1xuLy8gTm90ZSB0aGF0IHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIHJhbmdlLCBiZWNhdXNlIERPTSByYW5nZVxuLy8gb2JqZWN0cyBhcmUgZXZlcnkgZXhwZW5zaXZlLCBhbmQga2VlcCBzbG93aW5nIGRvd24gc3Vic2VxdWVudCBET01cbi8vIHVwZGF0ZXMsIGZvciBzb21lIHJlYXNvbi5cbmNvbnN0IHRleHRSYW5nZSA9IGZ1bmN0aW9uIChub2RlLCBmcm9tLCB0bykge1xuICAgIGxldCByYW5nZSA9IHJldXNlZFJhbmdlIHx8IChyZXVzZWRSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byA9PSBudWxsID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20gfHwgMCk7XG4gICAgcmV0dXJuIHJhbmdlO1xufTtcbmNvbnN0IGNsZWFyUmV1c2VkUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV1c2VkUmFuZ2UgPSBudWxsO1xufTtcbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbmNvbnN0IGlzRXF1aXZhbGVudFBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gICAgcmV0dXJuIHRhcmdldE5vZGUgJiYgKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxuICAgICAgICBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAxKSk7XG59O1xuY29uc3QgYXRvbUVsZW1lbnRzID0gL14oaW1nfGJyfGlucHV0fHRleHRhcmVhfGhyKSQvaTtcbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvZmYgPT0gKGRpciA8IDAgPyAwIDogbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEgfHwgaGFzQmxvY2tEZXNjKG5vZGUpIHx8IGF0b21FbGVtZW50cy50ZXN0KG5vZGUubm9kZU5hbWUpIHx8XG4gICAgICAgICAgICAgICAgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRvbUluZGV4KG5vZGUpICsgKGRpciA8IDAgPyAwIDogMSk7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkaXIgPCAwID8gbm9kZVNpemUobm9kZSkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbm9kZVNpemUobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gdGV4dE5vZGVCZWZvcmUkMShub2RlLCBvZmZzZXQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMgJiYgb2Zmc2V0KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBvZmZzZXQgPSBub2RlU2l6ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUFmdGVyJDEobm9kZSwgb2Zmc2V0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzICYmIG9mZnNldCA8IG5vZGUubm9kZVZhbHVlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKSArIDE7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc09uRWRnZShub2RlLCBvZmZzZXQsIHBhcmVudCkge1xuICAgIGZvciAobGV0IGF0U3RhcnQgPSBvZmZzZXQgPT0gMCwgYXRFbmQgPSBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSk7IGF0U3RhcnQgfHwgYXRFbmQ7KSB7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgaW5kZXggPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBhdFN0YXJ0ID0gYXRTdGFydCAmJiBpbmRleCA9PSAwO1xuICAgICAgICBhdEVuZCA9IGF0RW5kICYmIGluZGV4ID09IG5vZGVTaXplKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0Jsb2NrRGVzYyhkb20pIHtcbiAgICBsZXQgZGVzYztcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpXG4gICAgICAgIGlmIChkZXNjID0gY3VyLnBtVmlld0Rlc2MpXG4gICAgICAgICAgICBicmVhaztcbiAgICByZXR1cm4gZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2sgJiYgKGRlc2MuZG9tID09IGRvbSB8fCBkZXNjLmNvbnRlbnRET00gPT0gZG9tKTtcbn1cbi8vIFdvcmsgYXJvdW5kIENocm9tZSBpc3N1ZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDc1MjNcbi8vIChpc0NvbGxhcHNlZCBpbmFwcHJvcHJpYXRlbHkgcmV0dXJucyB0cnVlIGluIHNoYWRvdyBkb20pXG5jb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBmdW5jdGlvbiAoZG9tU2VsKSB7XG4gICAgcmV0dXJuIGRvbVNlbC5mb2N1c05vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG59O1xuZnVuY3Rpb24ga2V5RXZlbnQoa2V5Q29kZSwga2V5KSB7XG4gICAgbGV0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBldmVudC5pbml0RXZlbnQoXCJrZXlkb3duXCIsIHRydWUsIHRydWUpO1xuICAgIGV2ZW50LmtleUNvZGUgPSBrZXlDb2RlO1xuICAgIGV2ZW50LmtleSA9IGV2ZW50LmNvZGUgPSBrZXk7XG4gICAgcmV0dXJuIGV2ZW50O1xufVxuZnVuY3Rpb24gZGVlcEFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gICAgbGV0IGVsdCA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgIHdoaWxlIChlbHQgJiYgZWx0LnNoYWRvd1Jvb3QpXG4gICAgICAgIGVsdCA9IGVsdC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbmZ1bmN0aW9uIGNhcmV0RnJvbVBvaW50KGRvYywgeCwgeSkge1xuICAgIGlmIChkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgICAgICB0cnkgeyAvLyBGaXJlZm94IHRocm93cyBmb3IgdGhpcyBjYWxsIGluIGhhcmQtdG8tcHJlZGljdCBjaXJjdW1zdGFuY2VzICgjOTk0KVxuICAgICAgICAgICAgbGV0IHBvcyA9IGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgLy8gQ2xpcCB0aGUgb2Zmc2V0LCBiZWNhdXNlIENocm9tZSB3aWxsIHJldHVybiBhIHRleHQgb2Zmc2V0XG4gICAgICAgICAgICAvLyBpbnRvIDxpbnB1dD4gbm9kZXMsIHdoaWNoIGNhbid0IGJlIHRyZWF0ZWQgYXMgYSByZWd1bGFyIERPTVxuICAgICAgICAgICAgLy8gb2Zmc2V0XG4gICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHBvcy5vZmZzZXROb2RlLCBvZmZzZXQ6IE1hdGgubWluKG5vZGVTaXplKHBvcy5vZmZzZXROb2RlKSwgcG9zLm9mZnNldCkgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgfVxuICAgIGlmIChkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogcmFuZ2Uuc3RhcnRDb250YWluZXIsIG9mZnNldDogTWF0aC5taW4obm9kZVNpemUocmFuZ2Uuc3RhcnRDb250YWluZXIpLCByYW5nZS5zdGFydE9mZnNldCkgfTtcbiAgICB9XG59XG5cbmNvbnN0IG5hdiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvciA6IG51bGw7XG5jb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogbnVsbDtcbmNvbnN0IGFnZW50ID0gKG5hdiAmJiBuYXYudXNlckFnZW50KSB8fCBcIlwiO1xuY29uc3QgaWVfZWRnZSA9IC9FZGdlXFwvKFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGllX3VwdG8xMCA9IC9NU0lFIFxcZC8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZV8xMXVwID0gL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGllID0gISEoaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgaWVfZWRnZSk7XG5jb25zdCBpZV92ZXJzaW9uID0gaWVfdXB0bzEwID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogMDtcbmNvbnN0IGdlY2tvID0gIWllICYmIC9nZWNrb1xcLyhcXGQrKS9pLnRlc3QoYWdlbnQpO1xuZ2Vja28gJiYgKygvRmlyZWZveFxcLyhcXGQrKS8uZXhlYyhhZ2VudCkgfHwgWzAsIDBdKVsxXTtcbmNvbnN0IF9jaHJvbWUgPSAhaWUgJiYgL0Nocm9tZVxcLyhcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBjaHJvbWUgPSAhIV9jaHJvbWU7XG5jb25zdCBjaHJvbWVfdmVyc2lvbiA9IF9jaHJvbWUgPyArX2Nocm9tZVsxXSA6IDA7XG5jb25zdCBzYWZhcmkgPSAhaWUgJiYgISFuYXYgJiYgL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdi52ZW5kb3IpO1xuLy8gSXMgdHJ1ZSBmb3IgYm90aCBpT1MgYW5kIGlQYWRPUyBmb3IgY29udmVuaWVuY2VcbmNvbnN0IGlvcyA9IHNhZmFyaSAmJiAoL01vYmlsZVxcL1xcdysvLnRlc3QoYWdlbnQpIHx8ICEhbmF2ICYmIG5hdi5tYXhUb3VjaFBvaW50cyA+IDIpO1xuY29uc3QgbWFjID0gaW9zIHx8IChuYXYgPyAvTWFjLy50ZXN0KG5hdi5wbGF0Zm9ybSkgOiBmYWxzZSk7XG5jb25zdCB3aW5kb3dzID0gbmF2ID8gL1dpbi8udGVzdChuYXYucGxhdGZvcm0pIDogZmFsc2U7XG5jb25zdCBhbmRyb2lkID0gL0FuZHJvaWQgXFxkLy50ZXN0KGFnZW50KTtcbmNvbnN0IHdlYmtpdCA9ICEhZG9jICYmIFwid2Via2l0Rm9udFNtb290aGluZ1wiIGluIGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5jb25zdCB3ZWJraXRfdmVyc2lvbiA9IHdlYmtpdCA/ICsoL1xcYkFwcGxlV2ViS2l0XFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwO1xuXG5mdW5jdGlvbiB3aW5kb3dSZWN0KGRvYykge1xuICAgIGxldCB2cCA9IGRvYy5kZWZhdWx0VmlldyAmJiBkb2MuZGVmYXVsdFZpZXcudmlzdWFsVmlld3BvcnQ7XG4gICAgaWYgKHZwKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogMCwgcmlnaHQ6IHZwLndpZHRoLFxuICAgICAgICAgICAgdG9wOiAwLCBib3R0b206IHZwLmhlaWdodFxuICAgICAgICB9O1xuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICB0b3A6IDAsIGJvdHRvbTogZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIGdldFNpZGUodmFsdWUsIHNpZGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyB2YWx1ZSA6IHZhbHVlW3NpZGVdO1xufVxuZnVuY3Rpb24gY2xpZW50UmVjdChub2RlKSB7XG4gICAgbGV0IHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEFkanVzdCBmb3IgZWxlbWVudHMgd2l0aCBzdHlsZSBcInRyYW5zZm9ybTogc2NhbGUoKVwiXG4gICAgbGV0IHNjYWxlWCA9IChyZWN0LndpZHRoIC8gbm9kZS5vZmZzZXRXaWR0aCkgfHwgMTtcbiAgICBsZXQgc2NhbGVZID0gKHJlY3QuaGVpZ2h0IC8gbm9kZS5vZmZzZXRIZWlnaHQpIHx8IDE7XG4gICAgLy8gTWFrZSBzdXJlIHNjcm9sbGJhciB3aWR0aCBpc24ndCBpbmNsdWRlZCBpbiB0aGUgcmVjdGFuZ2xlXG4gICAgcmV0dXJuIHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5sZWZ0ICsgbm9kZS5jbGllbnRXaWR0aCAqIHNjYWxlWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIG5vZGUuY2xpZW50SGVpZ2h0ICogc2NhbGVZIH07XG59XG5mdW5jdGlvbiBzY3JvbGxSZWN0SW50b1ZpZXcodmlldywgcmVjdCwgc3RhcnRET00pIHtcbiAgICBsZXQgc2Nyb2xsVGhyZXNob2xkID0gdmlldy5zb21lUHJvcChcInNjcm9sbFRocmVzaG9sZFwiKSB8fCAwLCBzY3JvbGxNYXJnaW4gPSB2aWV3LnNvbWVQcm9wKFwic2Nyb2xsTWFyZ2luXCIpIHx8IDU7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZm9yIChsZXQgcGFyZW50ID0gc3RhcnRET00gfHwgdmlldy5kb207Oykge1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudE5vZGUocGFyZW50KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbHQgPSBwYXJlbnQ7XG4gICAgICAgIGxldCBhdFRvcCA9IGVsdCA9PSBkb2MuYm9keTtcbiAgICAgICAgbGV0IGJvdW5kaW5nID0gYXRUb3AgPyB3aW5kb3dSZWN0KGRvYykgOiBjbGllbnRSZWN0KGVsdCk7XG4gICAgICAgIGxldCBtb3ZlWCA9IDAsIG1vdmVZID0gMDtcbiAgICAgICAgaWYgKHJlY3QudG9wIDwgYm91bmRpbmcudG9wICsgZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwidG9wXCIpKVxuICAgICAgICAgICAgbW92ZVkgPSAtKGJvdW5kaW5nLnRvcCAtIHJlY3QudG9wICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwidG9wXCIpKTtcbiAgICAgICAgZWxzZSBpZiAocmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gLSBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJib3R0b21cIikpXG4gICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3AgPiBib3VuZGluZy5ib3R0b20gLSBib3VuZGluZy50b3BcbiAgICAgICAgICAgICAgICA/IHJlY3QudG9wICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwidG9wXCIpIC0gYm91bmRpbmcudG9wXG4gICAgICAgICAgICAgICAgOiByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcImJvdHRvbVwiKTtcbiAgICAgICAgaWYgKHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQgKyBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJsZWZ0XCIpKVxuICAgICAgICAgICAgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgLSByZWN0LmxlZnQgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJsZWZ0XCIpKTtcbiAgICAgICAgZWxzZSBpZiAocmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0IC0gZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwicmlnaHRcIikpXG4gICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInJpZ2h0XCIpO1xuICAgICAgICBpZiAobW92ZVggfHwgbW92ZVkpIHtcbiAgICAgICAgICAgIGlmIChhdFRvcCkge1xuICAgICAgICAgICAgICAgIGRvYy5kZWZhdWx0Vmlldy5zY3JvbGxCeShtb3ZlWCwgbW92ZVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0WCA9IGVsdC5zY3JvbGxMZWZ0LCBzdGFydFkgPSBlbHQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlWSlcbiAgICAgICAgICAgICAgICAgICAgZWx0LnNjcm9sbFRvcCArPSBtb3ZlWTtcbiAgICAgICAgICAgICAgICBpZiAobW92ZVgpXG4gICAgICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxMZWZ0ICs9IG1vdmVYO1xuICAgICAgICAgICAgICAgIGxldCBkWCA9IGVsdC5zY3JvbGxMZWZ0IC0gc3RhcnRYLCBkWSA9IGVsdC5zY3JvbGxUb3AgLSBzdGFydFk7XG4gICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogcmVjdC5sZWZ0IC0gZFgsIHRvcDogcmVjdC50b3AgLSBkWSwgcmlnaHQ6IHJlY3QucmlnaHQgLSBkWCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIGRZIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvcyA9IGF0VG9wID8gXCJmaXhlZFwiIDogZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpLnBvc2l0aW9uO1xuICAgICAgICBpZiAoL14oZml4ZWR8c3RpY2t5KSQvLnRlc3QocG9zKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBwYXJlbnQgPSBwb3MgPT0gXCJhYnNvbHV0ZVwiID8gcGFyZW50Lm9mZnNldFBhcmVudCA6IHBhcmVudE5vZGUocGFyZW50KTtcbiAgICB9XG59XG4vLyBTdG9yZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBlZGl0b3IncyBwYXJlbnQgbm9kZXMsIGFsb25nIHdpdGhcbi8vIHRoZSB0b3AgcG9zaXRpb24gb2YgYW4gZWxlbWVudCBuZWFyIHRoZSB0b3Agb2YgdGhlIGVkaXRvciwgd2hpY2hcbi8vIHdpbGwgYmUgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHZpc2libGUgdmlld3BvcnQgcmVtYWlucyBzdGFibGUgZXZlblxuLy8gd2hlbiB0aGUgc2l6ZSBvZiB0aGUgY29udGVudCBhYm92ZSBjaGFuZ2VzLlxuZnVuY3Rpb24gc3RvcmVTY3JvbGxQb3Modmlldykge1xuICAgIGxldCByZWN0ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHN0YXJ0WSA9IE1hdGgubWF4KDAsIHJlY3QudG9wKTtcbiAgICBsZXQgcmVmRE9NLCByZWZUb3A7XG4gICAgZm9yIChsZXQgeCA9IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsIHkgPSBzdGFydFkgKyAxOyB5IDwgTWF0aC5taW4oaW5uZXJIZWlnaHQsIHJlY3QuYm90dG9tKTsgeSArPSA1KSB7XG4gICAgICAgIGxldCBkb20gPSB2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKCFkb20gfHwgZG9tID09IHZpZXcuZG9tIHx8ICF2aWV3LmRvbS5jb250YWlucyhkb20pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBsb2NhbFJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChsb2NhbFJlY3QudG9wID49IHN0YXJ0WSAtIDIwKSB7XG4gICAgICAgICAgICByZWZET00gPSBkb207XG4gICAgICAgICAgICByZWZUb3AgPSBsb2NhbFJlY3QudG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgcmVmRE9NOiByZWZET00sIHJlZlRvcDogcmVmVG9wLCBzdGFjazogc2Nyb2xsU3RhY2sodmlldy5kb20pIH07XG59XG5mdW5jdGlvbiBzY3JvbGxTdGFjayhkb20pIHtcbiAgICBsZXQgc3RhY2sgPSBbXSwgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7IGN1ciA9IHBhcmVudE5vZGUoY3VyKSkge1xuICAgICAgICBzdGFjay5wdXNoKHsgZG9tOiBjdXIsIHRvcDogY3VyLnNjcm9sbFRvcCwgbGVmdDogY3VyLnNjcm9sbExlZnQgfSk7XG4gICAgICAgIGlmIChkb20gPT0gZG9jKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbn1cbi8vIFJlc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGVkaXRvcidzIHBhcmVudCBub2RlcyB0byB0aGF0IHdoYXRcbi8vIGl0IHdhcyBiZWZvcmUsIHdoZW4gc3RvcmVTY3JvbGxQb3Mgd2FzIGNhbGxlZC5cbmZ1bmN0aW9uIHJlc2V0U2Nyb2xsUG9zKHsgcmVmRE9NLCByZWZUb3AsIHN0YWNrIH0pIHtcbiAgICBsZXQgbmV3UmVmVG9wID0gcmVmRE9NID8gcmVmRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IDA7XG4gICAgcmVzdG9yZVNjcm9sbFN0YWNrKHN0YWNrLCBuZXdSZWZUb3AgPT0gMCA/IDAgOiBuZXdSZWZUb3AgLSByZWZUb3ApO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcm9sbFN0YWNrKHN0YWNrLCBkVG9wKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyBkb20sIHRvcCwgbGVmdCB9ID0gc3RhY2tbaV07XG4gICAgICAgIGlmIChkb20uc2Nyb2xsVG9wICE9IHRvcCArIGRUb3ApXG4gICAgICAgICAgICBkb20uc2Nyb2xsVG9wID0gdG9wICsgZFRvcDtcbiAgICAgICAgaWYgKGRvbS5zY3JvbGxMZWZ0ICE9IGxlZnQpXG4gICAgICAgICAgICBkb20uc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgfVxufVxubGV0IHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xuLy8gRmVhdHVyZS1kZXRlY3RzIHN1cHBvcnQgZm9yIC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pLCBhbmQgdXNlc1xuLy8gYSBmYWxsYmFjayBrbHVkZ2Ugd2hlbiBub3Qgc3VwcG9ydGVkLlxuZnVuY3Rpb24gZm9jdXNQcmV2ZW50U2Nyb2xsKGRvbSkge1xuICAgIGlmIChkb20uc2V0QWN0aXZlKVxuICAgICAgICByZXR1cm4gZG9tLnNldEFjdGl2ZSgpOyAvLyBpbiBJRVxuICAgIGlmIChwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpO1xuICAgIGxldCBzdG9yZWQgPSBzY3JvbGxTdGFjayhkb20pO1xuICAgIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID09IG51bGwgPyB7XG4gICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsKCkge1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIXByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICByZXN0b3JlU2Nyb2xsU3RhY2soc3RvcmVkLCAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kT2Zmc2V0SW5Ob2RlKG5vZGUsIGNvb3Jkcykge1xuICAgIGxldCBjbG9zZXN0LCBkeENsb3Nlc3QgPSAyZTgsIGNvb3Jkc0Nsb3Nlc3QsIG9mZnNldCA9IDA7XG4gICAgbGV0IHJvd0JvdCA9IGNvb3Jkcy50b3AsIHJvd1RvcCA9IGNvb3Jkcy50b3A7XG4gICAgbGV0IGZpcnN0QmVsb3csIGNvb3Jkc0JlbG93O1xuICAgIGZvciAobGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkLCBjaGlsZEluZGV4ID0gMDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcsIGNoaWxkSW5kZXgrKykge1xuICAgICAgICBsZXQgcmVjdHM7XG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmVjdHMgPSB0ZXh0UmFuZ2UoY2hpbGQpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKHJlY3QudG9wIDw9IHJvd0JvdCAmJiByZWN0LmJvdHRvbSA+PSByb3dUb3ApIHtcbiAgICAgICAgICAgICAgICByb3dCb3QgPSBNYXRoLm1heChyZWN0LmJvdHRvbSwgcm93Qm90KTtcbiAgICAgICAgICAgICAgICByb3dUb3AgPSBNYXRoLm1pbihyZWN0LnRvcCwgcm93VG9wKTtcbiAgICAgICAgICAgICAgICBsZXQgZHggPSByZWN0LmxlZnQgPiBjb29yZHMubGVmdCA/IHJlY3QubGVmdCAtIGNvb3Jkcy5sZWZ0XG4gICAgICAgICAgICAgICAgICAgIDogcmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0ID8gY29vcmRzLmxlZnQgLSByZWN0LnJpZ2h0IDogMDtcbiAgICAgICAgICAgICAgICBpZiAoZHggPCBkeENsb3Nlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBkeENsb3Nlc3QgPSBkeDtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzQ2xvc2VzdCA9IGR4ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMyA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCA/IHJlY3QucmlnaHQgOiByZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGNvb3Jkcy50b3BcbiAgICAgICAgICAgICAgICAgICAgfSA6IGNvb3JkcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEgJiYgZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBjaGlsZEluZGV4ICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QudG9wID4gY29vcmRzLnRvcCAmJiAhZmlyc3RCZWxvdyAmJiByZWN0LmxlZnQgPD0gY29vcmRzLmxlZnQgJiYgcmVjdC5yaWdodCA+PSBjb29yZHMubGVmdCkge1xuICAgICAgICAgICAgICAgIGZpcnN0QmVsb3cgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBjb29yZHNCZWxvdyA9IHsgbGVmdDogTWF0aC5tYXgocmVjdC5sZWZ0LCBNYXRoLm1pbihyZWN0LnJpZ2h0LCBjb29yZHMubGVmdCkpLCB0b3A6IHJlY3QudG9wIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNsb3Nlc3QgJiYgKGNvb3Jkcy5sZWZ0ID49IHJlY3QucmlnaHQgJiYgY29vcmRzLnRvcCA+PSByZWN0LnRvcCB8fFxuICAgICAgICAgICAgICAgIGNvb3Jkcy5sZWZ0ID49IHJlY3QubGVmdCAmJiBjb29yZHMudG9wID49IHJlY3QuYm90dG9tKSlcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBjaGlsZEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNsb3Nlc3QgJiYgZmlyc3RCZWxvdykge1xuICAgICAgICBjbG9zZXN0ID0gZmlyc3RCZWxvdztcbiAgICAgICAgY29vcmRzQ2xvc2VzdCA9IGNvb3Jkc0JlbG93O1xuICAgICAgICBkeENsb3Nlc3QgPSAwO1xuICAgIH1cbiAgICBpZiAoY2xvc2VzdCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiBmaW5kT2Zmc2V0SW5UZXh0KGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpO1xuICAgIGlmICghY2xvc2VzdCB8fCAoZHhDbG9zZXN0ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMSkpXG4gICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldCB9O1xuICAgIHJldHVybiBmaW5kT2Zmc2V0SW5Ob2RlKGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpO1xufVxuZnVuY3Rpb24gZmluZE9mZnNldEluVGV4dChub2RlLCBjb29yZHMpIHtcbiAgICBsZXQgbGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgaSArIDEpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBpKTtcbiAgICAgICAgbGV0IHJlY3QgPSBzaW5nbGVSZWN0KHJhbmdlLCAxKTtcbiAgICAgICAgaWYgKHJlY3QudG9wID09IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChpblJlY3QoY29vcmRzLCByZWN0KSlcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogaSArIChjb29yZHMubGVmdCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IDApIH07XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogMCB9O1xufVxuZnVuY3Rpb24gaW5SZWN0KGNvb3JkcywgcmVjdCkge1xuICAgIHJldHVybiBjb29yZHMubGVmdCA+PSByZWN0LmxlZnQgLSAxICYmIGNvb3Jkcy5sZWZ0IDw9IHJlY3QucmlnaHQgKyAxICYmXG4gICAgICAgIGNvb3Jkcy50b3AgPj0gcmVjdC50b3AgLSAxICYmIGNvb3Jkcy50b3AgPD0gcmVjdC5ib3R0b20gKyAxO1xufVxuZnVuY3Rpb24gdGFyZ2V0S2x1ZGdlKGRvbSwgY29vcmRzKSB7XG4gICAgbGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQgJiYgL15saSQvaS50ZXN0KHBhcmVudC5ub2RlTmFtZSkgJiYgY29vcmRzLmxlZnQgPCBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdClcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICByZXR1cm4gZG9tO1xufVxuZnVuY3Rpb24gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IGZpbmRPZmZzZXRJbk5vZGUoZWx0LCBjb29yZHMpLCBiaWFzID0gLTE7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiAhbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIGxldCByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgYmlhcyA9IHJlY3QubGVmdCAhPSByZWN0LnJpZ2h0ICYmIGNvb3Jkcy5sZWZ0ID4gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcyk7XG59XG5mdW5jdGlvbiBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpIHtcbiAgICAvLyBCcm93c2VyIChpbiBjYXJldFBvc2l0aW9uL1JhbmdlRnJvbVBvaW50KSB3aWxsIGFncmVzc2l2ZWx5XG4gICAgLy8gbm9ybWFsaXplIHRvd2FyZHMgbmVhcmJ5IGlubGluZSBub2Rlcy4gU2luY2Ugd2UgYXJlIGludGVyZXN0ZWQgaW5cbiAgICAvLyBwb3NpdGlvbnMgYmV0d2VlbiBibG9jayBub2RlcyB0b28sIHdlIGZpcnN0IHdhbGsgdXAgdGhlIGhpZXJhcmNoeVxuICAgIC8vIG9mIG5vZGVzIHRvIHNlZSBpZiB0aGVyZSBhcmUgYmxvY2sgbm9kZXMgdGhhdCB0aGUgY29vcmRpbmF0ZXNcbiAgICAvLyBmYWxsIG91dHNpZGUgb2YuIElmIHNvLCB3ZSB0YWtlIHRoZSBwb3NpdGlvbiBiZWZvcmUvYWZ0ZXIgdGhhdFxuICAgIC8vIGJsb2NrLiBJZiBub3QsIHdlIGNhbGwgYHBvc0Zyb21ET01gIG9uIHRoZSByYXcgbm9kZS9vZmZzZXQuXG4gICAgbGV0IG91dHNpZGVCbG9jayA9IC0xO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGUsIHNhd0Jsb2NrID0gZmFsc2U7Oykge1xuICAgICAgICBpZiAoY3VyID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGN1ciwgdHJ1ZSksIHJlY3Q7XG4gICAgICAgIGlmICghZGVzYylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZGVzYy5kb20ubm9kZVR5cGUgPT0gMSAmJiAoZGVzYy5ub2RlLmlzQmxvY2sgJiYgZGVzYy5wYXJlbnQgfHwgIWRlc2MuY29udGVudERPTSkgJiZcbiAgICAgICAgICAgIC8vIElnbm9yZSBlbGVtZW50cyB3aXRoIHplcm8tc2l6ZSBib3VuZGluZyByZWN0YW5nbGVzXG4gICAgICAgICAgICAoKHJlY3QgPSBkZXNjLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkud2lkdGggfHwgcmVjdC5oZWlnaHQpKSB7XG4gICAgICAgICAgICBpZiAoZGVzYy5ub2RlLmlzQmxvY2sgJiYgZGVzYy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGx5IHRoZSBob3Jpem9udGFsIHRlc3QgdG8gdGhlIGlubmVybW9zdCBibG9jay4gVmVydGljYWwgZm9yIGFueSBwYXJlbnQuXG4gICAgICAgICAgICAgICAgaWYgKCFzYXdCbG9jayAmJiByZWN0LmxlZnQgPiBjb29yZHMubGVmdCB8fCByZWN0LnRvcCA+IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG91dHNpZGVCbG9jayA9IGRlc2MucG9zQmVmb3JlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzYXdCbG9jayAmJiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgfHwgcmVjdC5ib3R0b20gPCBjb29yZHMudG9wKVxuICAgICAgICAgICAgICAgICAgICBvdXRzaWRlQmxvY2sgPSBkZXNjLnBvc0FmdGVyO1xuICAgICAgICAgICAgICAgIHNhd0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGVzYy5jb250ZW50RE9NICYmIG91dHNpZGVCbG9jayA8IDAgJiYgIWRlc2Mubm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW5zaWRlIGEgbGVhZiwgcmV0dXJuIHRoZSBzaWRlIG9mIHRoZSBsZWFmIGNsb3NlciB0byB0aGUgY29vcmRzXG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IGRlc2Mubm9kZS5pc0Jsb2NrID8gY29vcmRzLnRvcCA8IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDJcbiAgICAgICAgICAgICAgICAgICAgOiBjb29yZHMubGVmdCA8IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZSA/IGRlc2MucG9zQmVmb3JlIDogZGVzYy5wb3NBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBkZXNjLmRvbS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gb3V0c2lkZUJsb2NrID4gLTEgPyBvdXRzaWRlQmxvY2sgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIC0xKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRGcm9tUG9pbnQoZWxlbWVudCwgY29vcmRzLCBib3gpIHtcbiAgICBsZXQgbGVuID0gZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICBpZiAobGVuICYmIGJveC50b3AgPCBib3guYm90dG9tKSB7XG4gICAgICAgIGZvciAobGV0IHN0YXJ0SSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxlbiAtIDEsIE1hdGguZmxvb3IobGVuICogKGNvb3Jkcy50b3AgLSBib3gudG9wKSAvIChib3guYm90dG9tIC0gYm94LnRvcCkpIC0gMikpLCBpID0gc3RhcnRJOzspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3RzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpblJlY3QoY29vcmRzLCByZWN0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50RnJvbVBvaW50KGNoaWxkLCBjb29yZHMsIHJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSA9IChpICsgMSkgJSBsZW4pID09IHN0YXJ0SSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbi8vIEdpdmVuIGFuIHgseSBwb3NpdGlvbiBvbiB0aGUgZWRpdG9yLCBnZXQgdGhlIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudC5cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzKHZpZXcsIGNvb3Jkcykge1xuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50LCBub2RlLCBvZmZzZXQgPSAwO1xuICAgIGxldCBjYXJldCA9IGNhcmV0RnJvbVBvaW50KGRvYywgY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xuICAgIGlmIChjYXJldClcbiAgICAgICAgKHsgbm9kZSwgb2Zmc2V0IH0gPSBjYXJldCk7XG4gICAgbGV0IGVsdCA9ICh2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCA/IHZpZXcucm9vdCA6IGRvYylcbiAgICAgICAgLmVsZW1lbnRGcm9tUG9pbnQoY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xuICAgIGxldCBwb3M7XG4gICAgaWYgKCFlbHQgfHwgIXZpZXcuZG9tLmNvbnRhaW5zKGVsdC5ub2RlVHlwZSAhPSAxID8gZWx0LnBhcmVudE5vZGUgOiBlbHQpKSB7XG4gICAgICAgIGxldCBib3ggPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKCFpblJlY3QoY29vcmRzLCBib3gpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGVsdCA9IGVsZW1lbnRGcm9tUG9pbnQodmlldy5kb20sIGNvb3JkcywgYm94KTtcbiAgICAgICAgaWYgKCFlbHQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU2FmYXJpJ3MgY2FyZXRSYW5nZUZyb21Qb2ludCByZXR1cm5zIG5vbnNlbnNlIHdoZW4gb24gYSBkcmFnZ2FibGUgZWxlbWVudFxuICAgIGlmIChzYWZhcmkpIHtcbiAgICAgICAgZm9yIChsZXQgcCA9IGVsdDsgbm9kZSAmJiBwOyBwID0gcGFyZW50Tm9kZShwKSlcbiAgICAgICAgICAgIGlmIChwLmRyYWdnYWJsZSlcbiAgICAgICAgICAgICAgICBub2RlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHQgPSB0YXJnZXRLbHVkZ2UoZWx0LCBjb29yZHMpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICAgIGlmIChnZWNrbyAmJiBub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggd2lsbCBzb21ldGltZXMgcmV0dXJuIG9mZnNldHMgaW50byA8aW5wdXQ+IG5vZGVzLCB3aGljaFxuICAgICAgICAgICAgLy8gaGF2ZSBubyBhY3R1YWwgY2hpbGRyZW4sIGZyb20gY2FyZXRQb3NpdGlvbkZyb21Qb2ludCAoIzk1MylcbiAgICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKG9mZnNldCwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAvLyBJdCdsbCBhbHNvIG1vdmUgdGhlIHJldHVybmVkIHBvc2l0aW9uIGJlZm9yZSBpbWFnZSBub2RlcyxcbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhvc2UgYXJlIGJlaGluZCBpdC5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSwgYm94O1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Lm5vZGVOYW1lID09IFwiSU1HXCIgJiYgKGJveCA9IG5leHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLnJpZ2h0IDw9IGNvb3Jkcy5sZWZ0ICYmXG4gICAgICAgICAgICAgICAgICAgIGJveC5ib3R0b20gPiBjb29yZHMudG9wKVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJldjtcbiAgICAgICAgLy8gV2hlbiBjbGlja2luZyBhYm92ZSB0aGUgcmlnaHQgc2lkZSBvZiBhbiB1bmVkaXRhYmxlIG5vZGUsIENocm9tZSB3aWxsIHJlcG9ydCBhIGN1cnNvciBwb3NpdGlvbiBhZnRlciB0aGF0IG5vZGUuXG4gICAgICAgIGlmICh3ZWJraXQgJiYgb2Zmc2V0ICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiAocHJldiA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXSkubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgcHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiICYmIHByZXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wID49IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgLy8gU3VzcGljaW91c2x5IHNwZWNpZmljIGtsdWRnZSB0byB3b3JrIGFyb3VuZCBjYXJldCpGcm9tUG9pbnRcbiAgICAgICAgLy8gbmV2ZXIgcmV0dXJuaW5nIGEgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnRcbiAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20gJiYgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxICYmIG5vZGUubGFzdENoaWxkLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgIGNvb3Jkcy50b3AgPiBub2RlLmxhc3RDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20pXG4gICAgICAgICAgICBwb3MgPSB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemU7XG4gICAgICAgIC8vIElnbm9yZSBwb3NpdGlvbnMgZGlyZWN0bHkgYWZ0ZXIgYSBCUiwgc2luY2UgY2FyZXQqRnJvbVBvaW50XG4gICAgICAgIC8vICdyb3VuZCB1cCcgcG9zaXRpb25zIHRoYXQgd291bGQgYmUgbW9yZSBhY2N1cmF0ZWx5IHBsYWNlZFxuICAgICAgICAvLyBiZWZvcmUgdGhlIEJSIG5vZGUuXG4gICAgICAgIGVsc2UgaWYgKG9mZnNldCA9PSAwIHx8IG5vZGUubm9kZVR5cGUgIT0gMSB8fCBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0ubm9kZU5hbWUgIT0gXCJCUlwiKVxuICAgICAgICAgICAgcG9zID0gcG9zRnJvbUNhcmV0KHZpZXcsIG5vZGUsIG9mZnNldCwgY29vcmRzKTtcbiAgICB9XG4gICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICBwb3MgPSBwb3NGcm9tRWxlbWVudCh2aWV3LCBlbHQsIGNvb3Jkcyk7XG4gICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZWx0LCB0cnVlKTtcbiAgICByZXR1cm4geyBwb3MsIGluc2lkZTogZGVzYyA/IGRlc2MucG9zQXRTdGFydCAtIGRlc2MuYm9yZGVyIDogLTEgfTtcbn1cbmZ1bmN0aW9uIG5vblplcm8ocmVjdCkge1xuICAgIHJldHVybiByZWN0LnRvcCA8IHJlY3QuYm90dG9tIHx8IHJlY3QubGVmdCA8IHJlY3QucmlnaHQ7XG59XG5mdW5jdGlvbiBzaW5nbGVSZWN0KHRhcmdldCwgYmlhcykge1xuICAgIGxldCByZWN0cyA9IHRhcmdldC5nZXRDbGllbnRSZWN0cygpO1xuICAgIGlmIChyZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gcmVjdHNbYmlhcyA8IDAgPyAwIDogcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChub25aZXJvKGZpcnN0KSlcbiAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwocmVjdHMsIG5vblplcm8pIHx8IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cbmNvbnN0IEJJREkgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY10vO1xuLy8gR2l2ZW4gYSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQgbW9kZWwsIGdldCBhIGJvdW5kaW5nIGJveCBvZiB0aGVcbi8vIGNoYXJhY3RlciBhdCB0aGF0IHBvc2l0aW9uLCByZWxhdGl2ZSB0byB0aGUgd2luZG93LlxuZnVuY3Rpb24gY29vcmRzQXRQb3ModmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0LCBhdG9tIH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIHNpZGUgPCAwID8gLTEgOiAxKTtcbiAgICBsZXQgc3VwcG9ydEVtcHR5UmFuZ2UgPSB3ZWJraXQgfHwgZ2Vja287XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAvLyBUaGVzZSBicm93c2VycyBzdXBwb3J0IHF1ZXJ5aW5nIGVtcHR5IHRleHQgcmFuZ2VzLiBQcmVmZXIgdGhhdCBpblxuICAgICAgICAvLyBiaWRpIGNvbnRleHQgb3Igd2hlbiBhdCB0aGUgZW5kIG9mIGEgbm9kZS5cbiAgICAgICAgaWYgKHN1cHBvcnRFbXB0eVJhbmdlICYmIChCSURJLnRlc3Qobm9kZS5ub2RlVmFsdWUpIHx8IChzaWRlIDwgMCA/ICFvZmZzZXQgOiBvZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSkpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgb2Zmc2V0LCBvZmZzZXQpLCBzaWRlKTtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggcmV0dXJucyBiYWQgcmVzdWx0cyAodGhlIHBvc2l0aW9uIGJlZm9yZSB0aGUgc3BhY2UpXG4gICAgICAgICAgICAvLyB3aGVuIHF1ZXJ5aW5nIGEgcG9zaXRpb24gZGlyZWN0bHkgYWZ0ZXIgbGluZS1icm9rZW5cbiAgICAgICAgICAgIC8vIHdoaXRlc3BhY2UuIERldGVjdCB0aGlzIHNpdHVhdGlvbiBhbmQgYW5kIGtsdWRnZSBhcm91bmQgaXRcbiAgICAgICAgICAgIGlmIChnZWNrbyAmJiBvZmZzZXQgJiYgL1xccy8udGVzdChub2RlLm5vZGVWYWx1ZVtvZmZzZXQgLSAxXSkgJiYgb2Zmc2V0IDwgbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3RCZWZvcmUgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQgLSAxLCBvZmZzZXQgLSAxKSwgLTEpO1xuICAgICAgICAgICAgICAgIGlmIChyZWN0QmVmb3JlLnRvcCA9PSByZWN0LnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdEFmdGVyID0gc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgb2Zmc2V0LCBvZmZzZXQgKyAxKSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdEFmdGVyLnRvcCAhPSByZWN0LnRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihyZWN0QWZ0ZXIsIHJlY3RBZnRlci5sZWZ0IDwgcmVjdEJlZm9yZS5sZWZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gb2Zmc2V0LCB0byA9IG9mZnNldCwgdGFrZVNpZGUgPSBzaWRlIDwgMCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGlmIChzaWRlIDwgMCAmJiAhb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgICAgICB0YWtlU2lkZSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2lkZSA+PSAwICYmIG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmcm9tLS07XG4gICAgICAgICAgICAgICAgdGFrZVNpZGUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2lkZSA8IDApIHtcbiAgICAgICAgICAgICAgICBmcm9tLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIGZyb20sIHRvKSwgdGFrZVNpZGUpLCB0YWtlU2lkZSA8IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCAkZG9tID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MgLSAoYXRvbSB8fCAwKSk7XG4gICAgLy8gUmV0dXJuIGEgaG9yaXpvbnRhbCBsaW5lIGluIGJsb2NrIGNvbnRleHRcbiAgICBpZiAoISRkb20ucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgJiYgKHNpZGUgPCAwIHx8IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKSkpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5IKGJlZm9yZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0IDwgbm9kZVNpemUobm9kZSkpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGFmdGVyLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5IKGFmdGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhdHRlbkgobm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc2lkZSA+PSAwKTtcbiAgICB9XG4gICAgLy8gSW5saW5lLCBub3QgaW4gdGV4dCBub2RlICh0aGlzIGlzIG5vdCBCaWRpLXNhZmUpXG4gICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgJiYgKHNpZGUgPCAwIHx8IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKSkpIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgbGV0IHRhcmdldCA9IGJlZm9yZS5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKGJlZm9yZSwgbm9kZVNpemUoYmVmb3JlKSAtIChzdXBwb3J0RW1wdHlSYW5nZSA/IDAgOiAxKSlcbiAgICAgICAgICAgIC8vIEJSIG5vZGVzIHRlbmQgdG8gb25seSByZXR1cm4gdGhlIHJlY3RhbmdsZSBiZWZvcmUgdGhlbS5cbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIHRoZW0gaWYgdGhleSBhcmUgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGVpciBwYXJlbnRcbiAgICAgICAgICAgIDogYmVmb3JlLm5vZGVUeXBlID09IDEgJiYgKGJlZm9yZS5ub2RlTmFtZSAhPSBcIkJSXCIgfHwgIWJlZm9yZS5uZXh0U2libGluZykgPyBiZWZvcmUgOiBudWxsO1xuICAgICAgICBpZiAodGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3QodGFyZ2V0LCAxKSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCA8IG5vZGVTaXplKG5vZGUpKSB7XG4gICAgICAgIGxldCBhZnRlciA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICB3aGlsZSAoYWZ0ZXIucG1WaWV3RGVzYyAmJiBhZnRlci5wbVZpZXdEZXNjLmlnbm9yZUZvckNvb3JkcylcbiAgICAgICAgICAgIGFmdGVyID0gYWZ0ZXIubmV4dFNpYmxpbmc7XG4gICAgICAgIGxldCB0YXJnZXQgPSAhYWZ0ZXIgPyBudWxsIDogYWZ0ZXIubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShhZnRlciwgMCwgKHN1cHBvcnRFbXB0eVJhbmdlID8gMCA6IDEpKVxuICAgICAgICAgICAgOiBhZnRlci5ub2RlVHlwZSA9PSAxID8gYWZ0ZXIgOiBudWxsO1xuICAgICAgICBpZiAodGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3QodGFyZ2V0LCAtMSksIHRydWUpO1xuICAgIH1cbiAgICAvLyBBbGwgZWxzZSBmYWlsZWQsIGp1c3QgdHJ5IHRvIGdldCBhIHJlY3RhbmdsZSBmb3IgdGhlIHRhcmdldCBub2RlXG4gICAgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3Qobm9kZS5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKG5vZGUpIDogbm9kZSwgLXNpZGUpLCBzaWRlID49IDApO1xufVxuZnVuY3Rpb24gZmxhdHRlblYocmVjdCwgbGVmdCkge1xuICAgIGlmIChyZWN0LndpZHRoID09IDApXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIGxldCB4ID0gbGVmdCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQ7XG4gICAgcmV0dXJuIHsgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LmJvdHRvbSwgbGVmdDogeCwgcmlnaHQ6IHggfTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5IKHJlY3QsIHRvcCkge1xuICAgIGlmIChyZWN0LmhlaWdodCA9PSAwKVxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICBsZXQgeSA9IHRvcCA/IHJlY3QudG9wIDogcmVjdC5ib3R0b207XG4gICAgcmV0dXJuIHsgdG9wOiB5LCBib3R0b206IHksIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQgfTtcbn1cbmZ1bmN0aW9uIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsIGYpIHtcbiAgICBsZXQgdmlld1N0YXRlID0gdmlldy5zdGF0ZSwgYWN0aXZlID0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKHZpZXdTdGF0ZSAhPSBzdGF0ZSlcbiAgICAgICAgdmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgaWYgKGFjdGl2ZSAhPSB2aWV3LmRvbSlcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmKCk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBpZiAodmlld1N0YXRlICE9IHN0YXRlKVxuICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3U3RhdGUpO1xuICAgICAgICBpZiAoYWN0aXZlICE9IHZpZXcuZG9tICYmIGFjdGl2ZSlcbiAgICAgICAgICAgIGFjdGl2ZS5mb2N1cygpO1xuICAgIH1cbn1cbi8vIFdoZXRoZXIgdmVydGljYWwgcG9zaXRpb24gbW90aW9uIGluIGEgZ2l2ZW4gZGlyZWN0aW9uXG4vLyBmcm9tIGEgcG9zaXRpb24gd291bGQgbGVhdmUgYSB0ZXh0IGJsb2NrLlxuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2tWZXJ0aWNhbCh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgJHBvcyA9IGRpciA9PSBcInVwXCIgPyBzZWwuJGZyb20gOiBzZWwuJHRvO1xuICAgIHJldHVybiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCAoKSA9PiB7XG4gICAgICAgIGxldCB7IG5vZGU6IGRvbSB9ID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MoJHBvcy5wb3MsIGRpciA9PSBcInVwXCIgPyAtMSA6IDEpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmVhcmVzdCA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhkb20sIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFuZWFyZXN0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG5lYXJlc3Qubm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgZG9tID0gbmVhcmVzdC5jb250ZW50RE9NIHx8IG5lYXJlc3QuZG9tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tID0gbmVhcmVzdC5kb20ucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29vcmRzID0gY29vcmRzQXRQb3ModmlldywgJHBvcy5wb3MsIDEpO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCA9IGRvbS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgbGV0IGJveGVzO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgYm94ZXMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICBib3hlcyA9IHRleHRSYW5nZShjaGlsZCwgMCwgY2hpbGQubm9kZVZhbHVlLmxlbmd0aCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYm94ID0gYm94ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGJveC5ib3R0b20gPiBib3gudG9wICsgMSAmJlxuICAgICAgICAgICAgICAgICAgICAoZGlyID09IFwidXBcIiA/IGNvb3Jkcy50b3AgLSBib3gudG9wID4gKGJveC5ib3R0b20gLSBjb29yZHMudG9wKSAqIDJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYm94LmJvdHRvbSAtIGNvb3Jkcy5ib3R0b20gPiAoY29vcmRzLmJvdHRvbSAtIGJveC50b3ApICogMikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbn1cbmNvbnN0IG1heWJlUlRMID0gL1tcXHUwNTkwLVxcdTA4YWNdLztcbmZ1bmN0aW9uIGVuZE9mVGV4dGJsb2NrSG9yaXpvbnRhbCh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gICAgbGV0IHsgJGhlYWQgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnBhcmVudC5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSAkaGVhZC5wYXJlbnRPZmZzZXQsIGF0U3RhcnQgPSAhb2Zmc2V0LCBhdEVuZCA9IG9mZnNldCA9PSAkaGVhZC5wYXJlbnQuY29udGVudC5zaXplO1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsKVxuICAgICAgICByZXR1cm4gJGhlYWQucG9zID09ICRoZWFkLnN0YXJ0KCkgfHwgJGhlYWQucG9zID09ICRoZWFkLmVuZCgpO1xuICAgIC8vIElmIHRoZSB0ZXh0YmxvY2sgaXMgYWxsIExUUiwgb3IgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0XG4gICAgLy8gU2VsZWN0aW9uLm1vZGlmeSAoRWRnZSksIGZhbGwgYmFjayB0byBhIHByaW1pdGl2ZSBhcHByb2FjaFxuICAgIGlmICghbWF5YmVSVEwudGVzdCgkaGVhZC5wYXJlbnQudGV4dENvbnRlbnQpIHx8ICFzZWwubW9kaWZ5KVxuICAgICAgICByZXR1cm4gZGlyID09IFwibGVmdFwiIHx8IGRpciA9PSBcImJhY2t3YXJkXCIgPyBhdFN0YXJ0IDogYXRFbmQ7XG4gICAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsICgpID0+IHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGh1Z2UgaGFjaywgYnV0IGFwcGVhcnMgdG8gYmUgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGN1cnJlbnRseSBkbzogdXNlIGBTZWxlY3Rpb24ubW9kaWZ5YCB0byBtb3ZlIHRoZSBzZWxlY3Rpb24gYnlcbiAgICAgICAgLy8gb25lIGNoYXJhY3RlciwgYW5kIHNlZSBpZiB0aGF0IG1vdmVzIHRoZSBjdXJzb3Igb3V0IG9mIHRoZVxuICAgICAgICAvLyB0ZXh0YmxvY2sgKG9yIGRvZXNuJ3QgbW92ZSBpdCBhdCBhbGwsIHdoZW4gYXQgdGhlIHN0YXJ0L2VuZCBvZlxuICAgICAgICAvLyB0aGUgZG9jdW1lbnQpLlxuICAgICAgICBsZXQgeyBmb2N1c05vZGU6IG9sZE5vZGUsIGZvY3VzT2Zmc2V0OiBvbGRPZmYsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCB9ID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgb2xkQmlkaUxldmVsID0gc2VsLmNhcmV0QmlkaUxldmVsIC8vIE9ubHkgZm9yIEZpcmVmb3hcbiAgICAgICAgO1xuICAgICAgICBzZWwubW9kaWZ5KFwibW92ZVwiLCBkaXIsIFwiY2hhcmFjdGVyXCIpO1xuICAgICAgICBsZXQgcGFyZW50RE9NID0gJGhlYWQuZGVwdGggPyB2aWV3LmRvY1ZpZXcuZG9tQWZ0ZXJQb3MoJGhlYWQuYmVmb3JlKCkpIDogdmlldy5kb207XG4gICAgICAgIGxldCB7IGZvY3VzTm9kZTogbmV3Tm9kZSwgZm9jdXNPZmZzZXQ6IG5ld09mZiB9ID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3Tm9kZSAmJiAhcGFyZW50RE9NLmNvbnRhaW5zKG5ld05vZGUubm9kZVR5cGUgPT0gMSA/IG5ld05vZGUgOiBuZXdOb2RlLnBhcmVudE5vZGUpIHx8XG4gICAgICAgICAgICAob2xkTm9kZSA9PSBuZXdOb2RlICYmIG9sZE9mZiA9PSBuZXdPZmYpO1xuICAgICAgICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyBzZWxlY3Rpb25cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlbC5jb2xsYXBzZShhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG9sZE5vZGUgJiYgKG9sZE5vZGUgIT0gYW5jaG9yTm9kZSB8fCBvbGRPZmYgIT0gYW5jaG9yT2Zmc2V0KSAmJiBzZWwuZXh0ZW5kKVxuICAgICAgICAgICAgICAgIHNlbC5leHRlbmQob2xkTm9kZSwgb2xkT2ZmKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgIGlmIChvbGRCaWRpTGV2ZWwgIT0gbnVsbClcbiAgICAgICAgICAgIHNlbC5jYXJldEJpZGlMZXZlbCA9IG9sZEJpZGlMZXZlbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn1cbmxldCBjYWNoZWRTdGF0ZSA9IG51bGw7XG5sZXQgY2FjaGVkRGlyID0gbnVsbDtcbmxldCBjYWNoZWRSZXN1bHQgPSBmYWxzZTtcbmZ1bmN0aW9uIGVuZE9mVGV4dGJsb2NrKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBpZiAoY2FjaGVkU3RhdGUgPT0gc3RhdGUgJiYgY2FjaGVkRGlyID09IGRpcilcbiAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICBjYWNoZWRTdGF0ZSA9IHN0YXRlO1xuICAgIGNhY2hlZERpciA9IGRpcjtcbiAgICByZXR1cm4gY2FjaGVkUmVzdWx0ID0gZGlyID09IFwidXBcIiB8fCBkaXIgPT0gXCJkb3duXCJcbiAgICAgICAgPyBlbmRPZlRleHRibG9ja1ZlcnRpY2FsKHZpZXcsIHN0YXRlLCBkaXIpXG4gICAgICAgIDogZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsKHZpZXcsIHN0YXRlLCBkaXIpO1xufVxuXG4vLyBWaWV3IGRlc2NyaXB0aW9ucyBhcmUgZGF0YSBzdHJ1Y3R1cmVzIHRoYXQgZGVzY3JpYmUgdGhlIERPTSB0aGF0IGlzXG4vLyB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZWRpdG9yJ3MgY29udGVudC4gVGhleSBhcmUgdXNlZCBmb3I6XG4vL1xuLy8gLSBJbmNyZW1lbnRhbCByZWRyYXdpbmcgd2hlbiB0aGUgZG9jdW1lbnQgY2hhbmdlc1xuLy9cbi8vIC0gRmlndXJpbmcgb3V0IHdoYXQgcGFydCBvZiB0aGUgZG9jdW1lbnQgYSBnaXZlbiBET00gcG9zaXRpb25cbi8vICAgY29ycmVzcG9uZHMgdG9cbi8vXG4vLyAtIFdpcmluZyBpbiBjdXN0b20gaW1wbGVtZW50YXRpb25zIG9mIHRoZSBlZGl0aW5nIGludGVyZmFjZSBmb3IgYVxuLy8gICBnaXZlbiBub2RlXG4vL1xuLy8gVGhleSBmb3JtIGEgZG91Ymx5LWxpbmtlZCBtdXRhYmxlIHRyZWUsIHN0YXJ0aW5nIGF0IGB2aWV3LmRvY1ZpZXdgLlxuY29uc3QgTk9UX0RJUlRZID0gMCwgQ0hJTERfRElSVFkgPSAxLCBDT05URU5UX0RJUlRZID0gMiwgTk9ERV9ESVJUWSA9IDM7XG4vLyBTdXBlcmNsYXNzIGZvciB0aGUgdmFyaW91cyBraW5kcyBvZiBkZXNjcmlwdGlvbnMuIERlZmluZXMgdGhlaXJcbi8vIGJhc2ljIHN0cnVjdHVyZSBhbmQgc2hhcmVkIG1ldGhvZHMuXG5jbGFzcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBjaGlsZHJlbiwgZG9tLCBcbiAgICAvLyBUaGlzIGlzIHRoZSBub2RlIHRoYXQgaG9sZHMgdGhlIGNoaWxkIHZpZXdzLiBJdCBtYXkgYmUgbnVsbCBmb3JcbiAgICAvLyBkZXNjcyB0aGF0IGRvbid0IGhhdmUgY2hpbGRyZW4uXG4gICAgY29udGVudERPTSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NID0gY29udGVudERPTTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgLy8gQW4gZXhwYW5kbyBwcm9wZXJ0eSBvbiB0aGUgRE9NIG5vZGUgcHJvdmlkZXMgYSBsaW5rIGJhY2sgdG8gaXRzXG4gICAgICAgIC8vIGRlc2NyaXB0aW9uLlxuICAgICAgICBkb20ucG1WaWV3RGVzYyA9IHRoaXM7XG4gICAgfVxuICAgIC8vIFVzZWQgdG8gY2hlY2sgd2hldGhlciBhIGdpdmVuIGRlc2NyaXB0aW9uIGNvcnJlc3BvbmRzIHRvIGFcbiAgICAvLyB3aWRnZXQvbWFyay9ub2RlLlxuICAgIG1hdGNoZXNXaWRnZXQod2lkZ2V0KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1hdGNoZXNNYXJrKG1hcmspIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWF0Y2hlc0hhY2sobm9kZU5hbWUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLy8gV2hlbiBwYXJzaW5nIGluLWVkaXRvciBjb250ZW50IChpbiBkb21jaGFuZ2UuanMpLCB3ZSBhbGxvd1xuICAgIC8vIGRlc2NyaXB0aW9ucyB0byBkZXRlcm1pbmUgdGhlIHBhcnNlIHJ1bGVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG9cbiAgICAvLyBwYXJzZSB0aGVtLlxuICAgIHBhcnNlUnVsZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvLyBVc2VkIGJ5IHRoZSBlZGl0b3IncyBldmVudCBoYW5kbGVyIHRvIGlnbm9yZSBldmVudHMgdGhhdCBjb21lXG4gICAgLy8gZnJvbSBjZXJ0YWluIGRlc2NzLlxuICAgIHN0b3BFdmVudChldmVudCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgY29udGVudCByZXByZXNlbnRlZCBieSB0aGlzIGRlc2MuXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgc2l6ZSArPSB0aGlzLmNoaWxkcmVuW2ldLnNpemU7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICAvLyBGb3IgYmxvY2sgbm9kZXMsIHRoaXMgcmVwcmVzZW50cyB0aGUgc3BhY2UgdGFrZW4gdXAgYnkgdGhlaXJcbiAgICAvLyBzdGFydC9lbmQgdG9rZW5zLlxuICAgIGdldCBib3JkZXIoKSB7IHJldHVybiAwOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmRvbS5wbVZpZXdEZXNjID09IHRoaXMpXG4gICAgICAgICAgICB0aGlzLmRvbS5wbVZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgcG9zQmVmb3JlQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHRoaXMucG9zQXRTdGFydDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY3VyID09IGNoaWxkKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY3VyLnNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHBvc0JlZm9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnBvc0JlZm9yZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgcG9zQXRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQucG9zQmVmb3JlQ2hpbGQodGhpcykgKyB0aGlzLmJvcmRlciA6IDA7XG4gICAgfVxuICAgIGdldCBwb3NBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQmVmb3JlICsgdGhpcy5zaXplO1xuICAgIH1cbiAgICBnZXQgcG9zQXRFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyB0aGlzLnNpemUgLSAyICogdGhpcy5ib3JkZXI7XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgICAvLyBJZiB0aGUgRE9NIHBvc2l0aW9uIGlzIGluIHRoZSBjb250ZW50LCB1c2UgdGhlIGNoaWxkIGRlc2MgYWZ0ZXJcbiAgICAgICAgLy8gaXQgdG8gZmlndXJlIG91dCBhIHBvc2l0aW9uLlxuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTS5jb250YWlucyhkb20ubm9kZVR5cGUgPT0gMSA/IGRvbSA6IGRvbS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgaWYgKGJpYXMgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRvbUJlZm9yZSwgZGVzYztcbiAgICAgICAgICAgICAgICBpZiAoZG9tID09IHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgICAgICBkb21CZWZvcmUgPSBkb20uY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkb20ucGFyZW50Tm9kZSAhPSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20gPSBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbUJlZm9yZSAmJiAhKChkZXNjID0gZG9tQmVmb3JlLnBtVmlld0Rlc2MpICYmIGRlc2MucGFyZW50ID09IHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICBkb21CZWZvcmUgPSBkb21CZWZvcmUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb21CZWZvcmUgPyB0aGlzLnBvc0JlZm9yZUNoaWxkKGRlc2MpICsgZGVzYy5zaXplIDogdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGRvbUFmdGVyLCBkZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUFmdGVyID0gZG9tLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkb20ucGFyZW50Tm9kZSAhPSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20gPSBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChkb21BZnRlciAmJiAhKChkZXNjID0gZG9tQWZ0ZXIucG1WaWV3RGVzYykgJiYgZGVzYy5wYXJlbnQgPT0gdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIGRvbUFmdGVyID0gZG9tQWZ0ZXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUFmdGVyID8gdGhpcy5wb3NCZWZvcmVDaGlsZChkZXNjKSA6IHRoaXMucG9zQXRFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB1c2UgdmFyaW91cyBoZXVyaXN0aWNzLCBmYWxsaW5nIGJhY2sgb24gdGhlIGJpYXNcbiAgICAgICAgLy8gcGFyYW1ldGVyLCB0byBkZXRlcm1pbmUgd2hldGhlciB0byByZXR1cm4gdGhlIHBvc2l0aW9uIGF0IHRoZVxuICAgICAgICAvLyBzdGFydCBvciBhdCB0aGUgZW5kIG9mIHRoaXMgdmlldyBkZXNjLlxuICAgICAgICBsZXQgYXRFbmQ7XG4gICAgICAgIGlmIChkb20gPT0gdGhpcy5kb20gJiYgdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICBhdEVuZCA9IG9mZnNldCA+IGRvbUluZGV4KHRoaXMuY29udGVudERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTSAhPSB0aGlzLmRvbSAmJiB0aGlzLmRvbS5jb250YWlucyh0aGlzLmNvbnRlbnRET00pKSB7XG4gICAgICAgICAgICBhdEVuZCA9IGRvbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzLmNvbnRlbnRET00pICYgMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IDApXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2VhcmNoID0gZG9tOzsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaCA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2gucHJldmlvdXNTaWJsaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0RW5kID09IG51bGwgJiYgb2Zmc2V0ID09IGRvbS5jaGlsZE5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSBkb207OyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdEVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYXRFbmQgPT0gbnVsbCA/IGJpYXMgPiAwIDogYXRFbmQpID8gdGhpcy5wb3NBdEVuZCA6IHRoaXMucG9zQXRTdGFydDtcbiAgICB9XG4gICAgbmVhcmVzdERlc2MoZG9tLCBvbmx5Tm9kZXMgPSBmYWxzZSkge1xuICAgICAgICBmb3IgKGxldCBmaXJzdCA9IHRydWUsIGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbGV0IGRlc2MgPSB0aGlzLmdldERlc2MoY3VyKSwgbm9kZURPTTtcbiAgICAgICAgICAgIGlmIChkZXNjICYmICghb25seU5vZGVzIHx8IGRlc2Mubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBkb20gaXMgb3V0c2lkZSBvZiB0aGlzIGRlc2MncyBub2RlRE9NLCBkb24ndCBjb3VudCBpdC5cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QgJiYgKG5vZGVET00gPSBkZXNjLm5vZGVET00pICYmXG4gICAgICAgICAgICAgICAgICAgICEobm9kZURPTS5ub2RlVHlwZSA9PSAxID8gbm9kZURPTS5jb250YWlucyhkb20ubm9kZVR5cGUgPT0gMSA/IGRvbSA6IGRvbS5wYXJlbnROb2RlKSA6IG5vZGVET00gPT0gZG9tKSlcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldERlc2MoZG9tKSB7XG4gICAgICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IGRlc2M7IGN1cjsgY3VyID0gY3VyLnBhcmVudClcbiAgICAgICAgICAgIGlmIChjdXIgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICB9XG4gICAgcG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgICBmb3IgKGxldCBzY2FuID0gZG9tOyBzY2FuOyBzY2FuID0gc2Nhbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZ2V0RGVzYyhzY2FuKTtcbiAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLmxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBkZXNjIGZvciB0aGUgbm9kZSBhZnRlciB0aGUgZ2l2ZW4gcG9zLCBpZiBhbnkuIChXaGVuIGFcbiAgICAvLyBwYXJlbnQgbm9kZSBvdmVycm9kZSByZW5kZXJpbmcsIHRoZXJlIG1pZ2h0IG5vdCBiZSBvbmUuKVxuICAgIGRlc2NBdChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBwb3MgJiYgZW5kICE9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICghY2hpbGQuYm9yZGVyICYmIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBjaGlsZC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbm5lci5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBpbm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDwgZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5kZXNjQXQocG9zIC0gb2Zmc2V0IC0gY2hpbGQuYm9yZGVyKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcywgc2lkZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuZG9tLCBvZmZzZXQ6IDAsIGF0b206IHBvcyArIDEgfTtcbiAgICAgICAgLy8gRmlyc3QgZmluZCB0aGUgcG9zaXRpb24gaW4gdGhlIGNoaWxkIGFycmF5XG4gICAgICAgIGxldCBpID0gMCwgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgY3VyUG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IGN1clBvcyArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID4gcG9zIHx8IGNoaWxkIGluc3RhbmNlb2YgVHJhaWxpbmdIYWNrVmlld0Rlc2MpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwb3MgLSBjdXJQb3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJQb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhpcyBwb2ludHMgaW50byB0aGUgbWlkZGxlIG9mIGEgY2hpbGQsIGNhbGwgdGhyb3VnaFxuICAgICAgICBpZiAob2Zmc2V0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV0uZG9tRnJvbVBvcyhvZmZzZXQgLSB0aGlzLmNoaWxkcmVuW2ldLmJvcmRlciwgc2lkZSk7XG4gICAgICAgIC8vIEdvIGJhY2sgaWYgdGhlcmUgd2VyZSBhbnkgemVyby1sZW5ndGggd2lkZ2V0cyB3aXRoIHNpZGUgPj0gMCBiZWZvcmUgdGhpcyBwb2ludFxuICAgICAgICBmb3IgKGxldCBwcmV2OyBpICYmICEocHJldiA9IHRoaXMuY2hpbGRyZW5baSAtIDFdKS5zaXplICYmIHByZXYgaW5zdGFuY2VvZiBXaWRnZXRWaWV3RGVzYyAmJiBwcmV2LnNpZGUgPj0gMDsgaS0tKSB7IH1cbiAgICAgICAgLy8gU2NhbiB0b3dhcmRzIHRoZSBmaXJzdCB1c2VhYmxlIG5vZGVcbiAgICAgICAgaWYgKHNpZGUgPD0gMCkge1xuICAgICAgICAgICAgbGV0IHByZXYsIGVudGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoOzsgaS0tLCBlbnRlciA9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IGkgPyB0aGlzLmNoaWxkcmVuW2kgLSAxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2IHx8IHByZXYuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHNpZGUgJiYgZW50ZXIgJiYgIXByZXYuYm9yZGVyICYmICFwcmV2LmRvbUF0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXYuZG9tRnJvbVBvcyhwcmV2LnNpemUsIHNpZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBvZmZzZXQ6IHByZXYgPyBkb21JbmRleChwcmV2LmRvbSkgKyAxIDogMCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5leHQsIGVudGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoOzsgaSsrLCBlbnRlciA9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA/IHRoaXMuY2hpbGRyZW5baV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dCB8fCBuZXh0LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCAmJiBlbnRlciAmJiAhbmV4dC5ib3JkZXIgJiYgIW5leHQuZG9tQXRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5kb21Gcm9tUG9zKDAsIHNpZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBvZmZzZXQ6IG5leHQgPyBkb21JbmRleChuZXh0LmRvbSkgOiB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGggfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2VkIHRvIGZpbmQgYSBET00gcmFuZ2UgaW4gYSBzaW5nbGUgcGFyZW50IGZvciBhIGdpdmVuIGNoYW5nZWRcbiAgICAvLyByYW5nZS5cbiAgICBwYXJzZVJhbmdlKGZyb20sIHRvLCBiYXNlID0gMCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgZnJvbSwgdG8sIGZyb21PZmZzZXQ6IDAsIHRvT2Zmc2V0OiB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGggfTtcbiAgICAgICAgbGV0IGZyb21PZmZzZXQgPSAtMSwgdG9PZmZzZXQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gYmFzZSwgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAoZnJvbU9mZnNldCA9PSAtMSAmJiBmcm9tIDw9IGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZEJhc2UgPSBvZmZzZXQgKyBjaGlsZC5ib3JkZXI7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgbWF5YmUgZGVzY2VuZCBtYXJrIHZpZXdzIHRvIHBhcnNlIGEgbmFycm93ZXIgcmFuZ2U/XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPj0gY2hpbGRCYXNlICYmIHRvIDw9IGVuZCAtIGNoaWxkLmJvcmRlciAmJiBjaGlsZC5ub2RlICYmXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKGNoaWxkLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQucGFyc2VSYW5nZShmcm9tLCB0bywgY2hpbGRCYXNlKTtcbiAgICAgICAgICAgICAgICBmcm9tID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmV2ID0gdGhpcy5jaGlsZHJlbltqIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2LnNpemUgJiYgcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIXByZXYuZW1wdHlDaGlsZEF0KDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tT2Zmc2V0ID0gZG9tSW5kZXgocHJldi5kb20pICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZyb20gLT0gcHJldi5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZnJvbU9mZnNldCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZnJvbU9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbU9mZnNldCA+IC0xICYmIChlbmQgPiB0byB8fCBpID09IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICB0byA9IGVuZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5jaGlsZHJlbltqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuc2l6ZSAmJiBuZXh0LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhbmV4dC5lbXB0eUNoaWxkQXQoLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b09mZnNldCA9IGRvbUluZGV4KG5leHQuZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRvICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRvT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0b09mZnNldCA9IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIGZyb20sIHRvLCBmcm9tT2Zmc2V0LCB0b09mZnNldCB9O1xuICAgIH1cbiAgICBlbXB0eUNoaWxkQXQoc2lkZSkge1xuICAgICAgICBpZiAodGhpcy5ib3JkZXIgfHwgIXRoaXMuY29udGVudERPTSB8fCAhdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bc2lkZSA8IDAgPyAwIDogdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIGNoaWxkLnNpemUgPT0gMCB8fCBjaGlsZC5lbXB0eUNoaWxkQXQoc2lkZSk7XG4gICAgfVxuICAgIGRvbUFmdGVyUG9zKHBvcykge1xuICAgICAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IHRoaXMuZG9tRnJvbVBvcyhwb3MsIDApO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxIHx8IG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGFmdGVyIHBvcyBcIiArIHBvcyk7XG4gICAgICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICB9XG4gICAgLy8gVmlldyBkZXNjcyBhcmUgcmVzcG9uc2libGUgZm9yIHNldHRpbmcgYW55IHNlbGVjdGlvbiB0aGF0IGZhbGxzXG4gICAgLy8gZW50aXJlbHkgaW5zaWRlIG9mIHRoZW0sIHNvIHRoYXQgY3VzdG9tIGltcGxlbWVudGF0aW9ucyBjYW4gZG9cbiAgICAvLyBjdXN0b20gdGhpbmdzIHdpdGggdGhlIHNlbGVjdGlvbi4gTm90ZSB0aGF0IHRoaXMgZmFsbHMgYXBhcnQgd2hlblxuICAgIC8vIGEgc2VsZWN0aW9uIHN0YXJ0cyBpbiBzdWNoIGEgbm9kZSBhbmQgZW5kcyBpbiBhbm90aGVyLCBpbiB3aGljaFxuICAgIC8vIGNhc2Ugd2UganVzdCB1c2Ugd2hhdGV2ZXIgZG9tRnJvbVBvcyBwcm9kdWNlcyBhcyBhIGJlc3QgZWZmb3J0LlxuICAgIHNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHZpZXcsIGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBmYWxscyBlbnRpcmVseSBpbiBhIGNoaWxkLCBnaXZlIGl0IHRvIHRoYXQgY2hpbGRcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihhbmNob3IsIGhlYWQpLCB0byA9IE1hdGgubWF4KGFuY2hvciwgaGVhZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tID4gb2Zmc2V0ICYmIHRvIDwgZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5zZXRTZWxlY3Rpb24oYW5jaG9yIC0gb2Zmc2V0IC0gY2hpbGQuYm9yZGVyLCBoZWFkIC0gb2Zmc2V0IC0gY2hpbGQuYm9yZGVyLCB2aWV3LCBmb3JjZSk7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFuY2hvckRPTSA9IHRoaXMuZG9tRnJvbVBvcyhhbmNob3IsIGFuY2hvciA/IC0xIDogMSk7XG4gICAgICAgIGxldCBoZWFkRE9NID0gaGVhZCA9PSBhbmNob3IgPyBhbmNob3JET00gOiB0aGlzLmRvbUZyb21Qb3MoaGVhZCwgaGVhZCA/IC0xIDogMSk7XG4gICAgICAgIGxldCBkb21TZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGxldCBzZWxSYW5nZSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IGJyS2x1ZGdlID0gZmFsc2U7XG4gICAgICAgIC8vIE9uIEZpcmVmb3gsIHVzaW5nIFNlbGVjdGlvbi5jb2xsYXBzZSB0byBwdXQgdGhlIGN1cnNvciBhZnRlciBhXG4gICAgICAgIC8vIEJSIG5vZGUgZm9yIHNvbWUgcmVhc29uIGRvZXNuJ3QgYWx3YXlzIHdvcmsgKCMxMDczKS4gT24gU2FmYXJpLFxuICAgICAgICAvLyB0aGUgY3Vyc29yIHNvbWV0aW1lcyBpbmV4cGxpY2FibGUgdmlzdWFsbHkgbGFncyBiZWhpbmQgaXRzXG4gICAgICAgIC8vIHJlcG9ydGVkIHBvc2l0aW9uIGluIHN1Y2ggc2l0dWF0aW9ucyAoIzEwOTIpLlxuICAgICAgICBpZiAoKGdlY2tvIHx8IHNhZmFyaSkgJiYgYW5jaG9yID09IGhlYWQpIHtcbiAgICAgICAgICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gYW5jaG9yRE9NO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgIGJyS2x1ZGdlID0gISEob2Zmc2V0ICYmIG5vZGUubm9kZVZhbHVlW29mZnNldCAtIDFdID09IFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIC8vIElzc3VlICMxMTI4XG4gICAgICAgICAgICAgICAgaWYgKGJyS2x1ZGdlICYmIG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc2NhbiA9IG5vZGUsIGFmdGVyOyBzY2FuOyBzY2FuID0gc2Nhbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIgPSBzY2FuLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFmdGVyLm5vZGVOYW1lID09IFwiQlJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yRE9NID0gaGVhZERPTSA9IHsgbm9kZTogYWZ0ZXIucGFyZW50Tm9kZSwgb2Zmc2V0OiBkb21JbmRleChhZnRlcikgKyAxIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVzYyA9IHNjYW4ucG1WaWV3RGVzYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIGJyS2x1ZGdlID0gcHJldiAmJiAocHJldi5ub2RlTmFtZSA9PSBcIkJSXCIgfHwgcHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJlZm94IGNhbiBhY3Qgc3RyYW5nZWx5IHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBpbiBmcm9udCBvZiBhblxuICAgICAgICAvLyB1bmVkaXRhYmxlIG5vZGUuIFNlZSAjMTE2MyBhbmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTcwOTUzNlxuICAgICAgICBpZiAoZ2Vja28gJiYgc2VsUmFuZ2UuZm9jdXNOb2RlICYmIHNlbFJhbmdlLmZvY3VzTm9kZSAhPSBoZWFkRE9NLm5vZGUgJiYgc2VsUmFuZ2UuZm9jdXNOb2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IHNlbFJhbmdlLmZvY3VzTm9kZS5jaGlsZE5vZGVzW3NlbFJhbmdlLmZvY3VzT2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShmb3JjZSB8fCBicktsdWRnZSAmJiBzYWZhcmkpICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgc2VsUmFuZ2UuYW5jaG9yTm9kZSwgc2VsUmFuZ2UuYW5jaG9yT2Zmc2V0KSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oaGVhZERPTS5ub2RlLCBoZWFkRE9NLm9mZnNldCwgc2VsUmFuZ2UuZm9jdXNOb2RlLCBzZWxSYW5nZS5mb2N1c09mZnNldCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFNlbGVjdGlvbi5leHRlbmQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuICdpbnZlcnRlZCcgc2VsZWN0aW9uXG4gICAgICAgIC8vIChvbmUgd2hlcmUgdGhlIGZvY3VzIGlzIGJlZm9yZSB0aGUgYW5jaG9yKSwgYnV0IG5vdCBhbGxcbiAgICAgICAgLy8gYnJvd3NlcnMgc3VwcG9ydCBpdCB5ZXQuXG4gICAgICAgIGxldCBkb21TZWxFeHRlbmRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoKGRvbVNlbC5leHRlbmQgfHwgYW5jaG9yID09IGhlYWQpICYmICFicktsdWRnZSkge1xuICAgICAgICAgICAgZG9tU2VsLmNvbGxhcHNlKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciAhPSBoZWFkKVxuICAgICAgICAgICAgICAgICAgICBkb21TZWwuZXh0ZW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGRvbVNlbEV4dGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyB3aXRoIENocm9tZSB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFmdGVyIGNhbGxpbmdcbiAgICAgICAgICAgICAgICAvLyBjb2xsYXBzZSwgZXZlbiB3aGVuIGl0IHNob3VsZCBiZSB2YWxpZC4gVGhpcyBhcHBlYXJzIHRvIGJlIGEgYnVnLCBidXRcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBkaWZmaWN1bHQgdG8gaXNvbGF0ZS4gSWYgdGhpcyBoYXBwZW5zIGZhbGxiYWNrIHRvIHRoZSBvbGQgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgdXNpbmcgZXh0ZW5kLlxuICAgICAgICAgICAgICAgIC8vIFNpbWlsYXJseSwgdGhpcyBjb3VsZCBjcmFzaCBvbiBTYWZhcmkgaWYgdGhlIGVkaXRvciBpcyBoaWRkZW4sIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIHdhcyBubyBzZWxlY3Rpb24uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb21TZWxFeHRlbmRlZCkge1xuICAgICAgICAgICAgaWYgKGFuY2hvciA+IGhlYWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wID0gYW5jaG9yRE9NO1xuICAgICAgICAgICAgICAgIGFuY2hvckRPTSA9IGhlYWRET007XG4gICAgICAgICAgICAgICAgaGVhZERPTSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQoaGVhZERPTS5ub2RlLCBoZWFkRE9NLm9mZnNldCk7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgICAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICBkb21TZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb250ZW50RE9NICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIjtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRMb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTSAhPSB0aGlzLmRvbSAmJiAhdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGEgc3VidHJlZSBvZiB0aGUgZWxlbWVudCB0cmVlIHRoYXQgaGFzIGJlZW4gdG91Y2hlZFxuICAgIC8vIGJ5IGEgRE9NIGNoYW5nZSwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCByZWRyYXcgaXQuXG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IDAsIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gZW5kID8gZnJvbSA8PSBlbmQgJiYgdG8gPj0gb2Zmc2V0IDogZnJvbSA8IGVuZCAmJiB0byA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluc2lkZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlciwgZW5kSW5zaWRlID0gZW5kIC0gY2hpbGQuYm9yZGVyO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHN0YXJ0SW5zaWRlICYmIHRvIDw9IGVuZEluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZnJvbSA9PSBvZmZzZXQgfHwgdG8gPT0gZW5kID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSBzdGFydEluc2lkZSAmJiB0byA9PSBlbmRJbnNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaGlsZC5jb250ZW50TG9zdCB8fCBjaGlsZC5kb20ucGFyZW50Tm9kZSAhPSB0aGlzLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBOT0RFX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5tYXJrRGlydHkoZnJvbSAtIHN0YXJ0SW5zaWRlLCB0byAtIHN0YXJ0SW5zaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIWNoaWxkLmNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBDT05URU5UX0RJUlRZIDogTk9ERV9ESVJUWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eSA9IENPTlRFTlRfRElSVFk7XG4gICAgfVxuICAgIG1hcmtQYXJlbnRzRGlydHkoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IDE7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSB0aGlzLnBhcmVudDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50LCBsZXZlbCsrKSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSBsZXZlbCA9PSAxID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgICAgICAgICAgaWYgKG5vZGUuZGlydHkgPCBkaXJ0eSlcbiAgICAgICAgICAgICAgICBub2RlLmRpcnR5ID0gZGlydHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpZ25vcmVGb3JDb29yZHMoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlzVGV4dCh0ZXh0KSB7IHJldHVybiBmYWxzZTsgfVxufVxuLy8gQSB3aWRnZXQgZGVzYyByZXByZXNlbnRzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGVcbi8vIGRyYXduIGJldHdlZW4gdGhlIGRvY3VtZW50IG5vZGVzLlxuY2xhc3MgV2lkZ2V0Vmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgc2VsZiwgZG9tID0gd2lkZ2V0LnR5cGUudG9ET007XG4gICAgICAgIGlmICh0eXBlb2YgZG9tID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGRvbSA9IGRvbSh2aWV3LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGFyZW50LnBvc0JlZm9yZUNoaWxkKHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICghd2lkZ2V0LnR5cGUuc3BlYy5yYXcpIHtcbiAgICAgICAgICAgIGlmIChkb20ubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IHdyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci13aWRnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICBzZWxmID0gdGhpcztcbiAgICB9XG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHdpZGdldC50eXBlLmVxKHRoaXMud2lkZ2V0LnR5cGUpO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9OyB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCBzdG9wID0gdGhpcy53aWRnZXQuc3BlYy5zdG9wRXZlbnQ7XG4gICAgICAgIHJldHVybiBzdG9wID8gc3RvcChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIiB8fCB0aGlzLndpZGdldC5zcGVjLmlnbm9yZVNlbGVjdGlvbjtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy53aWRnZXQudHlwZS5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgc2lkZSgpIHsgcmV0dXJuIHRoaXMud2lkZ2V0LnR5cGUuc2lkZTsgfVxufVxuY2xhc3MgQ29tcG9zaXRpb25WaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGRvbSwgdGV4dERPTSwgdGV4dCkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICB0aGlzLnRleHRET00gPSB0ZXh0RE9NO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKGRvbSAhPSB0aGlzLnRleHRET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgKG9mZnNldCA/IHRoaXMuc2l6ZSA6IDApO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgb2Zmc2V0O1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLnRleHRET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dCkge1xuICAgICAgICByZXR1cm4gbXV0LnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWU7XG4gICAgfVxufVxuLy8gQSBtYXJrIGRlc2MgcmVwcmVzZW50cyBhIG1hcmsuIE1heSBoYXZlIG11bHRpcGxlIGNoaWxkcmVuLFxuLy8gZGVwZW5kaW5nIG9uIGhvdyB0aGUgbWFyayBpcyBzcGxpdC4gTm90ZSB0aGF0IG1hcmtzIGFyZSBkcmF3biB1c2luZ1xuLy8gYSBmaXhlZCBuZXN0aW5nIG9yZGVyLCBmb3Igc2ltcGxpY2l0eSBhbmQgcHJlZGljdGFiaWxpdHksIHNvIGluXG4vLyBzb21lIGNhc2VzIHRoZXkgd2lsbCBiZSBzcGxpdCBtb3JlIG9mdGVuIHRoYW4gd291bGQgYXBwZWFyXG4vLyBuZWNlc3NhcnkuXG5jbGFzcyBNYXJrVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBtYXJrLCBkb20sIGNvbnRlbnRET00sIHNwZWMpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG1hcmssIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQgY3VzdG9tID0gdmlldy5ub2RlVmlld3NbbWFyay50eXBlLm5hbWVdO1xuICAgICAgICBsZXQgc3BlYyA9IGN1c3RvbSAmJiBjdXN0b20obWFyaywgdmlldywgaW5saW5lKTtcbiAgICAgICAgaWYgKCFzcGVjIHx8ICFzcGVjLmRvbSlcbiAgICAgICAgICAgIHNwZWMgPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jdW1lbnQsIG1hcmsudHlwZS5zcGVjLnRvRE9NKG1hcmssIGlubGluZSksIG51bGwsIG1hcmsuYXR0cnMpO1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtWaWV3RGVzYyhwYXJlbnQsIG1hcmssIHNwZWMuZG9tLCBzcGVjLmNvbnRlbnRET00gfHwgc3BlYy5kb20sIHNwZWMpO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7XG4gICAgICAgIGlmICgodGhpcy5kaXJ0eSAmIE5PREVfRElSVFkpIHx8IHRoaXMubWFyay50eXBlLnNwZWMucmVwYXJzZUluVmlldylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4geyBtYXJrOiB0aGlzLm1hcmsudHlwZS5uYW1lLCBhdHRyczogdGhpcy5tYXJrLmF0dHJzLCBjb250ZW50RWxlbWVudDogdGhpcy5jb250ZW50RE9NIH07XG4gICAgfVxuICAgIG1hdGNoZXNNYXJrKG1hcmspIHsgcmV0dXJuIHRoaXMuZGlydHkgIT0gTk9ERV9ESVJUWSAmJiB0aGlzLm1hcmsuZXEobWFyayk7IH1cbiAgICBtYXJrRGlydHkoZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgICAgLy8gTW92ZSBkaXJ0eSBpbmZvIHRvIG5lYXJlc3Qgbm9kZSB2aWV3XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKCFwYXJlbnQubm9kZSlcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudC5kaXJ0eSA8IHRoaXMuZGlydHkpXG4gICAgICAgICAgICAgICAgcGFyZW50LmRpcnR5ID0gdGhpcy5kaXJ0eTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2xpY2UoZnJvbSwgdG8sIHZpZXcpIHtcbiAgICAgICAgbGV0IGNvcHkgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMucGFyZW50LCB0aGlzLm1hcmssIHRydWUsIHZpZXcpO1xuICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLmNoaWxkcmVuLCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgICBpZiAodG8gPCBzaXplKVxuICAgICAgICAgICAgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIHRvLCBzaXplLCB2aWV3KTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIDAsIGZyb20sIHZpZXcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbm9kZXNbaV0ucGFyZW50ID0gY29weTtcbiAgICAgICAgY29weS5jaGlsZHJlbiA9IG5vZGVzO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBzdXBlci5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vLyBOb2RlIHZpZXcgZGVzY3MgYXJlIHRoZSBtYWluLCBtb3N0IGNvbW1vbiB0eXBlIG9mIHZpZXcgZGVzYywgYW5kXG4vLyBjb3JyZXNwb25kIHRvIGFuIGFjdHVhbCBub2RlIGluIHRoZSBkb2N1bWVudC4gVW5saWtlIG1hcmsgZGVzY3MsXG4vLyB0aGV5IHBvcHVsYXRlIHRoZWlyIGNoaWxkIGFycmF5IHRoZW1zZWx2ZXMuXG5jbGFzcyBOb2RlVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgICAgIHRoaXMuaW5uZXJEZWNvID0gaW5uZXJEZWNvO1xuICAgICAgICB0aGlzLm5vZGVET00gPSBub2RlRE9NO1xuICAgIH1cbiAgICAvLyBCeSBkZWZhdWx0LCBhIG5vZGUgaXMgcmVuZGVyZWQgdXNpbmcgdGhlIGB0b0RPTWAgbWV0aG9kIGZyb20gdGhlXG4gICAgLy8gbm9kZSB0eXBlIHNwZWMuIEJ1dCBjbGllbnQgY29kZSBjYW4gdXNlIHRoZSBgbm9kZVZpZXdzYCBzcGVjIHRvXG4gICAgLy8gc3VwcGx5IGEgY3VzdG9tIG5vZGUgdmlldywgd2hpY2ggY2FuIGluZmx1ZW5jZSB2YXJpb3VzIGFzcGVjdHMgb2ZcbiAgICAvLyB0aGUgd2F5IHRoZSBub2RlIHdvcmtzLlxuICAgIC8vXG4gICAgLy8gKFVzaW5nIHN1YmNsYXNzaW5nIGZvciB0aGlzIHdhcyBpbnRlbnRpb25hbGx5IGRlY2lkZWQgYWdhaW5zdCxcbiAgICAvLyBzaW5jZSBpdCdkIHJlcXVpcmUgZXhwb3NpbmcgYSB3aG9sZSBzbGV3IG9mIGZpbmlja3lcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIHRvIHRoZSB1c2VyIGNvZGUgdGhhdCB0aGV5IHByb2JhYmx5IHdpbGxcbiAgICAvLyBuZXZlciBuZWVkLilcbiAgICBzdGF0aWMgY3JlYXRlKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgY3VzdG9tID0gdmlldy5ub2RlVmlld3Nbbm9kZS50eXBlLm5hbWVdLCBkZXNjT2JqO1xuICAgICAgICBsZXQgc3BlYyA9IGN1c3RvbSAmJiBjdXN0b20obm9kZSwgdmlldywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gKFRoaXMgaXMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB0aGUgY3VzdG9tIHZpZXcgdG8gZmluZCBpdHNcbiAgICAgICAgICAgIC8vIG93biBwb3NpdGlvbilcbiAgICAgICAgICAgIGlmICghZGVzY09iailcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgaWYgKGRlc2NPYmoucGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjT2JqLnBhcmVudC5wb3NCZWZvcmVDaGlsZChkZXNjT2JqKTtcbiAgICAgICAgfSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICBsZXQgZG9tID0gc3BlYyAmJiBzcGVjLmRvbSwgY29udGVudERPTSA9IHNwZWMgJiYgc3BlYy5jb250ZW50RE9NO1xuICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgIGlmICghZG9tKVxuICAgICAgICAgICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgIT0gMylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRleHQgbXVzdCBiZSByZW5kZXJlZCBhcyBhIERPTSB0ZXh0IG5vZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRvbSkge1xuICAgICAgICAgICAgbGV0IHNwZWMgPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jdW1lbnQsIG5vZGUudHlwZS5zcGVjLnRvRE9NKG5vZGUpLCBudWxsLCBub2RlLmF0dHJzKTtcbiAgICAgICAgICAgICh7IGRvbSwgY29udGVudERPTSB9ID0gc3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250ZW50RE9NICYmICFub2RlLmlzVGV4dCAmJiBkb20ubm9kZU5hbWUgIT0gXCJCUlwiKSB7IC8vIENocm9tZSBnZXRzIGNvbmZ1c2VkIGJ5IDxiciBjb250ZW50ZWRpdGFibGU9ZmFsc2U+XG4gICAgICAgICAgICBpZiAoIWRvbS5oYXNBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikpXG4gICAgICAgICAgICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpXG4gICAgICAgICAgICAgICAgZG9tLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGVET00gPSBkb207XG4gICAgICAgIGRvbSA9IGFwcGx5T3V0ZXJEZWNvKGRvbSwgb3V0ZXJEZWNvLCBub2RlKTtcbiAgICAgICAgaWYgKHNwZWMpXG4gICAgICAgICAgICByZXR1cm4gZGVzY09iaiA9IG5ldyBDdXN0b21Ob2RlVmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NIHx8IG51bGwsIG5vZGVET00sIHNwZWMsIHZpZXcsIHBvcyArIDEpO1xuICAgICAgICBlbHNlIGlmIChub2RlLmlzVGV4dClcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbm9kZURPTSwgdmlldyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCB2aWV3LCBwb3MgKyAxKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICAvLyBFeHBlcmltZW50YWwga2x1ZGdlIHRvIGFsbG93IG9wdC1pbiByZS1wYXJzaW5nIG9mIG5vZGVzXG4gICAgICAgIGlmICh0aGlzLm5vZGUudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gRklYTUUgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGNhbiBhbHdheXMgcmV0dXJuIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIGF0dHJzIG1lYW5zIHRoYXQgaWYgdGhlIHVzZXIgc29tZWhvdyBtYW5hZ2VzIHRvIGNoYW5nZSB0aGVcbiAgICAgICAgLy8gYXR0cnMgaW4gdGhlIGRvbSwgdGhhdCB3b24ndCBiZSBwaWNrZWQgdXAuIE5vdCBlbnRpcmVseSBzdXJlXG4gICAgICAgIC8vIHdoZXRoZXIgdGhpcyBpcyBhIHByb2JsZW1cbiAgICAgICAgbGV0IHJ1bGUgPSB7IG5vZGU6IHRoaXMubm9kZS50eXBlLm5hbWUsIGF0dHJzOiB0aGlzLm5vZGUuYXR0cnMgfTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS50eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIilcbiAgICAgICAgICAgIHJ1bGUucHJlc2VydmVXaGl0ZXNwYWNlID0gXCJmdWxsXCI7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICBydWxlLmdldENvbnRlbnQgPSAoKSA9PiB0aGlzLm5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZW50TG9zdCkge1xuICAgICAgICAgICAgcnVsZS5jb250ZW50RWxlbWVudCA9IHRoaXMuY29udGVudERPTTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBsaWtlcyB0byByYW5kb21seSByZWNyZWF0ZSBwYXJlbnQgbm9kZXMgd2hlblxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgdGhpbmdzLiBXaGVuIHRoYXQgaGFwcGVucywgdGhpcyB0cmllcyB0byBmaW5kIHRoZVxuICAgICAgICAgICAgLy8gbmV3IHBhcmVudC5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb20uY29udGFpbnMoY2hpbGQuZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSBjaGlsZC5kb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFydWxlLmNvbnRlbnRFbGVtZW50KVxuICAgICAgICAgICAgICAgIHJ1bGUuZ2V0Q29udGVudCA9ICgpID0+IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgIH1cbiAgICBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJ0eSA9PSBOT1RfRElSVFkgJiYgbm9kZS5lcSh0aGlzLm5vZGUpICYmXG4gICAgICAgICAgICBzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5vdXRlckRlY28pICYmIGlubmVyRGVjby5lcSh0aGlzLmlubmVyRGVjbyk7XG4gICAgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5ub2RlLm5vZGVTaXplOyB9XG4gICAgZ2V0IGJvcmRlcigpIHsgcmV0dXJuIHRoaXMubm9kZS5pc0xlYWYgPyAwIDogMTsgfVxuICAgIC8vIFN5bmNzIGB0aGlzLmNoaWxkcmVuYCB0byBtYXRjaCBgdGhpcy5ub2RlLmNvbnRlbnRgIGFuZCB0aGUgbG9jYWxcbiAgICAvLyBkZWNvcmF0aW9ucywgcG9zc2libHkgaW50cm9kdWNpbmcgbmVzdGluZyBmb3IgbWFya3MuIFRoZW4sIGluIGFcbiAgICAvLyBzZXBhcmF0ZSBzdGVwLCBzeW5jcyB0aGUgRE9NIGluc2lkZSBgdGhpcy5jb250ZW50RE9NYCB0b1xuICAgIC8vIGB0aGlzLmNoaWxkcmVuYC5cbiAgICB1cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGlubGluZSA9IHRoaXMubm9kZS5pbmxpbmVDb250ZW50LCBvZmYgPSBwb3M7XG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHZpZXcuY29tcG9zaW5nID8gdGhpcy5sb2NhbENvbXBvc2l0aW9uSW5mbyh2aWV3LCBwb3MpIDogbnVsbDtcbiAgICAgICAgbGV0IGxvY2FsQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPiAtMSA/IGNvbXBvc2l0aW9uIDogbnVsbDtcbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uSW5DaGlsZCA9IGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnBvcyA8IDA7XG4gICAgICAgIGxldCB1cGRhdGVyID0gbmV3IFZpZXdUcmVlVXBkYXRlcih0aGlzLCBsb2NhbENvbXBvc2l0aW9uICYmIGxvY2FsQ29tcG9zaXRpb24ubm9kZSwgdmlldyk7XG4gICAgICAgIGl0ZXJEZWNvKHRoaXMubm9kZSwgdGhpcy5pbm5lckRlY28sICh3aWRnZXQsIGksIGluc2lkZU5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmICh3aWRnZXQuc3BlYy5tYXJrcylcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKHdpZGdldC5zcGVjLm1hcmtzLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICAgICAgZWxzZSBpZiAod2lkZ2V0LnR5cGUuc2lkZSA+PSAwICYmICFpbnNpZGVOb2RlKVxuICAgICAgICAgICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoaSA9PSB0aGlzLm5vZGUuY2hpbGRDb3VudCA/IE1hcmsubm9uZSA6IHRoaXMubm9kZS5jaGlsZChpKS5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgYSBkZXNjIG1hdGNoaW5nIHRoaXMgd2lkZ2V0LCByZXVzZSBpdCxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpbnNlcnQgdGhlIHdpZGdldCBhcyBhIG5ldyB2aWV3IGRlc2MuXG4gICAgICAgICAgICB1cGRhdGVyLnBsYWNlV2lkZ2V0KHdpZGdldCwgdmlldywgb2ZmKTtcbiAgICAgICAgfSwgKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgaSkgPT4ge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB3cmFwcGluZyBtYXJrIGRlc2NzIG1hdGNoIHRoZSBub2RlJ3MgbWFya3MuXG4gICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGNoaWxkLm1hcmtzLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICAgICAgLy8gVHJ5IHNldmVyYWwgc3RyYXRlZ2llcyBmb3IgZHJhd2luZyB0aGlzIG5vZGVcbiAgICAgICAgICAgIGxldCBjb21wSW5kZXg7XG4gICAgICAgICAgICBpZiAodXBkYXRlci5maW5kTm9kZU1hdGNoKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgaSkpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvc2l0aW9uSW5DaGlsZCAmJiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tID4gb2ZmICYmXG4gICAgICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gPCBvZmYgKyBjaGlsZC5ub2RlU2l6ZSAmJlxuICAgICAgICAgICAgICAgIChjb21wSW5kZXggPSB1cGRhdGVyLmZpbmRJbmRleFdpdGhDaGlsZChjb21wb3NpdGlvbi5ub2RlKSkgPiAtMSAmJlxuICAgICAgICAgICAgICAgIHVwZGF0ZXIudXBkYXRlTm9kZUF0KGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgY29tcEluZGV4LCB2aWV3KSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAodXBkYXRlci51cGRhdGVOZXh0Tm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGksIG9mZikpIDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBpdCBhcyBhIG5ldyB2aWV3XG4gICAgICAgICAgICAgICAgdXBkYXRlci5hZGROb2RlKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgb2ZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERyb3AgYWxsIHJlbWFpbmluZyBkZXNjcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhbXSwgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHVwZGF0ZXIuYWRkVGV4dGJsb2NrSGFja3MoKTtcbiAgICAgICAgdXBkYXRlci5kZXN0cm95UmVzdCgpO1xuICAgICAgICAvLyBTeW5jIHRoZSBET00gaWYgYW55dGhpbmcgY2hhbmdlZFxuICAgICAgICBpZiAodXBkYXRlci5jaGFuZ2VkIHx8IHRoaXMuZGlydHkgPT0gQ09OVEVOVF9ESVJUWSkge1xuICAgICAgICAgICAgLy8gTWF5IGhhdmUgdG8gcHJvdGVjdCBmb2N1c2VkIERPTSBmcm9tIGJlaW5nIGNoYW5nZWQgaWYgYSBjb21wb3NpdGlvbiBpcyBhY3RpdmVcbiAgICAgICAgICAgIGlmIChsb2NhbENvbXBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvdGVjdExvY2FsQ29tcG9zaXRpb24odmlldywgbG9jYWxDb21wb3NpdGlvbik7XG4gICAgICAgICAgICByZW5kZXJEZXNjcyh0aGlzLmNvbnRlbnRET00sIHRoaXMuY2hpbGRyZW4sIHZpZXcpO1xuICAgICAgICAgICAgaWYgKGlvcylcbiAgICAgICAgICAgICAgICBpb3NIYWNrcyh0aGlzLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSB7XG4gICAgICAgIC8vIE9ubHkgZG8gc29tZXRoaW5nIGlmIGJvdGggdGhlIHNlbGVjdGlvbiBhbmQgYSBmb2N1c2VkIHRleHQgbm9kZVxuICAgICAgICAvLyBhcmUgaW5zaWRlIG9mIHRoaXMgbm9kZVxuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikgfHwgZnJvbSA8IHBvcyB8fCB0byA+IHBvcyArIHRoaXMubm9kZS5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRleHROb2RlID0gdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGU7XG4gICAgICAgIGlmICghdGV4dE5vZGUgfHwgIXRoaXMuZG9tLmNvbnRhaW5zKHRleHROb2RlLnBhcmVudE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdGV4dCBpbiB0aGUgZm9jdXNlZCBub2RlIGluIHRoZSBub2RlLCBzdG9wIGlmIGl0J3Mgbm90XG4gICAgICAgICAgICAvLyB0aGVyZSAobWF5IGhhdmUgYmVlbiBtb2RpZmllZCB0aHJvdWdoIG90aGVyIG1lYW5zLCBpbiB3aGljaFxuICAgICAgICAgICAgLy8gY2FzZSBpdCBzaG91bGQgb3ZlcndyaXR0ZW4pXG4gICAgICAgICAgICBsZXQgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIGxldCB0ZXh0UG9zID0gZmluZFRleHRJbkZyYWdtZW50KHRoaXMubm9kZS5jb250ZW50LCB0ZXh0LCBmcm9tIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFBvcyA8IDAgPyBudWxsIDogeyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiB0ZXh0UG9zLCB0ZXh0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiAtMSwgdGV4dDogXCJcIiB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIHsgbm9kZSwgcG9zLCB0ZXh0IH0pIHtcbiAgICAgICAgLy8gVGhlIG5vZGUgaXMgYWxyZWFkeSBwYXJ0IG9mIGEgbG9jYWwgdmlldyBkZXNjLCBsZWF2ZSBpdCB0aGVyZVxuICAgICAgICBpZiAodGhpcy5nZXREZXNjKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb21wb3NpdGlvbiB2aWV3IGZvciB0aGUgb3JwaGFuZWQgbm9kZXNcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBub2RlO1xuICAgICAgICBmb3IgKDs7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0b3BOb2RlLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgd2hpbGUgKHRvcE5vZGUucHJldmlvdXNTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b3BOb2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICB3aGlsZSAodG9wTm9kZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBpZiAodG9wTm9kZS5wbVZpZXdEZXNjKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVzYyA9IG5ldyBDb21wb3NpdGlvblZpZXdEZXNjKHRoaXMsIHRvcE5vZGUsIG5vZGUsIHRleHQpO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucHVzaChkZXNjKTtcbiAgICAgICAgLy8gUGF0Y2ggdXAgdGhpcy5jaGlsZHJlbiB0byBjb250YWluIHRoZSBjb21wb3NpdGlvbiB2aWV3XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSByZXBsYWNlTm9kZXModGhpcy5jaGlsZHJlbiwgcG9zLCBwb3MgKyB0ZXh0Lmxlbmd0aCwgdmlldywgZGVzYyk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgZGVzYyBtdXN0IGJlIHVwZGF0ZWQgdG8gbWF0Y2ggdGhlIGdpdmVuIG5vZGUgZGVjb3JhdGlvbixcbiAgICAvLyBkbyBzbyBhbmQgcmV0dXJuIHRydWUuXG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkgfHxcbiAgICAgICAgICAgICFub2RlLnNhbWVNYXJrdXAodGhpcy5ub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4odmlldywgdGhpcy5wb3NBdFN0YXJ0KTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICB9XG4gICAgdXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbykge1xuICAgICAgICBpZiAoc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG5lZWRzV3JhcCA9IHRoaXMubm9kZURPTS5ub2RlVHlwZSAhPSAxO1xuICAgICAgICBsZXQgb2xkRE9NID0gdGhpcy5kb207XG4gICAgICAgIHRoaXMuZG9tID0gcGF0Y2hPdXRlckRlY28odGhpcy5kb20sIHRoaXMubm9kZURPTSwgY29tcHV0ZU91dGVyRGVjbyh0aGlzLm91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApLCBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9IG9sZERPTSkge1xuICAgICAgICAgICAgb2xkRE9NLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dGVyRGVjbyA9IG91dGVyRGVjbztcbiAgICB9XG4gICAgLy8gTWFyayB0aGlzIG5vZGUgYXMgYmVpbmcgdGhlIHNlbGVjdGVkIG5vZGUuXG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZURPTS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgdGhpcy5kb20uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHNlbGVjdGVkIG5vZGUgbWFya2luZyBmcm9tIHRoaXMgbm9kZS5cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVET00ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0aGlzLm5vZGUuaXNBdG9tOyB9XG59XG4vLyBDcmVhdGUgYSB2aWV3IGRlc2MgZm9yIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgbm9kZSwgdG8gYmUgZXhwb3J0ZWRcbi8vIGFuZCB1c2VkIGJ5IHRoZSB2aWV3IGNsYXNzLlxuZnVuY3Rpb24gZG9jVmlld0Rlc2MoZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCB2aWV3KSB7XG4gICAgYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIGRvYyk7XG4gICAgbGV0IGRvY1ZpZXcgPSBuZXcgTm9kZVZpZXdEZXNjKHVuZGVmaW5lZCwgZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBkb20sIGRvbSwgdmlldywgMCk7XG4gICAgaWYgKGRvY1ZpZXcuY29udGVudERPTSlcbiAgICAgICAgZG9jVmlldy51cGRhdGVDaGlsZHJlbih2aWV3LCAwKTtcbiAgICByZXR1cm4gZG9jVmlldztcbn1cbmNsYXNzIFRleHRWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBub2RlRE9NLCB2aWV3KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbnVsbCwgbm9kZURPTSwgdmlldywgMCk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgbGV0IHNraXAgPSB0aGlzLm5vZGVET00ucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKHNraXAgJiYgc2tpcCAhPSB0aGlzLmRvbSAmJiAhc2tpcC5wbUlzRGVjbylcbiAgICAgICAgICAgIHNraXAgPSBza2lwLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiB7IHNraXA6IChza2lwIHx8IHRydWUpIH07XG4gICAgfVxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8ICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSAmJiAhdGhpcy5pblBhcmVudCgpKSB8fFxuICAgICAgICAgICAgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZIHx8IG5vZGUudGV4dCAhPSB0aGlzLm5vZGUudGV4dCkgJiYgbm9kZS50ZXh0ICE9IHRoaXMubm9kZURPTS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5ub2RlVmFsdWUgPSBub2RlLnRleHQ7XG4gICAgICAgICAgICBpZiAodmlldy50cmFja1dyaXRlcyA9PSB0aGlzLm5vZGVET00pXG4gICAgICAgICAgICAgICAgdmlldy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluUGFyZW50KCkge1xuICAgICAgICBsZXQgcGFyZW50RE9NID0gdGhpcy5wYXJlbnQuY29udGVudERPTTtcbiAgICAgICAgZm9yIChsZXQgbiA9IHRoaXMubm9kZURPTTsgbjsgbiA9IG4ucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIGlmIChuID09IHBhcmVudERPTSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLm5vZGVET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgICBpZiAoZG9tID09IHRoaXMubm9kZURPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyBNYXRoLm1pbihvZmZzZXQsIHRoaXMubm9kZS50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSAhPSBcImNoYXJhY3RlckRhdGFcIiAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlLmN1dChmcm9tLCB0byksIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHRoaXMucGFyZW50LCBub2RlLCB0aGlzLm91dGVyRGVjbywgdGhpcy5pbm5lckRlY28sIGRvbSwgZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSB0aGlzLm5vZGVET00gJiYgKGZyb20gPT0gMCB8fCB0byA9PSB0aGlzLm5vZGVET00ubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlzVGV4dCh0ZXh0KSB7IHJldHVybiB0aGlzLm5vZGUudGV4dCA9PSB0ZXh0OyB9XG59XG4vLyBBIGR1bW15IGRlc2MgdXNlZCB0byB0YWcgdHJhaWxpbmcgQlIgb3IgSU1HIG5vZGVzIGNyZWF0ZWQgdG8gd29ya1xuLy8gYXJvdW5kIGNvbnRlbnRFZGl0YWJsZSB0ZXJyaWJsZW5lc3MuXG5jbGFzcyBUcmFpbGluZ0hhY2tWaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9OyB9XG4gICAgbWF0Y2hlc0hhY2sobm9kZU5hbWUpIHsgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHRoaXMuZG9tLm5vZGVOYW1lID09IG5vZGVOYW1lOyB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlnbm9yZUZvckNvb3JkcygpIHsgcmV0dXJuIHRoaXMuZG9tLm5vZGVOYW1lID09IFwiSU1HXCI7IH1cbn1cbi8vIEEgc2VwYXJhdGUgc3ViY2xhc3MgaXMgdXNlZCBmb3IgY3VzdG9taXplZCBub2RlIHZpZXdzLCBzbyB0aGF0IHRoZVxuLy8gZXh0cmEgY2hlY2tzIG9ubHkgaGF2ZSB0byBiZSBtYWRlIGZvciBub2RlcyB0aGF0IGFyZSBhY3R1YWxseVxuLy8gY3VzdG9taXplZC5cbmNsYXNzIEN1c3RvbU5vZGVWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvLyBBIGN1c3RvbSBgdXBkYXRlYCBtZXRob2QgZ2V0cyB0byBkZWNpZGUgd2hldGhlciB0aGUgdXBkYXRlIGdvZXNcbiAgICAvLyB0aHJvdWdoLiBJZiBpdCBkb2VzLCBhbmQgdGhlcmUncyBhIGBjb250ZW50RE9NYCBub2RlLCBvdXIgbG9naWNcbiAgICAvLyB1cGRhdGVzIHRoZSBjaGlsZHJlbi5cbiAgICB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy51cGRhdGUgJiYgKHRoaXMubm9kZS50eXBlID09IG5vZGUudHlwZSB8fCB0aGlzLnNwZWMubXVsdGlUeXBlKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3BlYy51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGVudERPTSAmJiAhbm9kZS5pc0xlYWYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYy5zZWxlY3ROb2RlID8gdGhpcy5zcGVjLnNlbGVjdE5vZGUoKSA6IHN1cGVyLnNlbGVjdE5vZGUoKTtcbiAgICB9XG4gICAgZGVzZWxlY3ROb2RlKCkge1xuICAgICAgICB0aGlzLnNwZWMuZGVzZWxlY3ROb2RlID8gdGhpcy5zcGVjLmRlc2VsZWN0Tm9kZSgpIDogc3VwZXIuZGVzZWxlY3ROb2RlKCk7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHZpZXcsIGZvcmNlKSB7XG4gICAgICAgIHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24gPyB0aGlzLnNwZWMuc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldy5yb290KVxuICAgICAgICAgICAgOiBzdXBlci5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LCBmb3JjZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMuc3RvcEV2ZW50ID8gdGhpcy5zcGVjLnN0b3BFdmVudChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBzdXBlci5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgfVxufVxuLy8gU3luYyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgd2l0aCB0aGUgbm9kZXMgYXNzb2NpYXRlZFxuLy8gd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgdmlldyBkZXNjcywgcmVjdXJzaW5nIGludG8gbWFyayBkZXNjc1xuLy8gYmVjYXVzZSB0aGlzIHNob3VsZCBzeW5jIHRoZSBzdWJ0cmVlIGZvciBhIHdob2xlIG5vZGUgYXQgYSB0aW1lLlxuZnVuY3Rpb24gcmVuZGVyRGVzY3MocGFyZW50RE9NLCBkZXNjcywgdmlldykge1xuICAgIGxldCBkb20gPSBwYXJlbnRET00uZmlyc3RDaGlsZCwgd3JpdHRlbiA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkZXNjc1tpXSwgY2hpbGRET00gPSBkZXNjLmRvbTtcbiAgICAgICAgaWYgKGNoaWxkRE9NLnBhcmVudE5vZGUgPT0gcGFyZW50RE9NKSB7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRET00gIT0gZG9tKSB7XG4gICAgICAgICAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgcGFyZW50RE9NLmluc2VydEJlZm9yZShjaGlsZERPTSwgZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvbSA/IGRvbS5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnRET00ubGFzdENoaWxkO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3MoZGVzYy5jb250ZW50RE9NLCBkZXNjLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGRvbSA9IHBvcyA/IHBvcy5uZXh0U2libGluZyA6IHBhcmVudERPTS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICh3cml0dGVuICYmIHZpZXcudHJhY2tXcml0ZXMgPT0gcGFyZW50RE9NKVxuICAgICAgICB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbn1cbmNvbnN0IE91dGVyRGVjb0xldmVsID0gZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gICAgaWYgKG5vZGVOYW1lKVxuICAgICAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG59O1xuT3V0ZXJEZWNvTGV2ZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IG5vRGVjbyA9IFtuZXcgT3V0ZXJEZWNvTGV2ZWxdO1xuZnVuY3Rpb24gY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIG5vZGUsIG5lZWRzV3JhcCkge1xuICAgIGlmIChvdXRlckRlY28ubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBub0RlY287XG4gICAgbGV0IHRvcCA9IG5lZWRzV3JhcCA/IG5vRGVjb1swXSA6IG5ldyBPdXRlckRlY29MZXZlbCwgcmVzdWx0ID0gW3RvcF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRlckRlY28ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHJzID0gb3V0ZXJEZWNvW2ldLnR5cGUuYXR0cnM7XG4gICAgICAgIGlmICghYXR0cnMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGF0dHJzLm5vZGVOYW1lKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKGF0dHJzLm5vZGVOYW1lKSk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZWVkc1dyYXAgJiYgcmVzdWx0Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvcCA9IG5ldyBPdXRlckRlY29MZXZlbChub2RlLmlzSW5saW5lID8gXCJzcGFuXCIgOiBcImRpdlwiKSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgdG9wLmNsYXNzID0gKHRvcC5jbGFzcyA/IHRvcC5jbGFzcyArIFwiIFwiIDogXCJcIikgKyB2YWw7XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICB0b3Auc3R5bGUgPSAodG9wLnN0eWxlID8gdG9wLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgIHRvcFtuYW1lXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGF0Y2hPdXRlckRlY28ob3V0ZXJET00sIG5vZGVET00sIHByZXZDb21wdXRlZCwgY3VyQ29tcHV0ZWQpIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgdHJpdmlhbCBjYXNlXG4gICAgaWYgKHByZXZDb21wdXRlZCA9PSBub0RlY28gJiYgY3VyQ29tcHV0ZWQgPT0gbm9EZWNvKVxuICAgICAgICByZXR1cm4gbm9kZURPTTtcbiAgICBsZXQgY3VyRE9NID0gbm9kZURPTTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ckNvbXB1dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZWNvID0gY3VyQ29tcHV0ZWRbaV0sIHByZXYgPSBwcmV2Q29tcHV0ZWRbaV07XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5ub2RlTmFtZSA9PSBkZWNvLm5vZGVOYW1lICYmIGN1ckRPTSAhPSBvdXRlckRPTSAmJlxuICAgICAgICAgICAgICAgIChwYXJlbnQgPSBjdXJET00ucGFyZW50Tm9kZSkgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gZGVjby5ub2RlTmFtZSkge1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGVjby5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50LnBtSXNEZWNvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3VyRE9NKTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9EZWNvWzBdO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXRjaEF0dHJpYnV0ZXMoY3VyRE9NLCBwcmV2IHx8IG5vRGVjb1swXSwgZGVjbyk7XG4gICAgfVxuICAgIHJldHVybiBjdXJET007XG59XG5mdW5jdGlvbiBwYXRjaEF0dHJpYnV0ZXMoZG9tLCBwcmV2LCBjdXIpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiAhKG5hbWUgaW4gY3VyKSlcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBjdXIpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiBjdXJbbmFtZV0gIT0gcHJldltuYW1lXSlcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgY3VyW25hbWVdKTtcbiAgICBpZiAocHJldi5jbGFzcyAhPSBjdXIuY2xhc3MpIHtcbiAgICAgICAgbGV0IHByZXZMaXN0ID0gcHJldi5jbGFzcyA/IHByZXYuY2xhc3Muc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBsZXQgY3VyTGlzdCA9IGN1ci5jbGFzcyA/IGN1ci5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY3VyTGlzdC5pbmRleE9mKHByZXZMaXN0W2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NMaXN0LnJlbW92ZShwcmV2TGlzdFtpXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwcmV2TGlzdC5pbmRleE9mKGN1ckxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKGN1ckxpc3RbaV0pO1xuICAgICAgICBpZiAoZG9tLmNsYXNzTGlzdC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKHByZXYuc3R5bGUgIT0gY3VyLnN0eWxlKSB7XG4gICAgICAgIGlmIChwcmV2LnN0eWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IC9cXHMqKFtcXHdcXC1cXHhhMS1cXHVmZmZmXSspXFxzKjooPzpcIig/OlxcXFwufFteXCJdKSpcInwnKD86XFxcXC58W14nXSkqJ3xcXCguKj9cXCl8W147XSkqL2csIG07XG4gICAgICAgICAgICB3aGlsZSAobSA9IHByb3AuZXhlYyhwcmV2LnN0eWxlKSlcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUucmVtb3ZlUHJvcGVydHkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5zdHlsZSlcbiAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ICs9IGN1ci5zdHlsZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseU91dGVyRGVjbyhkb20sIGRlY28sIG5vZGUpIHtcbiAgICByZXR1cm4gcGF0Y2hPdXRlckRlY28oZG9tLCBkb20sIG5vRGVjbywgY29tcHV0ZU91dGVyRGVjbyhkZWNvLCBub2RlLCBkb20ubm9kZVR5cGUgIT0gMSkpO1xufVxuZnVuY3Rpb24gc2FtZU91dGVyRGVjbyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0udHlwZS5lcShiW2ldLnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0oZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8vIEhlbHBlciBjbGFzcyBmb3IgaW5jcmVtZW50YWxseSB1cGRhdGluZyBhIHRyZWUgb2YgbWFyayBkZXNjcyBhbmRcbi8vIHRoZSB3aWRnZXQgYW5kIG5vZGUgZGVzY3MgaW5zaWRlIG9mIHRoZW0uXG5jbGFzcyBWaWV3VHJlZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgbG9jaywgdmlldykge1xuICAgICAgICB0aGlzLmxvY2sgPSBsb2NrO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAvLyBJbmRleCBpbnRvIGB0aGlzLnRvcGAncyBjaGlsZCBhcnJheSwgcmVwcmVzZW50cyB0aGUgY3VycmVudFxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBXaGVuIGVudGVyaW5nIGEgbWFyaywgdGhlIGN1cnJlbnQgdG9wIGFuZCBpbmRleCBhcmUgcHVzaGVkXG4gICAgICAgIC8vIG9udG8gdGhpcy5cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciBhbnl0aGluZyB3YXMgY2hhbmdlZFxuICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMucHJlTWF0Y2ggPSBwcmVNYXRjaCh0b3Aubm9kZS5jb250ZW50LCB0b3ApO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFuZCByZW1vdmUgdGhlIGNoaWxkcmVuIGJldHdlZW4gdGhlIGdpdmVuIGluZGljZXMgaW5cbiAgICAvLyBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lCZXR3ZWVuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFsbCByZW1haW5pbmcgY2hpbGRyZW4gaW4gYHRoaXMudG9wYC5cbiAgICBkZXN0cm95UmVzdCgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBjdXJyZW50IHN0YWNrIG9mIG1hcmsgZGVzY3Mgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2ZcbiAgICAvLyBtYXJrcywgcmV1c2luZyBleGlzdGluZyBtYXJrIGRlc2NzIHdoZW4gcG9zc2libGUuXG4gICAgc3luY1RvTWFya3MobWFya3MsIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQga2VlcCA9IDAsIGRlcHRoID0gdGhpcy5zdGFjay5sZW5ndGggPj4gMTtcbiAgICAgICAgbGV0IG1heEtlZXAgPSBNYXRoLm1pbihkZXB0aCwgbWFya3MubGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBtYXhLZWVwICYmXG4gICAgICAgICAgICAoa2VlcCA9PSBkZXB0aCAtIDEgPyB0aGlzLnRvcCA6IHRoaXMuc3RhY2tbKGtlZXAgKyAxKSA8PCAxXSlcbiAgICAgICAgICAgICAgICAubWF0Y2hlc01hcmsobWFya3Nba2VlcF0pICYmIG1hcmtzW2tlZXBdLnR5cGUuc3BlYy5zcGFubmluZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICBrZWVwKys7XG4gICAgICAgIHdoaWxlIChrZWVwIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgICAgIHRoaXMudG9wLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkZXB0aCA8IG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMudG9wLCB0aGlzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgTWF0aC5taW4odGhpcy5pbmRleCArIDMsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubWF0Y2hlc01hcmsobWFya3NbZGVwdGhdKSAmJiAhdGhpcy5pc0xvY2tlZChuZXh0LmRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya0Rlc2MgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBtYXJrc1tkZXB0aF0sIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgsIDAsIG1hcmtEZXNjKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcCA9IG1hcmtEZXNjO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBub2RlIGRlc2MgbWF0Y2hpbmcgdGhlIGdpdmVuIGRhdGEuIFNraXAgb3ZlciBpdCBhbmRcbiAgICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHN1Y2Nlc3NmdWwuXG4gICAgZmluZE5vZGVNYXRjaChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gLTEsIHRhcmdldERlc2M7XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLnByZU1hdGNoLmluZGV4ICYmXG4gICAgICAgICAgICAodGFyZ2V0RGVzYyA9IHRoaXMucHJlTWF0Y2gubWF0Y2hlc1tpbmRleCAtIHRoaXMucHJlTWF0Y2guaW5kZXhdKS5wYXJlbnQgPT0gdGhpcy50b3AgJiZcbiAgICAgICAgICAgIHRhcmdldERlc2MubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRoaXMudG9wLmNoaWxkcmVuLmluZGV4T2YodGFyZ2V0RGVzYywgdGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleCwgZSA9IE1hdGgubWluKHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCwgaSArIDUpOyBpIDwgZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSAmJiAhdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHVwZGF0ZU5vZGVBdChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgsIHZpZXcpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGQuZGlydHkgPT0gTk9ERV9ESVJUWSAmJiBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSlcbiAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgaWYgKCFjaGlsZC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGluZGV4KTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZmluZEluZGV4V2l0aENoaWxkKGRvbU5vZGUpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgIGxldCBkZXNjID0gZG9tTm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b3AuY2hpbGRyZW5baV0gPT0gZGVzYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbU5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIHVwZGF0ZSB0aGUgbmV4dCBub2RlLCBpZiBhbnksIHRvIHRoZSBnaXZlbiBkYXRhLiBDaGVja3NcbiAgICAvLyBwcmUtbWF0Y2hlcyB0byBhdm9pZCBvdmVyd3JpdGluZyBub2RlcyB0aGF0IGNvdWxkIHN0aWxsIGJlIHVzZWQuXG4gICAgdXBkYXRlTmV4dE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGluZGV4LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTm9kZVZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZU1hdGNoID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmdldChuZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJlTWF0Y2ggIT0gbnVsbCAmJiBwcmVNYXRjaCAhPSBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0RE9NID0gbmV4dC5kb20sIHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdXBkYXRlIGlmIG5leHRET00gaXMgb3IgY29udGFpbnMgdGhpcy5sb2NrLCBleGNlcHQgaWZcbiAgICAgICAgICAgICAgICAvLyBpdCdzIGEgdGV4dCBub2RlIHdob3NlIGNvbnRlbnQgYWxyZWFkeSBtYXRjaGVzIHRoZSBuZXcgdGV4dFxuICAgICAgICAgICAgICAgIC8vIGFuZCB3aG9zZSBkZWNvcmF0aW9ucyBtYXRjaCB0aGUgbmV3IG9uZXMuXG4gICAgICAgICAgICAgICAgbGV0IGxvY2tlZCA9IHRoaXMuaXNMb2NrZWQobmV4dERPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGUgJiYgbmV4dC5ub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGVET00ubm9kZVZhbHVlID09IG5vZGUudGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCBuZXh0Lm91dGVyRGVjbykpO1xuICAgICAgICAgICAgICAgIGlmICghbG9ja2VkICYmIG5leHQudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kb20gIT0gbmV4dERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFsb2NrZWQgJiYgKHVwZGF0ZWQgPSB0aGlzLnJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQudXBkYXRlQ2hpbGRyZW4odmlldywgcG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gV2hlbiBhIG5vZGUgd2l0aCBjb250ZW50IGlzIHJlcGxhY2VkIGJ5IGEgZGlmZmVyZW50IG5vZGUgd2l0aFxuICAgIC8vIGlkZW50aWNhbCBjb250ZW50LCBtb3ZlIG92ZXIgaXRzIGNoaWxkcmVuLlxuICAgIHJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgICAgIGlmIChuZXh0LmRpcnR5IHx8IG5vZGUuaXNBdG9tIHx8ICFuZXh0LmNoaWxkcmVuLmxlbmd0aCB8fFxuICAgICAgICAgICAgIW5leHQubm9kZS5jb250ZW50LmVxKG5vZGUuY29udGVudCkgfHxcbiAgICAgICAgICAgICFzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgbmV4dC5vdXRlckRlY28pIHx8ICFpbm5lckRlY28uZXEobmV4dC5pbm5lckRlY28pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB3cmFwcGVyID0gTm9kZVZpZXdEZXNjLmNyZWF0ZSh0aGlzLnRvcCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcyk7XG4gICAgICAgIGlmICh3cmFwcGVyLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIHdyYXBwZXIuY2hpbGRyZW4gPSBuZXh0LmNoaWxkcmVuO1xuICAgICAgICAgICAgbmV4dC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2ggb2Ygd3JhcHBlci5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaC5wYXJlbnQgPSB3cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgLy8gSW5zZXJ0IHRoZSBub2RlIGFzIGEgbmV3bHkgY3JlYXRlZCBub2RlIGRlc2MuXG4gICAgYWRkTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgICAgIGxldCBkZXNjID0gTm9kZVZpZXdEZXNjLmNyZWF0ZSh0aGlzLnRvcCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcyk7XG4gICAgICAgIGlmIChkZXNjLmNvbnRlbnRET00pXG4gICAgICAgICAgICBkZXNjLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHBvcyArIDEpO1xuICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBkZXNjKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgcGxhY2VXaWRnZXQod2lkZ2V0LCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLmluZGV4IDwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0gOiBudWxsO1xuICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lm1hdGNoZXNXaWRnZXQod2lkZ2V0KSAmJlxuICAgICAgICAgICAgKHdpZGdldCA9PSBuZXh0LndpZGdldCB8fCAhbmV4dC53aWRnZXQudHlwZS50b0RPTS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRlc2MgPSBuZXcgV2lkZ2V0Vmlld0Rlc2ModGhpcy50b3AsIHdpZGdldCwgdmlldywgcG9zKTtcbiAgICAgICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGRlc2MpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgYSB0ZXh0YmxvY2sgbG9va3MgYW5kIGJlaGF2ZXMgY29ycmVjdGx5IGluXG4gICAgLy8gY29udGVudEVkaXRhYmxlLlxuICAgIGFkZFRleHRibG9ja0hhY2tzKCkge1xuICAgICAgICBsZXQgbGFzdENoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleCAtIDFdLCBwYXJlbnQgPSB0aGlzLnRvcDtcbiAgICAgICAgd2hpbGUgKGxhc3RDaGlsZCBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgcGFyZW50ID0gbGFzdENoaWxkO1xuICAgICAgICAgICAgbGFzdENoaWxkID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxhc3RDaGlsZCB8fCAvLyBFbXB0eSB0ZXh0YmxvY2tcbiAgICAgICAgICAgICEobGFzdENoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXdEZXNjKSB8fFxuICAgICAgICAgICAgL1xcbiQvLnRlc3QobGFzdENoaWxkLm5vZGUudGV4dCkgfHxcbiAgICAgICAgICAgICh0aGlzLnZpZXcucmVxdWlyZXNHZWNrb0hhY2tOb2RlICYmIC9cXHMkLy50ZXN0KGxhc3RDaGlsZC5ub2RlLnRleHQpKSkge1xuICAgICAgICAgICAgLy8gQXZvaWQgYnVncyBpbiBTYWZhcmkncyBjdXJzb3IgZHJhd2luZyAoIzExNjUpIGFuZCBDaHJvbWUncyBtb3VzZSBzZWxlY3Rpb24gKCMxMTUyKVxuICAgICAgICAgICAgaWYgKChzYWZhcmkgfHwgY2hyb21lKSAmJiBsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLmRvbS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkSGFja05vZGUoXCJJTUdcIiwgcGFyZW50KTtcbiAgICAgICAgICAgIHRoaXMuYWRkSGFja05vZGUoXCJCUlwiLCB0aGlzLnRvcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSGFja05vZGUobm9kZU5hbWUsIHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09IHRoaXMudG9wICYmIHRoaXMuaW5kZXggPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoICYmIHBhcmVudC5jaGlsZHJlblt0aGlzLmluZGV4XS5tYXRjaGVzSGFjayhub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PSBcIklNR1wiKSB7XG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3Itc2VwYXJhdG9yXCI7XG4gICAgICAgICAgICAgICAgZG9tLmFsdCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZU5hbWUgPT0gXCJCUlwiKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXRyYWlsaW5nQnJlYWtcIjtcbiAgICAgICAgICAgIGxldCBoYWNrID0gbmV3IFRyYWlsaW5nSGFja1ZpZXdEZXNjKHRoaXMudG9wLCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgIT0gdGhpcy50b3ApXG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2goaGFjayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGhhY2spO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0xvY2tlZChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2sgJiYgKG5vZGUgPT0gdGhpcy5sb2NrIHx8IG5vZGUubm9kZVR5cGUgPT0gMSAmJiBub2RlLmNvbnRhaW5zKHRoaXMubG9jay5wYXJlbnROb2RlKSk7XG4gICAgfVxufVxuLy8gSXRlcmF0ZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IGFuZCBhcnJheSBvZiBkZXNjcyB0byBmaW5kXG4vLyBkaXJlY3RseSBtYXRjaGluZyBvbmVzLCBpbiBvcmRlciB0byBhdm9pZCBvdmVyZWFnZXJseSByZXVzaW5nIHRob3NlXG4vLyBmb3Igb3RoZXIgbm9kZXMuIFJldHVybnMgdGhlIGZyYWdtZW50IGluZGV4IG9mIHRoZSBmaXJzdCBub2RlIHRoYXRcbi8vIGlzIHBhcnQgb2YgdGhlIHNlcXVlbmNlIG9mIG1hdGNoZWQgbm9kZXMgYXQgdGhlIGVuZCBvZiB0aGVcbi8vIGZyYWdtZW50LlxuZnVuY3Rpb24gcHJlTWF0Y2goZnJhZywgcGFyZW50RGVzYykge1xuICAgIGxldCBjdXJEZXNjID0gcGFyZW50RGVzYywgZGVzY0kgPSBjdXJEZXNjLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBsZXQgZkkgPSBmcmFnLmNoaWxkQ291bnQsIG1hdGNoZWQgPSBuZXcgTWFwLCBtYXRjaGVzID0gW107XG4gICAgb3V0ZXI6IHdoaWxlIChmSSA+IDApIHtcbiAgICAgICAgbGV0IGRlc2M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChkZXNjSSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY3VyRGVzYy5jaGlsZHJlbltkZXNjSSAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ckRlc2MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkZXNjSSA9IG5leHQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NJLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1ckRlc2MgPT0gcGFyZW50RGVzYykge1xuICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICBkZXNjSSA9IGN1ckRlc2MucGFyZW50LmNoaWxkcmVuLmluZGV4T2YoY3VyRGVzYyk7XG4gICAgICAgICAgICAgICAgY3VyRGVzYyA9IGN1ckRlc2MucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gZGVzYy5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKG5vZGUgIT0gZnJhZy5jaGlsZChmSSAtIDEpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC0tZkk7XG4gICAgICAgIG1hdGNoZWQuc2V0KGRlc2MsIGZJKTtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGRlc2MpO1xuICAgIH1cbiAgICByZXR1cm4geyBpbmRleDogZkksIG1hdGNoZWQsIG1hdGNoZXM6IG1hdGNoZXMucmV2ZXJzZSgpIH07XG59XG5mdW5jdGlvbiBjb21wYXJlU2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGEudHlwZS5zaWRlIC0gYi50eXBlLnNpZGU7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIGFic3RyYWN0cyBpdGVyYXRpbmcgb3ZlciB0aGUgbm9kZXMgYW5kIGRlY29yYXRpb25zIGluXG4vLyBhIGZyYWdtZW50LiBDYWxscyBgb25Ob2RlYCBmb3IgZWFjaCBub2RlLCB3aXRoIGl0cyBsb2NhbCBhbmQgY2hpbGRcbi8vIGRlY29yYXRpb25zLiBTcGxpdHMgdGV4dCBub2RlcyB3aGVuIHRoZXJlIGlzIGEgZGVjb3JhdGlvbiBzdGFydGluZ1xuLy8gb3IgZW5kaW5nIGluc2lkZSBvZiB0aGVtLiBDYWxscyBgb25XaWRnZXRgIGZvciBlYWNoIHdpZGdldC5cbmZ1bmN0aW9uIGl0ZXJEZWNvKHBhcmVudCwgZGVjbywgb25XaWRnZXQsIG9uTm9kZSkge1xuICAgIGxldCBsb2NhbHMgPSBkZWNvLmxvY2FscyhwYXJlbnQpLCBvZmZzZXQgPSAwO1xuICAgIC8vIFNpbXBsZSwgY2hlYXAgdmFyaWFudCBmb3Igd2hlbiB0aGVyZSBhcmUgbm8gbG9jYWwgZGVjb3JhdGlvbnNcbiAgICBpZiAobG9jYWxzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50LmNoaWxkKGkpO1xuICAgICAgICAgICAgb25Ob2RlKGNoaWxkLCBsb2NhbHMsIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCksIGkpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGRlY29JbmRleCA9IDAsIGFjdGl2ZSA9IFtdLCByZXN0Tm9kZSA9IG51bGw7XG4gICAgZm9yIChsZXQgcGFyZW50SW5kZXggPSAwOzspIHtcbiAgICAgICAgbGV0IHdpZGdldCwgd2lkZ2V0cztcbiAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGxvY2Fsc1tkZWNvSW5kZXgrK107XG4gICAgICAgICAgICBpZiAobmV4dC53aWRnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICh3aWRnZXRzIHx8ICh3aWRnZXRzID0gW3dpZGdldF0pKS5wdXNoKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICAgIGlmICh3aWRnZXRzKSB7XG4gICAgICAgICAgICAgICAgd2lkZ2V0cy5zb3J0KGNvbXBhcmVTaWRlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZGdldHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIG9uV2lkZ2V0KHdpZGdldHNbaV0sIHBhcmVudEluZGV4LCAhIXJlc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uV2lkZ2V0KHdpZGdldCwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZCwgaW5kZXg7XG4gICAgICAgIGlmIChyZXN0Tm9kZSkge1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNoaWxkID0gcmVzdE5vZGU7XG4gICAgICAgICAgICByZXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyZW50SW5kZXggPCBwYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgICAgICAgIGNoaWxkID0gcGFyZW50LmNoaWxkKHBhcmVudEluZGV4KyspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoYWN0aXZlW2ldLnRvIDw9IG9mZnNldClcbiAgICAgICAgICAgICAgICBhY3RpdmUuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLmZyb20gPD0gb2Zmc2V0ICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID4gb2Zmc2V0KVxuICAgICAgICAgICAgYWN0aXZlLnB1c2gobG9jYWxzW2RlY29JbmRleCsrXSk7XG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgaWYgKGNoaWxkLmlzVGV4dCkge1xuICAgICAgICAgICAgbGV0IGN1dEF0ID0gZW5kO1xuICAgICAgICAgICAgaWYgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0uZnJvbSA8IGN1dEF0KVxuICAgICAgICAgICAgICAgIGN1dEF0ID0gbG9jYWxzW2RlY29JbmRleF0uZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVbaV0udG8gPCBjdXRBdClcbiAgICAgICAgICAgICAgICAgICAgY3V0QXQgPSBhY3RpdmVbaV0udG87XG4gICAgICAgICAgICBpZiAoY3V0QXQgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICByZXN0Tm9kZSA9IGNoaWxkLmN1dChjdXRBdCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoMCwgY3V0QXQgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGN1dEF0O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA8IGVuZClcbiAgICAgICAgICAgICAgICBkZWNvSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0ZXJEZWNvID0gY2hpbGQuaXNJbmxpbmUgJiYgIWNoaWxkLmlzTGVhZiA/IGFjdGl2ZS5maWx0ZXIoZCA9PiAhZC5pbmxpbmUpIDogYWN0aXZlLnNsaWNlKCk7XG4gICAgICAgIG9uTm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBkZWNvLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpLCBpbmRleCk7XG4gICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG59XG4vLyBMaXN0IG1hcmtlcnMgaW4gTW9iaWxlIFNhZmFyaSB3aWxsIG15c3RlcmlvdXNseSBkaXNhcHBlYXJcbi8vIHNvbWV0aW1lcy4gVGhpcyB3b3JrcyBhcm91bmQgdGhhdC5cbmZ1bmN0aW9uIGlvc0hhY2tzKGRvbSkge1xuICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJVTFwiIHx8IGRvbS5ub2RlTmFtZSA9PSBcIk9MXCIpIHtcbiAgICAgICAgbGV0IG9sZENTUyA9IGRvbS5zdHlsZS5jc3NUZXh0O1xuICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUyArIFwiOyBsaXN0LXN0eWxlOiBzcXVhcmUgIWltcG9ydGFudFwiO1xuICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pLmxpc3RTdHlsZTtcbiAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XG4gICAgfVxufVxuLy8gRmluZCBhIHBpZWNlIG9mIHRleHQgaW4gYW4gaW5saW5lIGZyYWdtZW50LCBvdmVybGFwcGluZyBmcm9tLXRvXG5mdW5jdGlvbiBmaW5kVGV4dEluRnJhZ21lbnQoZnJhZywgdGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IGZyYWcuY2hpbGRDb3VudCAmJiBwb3MgPD0gdG87KSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZyYWcuY2hpbGQoaSsrKSwgY2hpbGRTdGFydCA9IHBvcztcbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoIWNoaWxkLmlzVGV4dClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgc3RyID0gY2hpbGQudGV4dDtcbiAgICAgICAgd2hpbGUgKGkgPCBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZnJhZy5jaGlsZChpKyspO1xuICAgICAgICAgICAgcG9zICs9IG5leHQubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoIW5leHQuaXNUZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RyICs9IG5leHQudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IGZyb20pIHtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdG8gJiYgc3RyLnNsaWNlKHRvIC0gdGV4dC5sZW5ndGggLSBjaGlsZFN0YXJ0LCB0byAtIGNoaWxkU3RhcnQpID09IHRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvIC0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBjaGlsZFN0YXJ0IDwgdG8gPyBzdHIubGFzdEluZGV4T2YodGV4dCwgdG8gLSBjaGlsZFN0YXJ0IC0gMSkgOiAtMTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+PSAwICYmIGZvdW5kICsgdGV4dC5sZW5ndGggKyBjaGlsZFN0YXJ0ID49IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkU3RhcnQgKyBmb3VuZDtcbiAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIHN0ci5sZW5ndGggPj0gKHRvICsgdGV4dC5sZW5ndGgpIC0gY2hpbGRTdGFydCAmJlxuICAgICAgICAgICAgICAgIHN0ci5zbGljZSh0byAtIGNoaWxkU3RhcnQsIHRvIC0gY2hpbGRTdGFydCArIHRleHQubGVuZ3RoKSA9PSB0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vLyBSZXBsYWNlIHJhbmdlIGZyb20tdG8gaW4gYW4gYXJyYXkgb2YgdmlldyBkZXNjcyB3aXRoIHJlcGxhY2VtZW50XG4vLyAobWF5IGJlIG51bGwgdG8ganVzdCBkZWxldGUpLiBUaGlzIGdvZXMgdmVyeSBtdWNoIGFnYWluc3QgdGhlIGdyYWluXG4vLyBvZiB0aGUgcmVzdCBvZiB0aGlzIGNvZGUsIHdoaWNoIHRlbmRzIHRvIGNyZWF0ZSBub2RlcyB3aXRoIHRoZVxuLy8gcmlnaHQgc2hhcGUgaW4gb25lIGdvLCByYXRoZXIgdGhhbiBtZXNzaW5nIHdpdGggdGhlbSBhZnRlclxuLy8gY3JlYXRpb24sIGJ1dCBpcyBuZWNlc3NhcnkgaW4gdGhlIGNvbXBvc2l0aW9uIGhhY2suXG5mdW5jdGlvbiByZXBsYWNlTm9kZXMobm9kZXMsIGZyb20sIHRvLCB2aWV3LCByZXBsYWNlbWVudCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGVzW2ldLCBzdGFydCA9IG9mZiwgZW5kID0gb2ZmICs9IGNoaWxkLnNpemU7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSgwLCBmcm9tIC0gc3RhcnQsIHZpZXcpKTtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSh0byAtIHN0YXJ0LCBjaGlsZC5zaXplLCB2aWV3KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4gPSBudWxsKSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSwgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgaWYgKCFkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbmVhcmVzdERlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tU2VsLmZvY3VzTm9kZSksIGluV2lkZ2V0ID0gbmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2Muc2l6ZSA9PSAwO1xuICAgIGxldCBoZWFkID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCAxKTtcbiAgICBpZiAoaGVhZCA8IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCAkaGVhZCA9IGRvYy5yZXNvbHZlKGhlYWQpLCBhbmNob3IsIHNlbGVjdGlvbjtcbiAgICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpIHtcbiAgICAgICAgYW5jaG9yID0gaGVhZDtcbiAgICAgICAgd2hpbGUgKG5lYXJlc3REZXNjICYmICFuZWFyZXN0RGVzYy5ub2RlKVxuICAgICAgICAgICAgbmVhcmVzdERlc2MgPSBuZWFyZXN0RGVzYy5wYXJlbnQ7XG4gICAgICAgIGxldCBuZWFyZXN0RGVzY05vZGUgPSBuZWFyZXN0RGVzYy5ub2RlO1xuICAgICAgICBpZiAobmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2NOb2RlLmlzQXRvbSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShuZWFyZXN0RGVzY05vZGUpICYmIG5lYXJlc3REZXNjLnBhcmVudFxuICAgICAgICAgICAgJiYgIShuZWFyZXN0RGVzY05vZGUuaXNJbmxpbmUgJiYgaXNPbkVkZ2UoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCBuZWFyZXN0RGVzYy5kb20pKSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IG5lYXJlc3REZXNjLnBvc0JlZm9yZTtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IG5ldyBOb2RlU2VsZWN0aW9uKGhlYWQgPT0gcG9zID8gJGhlYWQgOiBkb2MucmVzb2x2ZShwb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGRvbVNlbCBpbnN0YW5jZW9mIHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuU2VsZWN0aW9uICYmIGRvbVNlbC5yYW5nZUNvdW50ID4gMSkge1xuICAgICAgICAgICAgbGV0IG1pbiA9IGhlYWQsIG1heCA9IGhlYWQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbVNlbC5yYW5nZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb21TZWwuZ2V0UmFuZ2VBdChpKTtcbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCwgMSkpO1xuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgdmlldy5kb2NWaWV3LnBvc0Zyb21ET00ocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQsIC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWluIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIFthbmNob3IsIGhlYWRdID0gbWF4ID09IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciA/IFttYXgsIG1pbl0gOiBbbWluLCBtYXhdO1xuICAgICAgICAgICAgJGhlYWQgPSBkb2MucmVzb2x2ZShoZWFkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvciA9IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jaG9yIDwgMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGJpYXMgPSBvcmlnaW4gPT0gXCJwb2ludGVyXCIgfHwgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmhlYWQgPCAkaGVhZC5wb3MgJiYgIWluV2lkZ2V0KSA/IDEgOiAtMTtcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkYW5jaG9yLCAkaGVhZCwgYmlhcyk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiBlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy5lZGl0YWJsZSA/IHZpZXcuaGFzRm9jdXMoKSA6XG4gICAgICAgIGhhc1NlbGVjdGlvbih2aWV3KSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY29udGFpbnModmlldy5kb20pO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uVG9ET00odmlldywgZm9yY2UgPSBmYWxzZSkge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBzeW5jTm9kZVNlbGVjdGlvbih2aWV3LCBzZWwpO1xuICAgIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIFRoZSBkZWxheWVkIGRyYWcgc2VsZWN0aW9uIGNhdXNlcyBpc3N1ZXMgd2l0aCBDZWxsIFNlbGVjdGlvbnNcbiAgICAvLyBpbiBTYWZhcmkuIEFuZCB0aGUgZHJhZyBzZWxlY3Rpb24gZGVsYXkgaXMgdG8gd29ya2Fyb25kIGlzc3Vlc1xuICAgIC8vIHdoaWNoIG9ubHkgcHJlc2VudCBpbiBDaHJvbWUuXG4gICAgaWYgKCFmb3JjZSAmJiB2aWV3LmlucHV0Lm1vdXNlRG93biAmJiB2aWV3LmlucHV0Lm1vdXNlRG93bi5hbGxvd0RlZmF1bHQgJiYgY2hyb21lKSB7XG4gICAgICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCksIGN1clNlbCA9IHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICYmIGN1clNlbC5hbmNob3JOb2RlICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCwgY3VyU2VsLmFuY2hvck5vZGUsIGN1clNlbC5hbmNob3JPZmZzZXQpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93bi5kZWxheWVkU2VsZWN0aW9uU3luYyA9IHRydWU7XG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZGlzY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIGlmICh2aWV3LmN1cnNvcldyYXBwZXIpIHtcbiAgICAgICAgc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB7IGFuY2hvciwgaGVhZCB9ID0gc2VsLCByZXNldEVkaXRhYmxlRnJvbSwgcmVzZXRFZGl0YWJsZVRvO1xuICAgICAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgJiYgIShzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKCFzZWwuJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZUZyb20gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwuZnJvbSk7XG4gICAgICAgICAgICBpZiAoIXNlbC5lbXB0eSAmJiAhc2VsLiRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGVUbyA9IHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHNlbC50byk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5kb2NWaWV3LnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHZpZXcsIGZvcmNlKTtcbiAgICAgICAgaWYgKGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZUZyb20pXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZShyZXNldEVkaXRhYmxlRnJvbSk7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZVRvKVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGUocmVzZXRFZGl0YWJsZVRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsLnZpc2libGUpIHtcbiAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgICAgICBpZiAoXCJvbnNlbGVjdGlvbmNoYW5nZVwiIGluIGRvY3VtZW50KVxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmNvbm5lY3RTZWxlY3Rpb24oKTtcbn1cbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBXZWJraXQgbm90IGFsbG93aW5nIGEgc2VsZWN0aW9uIHRvIHN0YXJ0L2VuZFxuLy8gYmV0d2VlbiBub24tZWRpdGFibGUgYmxvY2sgbm9kZXMuIFdlIGJyaWVmbHkgbWFrZSBzb21ldGhpbmdcbi8vIGVkaXRhYmxlLCBzZXQgdGhlIHNlbGVjdGlvbiwgdGhlbiBzZXQgaXQgdW5lZGl0YWJsZSBhZ2Fpbi5cbmNvbnN0IGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlID0gc2FmYXJpIHx8IGNocm9tZSAmJiBjaHJvbWVfdmVyc2lvbiA8IDYzO1xuZnVuY3Rpb24gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgcG9zKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIDApO1xuICAgIGxldCBhZnRlciA9IG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSA6IG51bGw7XG4gICAgbGV0IGJlZm9yZSA9IG9mZnNldCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXSA6IG51bGw7XG4gICAgaWYgKHNhZmFyaSAmJiBhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgIGlmICgoIWFmdGVyIHx8IGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgICghYmVmb3JlIHx8IGJlZm9yZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSkge1xuICAgICAgICBpZiAoYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgICAgICBlbHNlIGlmIChiZWZvcmUpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYmVmb3JlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBcInRydWVcIjtcbiAgICBpZiAoc2FmYXJpICYmIGVsZW1lbnQuZHJhZ2dhYmxlKSB7XG4gICAgICAgIGVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiByZXNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICBpZiAoZWxlbWVudC53YXNEcmFnZ2FibGUpIHtcbiAgICAgICAgZWxlbWVudC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICBlbGVtZW50Lndhc0RyYWdnYWJsZSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSh2aWV3KSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQpO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBkb21TZWwuYW5jaG9yTm9kZSwgb2Zmc2V0ID0gZG9tU2VsLmFuY2hvck9mZnNldDtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICE9IG5vZGUgfHwgZG9tU2VsLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBpZiAoIWRvbVNlbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBub2RlID0gdmlldy5jdXJzb3JXcmFwcGVyLmRvbSwgaW1nID0gbm9kZS5ub2RlTmFtZSA9PSBcIklNR1wiO1xuICAgIGlmIChpbWcpXG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUucGFyZW50Tm9kZSwgZG9tSW5kZXgobm9kZSkgKyAxKTtcbiAgICBlbHNlXG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIDApO1xuICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgIGRvbVNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBkb21TZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIC8vIEtsdWRnZSB0byBraWxsICdjb250cm9sIHNlbGVjdGlvbicgaW4gSUUxMSB3aGVuIHNlbGVjdGluZyBhblxuICAgIC8vIGludmlzaWJsZSBjdXJzb3Igd3JhcHBlciwgc2luY2UgdGhhdCB3b3VsZCByZXN1bHQgaW4gdGhvc2Ugd2VpcmRcbiAgICAvLyByZXNpemUgaGFuZGxlcyBhbmQgYSBzZWxlY3Rpb24gdGhhdCBjb25zaWRlcnMgdGhlIGFic29sdXRlbHlcbiAgICAvLyBwb3NpdGlvbmVkIHdyYXBwZXIsIHJhdGhlciB0aGFuIHRoZSByb290IGVkaXRhYmxlIG5vZGUsIHRoZVxuICAgIC8vIGZvY3VzZWQgZWxlbWVudC5cbiAgICBpZiAoIWltZyAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSAmJiBpZSAmJiBpZV92ZXJzaW9uIDw9IDExKSB7XG4gICAgICAgIG5vZGUuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBub2RlLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKSB7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcuZGVzY0F0KHNlbC5mcm9tKTtcbiAgICAgICAgaWYgKGRlc2MgIT0gdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgICAgICAgICAgY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgZGVzYy5zZWxlY3ROb2RlKCk7XG4gICAgICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gZGVzYztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpO1xuICAgIH1cbn1cbi8vIENsZWFyIGFsbCBET00gc3RhdGVmdWxuZXNzIG9mIHRoZSBsYXN0IG5vZGUgc2VsZWN0aW9uLlxuZnVuY3Rpb24gY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgICAgICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYy5wYXJlbnQpXG4gICAgICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjLmRlc2VsZWN0Tm9kZSgpO1xuICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkJldHdlZW4odmlldywgJGFuY2hvciwgJGhlYWQsIGJpYXMpIHtcbiAgICByZXR1cm4gdmlldy5zb21lUHJvcChcImNyZWF0ZVNlbGVjdGlvbkJldHdlZW5cIiwgZiA9PiBmKHZpZXcsICRhbmNob3IsICRoZWFkKSlcbiAgICAgICAgfHwgVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKCRhbmNob3IsICRoZWFkLCBiaWFzKTtcbn1cbmZ1bmN0aW9uIGhhc0ZvY3VzQW5kU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5lZGl0YWJsZSAmJiAhdmlldy5oYXNGb2N1cygpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGhhc1NlbGVjdGlvbih2aWV3KTtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbih2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBpZiAoIXNlbC5hbmNob3JOb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyZWZveCB3aWxsIHJhaXNlICdwZXJtaXNzaW9uIGRlbmllZCcgZXJyb3JzIHdoZW4gYWNjZXNzaW5nXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb2YgYHNlbC5hbmNob3JOb2RlYCB3aGVuIGl0J3MgaW4gYSBnZW5lcmF0ZWQgQ1NTXG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHJldHVybiB2aWV3LmRvbS5jb250YWlucyhzZWwuYW5jaG9yTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmFuY2hvck5vZGUucGFyZW50Tm9kZSA6IHNlbC5hbmNob3JOb2RlKSAmJlxuICAgICAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgdmlldy5kb20uY29udGFpbnMoc2VsLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmZvY3VzTm9kZS5wYXJlbnROb2RlIDogc2VsLmZvY3VzTm9kZSkpO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYW5jaG9ySW5SaWdodFBsYWNlKHZpZXcpIHtcbiAgICBsZXQgYW5jaG9yRE9NID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLCAwKTtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIHJldHVybiBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBtb3ZlU2VsZWN0aW9uQmxvY2soc3RhdGUsIGRpcikge1xuICAgIGxldCB7ICRhbmNob3IsICRoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0ICRzaWRlID0gZGlyID4gMCA/ICRhbmNob3IubWF4KCRoZWFkKSA6ICRhbmNob3IubWluKCRoZWFkKTtcbiAgICBsZXQgJHN0YXJ0ID0gISRzaWRlLnBhcmVudC5pbmxpbmVDb250ZW50ID8gJHNpZGUgOiAkc2lkZS5kZXB0aCA/IHN0YXRlLmRvYy5yZXNvbHZlKGRpciA+IDAgPyAkc2lkZS5hZnRlcigpIDogJHNpZGUuYmVmb3JlKCkpIDogbnVsbDtcbiAgICByZXR1cm4gJHN0YXJ0ICYmIFNlbGVjdGlvbi5maW5kRnJvbSgkc3RhcnQsIGRpcik7XG59XG5mdW5jdGlvbiBhcHBseSh2aWV3LCBzZWwpIHtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB7ICRoZWFkIH0gPSBzZWwsIG5vZGUgPSAkaGVhZC50ZXh0T2Zmc2V0ID8gbnVsbCA6IGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuaXNUZXh0IHx8ICFub2RlLmlzTGVhZilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgJG5ld0hlYWQgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKCRoZWFkLnBvcyArIG5vZGUubm9kZVNpemUgKiAoZGlyIDwgMCA/IC0xIDogMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKHNlbC4kYW5jaG9yLCAkbmV3SGVhZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzZWwuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiAobmV4dCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpKSB7XG4gICAgICAgICAgICBsZXQgJGhlYWQgPSBzZWwuJGhlYWQsIG5vZGUgPSAkaGVhZC50ZXh0T2Zmc2V0ID8gbnVsbCA6IGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyLCBkZXNjO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBub2RlUG9zID0gZGlyIDwgMCA/ICRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUgOiAkaGVhZC5wb3M7XG4gICAgICAgICAgICBpZiAoIShub2RlLmlzQXRvbSB8fCAoZGVzYyA9IHZpZXcuZG9jVmlldy5kZXNjQXQobm9kZVBvcykpICYmICFkZXNjLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbihkaXIgPCAwID8gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgkaGVhZC5wb3MgLSBub2RlLm5vZGVTaXplKSA6ICRoZWFkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3ZWJraXQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSB3aWxsIGludHJvZHVjZSBleHRyYSBwb2ludGxlc3MgY3Vyc29yXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb25zIGFyb3VuZCBpbmxpbmUgdW5lZGl0YWJsZSBub2Rlcywgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgIC8vIHRha2Ugb3ZlciBhbmQgbW92ZSB0aGUgY3Vyc29yIHBhc3QgdGhlbSAoIzkzNylcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24odmlldy5zdGF0ZS5kb2MucmVzb2x2ZShkaXIgPCAwID8gbm9kZVBvcyA6IG5vZGVQb3MgKyBub2RlLm5vZGVTaXplKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsLm5vZGUuaXNJbmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVMZW4obm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNJZ25vcmFibGUoZG9tLCBkaXIpIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Muc2l6ZSA9PSAwICYmIChkaXIgPCAwIHx8IGRvbS5uZXh0U2libGluZyB8fCBkb20ubm9kZU5hbWUgIT0gXCJCUlwiKTtcbn1cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKSB7XG4gICAgcmV0dXJuIGRpciA8IDAgPyBza2lwSWdub3JlZE5vZGVzQmVmb3JlKHZpZXcpIDogc2tpcElnbm9yZWROb2Rlc0FmdGVyKHZpZXcpO1xufVxuLy8gTWFrZSBzdXJlIHRoZSBjdXJzb3IgaXNuJ3QgZGlyZWN0bHkgYWZ0ZXIgb25lIG9yIG1vcmUgaWdub3JlZFxuLy8gbm9kZXMsIHdoaWNoIHdpbGwgY29uZnVzZSB0aGUgYnJvd3NlcidzIGN1cnNvciBtb3Rpb24gbG9naWMuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzQmVmb3JlKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBtb3ZlTm9kZSwgbW92ZU9mZnNldCwgZm9yY2UgPSBmYWxzZTtcbiAgICAvLyBHZWNrbyB3aWxsIGRvIG9kZCB0aGluZ3Mgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGRpcmVjdGx5IGluIGZyb250XG4gICAgLy8gb2YgYSBub24tZWRpdGFibGUgbm9kZSwgc28gaW4gdGhhdCBjYXNlLCBtb3ZlIGl0IGludG8gdGhlIG5leHRcbiAgICAvLyBub2RlIGlmIHBvc3NpYmxlLiBJc3N1ZSBwcm9zZW1pcnJvci9wcm9zZW1pcnJvciM4MzIuXG4gICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlTGVuKG5vZGUpICYmIGlzSWdub3JhYmxlKG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLCAtMSkpXG4gICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChpc0lnbm9yYWJsZShiZWZvcmUsIC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSAtLW9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAocHJldiAmJiBpc0lnbm9yYWJsZShwcmV2LCAtMSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gZG9tSW5kZXgocHJldik7XG4gICAgICAgICAgICAgICAgcHJldiA9IHByZXYucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwcmV2O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG5vZGVMZW4obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvcmNlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBub2RlLCBvZmZzZXQpO1xuICAgIGVsc2UgaWYgKG1vdmVOb2RlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBtb3ZlTm9kZSwgbW92ZU9mZnNldCk7XG59XG4vLyBNYWtlIHN1cmUgdGhlIGN1cnNvciBpc24ndCBkaXJlY3RseSBiZWZvcmUgb25lIG9yIG1vcmUgaWdub3JlZFxuLy8gbm9kZXMuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzQWZ0ZXIodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gICAgbGV0IG1vdmVOb2RlLCBtb3ZlT2Zmc2V0O1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBhZnRlciA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGlzSWdub3JhYmxlKGFmdGVyLCAxKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gKytvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQgJiYgaXNJZ25vcmFibGUobmV4dCwgMSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5leHQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gZG9tSW5kZXgobmV4dCkgKyAxO1xuICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbGVuID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgbGVuID0gbm9kZUxlbihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobW92ZU5vZGUpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tOb2RlKGRvbSkge1xuICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrO1xufVxuZnVuY3Rpb24gdGV4dE5vZGVBZnRlcihub2RlLCBvZmZzZXQpIHtcbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDEgJiYgbmV4dC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHROb2RlQmVmb3JlKG5vZGUsIG9mZnNldCkge1xuICAgIHdoaWxlIChub2RlICYmICFvZmZzZXQgJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDEgJiYgbmV4dC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICBvZmZzZXQgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFNlbEZvY3VzKHZpZXcsIG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDMpIHtcbiAgICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXI7XG4gICAgICAgIGlmIChhZnRlciA9IHRleHROb2RlQWZ0ZXIobm9kZSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgbm9kZSA9IGFmdGVyO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZWZvcmUgPSB0ZXh0Tm9kZUJlZm9yZShub2RlLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgb2Zmc2V0ID0gYmVmb3JlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWwpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKHNlbCkpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsLmV4dGVuZCkge1xuICAgICAgICBzZWwuZXh0ZW5kKG5vZGUsIG9mZnNldCk7XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgLy8gSWYgbm8gc3RhdGUgdXBkYXRlIGVuZHMgdXAgaGFwcGVuaW5nLCByZXNldCB0aGUgc2VsZWN0aW9uLlxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodmlldy5zdGF0ZSA9PSBzdGF0ZSlcbiAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGZpbmREaXJlY3Rpb24odmlldywgcG9zKSB7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCEoY2hyb21lIHx8IHdpbmRvd3MpICYmICRwb3MucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgaWYgKHBvcyA+ICRwb3Muc3RhcnQoKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHZpZXcuY29vcmRzQXRQb3MocG9zIC0gMSk7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGJlZm9yZS50b3AgKyBiZWZvcmUuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICBpZiAobWlkID4gY29vcmRzLnRvcCAmJiBtaWQgPCBjb29yZHMuYm90dG9tICYmIE1hdGguYWJzKGJlZm9yZS5sZWZ0IC0gY29vcmRzLmxlZnQpID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlLmxlZnQgPCBjb29yZHMubGVmdCA/IFwibHRyXCIgOiBcInJ0bFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCAkcG9zLmVuZCgpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyArIDEpO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChhZnRlci50b3AgKyBhZnRlci5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgIGlmIChtaWQgPiBjb29yZHMudG9wICYmIG1pZCA8IGNvb3Jkcy5ib3R0b20gJiYgTWF0aC5hYnMoYWZ0ZXIubGVmdCAtIGNvb3Jkcy5sZWZ0KSA+IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyLmxlZnQgPiBjb29yZHMubGVmdCA/IFwibHRyXCIgOiBcInJ0bFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUodmlldy5kb20pLmRpcmVjdGlvbjtcbiAgICByZXR1cm4gY29tcHV0ZWQgPT0gXCJydGxcIiA/IFwicnRsXCIgOiBcImx0clwiO1xufVxuLy8gQ2hlY2sgd2hldGhlciB2ZXJ0aWNhbCBzZWxlY3Rpb24gbW90aW9uIHdvdWxkIGludm9sdmUgbm9kZVxuLy8gc2VsZWN0aW9ucy4gSWYgc28sIGFwcGx5IGl0IChpZiBub3QsIHRoZSByZXN1bHQgaXMgbGVmdCB0byB0aGVcbi8vIGJyb3dzZXIpXG5mdW5jdGlvbiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiAhc2VsLmVtcHR5IHx8IG1vZHMuaW5kZXhPZihcInNcIikgPiAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChtYWMgJiYgbW9kcy5pbmRleE9mKFwibVwiKSA+IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgJGZyb20sICR0byB9ID0gc2VsO1xuICAgIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdmlldy5lbmRPZlRleHRibG9jayhkaXIgPCAwID8gXCJ1cFwiIDogXCJkb3duXCIpKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgIGlmIChuZXh0ICYmIChuZXh0IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV4dCk7XG4gICAgfVxuICAgIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSBkaXIgPCAwID8gJGZyb20gOiAkdG87XG4gICAgICAgIGxldCBiZXlvbmQgPSBzZWwgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24gPyBTZWxlY3Rpb24ubmVhcihzaWRlLCBkaXIpIDogU2VsZWN0aW9uLmZpbmRGcm9tKHNpZGUsIGRpcik7XG4gICAgICAgIHJldHVybiBiZXlvbmQgPyBhcHBseSh2aWV3LCBiZXlvbmQpIDogZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIGRpcikge1xuICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yLCBlbXB0eSB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyID4gMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IG5leHROb2RlID0gISRoZWFkLnRleHRPZmZzZXQgJiYgKGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyKTtcbiAgICBpZiAobmV4dE5vZGUgJiYgIW5leHROb2RlLmlzVGV4dCkge1xuICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgkaGVhZC5wb3MgLSBuZXh0Tm9kZS5ub2RlU2l6ZSwgJGhlYWQucG9zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIuZGVsZXRlKCRoZWFkLnBvcywgJGhlYWQucG9zICsgbmV4dE5vZGUubm9kZVNpemUpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN3aXRjaEVkaXRhYmxlKHZpZXcsIG5vZGUsIHN0YXRlKSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgbm9kZS5jb250ZW50RWRpdGFibGUgPSBzdGF0ZTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG59XG4vLyBJc3N1ZSAjODY3IC8gIzEwOTAgLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05MDM4MjFcbi8vIEluIHdoaWNoIFNhZmFyaSAoYW5kIGF0IHNvbWUgcG9pbnQgaW4gdGhlIHBhc3QsIENocm9tZSkgZG9lcyByZWFsbHlcbi8vIHdyb25nIHRoaW5ncyB3aGVuIHRoZSBkb3duIGFycm93IGlzIHByZXNzZWQgd2hlbiB0aGUgY3Vyc29yIGlzXG4vLyBkaXJlY3RseSBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2sgYW5kIGhhcyBhbiB1bmVkaXRhYmxlIG5vZGVcbi8vIGFmdGVyIGl0XG5mdW5jdGlvbiBzYWZhcmlEb3duQXJyb3dCdWcodmlldykge1xuICAgIGlmICghc2FmYXJpIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRoZWFkLnBhcmVudE9mZnNldCA+IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKGZvY3VzTm9kZSAmJiBmb2N1c05vZGUubm9kZVR5cGUgPT0gMSAmJiBmb2N1c09mZnNldCA9PSAwICYmXG4gICAgICAgIGZvY3VzTm9kZS5maXJzdENoaWxkICYmIGZvY3VzTm9kZS5maXJzdENoaWxkLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZm9jdXNOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCBcInRydWVcIik7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc3dpdGNoRWRpdGFibGUodmlldywgY2hpbGQsIFwiZmFsc2VcIiksIDIwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQSBiYWNrZHJvcCBrZXkgbWFwcGluZyB1c2VkIHRvIG1ha2Ugc3VyZSB3ZSBhbHdheXMgc3VwcHJlc3Mga2V5c1xuLy8gdGhhdCBoYXZlIGEgZGFuZ2Vyb3VzIGRlZmF1bHQgZWZmZWN0LCBldmVuIGlmIHRoZSBjb21tYW5kcyB0aGV5IGFyZVxuLy8gYm91bmQgdG8gcmV0dXJuIGZhbHNlLCBhbmQgdG8gbWFrZSBzdXJlIHRoYXQgY3Vyc29yLW1vdGlvbiBrZXlzXG4vLyBmaW5kIGEgY3Vyc29yIChhcyBvcHBvc2VkIHRvIGEgbm9kZSBzZWxlY3Rpb24pIHdoZW4gcHJlc3NlZC4gRm9yXG4vLyBjdXJzb3ItbW90aW9uIGtleXMsIHRoZSBjb2RlIGluIHRoZSBoYW5kbGVycyBhbHNvIHRha2VzIGNhcmUgb2Zcbi8vIGJsb2NrIHNlbGVjdGlvbnMuXG5mdW5jdGlvbiBnZXRNb2RzKGV2ZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcImNcIjtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwibVwiO1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcImFcIjtcbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcInNcIjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgY29kZSA9IGV2ZW50LmtleUNvZGUsIG1vZHMgPSBnZXRNb2RzKGV2ZW50KTtcbiAgICBpZiAoY29kZSA9PSA4IHx8IChtYWMgJiYgY29kZSA9PSA3MiAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBCYWNrc3BhY2UsIEN0cmwtaCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIC0xKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGNvZGUgPT0gNDYgJiYgIWV2ZW50LnNoaWZ0S2V5KSB8fCAobWFjICYmIGNvZGUgPT0gNjggJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gRGVsZXRlLCBDdHJsLWQgb24gTWFjXG4gICAgICAgIHJldHVybiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCAxKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDEzIHx8IGNvZGUgPT0gMjcpIHsgLy8gRW50ZXIsIEVzY1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzNyB8fCAobWFjICYmIGNvZGUgPT0gNjYgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gTGVmdCBhcnJvdywgQ3RybC1iIG9uIE1hY1xuICAgICAgICBsZXQgZGlyID0gY29kZSA9PSAzNyA/IChmaW5kRGlyZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pID09IFwibHRyXCIgPyAtMSA6IDEpIDogLTE7XG4gICAgICAgIHJldHVybiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzkgfHwgKG1hYyAmJiBjb2RlID09IDcwICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIFJpZ2h0IGFycm93LCBDdHJsLWYgb24gTWFjXG4gICAgICAgIGxldCBkaXIgPSBjb2RlID09IDM5ID8gKGZpbmREaXJlY3Rpb24odmlldywgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSkgPT0gXCJsdHJcIiA/IDEgOiAtMSkgOiAxO1xuICAgICAgICByZXR1cm4gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM4IHx8IChtYWMgJiYgY29kZSA9PSA4MCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBVcCBhcnJvdywgQ3RybC1wIG9uIE1hY1xuICAgICAgICByZXR1cm4gc2VsZWN0VmVydGljYWxseSh2aWV3LCAtMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAtMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gNDAgfHwgKG1hYyAmJiBjb2RlID09IDc4ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIERvd24gYXJyb3csIEN0cmwtbiBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB8fCBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIDEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vZHMgPT0gKG1hYyA/IFwibVwiIDogXCJjXCIpICYmXG4gICAgICAgIChjb2RlID09IDY2IHx8IGNvZGUgPT0gNzMgfHwgY29kZSA9PSA4OSB8fCBjb2RlID09IDkwKSkgeyAvLyBNb2QtW2JpeXpdXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSkge1xuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1Db3BpZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIGxldCBjb250ZXh0ID0gW10sIHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSBzbGljZTtcbiAgICB3aGlsZSAob3BlblN0YXJ0ID4gMSAmJiBvcGVuRW5kID4gMSAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSAmJiBjb250ZW50LmZpcnN0Q2hpbGQuY2hpbGRDb3VudCA9PSAxKSB7XG4gICAgICAgIG9wZW5TdGFydC0tO1xuICAgICAgICBvcGVuRW5kLS07XG4gICAgICAgIGxldCBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBjb250ZXh0LnB1c2gobm9kZS50eXBlLm5hbWUsIG5vZGUuYXR0cnMgIT0gbm9kZS50eXBlLmRlZmF1bHRBdHRycyA/IG5vZGUuYXR0cnMgOiBudWxsKTtcbiAgICAgICAgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgICB9XG4gICAgbGV0IHNlcmlhbGl6ZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkU2VyaWFsaXplclwiKSB8fCBET01TZXJpYWxpemVyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgIGxldCBkb2MgPSBkZXRhY2hlZERvYygpLCB3cmFwID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChzZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KGNvbnRlbnQsIHsgZG9jdW1lbnQ6IGRvYyB9KSk7XG4gICAgbGV0IGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQsIG5lZWRzV3JhcCwgd3JhcHBlcnMgPSAwO1xuICAgIHdoaWxlIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJiAobmVlZHNXcmFwID0gd3JhcE1hcFtmaXJzdENoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gbmVlZHNXcmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KG5lZWRzV3JhcFtpXSk7XG4gICAgICAgICAgICB3aGlsZSAod3JhcC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQod3JhcC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgICAgICB3cmFwcGVycysrO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIsIGAke29wZW5TdGFydH0gJHtvcGVuRW5kfSR7d3JhcHBlcnMgPyBgIC0ke3dyYXBwZXJzfWAgOiBcIlwifSAke0pTT04uc3RyaW5naWZ5KGNvbnRleHQpfWApO1xuICAgIGxldCB0ZXh0ID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIsIGYgPT4gZihzbGljZSwgdmlldykpIHx8XG4gICAgICAgIHNsaWNlLmNvbnRlbnQudGV4dEJldHdlZW4oMCwgc2xpY2UuY29udGVudC5zaXplLCBcIlxcblxcblwiKTtcbiAgICByZXR1cm4geyBkb206IHdyYXAsIHRleHQsIHNsaWNlIH07XG59XG4vLyBSZWFkIGEgc2xpY2Ugb2YgY29udGVudCBmcm9tIHRoZSBjbGlwYm9hcmQgKG9yIGRyb3AgZGF0YSkuXG5mdW5jdGlvbiBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgdGV4dCwgaHRtbCwgcGxhaW5UZXh0LCAkY29udGV4dCkge1xuICAgIGxldCBpbkNvZGUgPSAkY29udGV4dC5wYXJlbnQudHlwZS5zcGVjLmNvZGU7XG4gICAgbGV0IGRvbSwgc2xpY2U7XG4gICAgaWYgKCFodG1sICYmICF0ZXh0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYXNUZXh0ID0gdGV4dCAmJiAocGxhaW5UZXh0IHx8IGluQ29kZSB8fCAhaHRtbCk7XG4gICAgaWYgKGFzVGV4dCkge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkVGV4dFwiLCBmID0+IHsgdGV4dCA9IGYodGV4dCwgaW5Db2RlIHx8IHBsYWluVGV4dCwgdmlldyk7IH0pO1xuICAgICAgICBpZiAoaW5Db2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRleHQgPyBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh2aWV3LnN0YXRlLnNjaGVtYS50ZXh0KHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSkpLCAwLCAwKSA6IFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgcGFyc2VkID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRQYXJzZXJcIiwgZiA9PiBmKHRleHQsICRjb250ZXh0LCBwbGFpblRleHQsIHZpZXcpKTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgc2xpY2UgPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSAkY29udGV4dC5tYXJrcygpO1xuICAgICAgICAgICAgbGV0IHsgc2NoZW1hIH0gPSB2aWV3LnN0YXRlLCBzZXJpYWxpemVyID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGV4dC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pKy8pLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwID0gZG9tLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgICAgICAgICAgIHAuYXBwZW5kQ2hpbGQoc2VyaWFsaXplci5zZXJpYWxpemVOb2RlKHNjaGVtYS50ZXh0KGJsb2NrLCBtYXJrcykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkSFRNTFwiLCBmID0+IHsgaHRtbCA9IGYoaHRtbCwgdmlldyk7IH0pO1xuICAgICAgICBkb20gPSByZWFkSFRNTChodG1sKTtcbiAgICAgICAgaWYgKHdlYmtpdClcbiAgICAgICAgICAgIHJlc3RvcmVSZXBsYWNlZFNwYWNlcyhkb20pO1xuICAgIH1cbiAgICBsZXQgY29udGV4dE5vZGUgPSBkb20gJiYgZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1wbS1zbGljZV1cIik7XG4gICAgbGV0IHNsaWNlRGF0YSA9IGNvbnRleHROb2RlICYmIC9eKFxcZCspIChcXGQrKSg/OiAtKFxcZCspKT8gKC4qKS8uZXhlYyhjb250ZXh0Tm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIpIHx8IFwiXCIpO1xuICAgIGlmIChzbGljZURhdGEgJiYgc2xpY2VEYXRhWzNdKVxuICAgICAgICBmb3IgKGxldCBpID0gK3NsaWNlRGF0YVszXTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRvbSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgaWYgKCFzbGljZSkge1xuICAgICAgICBsZXQgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFBhcnNlclwiKSB8fCB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICAgICAgc2xpY2UgPSBwYXJzZXIucGFyc2VTbGljZShkb20sIHtcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogISEoYXNUZXh0IHx8IHNsaWNlRGF0YSksXG4gICAgICAgICAgICBjb250ZXh0OiAkY29udGV4dCxcbiAgICAgICAgICAgIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZG9tLm5leHRTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIGRvbS5wYXJlbnROb2RlICYmICFpbmxpbmVQYXJlbnRzLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpZ25vcmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzbGljZURhdGEpIHtcbiAgICAgICAgc2xpY2UgPSBhZGRDb250ZXh0KGNsb3NlU2xpY2Uoc2xpY2UsICtzbGljZURhdGFbMV0sICtzbGljZURhdGFbMl0pLCBzbGljZURhdGFbNF0pO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gSFRNTCB3YXNuJ3QgY3JlYXRlZCBieSBQcm9zZU1pcnJvci4gTWFrZSBzdXJlIHRvcC1sZXZlbCBzaWJsaW5ncyBhcmUgY29oZXJlbnRcbiAgICAgICAgc2xpY2UgPSBTbGljZS5tYXhPcGVuKG5vcm1hbGl6ZVNpYmxpbmdzKHNsaWNlLmNvbnRlbnQsICRjb250ZXh0KSwgdHJ1ZSk7XG4gICAgICAgIGlmIChzbGljZS5vcGVuU3RhcnQgfHwgc2xpY2Uub3BlbkVuZCkge1xuICAgICAgICAgICAgbGV0IG9wZW5TdGFydCA9IDAsIG9wZW5FbmQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZDsgb3BlblN0YXJ0IDwgc2xpY2Uub3BlblN0YXJ0ICYmICFub2RlLnR5cGUuc3BlYy5pc29sYXRpbmc7IG9wZW5TdGFydCsrLCBub2RlID0gbm9kZS5maXJzdENoaWxkKSB7IH1cbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzbGljZS5jb250ZW50Lmxhc3RDaGlsZDsgb3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQgJiYgIW5vZGUudHlwZS5zcGVjLmlzb2xhdGluZzsgb3BlbkVuZCsrLCBub2RlID0gbm9kZS5sYXN0Q2hpbGQpIHsgfVxuICAgICAgICAgICAgc2xpY2UgPSBjbG9zZVNsaWNlKHNsaWNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIHJldHVybiBzbGljZTtcbn1cbmNvbnN0IGlubGluZVBhcmVudHMgPSAvXihhfGFiYnJ8YWNyb255bXxifGNpdGV8Y29kZXxkZWx8ZW18aXxpbnN8a2JkfGxhYmVsfG91dHB1dHxxfHJ1Ynl8c3xzYW1wfHNwYW58c3Ryb25nfHN1YnxzdXB8dGltZXx1fHR0fHZhcikkL2k7XG4vLyBUYWtlcyBhIHNsaWNlIHBhcnNlZCB3aXRoIHBhcnNlU2xpY2UsIHdoaWNoIG1lYW5zIHRoZXJlIGhhc24ndCBiZWVuXG4vLyBhbnkgY29udGVudC1leHByZXNzaW9uIGNoZWNraW5nIGRvbmUgb24gdGhlIHRvcCBub2RlcywgdHJpZXMgdG9cbi8vIGZpbmQgYSBwYXJlbnQgbm9kZSBpbiB0aGUgY3VycmVudCBjb250ZXh0IHRoYXQgbWlnaHQgZml0IHRoZSBub2Rlcyxcbi8vIGFuZCBpZiBzdWNjZXNzZnVsLCByZWJ1aWxkcyB0aGUgc2xpY2Ugc28gdGhhdCBpdCBmaXRzIGludG8gdGhhdCBwYXJlbnQuXG4vL1xuLy8gVGhpcyBhZGRyZXNzZXMgdGhlIHByb2JsZW0gdGhhdCBUcmFuc2Zvcm0ucmVwbGFjZSBleHBlY3RzIGFcbi8vIGNvaGVyZW50IHNsaWNlLCBhbmQgd2lsbCBmYWlsIHRvIHBsYWNlIGEgc2V0IG9mIHNpYmxpbmdzIHRoYXQgZG9uJ3Rcbi8vIGZpdCBhbnl3aGVyZSBpbiB0aGUgc2NoZW1hLlxuZnVuY3Rpb24gbm9ybWFsaXplU2libGluZ3MoZnJhZ21lbnQsICRjb250ZXh0KSB7XG4gICAgaWYgKGZyYWdtZW50LmNoaWxkQ291bnQgPCAyKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgZm9yIChsZXQgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gJGNvbnRleHQubm9kZShkKTtcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4KGQpKTtcbiAgICAgICAgbGV0IGxhc3RXcmFwLCByZXN1bHQgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB3cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSksIGluTGFzdDtcbiAgICAgICAgICAgIGlmICghd3JhcClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpbkxhc3QgPSByZXN1bHQubGVuZ3RoICYmIGxhc3RXcmFwLmxlbmd0aCAmJiBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIDApKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IGluTGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gY2xvc2VSaWdodChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCBsYXN0V3JhcC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxldCB3cmFwcGVkID0gd2l0aFdyYXBwZXJzKG5vZGUsIHdyYXApO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHdyYXBwZWQpO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hUeXBlKHdyYXBwZWQudHlwZSk7XG4gICAgICAgICAgICAgICAgbGFzdFdyYXAgPSB3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIHdpdGhXcmFwcGVycyhub2RlLCB3cmFwLCBmcm9tID0gMCkge1xuICAgIGZvciAobGV0IGkgPSB3cmFwLmxlbmd0aCAtIDE7IGkgPj0gZnJvbTsgaS0tKVxuICAgICAgICBub2RlID0gd3JhcFtpXS5jcmVhdGUobnVsbCwgRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG4vLyBVc2VkIHRvIGdyb3VwIGFkamFjZW50IG5vZGVzIHdyYXBwZWQgaW4gc2ltaWxhciBwYXJlbnRzIGJ5XG4vLyBub3JtYWxpemVTaWJsaW5ncyBpbnRvIHRoZSBzYW1lIHBhcmVudCBub2RlXG5mdW5jdGlvbiBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHNpYmxpbmcsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoIDwgd3JhcC5sZW5ndGggJiYgZGVwdGggPCBsYXN0V3JhcC5sZW5ndGggJiYgd3JhcFtkZXB0aF0gPT0gbGFzdFdyYXBbZGVwdGhdKSB7XG4gICAgICAgIGxldCBpbm5lciA9IGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZy5sYXN0Q2hpbGQsIGRlcHRoICsgMSk7XG4gICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LnJlcGxhY2VDaGlsZChzaWJsaW5nLmNoaWxkQ291bnQgLSAxLCBpbm5lcikpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBzaWJsaW5nLmNvbnRlbnRNYXRjaEF0KHNpYmxpbmcuY2hpbGRDb3VudCk7XG4gICAgICAgIGlmIChtYXRjaC5tYXRjaFR5cGUoZGVwdGggPT0gd3JhcC5sZW5ndGggLSAxID8gbm9kZS50eXBlIDogd3JhcFtkZXB0aCArIDFdKSlcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LmFwcGVuZChGcmFnbWVudC5mcm9tKHdpdGhXcmFwcGVycyhub2RlLCB3cmFwLCBkZXB0aCArIDEpKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlUmlnaHQobm9kZSwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgbGV0IGZyYWdtZW50ID0gbm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChub2RlLmNoaWxkQ291bnQgLSAxLCBjbG9zZVJpZ2h0KG5vZGUubGFzdENoaWxkLCBkZXB0aCAtIDEpKTtcbiAgICBsZXQgZmlsbCA9IG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICByZXR1cm4gbm9kZS5jb3B5KGZyYWdtZW50LmFwcGVuZChmaWxsKSk7XG59XG5mdW5jdGlvbiBjbG9zZVJhbmdlKGZyYWdtZW50LCBzaWRlLCBmcm9tLCB0bywgZGVwdGgsIG9wZW5FbmQpIHtcbiAgICBsZXQgbm9kZSA9IHNpZGUgPCAwID8gZnJhZ21lbnQuZmlyc3RDaGlsZCA6IGZyYWdtZW50Lmxhc3RDaGlsZCwgaW5uZXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgaWYgKGZyYWdtZW50LmNoaWxkQ291bnQgPiAxKVxuICAgICAgICBvcGVuRW5kID0gMDtcbiAgICBpZiAoZGVwdGggPCB0byAtIDEpXG4gICAgICAgIGlubmVyID0gY2xvc2VSYW5nZShpbm5lciwgc2lkZSwgZnJvbSwgdG8sIGRlcHRoICsgMSwgb3BlbkVuZCk7XG4gICAgaWYgKGRlcHRoID49IGZyb20pXG4gICAgICAgIGlubmVyID0gc2lkZSA8IDAgPyBub2RlLmNvbnRlbnRNYXRjaEF0KDApLmZpbGxCZWZvcmUoaW5uZXIsIG9wZW5FbmQgPD0gZGVwdGgpLmFwcGVuZChpbm5lcilcbiAgICAgICAgICAgIDogaW5uZXIuYXBwZW5kKG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZChzaWRlIDwgMCA/IDAgOiBmcmFnbWVudC5jaGlsZENvdW50IC0gMSwgbm9kZS5jb3B5KGlubmVyKSk7XG59XG5mdW5jdGlvbiBjbG9zZVNsaWNlKHNsaWNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBpZiAob3BlblN0YXJ0IDwgc2xpY2Uub3BlblN0YXJ0KVxuICAgICAgICBzbGljZSA9IG5ldyBTbGljZShjbG9zZVJhbmdlKHNsaWNlLmNvbnRlbnQsIC0xLCBvcGVuU3RhcnQsIHNsaWNlLm9wZW5TdGFydCwgMCwgc2xpY2Uub3BlbkVuZCksIG9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZCk7XG4gICAgaWYgKG9wZW5FbmQgPCBzbGljZS5vcGVuRW5kKVxuICAgICAgICBzbGljZSA9IG5ldyBTbGljZShjbG9zZVJhbmdlKHNsaWNlLmNvbnRlbnQsIDEsIG9wZW5FbmQsIHNsaWNlLm9wZW5FbmQsIDAsIDApLCBzbGljZS5vcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIHJldHVybiBzbGljZTtcbn1cbi8vIFRyaWNrIGZyb20galF1ZXJ5IC0tIHNvbWUgZWxlbWVudHMgbXVzdCBiZSB3cmFwcGVkIGluIG90aGVyXG4vLyBlbGVtZW50cyBmb3IgaW5uZXJIVE1MIHRvIHdvcmsuIEkuZS4gaWYgeW91IGRvIGBkaXYuaW5uZXJIVE1MID1cbi8vIFwiPHRkPi4uPC90ZD5cImAgdGhlIHRhYmxlIGNlbGxzIGFyZSBpZ25vcmVkLlxuY29uc3Qgd3JhcE1hcCA9IHtcbiAgICB0aGVhZDogW1widGFibGVcIl0sXG4gICAgdGJvZHk6IFtcInRhYmxlXCJdLFxuICAgIHRmb290OiBbXCJ0YWJsZVwiXSxcbiAgICBjYXB0aW9uOiBbXCJ0YWJsZVwiXSxcbiAgICBjb2xncm91cDogW1widGFibGVcIl0sXG4gICAgY29sOiBbXCJ0YWJsZVwiLCBcImNvbGdyb3VwXCJdLFxuICAgIHRyOiBbXCJ0YWJsZVwiLCBcInRib2R5XCJdLFxuICAgIHRkOiBbXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidHJcIl0sXG4gICAgdGg6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXVxufTtcbmxldCBfZGV0YWNoZWREb2MgPSBudWxsO1xuZnVuY3Rpb24gZGV0YWNoZWREb2MoKSB7XG4gICAgcmV0dXJuIF9kZXRhY2hlZERvYyB8fCAoX2RldGFjaGVkRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwidGl0bGVcIikpO1xufVxubGV0IF9wb2xpY3kgPSBudWxsO1xuZnVuY3Rpb24gbWF5YmVXcmFwVHJ1c3RlZChodG1sKSB7XG4gICAgbGV0IHRydXN0ZWRUeXBlcyA9IHdpbmRvdy50cnVzdGVkVHlwZXM7XG4gICAgaWYgKCF0cnVzdGVkVHlwZXMpXG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIC8vIFdpdGggdGhlIHJlcXVpcmUtdHJ1c3RlZC10eXBlcy1mb3IgQ1NQLCBDaHJvbWUgd2lsbCBibG9ja1xuICAgIC8vIGlubmVySFRNTCwgZXZlbiBvbiBhIGRldGFjaGVkIGRvY3VtZW50LiBUaGlzIHdyYXBzIHRoZSBzdHJpbmcgaW5cbiAgICAvLyBhIHdheSB0aGF0IG1ha2VzIHRoZSBicm93c2VyIGFsbG93IHVzIHRvIHVzZSBpdHMgcGFyc2VyIGFnYWluLlxuICAgIGlmICghX3BvbGljeSlcbiAgICAgICAgX3BvbGljeSA9IHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3koXCJQcm9zZU1pcnJvckNsaXBib2FyZFwiLCB7IGNyZWF0ZUhUTUw6IChzKSA9PiBzIH0pO1xuICAgIHJldHVybiBfcG9saWN5LmNyZWF0ZUhUTUwoaHRtbCk7XG59XG5mdW5jdGlvbiByZWFkSFRNTChodG1sKSB7XG4gICAgbGV0IG1ldGFzID0gL14oXFxzKjxtZXRhIFtePl0qPikqLy5leGVjKGh0bWwpO1xuICAgIGlmIChtZXRhcylcbiAgICAgICAgaHRtbCA9IGh0bWwuc2xpY2UobWV0YXNbMF0ubGVuZ3RoKTtcbiAgICBsZXQgZWx0ID0gZGV0YWNoZWREb2MoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGxldCBmaXJzdFRhZyA9IC88KFthLXpdW14+XFxzXSspL2kuZXhlYyhodG1sKSwgd3JhcDtcbiAgICBpZiAod3JhcCA9IGZpcnN0VGFnICYmIHdyYXBNYXBbZmlyc3RUYWdbMV0udG9Mb3dlckNhc2UoKV0pXG4gICAgICAgIGh0bWwgPSB3cmFwLm1hcChuID0+IFwiPFwiICsgbiArIFwiPlwiKS5qb2luKFwiXCIpICsgaHRtbCArIHdyYXAubWFwKG4gPT4gXCI8L1wiICsgbiArIFwiPlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICBlbHQuaW5uZXJIVE1MID0gbWF5YmVXcmFwVHJ1c3RlZChodG1sKTtcbiAgICBpZiAod3JhcClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZWx0ID0gZWx0LnF1ZXJ5U2VsZWN0b3Iod3JhcFtpXSkgfHwgZWx0O1xuICAgIHJldHVybiBlbHQ7XG59XG4vLyBXZWJraXQgYnJvd3NlcnMgZG8gc29tZSBoYXJkLXRvLXByZWRpY3QgcmVwbGFjZW1lbnQgb2YgcmVndWxhclxuLy8gc3BhY2VzIHdpdGggbm9uLWJyZWFraW5nIHNwYWNlcyB3aGVuIHB1dHRpbmcgY29udGVudCBvbiB0aGVcbi8vIGNsaXBib2FyZC4gVGhpcyB0cmllcyB0byBjb252ZXJ0IHN1Y2ggbm9uLWJyZWFraW5nIHNwYWNlcyAod2hpY2hcbi8vIHdpbGwgYmUgd3JhcHBlZCBpbiBhIHBsYWluIHNwYW4gb24gQ2hyb21lLCBhIHNwYW4gd2l0aCBjbGFzc1xuLy8gQXBwbGUtY29udmVydGVkLXNwYWNlIG9uIFNhZmFyaSkgYmFjayB0byByZWd1bGFyIHNwYWNlcy5cbmZ1bmN0aW9uIHJlc3RvcmVSZXBsYWNlZFNwYWNlcyhkb20pIHtcbiAgICBsZXQgbm9kZXMgPSBkb20ucXVlcnlTZWxlY3RvckFsbChjaHJvbWUgPyBcInNwYW46bm90KFtjbGFzc10pOm5vdChbc3R5bGVdKVwiIDogXCJzcGFuLkFwcGxlLWNvbnZlcnRlZC1zcGFjZVwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZS50ZXh0Q29udGVudCA9PSBcIlxcdTAwYTBcIiAmJiBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGRvbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiKSwgbm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkQ29udGV4dChzbGljZSwgY29udGV4dCkge1xuICAgIGlmICghc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIGxldCBzY2hlbWEgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQudHlwZS5zY2hlbWEsIGFycmF5O1xuICAgIHRyeSB7XG4gICAgICAgIGFycmF5ID0gSlNPTi5wYXJzZShjb250ZXh0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIH1cbiAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHNsaWNlO1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS5ub2Rlc1thcnJheVtpXV07XG4gICAgICAgIGlmICghdHlwZSB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhcnJheVtpICsgMV0sIGNvbnRlbnQpKTtcbiAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIG9wZW5FbmQrKztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xufVxuXG4vLyBBIGNvbGxlY3Rpb24gb2YgRE9NIGV2ZW50cyB0aGF0IG9jY3VyIHdpdGhpbiB0aGUgZWRpdG9yLCBhbmQgY2FsbGJhY2sgZnVuY3Rpb25zXG4vLyB0byBpbnZva2Ugd2hlbiB0aGUgZXZlbnQgZmlyZXMuXG5jb25zdCBoYW5kbGVycyA9IHt9O1xuY29uc3QgZWRpdEhhbmRsZXJzID0ge307XG5jb25zdCBwYXNzaXZlSGFuZGxlcnMgPSB7IHRvdWNoc3RhcnQ6IHRydWUsIHRvdWNobW92ZTogdHJ1ZSB9O1xuY2xhc3MgSW5wdXRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2hpZnRLZXkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZVRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDbGljayA9IHsgdGltZTogMCwgeDogMCwgeTogMCwgdHlwZTogXCJcIiB9O1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICB0aGlzLmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RGb2N1cyA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q2hyb21lRGVsZXRlID0gMDtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbk5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBvc2luZ1RpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbk5vZGVzID0gW107XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0ID0gLTJlODtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbklEID0gMTtcbiAgICAgICAgLy8gU2V0IHRvIGEgY29tcG9zaXRpb24gSUQgd2hlbiB0aGVyZSBhcmUgcGVuZGluZyBjaGFuZ2VzIGF0IGNvbXBvc2l0aW9uZW5kXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IDA7XG4gICAgICAgIHRoaXMuZG9tQ2hhbmdlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmhpZGVTZWxlY3Rpb25HdWFyZCA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5pdElucHV0KHZpZXcpIHtcbiAgICBmb3IgKGxldCBldmVudCBpbiBoYW5kbGVycykge1xuICAgICAgICBsZXQgaGFuZGxlciA9IGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW2V2ZW50XSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50QmVsb25nc1RvVmlldyh2aWV3LCBldmVudCkgJiYgIXJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpICYmXG4gICAgICAgICAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgIShldmVudC50eXBlIGluIGVkaXRIYW5kbGVycykpKVxuICAgICAgICAgICAgICAgIGhhbmRsZXIodmlldywgZXZlbnQpO1xuICAgICAgICB9LCBwYXNzaXZlSGFuZGxlcnNbZXZlbnRdID8geyBwYXNzaXZlOiB0cnVlIH0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvLyBPbiBTYWZhcmksIGZvciByZWFzb25zIGJleW9uZCBteSB1bmRlcnN0YW5kaW5nLCBhZGRpbmcgYW4gaW5wdXRcbiAgICAvLyBldmVudCBoYW5kbGVyIG1ha2VzIGFuIGlzc3VlIHdoZXJlIHRoZSBjb21wb3NpdGlvbiB2YW5pc2hlcyB3aGVuXG4gICAgLy8geW91IHByZXNzIGVudGVyIGdvIGF3YXkuXG4gICAgaWYgKHNhZmFyaSlcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IG51bGwpO1xuICAgIGVuc3VyZUxpc3RlbmVycyh2aWV3KTtcbn1cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBvcmlnaW4pIHtcbiAgICB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBvcmlnaW47XG4gICAgdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uVGltZSA9IERhdGUubm93KCk7XG59XG5mdW5jdGlvbiBkZXN0cm95SW5wdXQodmlldykge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIGZvciAobGV0IHR5cGUgaW4gdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzKVxuICAgICAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSk7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0KTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUxpc3RlbmVycyh2aWV3KSB7XG4gICAgdmlldy5zb21lUHJvcChcImhhbmRsZURPTUV2ZW50c1wiLCBjdXJyZW50SGFuZGxlcnMgPT4ge1xuICAgICAgICBmb3IgKGxldCB0eXBlIGluIGN1cnJlbnRIYW5kbGVycylcbiAgICAgICAgICAgIGlmICghdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdKVxuICAgICAgICAgICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdID0gZXZlbnQgPT4gcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkge1xuICAgIHJldHVybiB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGhhbmRsZXJzID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudC50eXBlXTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIgPyBoYW5kbGVyKHZpZXcsIGV2ZW50KSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkIDogZmFsc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBldmVudEJlbG9uZ3NUb1ZpZXcodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmJ1YmJsZXMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbm9kZSA9IGV2ZW50LnRhcmdldDsgbm9kZSAhPSB2aWV3LmRvbTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgfHxcbiAgICAgICAgICAgIChub2RlLnBtVmlld0Rlc2MgJiYgbm9kZS5wbVZpZXdEZXNjLnN0b3BFdmVudChldmVudCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCh2aWV3LCBldmVudCkge1xuICAgIGlmICghcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkgJiYgaGFuZGxlcnNbZXZlbnQudHlwZV0gJiZcbiAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgIShldmVudC50eXBlIGluIGVkaXRIYW5kbGVycykpKVxuICAgICAgICBoYW5kbGVyc1tldmVudC50eXBlXSh2aWV3LCBldmVudCk7XG59XG5lZGl0SGFuZGxlcnMua2V5ZG93biA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgdmlldy5pbnB1dC5zaGlmdEtleSA9IGV2ZW50LmtleUNvZGUgPT0gMTYgfHwgZXZlbnQuc2hpZnRLZXk7XG4gICAgaWYgKGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpKVxuICAgICAgICByZXR1cm47XG4gICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFN1cHByZXNzIGVudGVyIGtleSBldmVudHMgb24gQ2hyb21lIEFuZHJvaWQsIGJlY2F1c2UgdGhvc2UgdGVuZFxuICAgIC8vIHRvIGJlIHBhcnQgb2YgYSBjb25mdXNlZCBzZXF1ZW5jZSBvZiBjb21wb3NpdGlvbiBldmVudHMgZmlyZWQsXG4gICAgLy8gYW5kIGhhbmRsaW5nIHRoZW0gZWFnZXJseSB0ZW5kcyB0byBjb3JydXB0IHRoZSBpbnB1dC5cbiAgICBpZiAoYW5kcm9pZCAmJiBjaHJvbWUgJiYgZXZlbnQua2V5Q29kZSA9PSAxMylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChldmVudC5rZXlDb2RlICE9IDIyOSlcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgLy8gT24gaU9TLCBpZiB3ZSBwcmV2ZW50RGVmYXVsdCBlbnRlciBrZXkgcHJlc3NlcywgdGhlIHZpcnR1YWxcbiAgICAvLyBrZXlib2FyZCBnZXRzIGNvbmZ1c2VkLiBTbyB0aGUgaGFjayBoZXJlIGlzIHRvIHNldCBhIGZsYWcgdGhhdFxuICAgIC8vIG1ha2VzIHRoZSBET00gY2hhbmdlIGNvZGUgcmVjb2duaXplIHRoYXQgd2hhdCBqdXN0IGhhcHBlbnMgc2hvdWxkXG4gICAgLy8gYmUgcmVwbGFjZWQgYnkgd2hhdGV2ZXIgdGhlIEVudGVyIGtleSBoYW5kbGVycyBkby5cbiAgICBpZiAoaW9zICYmIGV2ZW50LmtleUNvZGUgPT0gMTMgJiYgIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQubWV0YUtleSkge1xuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSBub3c7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPT0gbm93KSB7XG4gICAgICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSk7XG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyMDApO1xuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywgZXZlbnQpKSB8fCBjYXB0dXJlS2V5RG93bih2aWV3LCBldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcImtleVwiKTtcbiAgICB9XG59O1xuZWRpdEhhbmRsZXJzLmtleXVwID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTYpXG4gICAgICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBmYWxzZTtcbn07XG5lZGl0SGFuZGxlcnMua2V5cHJlc3MgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSB8fCAhZXZlbnQuY2hhckNvZGUgfHxcbiAgICAgICAgZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5IHx8IG1hYyAmJiBldmVudC5tZXRhS2V5KVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlQcmVzc1wiLCBmID0+IGYodmlldywgZXZlbnQpKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoIShzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB8fCAhc2VsLiRmcm9tLnNhbWVQYXJlbnQoc2VsLiR0bykpIHtcbiAgICAgICAgbGV0IHRleHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmNoYXJDb2RlKTtcbiAgICAgICAgaWYgKCEvW1xcclxcbl0vLnRlc3QodGV4dCkgJiYgIXZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZiA9PiBmKHZpZXcsIHNlbC4kZnJvbS5wb3MsIHNlbC4kdG8ucG9zLCB0ZXh0KSkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZXZlbnRDb29yZHMoZXZlbnQpIHsgcmV0dXJuIHsgbGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZIH07IH1cbmZ1bmN0aW9uIGlzTmVhcihldmVudCwgY2xpY2spIHtcbiAgICBsZXQgZHggPSBjbGljay54IC0gZXZlbnQuY2xpZW50WCwgZHkgPSBjbGljay55IC0gZXZlbnQuY2xpZW50WTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgPCAxMDA7XG59XG5mdW5jdGlvbiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIHByb3BOYW1lLCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGlmICh2aWV3LnNvbWVQcm9wKHByb3BOYW1lLCBmID0+IGkgPiAkcG9zLmRlcHRoID8gZih2aWV3LCBwb3MsICRwb3Mubm9kZUFmdGVyLCAkcG9zLmJlZm9yZShpKSwgZXZlbnQsIHRydWUpXG4gICAgICAgICAgICA6IGYodmlldywgcG9zLCAkcG9zLm5vZGUoaSksICRwb3MuYmVmb3JlKGkpLCBldmVudCwgZmFsc2UpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24odmlldywgc2VsZWN0aW9uLCBvcmlnaW4pIHtcbiAgICBpZiAoIXZpZXcuZm9jdXNlZClcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5lcShzZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBpZiAob3JpZ2luID09IFwicG9pbnRlclwiKVxuICAgICAgICB0ci5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdENsaWNrZWRMZWFmKHZpZXcsIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKSwgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgIGlmIChub2RlICYmIG5vZGUuaXNBdG9tICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0Q2xpY2tlZE5vZGUodmlldywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0ZWROb2RlLCBzZWxlY3RBdDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbilcbiAgICAgICAgc2VsZWN0ZWROb2RlID0gc2VsLm5vZGU7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcbiAgICAgICAgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIHNlbC4kZnJvbS5kZXB0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBpID49IHNlbC4kZnJvbS5kZXB0aCAmJiAkcG9zLmJlZm9yZShzZWwuJGZyb20uZGVwdGggKyAxKSA9PSBzZWwuJGZyb20ucG9zKVxuICAgICAgICAgICAgICAgIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoc2VsLiRmcm9tLmRlcHRoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWxlY3RBdCA9ICRwb3MuYmVmb3JlKGkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdEF0ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBzZWxlY3RBdCksIFwicG9pbnRlclwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50LCBzZWxlY3ROb2RlKSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSkgfHxcbiAgICAgICAgKHNlbGVjdE5vZGUgPyBzZWxlY3RDbGlja2VkTm9kZSh2aWV3LCBpbnNpZGUpIDogc2VsZWN0Q2xpY2tlZExlYWYodmlldywgaW5zaWRlKSk7XG59XG5mdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZURvdWJsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRG91YmxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVRyaXBsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlVHJpcGxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVUcmlwbGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpIHx8XG4gICAgICAgIGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGlmIChpbnNpZGUgPT0gLTEpIHtcbiAgICAgICAgaWYgKGRvYy5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCAwLCBkb2MuY29udGVudC5zaXplKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcbiAgICAgICAgbGV0IG5vZGVQb3MgPSAkcG9zLmJlZm9yZShpKTtcbiAgICAgICAgaWYgKG5vZGUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIG5vZGVQb3MgKyAxLCBub2RlUG9zICsgMSArIG5vZGUuY29udGVudC5zaXplKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICBlbHNlIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIG5vZGVQb3MpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JjZURPTUZsdXNoKHZpZXcpIHtcbiAgICByZXR1cm4gZW5kQ29tcG9zaXRpb24odmlldyk7XG59XG5jb25zdCBzZWxlY3ROb2RlTW9kaWZpZXIgPSBtYWMgPyBcIm1ldGFLZXlcIiA6IFwiY3RybEtleVwiO1xuaGFuZGxlcnMubW91c2Vkb3duID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgbGV0IGZsdXNoZWQgPSBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICAgIGxldCBub3cgPSBEYXRlLm5vdygpLCB0eXBlID0gXCJzaW5nbGVDbGlja1wiO1xuICAgIGlmIChub3cgLSB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lIDwgNTAwICYmIGlzTmVhcihldmVudCwgdmlldy5pbnB1dC5sYXN0Q2xpY2spICYmICFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdKSB7XG4gICAgICAgIGlmICh2aWV3LmlucHV0Lmxhc3RDbGljay50eXBlID09IFwic2luZ2xlQ2xpY2tcIilcbiAgICAgICAgICAgIHR5cGUgPSBcImRvdWJsZUNsaWNrXCI7XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuaW5wdXQubGFzdENsaWNrLnR5cGUgPT0gXCJkb3VibGVDbGlja1wiKVxuICAgICAgICAgICAgdHlwZSA9IFwidHJpcGxlQ2xpY2tcIjtcbiAgICB9XG4gICAgdmlldy5pbnB1dC5sYXN0Q2xpY2sgPSB7IHRpbWU6IG5vdywgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSwgdHlwZSB9O1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgaWYgKCFwb3MpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpIHtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQubW91c2VEb3duKVxuICAgICAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24uZG9uZSgpO1xuICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93biA9IG5ldyBNb3VzZURvd24odmlldywgcG9zLCBldmVudCwgISFmbHVzaGVkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHR5cGUgPT0gXCJkb3VibGVDbGlja1wiID8gaGFuZGxlRG91YmxlQ2xpY2sgOiBoYW5kbGVUcmlwbGVDbGljaykodmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xuICAgIH1cbn07XG5jbGFzcyBNb3VzZURvd24ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHBvcywgZXZlbnQsIGZsdXNoZWQpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy5mbHVzaGVkID0gZmx1c2hlZDtcbiAgICAgICAgdGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1pZ2h0RHJhZyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhcnREb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICAgICAgdGhpcy5zZWxlY3ROb2RlID0gISFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdO1xuICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICBsZXQgdGFyZ2V0Tm9kZSwgdGFyZ2V0UG9zO1xuICAgICAgICBpZiAocG9zLmluc2lkZSA+IC0xKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlID0gdmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBvcy5pbnNpZGUpO1xuICAgICAgICAgICAgdGFyZ2V0UG9zID0gcG9zLmluc2lkZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKTtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSAkcG9zLnBhcmVudDtcbiAgICAgICAgICAgIHRhcmdldFBvcyA9ICRwb3MuZGVwdGggPyAkcG9zLmJlZm9yZSgpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBmbHVzaGVkID8gbnVsbCA6IGV2ZW50LnRhcmdldDtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGVzYyA9IHRhcmdldCA/IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyh0YXJnZXQsIHRydWUpIDogbnVsbDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXREZXNjICYmIHRhcmdldERlc2MuZG9tLm5vZGVUeXBlID09IDEgPyB0YXJnZXREZXNjLmRvbSA6IG51bGw7XG4gICAgICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gdmlldy5zdGF0ZTtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PSAwICYmXG4gICAgICAgICAgICB0YXJnZXROb2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUgJiYgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuc2VsZWN0YWJsZSAhPT0gZmFsc2UgfHxcbiAgICAgICAgICAgIHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmZyb20gPD0gdGFyZ2V0UG9zICYmIHNlbGVjdGlvbi50byA+IHRhcmdldFBvcylcbiAgICAgICAgICAgIHRoaXMubWlnaHREcmFnID0ge1xuICAgICAgICAgICAgICAgIG5vZGU6IHRhcmdldE5vZGUsXG4gICAgICAgICAgICAgICAgcG9zOiB0YXJnZXRQb3MsXG4gICAgICAgICAgICAgICAgYWRkQXR0cjogISEodGhpcy50YXJnZXQgJiYgIXRoaXMudGFyZ2V0LmRyYWdnYWJsZSksXG4gICAgICAgICAgICAgICAgc2V0VW5lZGl0YWJsZTogISEodGhpcy50YXJnZXQgJiYgZ2Vja28gJiYgIXRoaXMudGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCAmJiB0aGlzLm1pZ2h0RHJhZyAmJiAodGhpcy5taWdodERyYWcuYWRkQXR0ciB8fCB0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyKVxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy5pbnB1dC5tb3VzZURvd24gPT0gdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnNldEF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiLCBcImZhbHNlXCIpO1xuICAgICAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwID0gdGhpcy51cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcykpO1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xuICAgIH1cbiAgICBkb25lKCkge1xuICAgICAgICB0aGlzLnZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwKTtcbiAgICAgICAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUpO1xuICAgICAgICBpZiAodGhpcy5taWdodERyYWcgJiYgdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cilcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIik7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYylcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2VsZWN0aW9uVG9ET00odGhpcy52aWV3KSk7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dC5tb3VzZURvd24gPSBudWxsO1xuICAgIH1cbiAgICB1cChldmVudCkge1xuICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5kb2MgIT0gdGhpcy5zdGFydERvYylcbiAgICAgICAgICAgIHBvcyA9IHRoaXMudmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgICAgICB0aGlzLnVwZGF0ZUFsbG93RGVmYXVsdChldmVudCk7XG4gICAgICAgIGlmICh0aGlzLmFsbG93RGVmYXVsdCB8fCAhcG9zKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFuZGxlU2luZ2xlQ2xpY2sodGhpcy52aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCwgdGhpcy5zZWxlY3ROb2RlKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgICAgICAgKHRoaXMuZmx1c2hlZCB8fFxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBpZ25vcmVzIGNsaWNrcyBvbiBkcmFnZ2FibGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAoc2FmYXJpICYmIHRoaXMubWlnaHREcmFnICYmICF0aGlzLm1pZ2h0RHJhZy5ub2RlLmlzQXRvbSkgfHxcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMgdHJlYXQgYSBub2RlIHNlbGVjdGlvbiBhcyBhXG4gICAgICAgICAgICAgICAgLy8gY3Vyc29yLCBidXQgc3RpbGwgcmVwb3J0IHRoYXQgdGhlIG5vZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGFza2VkIHRocm91Z2ggZ2V0U2VsZWN0aW9uLiBZb3UnbGwgdGhlbiBnZXQgYVxuICAgICAgICAgICAgICAgIC8vIHNpdHVhdGlvbiB3aGVyZSBjbGlja2luZyBhdCB0aGUgcG9pbnQgd2hlcmUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIChoaWRkZW4pIGN1cnNvciBpcyBkb2Vzbid0IGNoYW5nZSB0aGUgc2VsZWN0aW9uLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aHVzIGRvZXNuJ3QgZ2V0IGEgcmVhY3Rpb24gZnJvbSBQcm9zZU1pcnJvci4gVGhpc1xuICAgICAgICAgICAgICAgIC8vIHdvcmtzIGFyb3VuZCB0aGF0LlxuICAgICAgICAgICAgICAgIChjaHJvbWUgJiYgIXRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihNYXRoLmFicyhwb3MucG9zIC0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tKSwgTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24udG8pKSA8PSAyKSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih0aGlzLnZpZXcsIFNlbGVjdGlvbi5uZWFyKHRoaXMudmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKSksIFwicG9pbnRlclwiKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZShldmVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUFsbG93RGVmYXVsdChldmVudCk7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMgPT0gMClcbiAgICAgICAgICAgIHRoaXMuZG9uZSgpO1xuICAgIH1cbiAgICB1cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGVmYXVsdCAmJiAoTWF0aC5hYnModGhpcy5ldmVudC54IC0gZXZlbnQuY2xpZW50WCkgPiA0IHx8XG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmV2ZW50LnkgLSBldmVudC5jbGllbnRZKSA+IDQpKVxuICAgICAgICAgICAgdGhpcy5hbGxvd0RlZmF1bHQgPSB0cnVlO1xuICAgIH1cbn1cbmhhbmRsZXJzLnRvdWNoc3RhcnQgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RUb3VjaCA9IERhdGUubm93KCk7XG4gICAgZm9yY2VET01GbHVzaCh2aWV3KTtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLnRvdWNobW92ZSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXQubGFzdFRvdWNoID0gRGF0ZS5ub3coKTtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLmNvbnRleHRtZW51ID0gdmlldyA9PiBmb3JjZURPTUZsdXNoKHZpZXcpO1xuZnVuY3Rpb24gaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0dW0uZGUvMjAxNi8wNi8yNC9oYW5kbGluZy1pbWUtZXZlbnRzLWluLWphdmFzY3JpcHQvLlxuICAgIC8vIE9uIEphcGFuZXNlIGlucHV0IG1ldGhvZCBlZGl0b3JzIChJTUVzKSwgdGhlIEVudGVyIGtleSBpcyB1c2VkIHRvIGNvbmZpcm0gY2hhcmFjdGVyXG4gICAgLy8gc2VsZWN0aW9uLiBPbiBTYWZhcmksIHdoZW4gRW50ZXIgaXMgcHJlc3NlZCwgY29tcG9zaXRpb25lbmQgYW5kIGtleWRvd24gZXZlbnRzIGFyZVxuICAgIC8vIGVtaXR0ZWQuIFRoZSBrZXlkb3duIGV2ZW50IHRyaWdnZXJzIG5ld2xpbmUgaW5zZXJ0aW9uLCB3aGljaCB3ZSBkb24ndCB3YW50LlxuICAgIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgdHJ1ZSBpZiB0aGUga2V5ZG93biBldmVudCBzaG91bGQgYmUgaWdub3JlZC5cbiAgICAvLyBXZSBvbmx5IGlnbm9yZSBpdCBvbmNlLCBhcyBwcmVzc2luZyBFbnRlciBhIHNlY29uZCB0aW1lICpzaG91bGQqIGluc2VydCBhIG5ld2xpbmUuXG4gICAgLy8gRnVydGhlcm1vcmUsIHRoZSBrZXlkb3duIGV2ZW50IHRpbWVzdGFtcCBtdXN0IGJlIGNsb3NlIHRvIHRoZSBjb21wb3NpdGlvbkVuZGVkQXQgdGltZXN0YW1wLlxuICAgIC8vIFRoaXMgZ3VhcmRzIGFnYWluc3QgdGhlIGNhc2Ugd2hlcmUgY29tcG9zaXRpb25lbmQgaXMgdHJpZ2dlcmVkIHdpdGhvdXQgdGhlIGtleWJvYXJkXG4gICAgLy8gKGUuZy4gY2hhcmFjdGVyIGNvbmZpcm1hdGlvbiBtYXkgYmUgZG9uZSB3aXRoIHRoZSBtb3VzZSksIGFuZCBrZXlkb3duIGlzIHRyaWdnZXJlZFxuICAgIC8vIGFmdGVyd2FyZHMtIHdlIHdvdWxkbid0IHdhbnQgdG8gaWdub3JlIHRoZSBrZXlkb3duIGV2ZW50IGluIHRoaXMgY2FzZS5cbiAgICBpZiAoc2FmYXJpICYmIE1hdGguYWJzKGV2ZW50LnRpbWVTdGFtcCAtIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0KSA8IDUwMCkge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBEcm9wIGFjdGl2ZSBjb21wb3NpdGlvbiBhZnRlciA1IHNlY29uZHMgb2YgaW5hY3Rpdml0eSBvbiBBbmRyb2lkXG5jb25zdCB0aW1lb3V0Q29tcG9zaXRpb24gPSBhbmRyb2lkID8gNTAwMCA6IC0xO1xuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uc3RhcnQgPSBlZGl0SGFuZGxlcnMuY29tcG9zaXRpb251cGRhdGUgPSB2aWV3ID0+IHtcbiAgICBpZiAoIXZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2goKTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsICRwb3MgPSBzdGF0ZS5zZWxlY3Rpb24uJHRvO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJlxuICAgICAgICAgICAgKHN0YXRlLnN0b3JlZE1hcmtzIHx8XG4gICAgICAgICAgICAgICAgKCEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5wYXJlbnRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLnNvbWUobSA9PiBtLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlKSkpKSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIHdyYXAgdGhlIGN1cnNvciBpbiBtYXJrIG5vZGVzIGRpZmZlcmVudCBmcm9tIHRoZSBvbmVzIGluIHRoZSBET00gY29udGV4dFxuICAgICAgICAgICAgdmlldy5tYXJrQ3Vyc29yID0gdmlldy5zdGF0ZS5zdG9yZWRNYXJrcyB8fCAkcG9zLm1hcmtzKCk7XG4gICAgICAgICAgICBlbmRDb21wb3NpdGlvbih2aWV3LCB0cnVlKTtcbiAgICAgICAgICAgIHZpZXcubWFya0N1cnNvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRDb21wb3NpdGlvbih2aWV3LCAhc3RhdGUuc2VsZWN0aW9uLmVtcHR5KTtcbiAgICAgICAgICAgIC8vIEluIGZpcmVmb3gsIGlmIHRoZSBjdXJzb3IgaXMgYWZ0ZXIgYnV0IG91dHNpZGUgYSBtYXJrZWQgbm9kZSxcbiAgICAgICAgICAgIC8vIHRoZSBpbnNlcnRlZCB0ZXh0IHdvbid0IGluaGVyaXQgdGhlIG1hcmtzLiBTbyB0aGlzIG1vdmVzIGl0XG4gICAgICAgICAgICAvLyBpbnNpZGUgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgaWYgKGdlY2tvICYmIHN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJiAkcG9zLnBhcmVudE9mZnNldCAmJiAhJHBvcy50ZXh0T2Zmc2V0ICYmICRwb3Mubm9kZUJlZm9yZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7IG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCAhPSAwOykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gb2Zmc2V0IDwgMCA/IG5vZGUubGFzdENoaWxkIDogbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwuY29sbGFwc2UoYmVmb3JlLCBiZWZvcmUubm9kZVZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IHRydWU7XG4gICAgfVxuICAgIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCB0aW1lb3V0Q29tcG9zaXRpb24pO1xufTtcbmVkaXRIYW5kbGVycy5jb21wb3NpdGlvbmVuZCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzID0gdmlldy5kb21PYnNlcnZlci5wZW5kaW5nUmVjb3JkcygpLmxlbmd0aCA/IHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCA6IDA7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2RlID0gbnVsbDtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcylcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdmlldy5kb21PYnNlcnZlci5mbHVzaCgpKTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbklEKys7XG4gICAgICAgIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCAyMCk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCBkZWxheSkge1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQpO1xuICAgIGlmIChkZWxheSA+IC0xKVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGVuZENvbXBvc2l0aW9uKHZpZXcpLCBkZWxheSk7XG59XG5mdW5jdGlvbiBjbGVhckNvbXBvc2l0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSB0aW1lc3RhbXBGcm9tQ3VzdG9tRXZlbnQoKTtcbiAgICB9XG4gICAgd2hpbGUgKHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5sZW5ndGggPiAwKVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucG9wKCkubWFya1BhcmVudHNEaXJ0eSgpO1xufVxuZnVuY3Rpb24gZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBpZiAoIXNlbC5mb2N1c05vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0ZXh0QmVmb3JlID0gdGV4dE5vZGVCZWZvcmUkMShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGxldCB0ZXh0QWZ0ZXIgPSB0ZXh0Tm9kZUFmdGVyJDEoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBpZiAodGV4dEJlZm9yZSAmJiB0ZXh0QWZ0ZXIgJiYgdGV4dEJlZm9yZSAhPSB0ZXh0QWZ0ZXIpIHtcbiAgICAgICAgbGV0IGRlc2NBZnRlciA9IHRleHRBZnRlci5wbVZpZXdEZXNjLCBsYXN0Q2hhbmdlZCA9IHZpZXcuZG9tT2JzZXJ2ZXIubGFzdENoYW5nZWRUZXh0Tm9kZTtcbiAgICAgICAgaWYgKHRleHRCZWZvcmUgPT0gbGFzdENoYW5nZWQgfHwgdGV4dEFmdGVyID09IGxhc3RDaGFuZ2VkKVxuICAgICAgICAgICAgcmV0dXJuIGxhc3RDaGFuZ2VkO1xuICAgICAgICBpZiAoIWRlc2NBZnRlciB8fCAhZGVzY0FmdGVyLmlzVGV4dCh0ZXh0QWZ0ZXIubm9kZVZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZSA9PSB0ZXh0QWZ0ZXIpIHtcbiAgICAgICAgICAgIGxldCBkZXNjQmVmb3JlID0gdGV4dEJlZm9yZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgaWYgKCEoIWRlc2NCZWZvcmUgfHwgIWRlc2NCZWZvcmUuaXNUZXh0KHRleHRCZWZvcmUubm9kZVZhbHVlKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHRBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dEJlZm9yZSB8fCB0ZXh0QWZ0ZXI7XG59XG5mdW5jdGlvbiB0aW1lc3RhbXBGcm9tQ3VzdG9tRXZlbnQoKSB7XG4gICAgbGV0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBldmVudC5pbml0RXZlbnQoXCJldmVudFwiLCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wO1xufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBlbmRDb21wb3NpdGlvbih2aWV3LCByZXN0YXJ0aW5nID0gZmFsc2UpIHtcbiAgICBpZiAoYW5kcm9pZCAmJiB2aWV3LmRvbU9ic2VydmVyLmZsdXNoaW5nU29vbiA+PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgdmlldy5kb21PYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgY2xlYXJDb21wb3NpdGlvbih2aWV3KTtcbiAgICBpZiAocmVzdGFydGluZyB8fCB2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KSB7XG4gICAgICAgIGxldCBzZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcpO1xuICAgICAgICBpZiAoc2VsICYmICFzZWwuZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpKTtcbiAgICAgICAgZWxzZSBpZiAoKHZpZXcubWFya0N1cnNvciB8fCByZXN0YXJ0aW5nKSAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24uZW1wdHkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuZGVsZXRlU2VsZWN0aW9uKCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXcuc3RhdGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2FwdHVyZUNvcHkodmlldywgZG9tKSB7XG4gICAgLy8gVGhlIGV4dHJhIHdyYXBwZXIgaXMgc29tZWhvdyBuZWNlc3Nhcnkgb24gSUUvRWRnZSB0byBwcmV2ZW50IHRoZVxuICAgIC8vIGNvbnRlbnQgZnJvbSBiZWluZyBtYW5nbGVkIHdoZW4gaXQgaXMgcHV0IG9udG8gdGhlIGNsaXBib2FyZFxuICAgIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB3cmFwID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICB3cmFwLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgd3JhcC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZG9tKTtcbiAgICAvLyBEb25lIGJlY2F1c2UgSUUgd2lsbCBmaXJlIGEgc2VsZWN0aW9uY2hhbmdlIG1vdmluZyB0aGUgc2VsZWN0aW9uXG4gICAgLy8gdG8gaXRzIHN0YXJ0IHdoZW4gcmVtb3ZlQWxsUmFuZ2VzIGlzIGNhbGxlZCBhbmQgdGhlIGVkaXRvciBzdGlsbFxuICAgIC8vIGhhcyBmb2N1cyAod2hpY2ggd2lsbCBtZXNzIHVwIHRoZSBlZGl0b3IncyBzZWxlY3Rpb24gc3RhdGUpLlxuICAgIHZpZXcuZG9tLmJsdXIoKTtcbiAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHdyYXAucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIHdyYXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwKTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH0sIDUwKTtcbn1cbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSeKAlGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbmNvbnN0IGJyb2tlbkNsaXBib2FyZEFQSSA9IChpZSAmJiBpZV92ZXJzaW9uIDwgMTUpIHx8XG4gICAgKGlvcyAmJiB3ZWJraXRfdmVyc2lvbiA8IDYwNCk7XG5oYW5kbGVycy5jb3B5ID0gZWRpdEhhbmRsZXJzLmN1dCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLCBjdXQgPSBldmVudC50eXBlID09IFwiY3V0XCI7XG4gICAgaWYgKHNlbC5lbXB0eSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIElFIGFuZCBFZGdlJ3MgY2xpcGJvYXJkIGludGVyZmFjZSBpcyBjb21wbGV0ZWx5IGJyb2tlblxuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgbGV0IHNsaWNlID0gc2VsLmNvbnRlbnQoKSwgeyBkb20sIHRleHQgfSA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZUNvcHkodmlldywgZG9tKTtcbiAgICB9XG4gICAgaWYgKGN1dClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YShcInVpRXZlbnRcIiwgXCJjdXRcIikpO1xufTtcbmZ1bmN0aW9uIHNsaWNlU2luZ2xlTm9kZShzbGljZSkge1xuICAgIHJldHVybiBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDEgPyBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQgOiBudWxsO1xufVxuZnVuY3Rpb24gY2FwdHVyZVBhc3RlKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCF2aWV3LmRvbS5wYXJlbnROb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHBsYWluVGV4dCA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlO1xuICAgIGxldCB0YXJnZXQgPSB2aWV3LmRvbS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGxhaW5UZXh0ID8gXCJ0ZXh0YXJlYVwiIDogXCJkaXZcIikpO1xuICAgIGlmICghcGxhaW5UZXh0KVxuICAgICAgICB0YXJnZXQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIGxldCBwbGFpbiA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSAhPSA0NTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICBpZiAodGFyZ2V0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgICAgICBpZiAocGxhaW5UZXh0KVxuICAgICAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudmFsdWUsIG51bGwsIHBsYWluLCBldmVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnRleHRDb250ZW50LCB0YXJnZXQuaW5uZXJIVE1MLCBwbGFpbiwgZXZlbnQpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGRvUGFzdGUodmlldywgdGV4dCwgaHRtbCwgcHJlZmVyUGxhaW4sIGV2ZW50KSB7XG4gICAgbGV0IHNsaWNlID0gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIHRleHQsIGh0bWwsIHByZWZlclBsYWluLCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbSk7XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVQYXN0ZVwiLCBmID0+IGYodmlldywgZXZlbnQsIHNsaWNlIHx8IFNsaWNlLmVtcHR5KSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghc2xpY2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2luZ2xlTm9kZSA9IHNsaWNlU2luZ2xlTm9kZShzbGljZSk7XG4gICAgbGV0IHRyID0gc2luZ2xlTm9kZVxuICAgICAgICA/IHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbldpdGgoc2luZ2xlTm9kZSwgcHJlZmVyUGxhaW4pXG4gICAgICAgIDogdmlldy5zdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uKHNsaWNlKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YShcInBhc3RlXCIsIHRydWUpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwicGFzdGVcIikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VGV4dChjbGlwYm9hcmREYXRhKSB7XG4gICAgbGV0IHRleHQgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpIHx8IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgaWYgKHRleHQpXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGxldCB1cmlzID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC91cmktbGlzdFwiKTtcbiAgICByZXR1cm4gdXJpcyA/IHVyaXMucmVwbGFjZSgvXFxyP1xcbi9nLCBcIiBcIikgOiBcIlwiO1xufVxuZWRpdEhhbmRsZXJzLnBhc3RlID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICAvLyBIYW5kbGluZyBwYXN0ZSBmcm9tIEphdmFTY3JpcHQgZHVyaW5nIGNvbXBvc2l0aW9uIGlzIHZlcnkgcG9vcmx5XG4gICAgLy8gaGFuZGxlZCBieSBicm93c2Vycywgc28gYXMgYSBkb2RneSBidXQgcHJlZmVyYWJsZSBrbHVkZ2UsIHdlIGp1c3RcbiAgICAvLyBsZXQgdGhlIGJyb3dzZXIgZG8gaXRzIG5hdGl2ZSB0aGluZyB0aGVyZSwgZXhjZXB0IG9uIEFuZHJvaWQsXG4gICAgLy8gd2hlcmUgdGhlIGVkaXRvciBpcyBhbG1vc3QgYWx3YXlzIGNvbXBvc2luZy5cbiAgICBpZiAodmlldy5jb21wb3NpbmcgJiYgIWFuZHJvaWQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGxldCBwbGFpbiA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSAhPSA0NTtcbiAgICBpZiAoZGF0YSAmJiBkb1Bhc3RlKHZpZXcsIGdldFRleHQoZGF0YSksIGRhdGEuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgcGxhaW4sIGV2ZW50KSlcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBlbHNlXG4gICAgICAgIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCk7XG59O1xuY2xhc3MgRHJhZ2dpbmcge1xuICAgIGNvbnN0cnVjdG9yKHNsaWNlLCBtb3ZlLCBub2RlKSB7XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5tb3ZlID0gbW92ZTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG59XG5jb25zdCBkcmFnQ29weU1vZGlmaWVyID0gbWFjID8gXCJhbHRLZXlcIiA6IFwiY3RybEtleVwiO1xuZnVuY3Rpb24gZHJhZ01vdmVzKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IG1vdmVzID0gdmlldy5zb21lUHJvcChcImRyYWdDb3BpZXNcIiwgdGVzdCA9PiAhdGVzdChldmVudCkpO1xuICAgIHJldHVybiBtb3ZlcyAhPSBudWxsID8gbW92ZXMgOiAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl07XG59XG5oYW5kbGVycy5kcmFnc3RhcnQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBtb3VzZURvd24gPSB2aWV3LmlucHV0Lm1vdXNlRG93bjtcbiAgICBpZiAobW91c2VEb3duKVxuICAgICAgICBtb3VzZURvd24uZG9uZSgpO1xuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBwb3MgPSBzZWwuZW1wdHkgPyBudWxsIDogdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgIGxldCBub2RlO1xuICAgIGlmIChwb3MgJiYgcG9zLnBvcyA+PSBzZWwuZnJvbSAmJiBwb3MucG9zIDw9IChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uID8gc2VsLnRvIC0gMSA6IHNlbC50bykpIDtcbiAgICBlbHNlIGlmIChtb3VzZURvd24gJiYgbW91c2VEb3duLm1pZ2h0RHJhZykge1xuICAgICAgICBub2RlID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIG1vdXNlRG93bi5taWdodERyYWcucG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGV2ZW50LnRhcmdldCwgdHJ1ZSk7XG4gICAgICAgIGlmIChkZXNjICYmIGRlc2Mubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIGRlc2MgIT0gdmlldy5kb2NWaWV3KVxuICAgICAgICAgICAgbm9kZSA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBkZXNjLnBvc0JlZm9yZSk7XG4gICAgfVxuICAgIGxldCBkcmFnZ2VkU2xpY2UgPSAobm9kZSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbikuY29udGVudCgpO1xuICAgIGxldCB7IGRvbSwgdGV4dCwgc2xpY2UgfSA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBkcmFnZ2VkU2xpY2UpO1xuICAgIC8vIFByZS0xMjAgQ2hyb21lIHZlcnNpb25zIGNsZWFyIGZpbGVzIHdoZW4gY2FsbGluZyBgY2xlYXJEYXRhYCAoIzE0NzIpXG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoIHx8ICFjaHJvbWUgfHwgY2hyb21lX3ZlcnNpb24gPiAxMjApXG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5jbGVhckRhdGEoKTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShicm9rZW5DbGlwYm9hcmRBUEkgPyBcIlRleHRcIiA6IFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3IvaXNzdWVzLzExNTZcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgICBpZiAoIWJyb2tlbkNsaXBib2FyZEFQSSlcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgIHZpZXcuZHJhZ2dpbmcgPSBuZXcgRHJhZ2dpbmcoc2xpY2UsIGRyYWdNb3Zlcyh2aWV3LCBldmVudCksIG5vZGUpO1xufTtcbmhhbmRsZXJzLmRyYWdlbmQgPSB2aWV3ID0+IHtcbiAgICBsZXQgZHJhZ2dpbmcgPSB2aWV3LmRyYWdnaW5nO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuZHJhZ2dpbmcgPT0gZHJhZ2dpbmcpXG4gICAgICAgICAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICB9LCA1MCk7XG59O1xuZWRpdEhhbmRsZXJzLmRyYWdvdmVyID0gZWRpdEhhbmRsZXJzLmRyYWdlbnRlciA9IChfLCBlKSA9PiBlLnByZXZlbnREZWZhdWx0KCk7XG5lZGl0SGFuZGxlcnMuZHJvcCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBldmVudFBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBpZiAoIWV2ZW50UG9zKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRtb3VzZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZXZlbnRQb3MucG9zKTtcbiAgICBsZXQgc2xpY2UgPSBkcmFnZ2luZyAmJiBkcmFnZ2luZy5zbGljZTtcbiAgICBpZiAoc2xpY2UpIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCBnZXRUZXh0KGV2ZW50LmRhdGFUcmFuc2ZlciksIGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgZmFsc2UsICRtb3VzZSk7XG4gICAgfVxuICAgIGxldCBtb3ZlID0gISEoZHJhZ2dpbmcgJiYgZHJhZ01vdmVzKHZpZXcsIGV2ZW50KSk7XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVEcm9wXCIsIGYgPT4gZih2aWV3LCBldmVudCwgc2xpY2UgfHwgU2xpY2UuZW1wdHksIG1vdmUpKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc2xpY2UpXG4gICAgICAgIHJldHVybjtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCBpbnNlcnRQb3MgPSBzbGljZSA/IGRyb3BQb2ludCh2aWV3LnN0YXRlLmRvYywgJG1vdXNlLnBvcywgc2xpY2UpIDogJG1vdXNlLnBvcztcbiAgICBpZiAoaW5zZXJ0UG9zID09IG51bGwpXG4gICAgICAgIGluc2VydFBvcyA9ICRtb3VzZS5wb3M7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICBpZiAobW92ZSkge1xuICAgICAgICBsZXQgeyBub2RlIH0gPSBkcmFnZ2luZztcbiAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICBub2RlLnJlcGxhY2UodHIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgbGV0IHBvcyA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gICAgbGV0IGlzTm9kZSA9IHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLm9wZW5FbmQgPT0gMCAmJiBzbGljZS5jb250ZW50LmNoaWxkQ291bnQgPT0gMTtcbiAgICBsZXQgYmVmb3JlSW5zZXJ0ID0gdHIuZG9jO1xuICAgIGlmIChpc05vZGUpXG4gICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgocG9zLCBwb3MsIHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgZWxzZVxuICAgICAgICB0ci5yZXBsYWNlUmFuZ2UocG9zLCBwb3MsIHNsaWNlKTtcbiAgICBpZiAodHIuZG9jLmVxKGJlZm9yZUluc2VydCkpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgJHBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKGlzTm9kZSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpICYmXG4gICAgICAgICRwb3Mubm9kZUFmdGVyICYmICRwb3Mubm9kZUFmdGVyLnNhbWVNYXJrdXAoc2xpY2UuY29udGVudC5maXJzdENoaWxkKSkge1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24obmV3IE5vZGVTZWxlY3Rpb24oJHBvcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGVuZCA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gICAgICAgIHRyLm1hcHBpbmcubWFwc1t0ci5tYXBwaW5nLm1hcHMubGVuZ3RoIC0gMV0uZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiBlbmQgPSBuZXdUbyk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRwb3MsIHRyLmRvYy5yZXNvbHZlKGVuZCkpKTtcbiAgICB9XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2V0TWV0YShcInVpRXZlbnRcIiwgXCJkcm9wXCIpKTtcbn07XG5oYW5kbGVycy5mb2N1cyA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXQubGFzdEZvY3VzID0gRGF0ZS5ub3coKTtcbiAgICBpZiAoIXZpZXcuZm9jdXNlZCkge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgdmlldy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5kb2NWaWV3ICYmIHZpZXcuaGFzRm9jdXMoKSAmJiAhdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmVxKHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSkpXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgIH0sIDIwKTtcbiAgICB9XG59O1xuaGFuZGxlcnMuYmx1ciA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgaWYgKHZpZXcuZm9jdXNlZCkge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgdmlldy5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgICAgdmlldy5mb2N1c2VkID0gZmFsc2U7XG4gICAgfVxufTtcbmhhbmRsZXJzLmJlZm9yZWlucHV0ID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICAvLyBXZSBzaG91bGQgcHJvYmFibHkgZG8gbW9yZSB3aXRoIGJlZm9yZWlucHV0IGV2ZW50cywgYnV0IHN1cHBvcnRcbiAgICAvLyBpcyBzbyBzcG90dHkgdGhhdCBJJ20gc3RpbGwgd2FpdGluZyB0byBzZWUgd2hlcmUgdGhleSBhcmUgZ29pbmcuXG4gICAgLy8gVmVyeSBzcGVjaWZpYyBoYWNrIHRvIGRlYWwgd2l0aCBiYWNrc3BhY2Ugc29tZXRpbWVzIGZhaWxpbmcgb25cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aGVuIGFmdGVyIGFuIHVuZWRpdGFibGUgbm9kZS5cbiAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQgJiYgZXZlbnQuaW5wdXRUeXBlID09IFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCIpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5mbHVzaFNvb24oKTtcbiAgICAgICAgbGV0IHsgZG9tQ2hhbmdlQ291bnQgfSA9IHZpZXcuaW5wdXQ7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXQuZG9tQ2hhbmdlQ291bnQgIT0gZG9tQ2hhbmdlQ291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBFdmVudCBhbHJlYWR5IGhhZCBzb21lIGVmZmVjdFxuICAgICAgICAgICAgLy8gVGhpcyBidWcgdGVuZHMgdG8gY2xvc2UgdGhlIHZpcnR1YWwga2V5Ym9hcmQsIHNvIHdlIHJlZm9jdXNcbiAgICAgICAgICAgIHZpZXcuZG9tLmJsdXIoKTtcbiAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoOCwgXCJCYWNrc3BhY2VcIikpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIC8vIENydWRlIGFwcHJveGltYXRpb24gb2YgYmFja3NwYWNlIGJlaGF2aW9yIHdoZW4gbm8gY29tbWFuZCBoYW5kbGVkIGl0XG4gICAgICAgICAgICBpZiAoJGN1cnNvciAmJiAkY3Vyc29yLnBvcyA+IDApXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmRlbGV0ZSgkY3Vyc29yLnBvcyAtIDEsICRjdXJzb3IucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfSwgNTApO1xuICAgIH1cbn07XG4vLyBNYWtlIHN1cmUgYWxsIGhhbmRsZXJzIGdldCByZWdpc3RlcmVkXG5mb3IgKGxldCBwcm9wIGluIGVkaXRIYW5kbGVycylcbiAgICBoYW5kbGVyc1twcm9wXSA9IGVkaXRIYW5kbGVyc1twcm9wXTtcblxuZnVuY3Rpb24gY29tcGFyZU9ianMoYSwgYikge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IHAgaW4gYSlcbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgcCBpbiBiKVxuICAgICAgICBpZiAoIShwIGluIGEpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodG9ET00sIHNwZWMpIHtcbiAgICAgICAgdGhpcy50b0RPTSA9IHRvRE9NO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICAgICAgdGhpcy5zaWRlID0gdGhpcy5zcGVjLnNpZGUgfHwgMDtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCB7IHBvcywgZGVsZXRlZCB9ID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCB0aGlzLnNpZGUgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQgPyBudWxsIDogbmV3IERlY29yYXRpb24ocG9zIC0gb2Zmc2V0LCBwb3MgLSBvZmZzZXQsIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgV2lkZ2V0VHlwZSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLnNwZWMua2V5ICYmIHRoaXMuc3BlYy5rZXkgPT0gb3RoZXIuc3BlYy5rZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b0RPTSA9PSBvdGhlci50b0RPTSAmJiBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKSk7XG4gICAgfVxuICAgIGRlc3Ryb3kobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5zcGVjLmRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLnNwZWMuZGVzdHJveShub2RlKTtcbiAgICB9XG59XG5jbGFzcyBJbmxpbmVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihhdHRycywgc3BlYykge1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWMgfHwgbm9TcGVjO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgc3Bhbiwgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIHRoaXMuc3BlYy5pbmNsdXNpdmVTdGFydCA/IC0xIDogMSkgLSBvZmZzZXQ7XG4gICAgICAgIGxldCB0byA9IG1hcHBpbmcubWFwKHNwYW4udG8gKyBvbGRPZmZzZXQsIHRoaXMuc3BlYy5pbmNsdXNpdmVFbmQgPyAxIDogLTEpIC0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gZnJvbSA+PSB0byA/IG51bGwgOiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgdGhpcyk7XG4gICAgfVxuICAgIHZhbGlkKF8sIHNwYW4pIHsgcmV0dXJuIHNwYW4uZnJvbSA8IHNwYW4udG87IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgSW5saW5lVHlwZSAmJiBjb21wYXJlT2Jqcyh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzKHNwYW4pIHsgcmV0dXJuIHNwYW4udHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGU7IH1cbiAgICBkZXN0cm95KCkgeyB9XG59XG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCAxKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLnRvICsgb2xkT2Zmc2V0LCAtMSk7XG4gICAgICAgIGlmICh0by5kZWxldGVkIHx8IHRvLnBvcyA8PSBmcm9tLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbS5wb3MgLSBvZmZzZXQsIHRvLnBvcyAtIG9mZnNldCwgdGhpcyk7XG4gICAgfVxuICAgIHZhbGlkKG5vZGUsIHNwYW4pIHtcbiAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChzcGFuLmZyb20pLCBjaGlsZDtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA9PSBzcGFuLmZyb20gJiYgIShjaGlsZCA9IG5vZGUuY2hpbGQoaW5kZXgpKS5pc1RleHQgJiYgb2Zmc2V0ICsgY2hpbGQubm9kZVNpemUgPT0gc3Bhbi50bztcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIE5vZGVUeXBlICYmIGNvbXBhcmVPYmpzKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpO1xuICAgIH1cbiAgICBkZXN0cm95KCkgeyB9XG59XG4vKipcbkRlY29yYXRpb24gb2JqZWN0cyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIHZpZXcgdGhyb3VnaCB0aGVcbltgZGVjb3JhdGlvbnNgIHByb3BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzLmRlY29yYXRpb25zKS4gVGhleSBjb21lIGluXG5zZXZlcmFsIHZhcmlhbnRz4oCUc2VlIHRoZSBzdGF0aWMgbWVtYmVycyBvZiB0aGlzIGNsYXNzIGZvciBkZXRhaWxzLlxuKi9cbmNsYXNzIERlY29yYXRpb24ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBkZWNvcmF0aW9uLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbi4gV2lsbCBiZSB0aGUgc2FtZSBhcyBgZnJvbWAgZm9yIFt3aWRnZXRcbiAgICBkZWNvcmF0aW9uc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl53aWRnZXQpLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHlwZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29weShmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZXEob3RoZXIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5lcShvdGhlci50eXBlKSAmJiB0aGlzLmZyb20gKyBvZmZzZXQgPT0gb3RoZXIuZnJvbSAmJiB0aGlzLnRvICsgb2Zmc2V0ID09IG90aGVyLnRvO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcChtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLm1hcChtYXBwaW5nLCB0aGlzLCBvZmZzZXQsIG9sZE9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggaXMgYSBET00gbm9kZSB0aGF0J3Mgc2hvd24gaW5cbiAgICB0aGUgZG9jdW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdVxuICAgIGRlbGF5IHJlbmRlcmluZyB0aGUgd2lkZ2V0IGJ5IHBhc3NpbmcgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAgICBjYWxsZWQgd2hlbiB0aGUgd2lkZ2V0IGlzIGFjdHVhbGx5IGRyYXduIGluIGEgdmlldywgYnV0IHlvdSBjYW5cbiAgICBhbHNvIGRpcmVjdGx5IHBhc3MgYSBET00gbm9kZS4gYGdldFBvc2AgY2FuIGJlIHVzZWQgdG8gZmluZCB0aGVcbiAgICB3aWRnZXQncyBjdXJyZW50IGRvY3VtZW50IHBvc2l0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHdpZGdldChwb3MsIHRvRE9NLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihwb3MsIHBvcywgbmV3IFdpZGdldFR5cGUodG9ET00sIHNwZWMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlcyBhbiBpbmxpbmUgZGVjb3JhdGlvbiwgd2hpY2ggYWRkcyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyB0b1xuICAgIGVhY2ggaW5saW5lIG5vZGUgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuXG4gICAgKi9cbiAgICBzdGF0aWMgaW5saW5lKGZyb20sIHRvLCBhdHRycywgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIG5ldyBJbmxpbmVUeXBlKGF0dHJzLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYSBub2RlIGRlY29yYXRpb24uIGBmcm9tYCBhbmQgYHRvYCBzaG91bGQgcG9pbnQgcHJlY2lzZWx5XG4gICAgYmVmb3JlIGFuZCBhZnRlciBhIG5vZGUgaW4gdGhlIGRvY3VtZW50LiBUaGF0IG5vZGUsIGFuZCBvbmx5IHRoYXRcbiAgICBub2RlLCB3aWxsIHJlY2VpdmUgdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgbm9kZShmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgTm9kZVR5cGUoYXR0cnMsIHNwZWMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNwZWMgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyB0aGlzIGRlY29yYXRpb24uIENhbiBiZSB1c2VmdWxcbiAgICBpZiB5b3UndmUgc3RvcmVkIGV4dHJhIGluZm9ybWF0aW9uIGluIHRoYXQgb2JqZWN0LlxuICAgICovXG4gICAgZ2V0IHNwZWMoKSB7IHJldHVybiB0aGlzLnR5cGUuc3BlYzsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlubGluZSgpIHsgcmV0dXJuIHRoaXMudHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCB3aWRnZXQoKSB7IHJldHVybiB0aGlzLnR5cGUgaW5zdGFuY2VvZiBXaWRnZXRUeXBlOyB9XG59XG5jb25zdCBub25lID0gW10sIG5vU3BlYyA9IHt9O1xuLyoqXG5BIGNvbGxlY3Rpb24gb2YgW2RlY29yYXRpb25zXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uKSwgb3JnYW5pemVkIGluIHN1Y2hcbmEgd2F5IHRoYXQgdGhlIGRyYXdpbmcgYWxnb3JpdGhtIGNhbiBlZmZpY2llbnRseSB1c2UgYW5kIGNvbXBhcmVcbnRoZW0uIFRoaXMgaXMgYSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJl4oCUaXQgaXMgbm90IG1vZGlmaWVkLFxudXBkYXRlcyBjcmVhdGUgYSBuZXcgdmFsdWUuXG4qL1xuY2xhc3MgRGVjb3JhdGlvblNldCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbCwgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsLmxlbmd0aCA/IGxvY2FsIDogbm9uZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuIDogbm9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGRlY29yYXRpb25zLCB1c2luZyB0aGUgc3RydWN0dXJlIG9mIHRoZSBnaXZlblxuICAgIGRvY3VtZW50LiBUaGlzIHdpbGwgY29uc3VtZSAobW9kaWZ5KSB0aGUgYGRlY29yYXRpb25zYCBhcnJheSwgc29cbiAgICB5b3UgbXVzdCBtYWtlIGEgY29weSBpZiB5b3Ugd2FudCBuZWVkIHRvIHByZXNlcnZlIHRoYXQuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRvYywgZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGRlY29yYXRpb25zLmxlbmd0aCA/IGJ1aWxkVHJlZShkZWNvcmF0aW9ucywgZG9jLCAwLCBub1NwZWMpIDogZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgYWxsIGRlY29yYXRpb25zIGluIHRoaXMgc2V0IHdoaWNoIHRvdWNoIHRoZSBnaXZlbiByYW5nZVxuICAgIChpbmNsdWRpbmcgZGVjb3JhdGlvbnMgdGhhdCBzdGFydCBvciBlbmQgZGlyZWN0bHkgYXQgdGhlXG4gICAgYm91bmRhcmllcykgYW5kIG1hdGNoIHRoZSBnaXZlbiBwcmVkaWNhdGUgb24gdGhlaXIgc3BlYy4gV2hlblxuICAgIGBzdGFydGAgYW5kIGBlbmRgIGFyZSBvbWl0dGVkLCBhbGwgZGVjb3JhdGlvbnMgaW4gdGhlIHNldCBhcmVcbiAgICBjb25zaWRlcmVkLiBXaGVuIGBwcmVkaWNhdGVgIGlzbid0IGdpdmVuLCBhbGwgZGVjb3JhdGlvbnMgYXJlXG4gICAgYXNzdW1lZCB0byBtYXRjaC5cbiAgICAqL1xuICAgIGZpbmQoc3RhcnQsIGVuZCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5maW5kSW5uZXIoc3RhcnQgPT0gbnVsbCA/IDAgOiBzdGFydCwgZW5kID09IG51bGwgPyAxZTkgOiBlbmQsIHJlc3VsdCwgMCwgcHJlZGljYXRlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmluZElubmVyKHN0YXJ0LCBlbmQsIHJlc3VsdCwgb2Zmc2V0LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IHRoaXMubG9jYWxbaV07XG4gICAgICAgICAgICBpZiAoc3Bhbi5mcm9tIDw9IGVuZCAmJiBzcGFuLnRvID49IHN0YXJ0ICYmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZShzcGFuLnNwZWMpKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFuLmNvcHkoc3Bhbi5mcm9tICsgb2Zmc2V0LCBzcGFuLnRvICsgb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSA8IGVuZCAmJiB0aGlzLmNoaWxkcmVuW2kgKyAxXSA+IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT2ZmID0gdGhpcy5jaGlsZHJlbltpXSArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpICsgMl0uZmluZElubmVyKHN0YXJ0IC0gY2hpbGRPZmYsIGVuZCAtIGNoaWxkT2ZmLCByZXN1bHQsIG9mZnNldCArIGNoaWxkT2ZmLCBwcmVkaWNhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGUgc2V0IG9mIGRlY29yYXRpb25zIGluIHJlc3BvbnNlIHRvIGEgY2hhbmdlIGluIHRoZVxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgbWFwKG1hcHBpbmcsIGRvYywgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSB8fCBtYXBwaW5nLm1hcHMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwSW5uZXIobWFwcGluZywgZG9jLCAwLCAwLCBvcHRpb25zIHx8IG5vU3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWFwSW5uZXIobWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG5ld0xvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSB0aGlzLmxvY2FsW2ldLm1hcChtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCk7XG4gICAgICAgICAgICBpZiAobWFwcGVkICYmIG1hcHBlZC50eXBlLnZhbGlkKG5vZGUsIG1hcHBlZCkpXG4gICAgICAgICAgICAgICAgKG5ld0xvY2FsIHx8IChuZXdMb2NhbCA9IFtdKSkucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKHRoaXMubG9jYWxbaV0uc3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG1hcENoaWxkcmVuKHRoaXMuY2hpbGRyZW4sIG5ld0xvY2FsIHx8IFtdLCBtYXBwaW5nLCBub2RlLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXdMb2NhbCA/IG5ldyBEZWNvcmF0aW9uU2V0KG5ld0xvY2FsLnNvcnQoYnlQb3MpLCBub25lKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgdGhlIGdpdmVuIGFycmF5IG9mIGRlY29yYXRpb25zIHRvIHRoZSBvbmVzIGluIHRoZSBzZXQsXG4gICAgcHJvZHVjaW5nIGEgbmV3IHNldC4gQ29uc3VtZXMgdGhlIGBkZWNvcmF0aW9uc2AgYXJyYXkuIE5lZWRzXG4gICAgYWNjZXNzIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50IHRvIGNyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgdHJlZVxuICAgIHN0cnVjdHVyZS5cbiAgICAqL1xuICAgIGFkZChkb2MsIGRlY29yYXRpb25zKSB7XG4gICAgICAgIGlmICghZGVjb3JhdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKGRvYywgZGVjb3JhdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRJbm5lcihkb2MsIGRlY29yYXRpb25zLCAwKTtcbiAgICB9XG4gICAgYWRkSW5uZXIoZG9jLCBkZWNvcmF0aW9ucywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiwgY2hpbGRJbmRleCA9IDA7XG4gICAgICAgIGRvYy5mb3JFYWNoKChjaGlsZE5vZGUsIGNoaWxkT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBsZXQgYmFzZU9mZnNldCA9IGNoaWxkT2Zmc2V0ICsgb2Zmc2V0LCBmb3VuZDtcbiAgICAgICAgICAgIGlmICghKGZvdW5kID0gdGFrZVNwYW5zRm9yTm9kZShkZWNvcmF0aW9ucywgY2hpbGROb2RlLCBiYXNlT2Zmc2V0KSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZEluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2NoaWxkSW5kZXhdIDwgY2hpbGRPZmZzZXQpXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleCArPSAzO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2NoaWxkSW5kZXhdID09IGNoaWxkT2Zmc2V0KVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2NoaWxkSW5kZXggKyAyXSA9IGNoaWxkcmVuW2NoaWxkSW5kZXggKyAyXS5hZGRJbm5lcihjaGlsZE5vZGUsIGZvdW5kLCBiYXNlT2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDAsIGNoaWxkT2Zmc2V0LCBjaGlsZE9mZnNldCArIGNoaWxkTm9kZS5ub2RlU2l6ZSwgYnVpbGRUcmVlKGZvdW5kLCBjaGlsZE5vZGUsIGJhc2VPZmZzZXQgKyAxLCBub1NwZWMpKTtcbiAgICAgICAgICAgIGNoaWxkSW5kZXggKz0gMztcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsb2NhbCA9IG1vdmVTcGFucyhjaGlsZEluZGV4ID8gd2l0aG91dE51bGxzKGRlY29yYXRpb25zKSA6IGRlY29yYXRpb25zLCAtb2Zmc2V0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghbG9jYWxbaV0udHlwZS52YWxpZChkb2MsIGxvY2FsW2ldKSlcbiAgICAgICAgICAgICAgICBsb2NhbC5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLmxlbmd0aCA/IHRoaXMubG9jYWwuY29uY2F0KGxvY2FsKS5zb3J0KGJ5UG9zKSA6IHRoaXMubG9jYWwsIGNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc2V0IHRoYXQgY29udGFpbnMgdGhlIGRlY29yYXRpb25zIGluIHRoaXMgc2V0LCBtaW51c1xuICAgIHRoZSBvbmVzIGluIHRoZSBnaXZlbiBhcnJheS5cbiAgICAqL1xuICAgIHJlbW92ZShkZWNvcmF0aW9ucykge1xuICAgICAgICBpZiAoZGVjb3JhdGlvbnMubGVuZ3RoID09IDAgfHwgdGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgMCk7XG4gICAgfVxuICAgIHJlbW92ZUlubmVyKGRlY29yYXRpb25zLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiwgbG9jYWwgPSB0aGlzLmxvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQ7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGNoaWxkcmVuW2ldICsgb2Zmc2V0LCB0byA9IGNoaWxkcmVuW2kgKyAxXSArIG9mZnNldDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBzcGFuOyBqIDwgZGVjb3JhdGlvbnMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKHNwYW4gPSBkZWNvcmF0aW9uc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Bhbi5mcm9tID4gZnJvbSAmJiBzcGFuLnRvIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25zW2pdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIChmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuID09IHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICBsZXQgcmVtb3ZlZCA9IGNoaWxkcmVuW2kgKyAyXS5yZW1vdmVJbm5lcihmb3VuZCwgZnJvbSArIDEpO1xuICAgICAgICAgICAgaWYgKHJlbW92ZWQgIT0gZW1wdHkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMl0gPSByZW1vdmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDMpO1xuICAgICAgICAgICAgICAgIGkgLT0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWwubGVuZ3RoKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHNwYW47IGkgPCBkZWNvcmF0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoc3BhbiA9IGRlY29yYXRpb25zW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbG9jYWwubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxbal0uZXEoc3Bhbiwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbCA9PSB0aGlzLmxvY2FsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbCA9IHRoaXMubG9jYWwuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbC5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuICYmIGxvY2FsID09IHRoaXMubG9jYWwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIGxvY2FsLmxlbmd0aCB8fCBjaGlsZHJlbi5sZW5ndGggPyBuZXcgRGVjb3JhdGlvblNldChsb2NhbCwgY2hpbGRyZW4pIDogZW1wdHk7XG4gICAgfVxuICAgIGZvckNoaWxkKG9mZnNldCwgbm9kZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5lbXB0eTtcbiAgICAgICAgbGV0IGNoaWxkLCBsb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baSArIDJdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBvZmZzZXQgKyAxLCBlbmQgPSBzdGFydCArIG5vZGUuY29udGVudC5zaXplO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBkZWMgPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKGRlYy5mcm9tIDwgZW5kICYmIGRlYy50byA+IHN0YXJ0ICYmIChkZWMudHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChzdGFydCwgZGVjLmZyb20pIC0gc3RhcnQsIHRvID0gTWF0aC5taW4oZW5kLCBkZWMudG8pIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgKGxvY2FsIHx8IChsb2NhbCA9IFtdKSkucHVzaChkZWMuY29weShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgbGV0IGxvY2FsU2V0ID0gbmV3IERlY29yYXRpb25TZXQobG9jYWwuc29ydChieVBvcyksIG5vbmUpO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkID8gbmV3IERlY29yYXRpb25Hcm91cChbbG9jYWxTZXQsIGNoaWxkXSkgOiBsb2NhbFNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gb3RoZXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0KSB8fFxuICAgICAgICAgICAgdGhpcy5sb2NhbC5sZW5ndGggIT0gb3RoZXIubG9jYWwubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPSBvdGhlci5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5sb2NhbFtpXS5lcShvdGhlci5sb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSAhPSBvdGhlci5jaGlsZHJlbltpXSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDFdICE9IG90aGVyLmNoaWxkcmVuW2kgKyAxXSB8fFxuICAgICAgICAgICAgICAgICF0aGlzLmNoaWxkcmVuW2kgKyAyXS5lcShvdGhlci5jaGlsZHJlbltpICsgMl0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9jYWxzKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZU92ZXJsYXAodGhpcy5sb2NhbHNJbm5lcihub2RlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9jYWxzSW5uZXIobm9kZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBub25lO1xuICAgICAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50IHx8ICF0aGlzLmxvY2FsLnNvbWUoSW5saW5lVHlwZS5pcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMubG9jYWxbaV0udHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubG9jYWxbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZvckVhY2hTZXQoZikgeyBmKHRoaXMpOyB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgZGVjb3JhdGlvbnMuXG4qL1xuRGVjb3JhdGlvblNldC5lbXB0eSA9IG5ldyBEZWNvcmF0aW9uU2V0KFtdLCBbXSk7XG4vKipcbkBpbnRlcm5hbFxuKi9cbkRlY29yYXRpb25TZXQucmVtb3ZlT3ZlcmxhcCA9IHJlbW92ZU92ZXJsYXA7XG5jb25zdCBlbXB0eSA9IERlY29yYXRpb25TZXQuZW1wdHk7XG4vLyBBbiBhYnN0cmFjdGlvbiB0aGF0IGFsbG93cyB0aGUgY29kZSBkZWFsaW5nIHdpdGggZGVjb3JhdGlvbnMgdG9cbi8vIHRyZWF0IG11bHRpcGxlIERlY29yYXRpb25TZXQgb2JqZWN0cyBhcyBpZiBpdCB3ZXJlIGEgc2luZ2xlIG9iamVjdFxuLy8gd2l0aCAoYSBzdWJzZXQgb2YpIHRoZSBzYW1lIGludGVyZmFjZS5cbmNsYXNzIERlY29yYXRpb25Hcm91cCB7XG4gICAgY29uc3RydWN0b3IobWVtYmVycykge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgZG9jKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlZERlY29zID0gdGhpcy5tZW1iZXJzLm1hcChtZW1iZXIgPT4gbWVtYmVyLm1hcChtYXBwaW5nLCBkb2MsIG5vU3BlYykpO1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbkdyb3VwLmZyb20obWFwcGVkRGVjb3MpO1xuICAgIH1cbiAgICBmb3JDaGlsZChvZmZzZXQsIGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5lbXB0eTtcbiAgICAgICAgbGV0IGZvdW5kID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5tZW1iZXJzW2ldLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBlbXB0eSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBEZWNvcmF0aW9uR3JvdXApXG4gICAgICAgICAgICAgICAgZm91bmQgPSBmb3VuZC5jb25jYXQocmVzdWx0Lm1lbWJlcnMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZvdW5kLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbkdyb3VwLmZyb20oZm91bmQpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERlY29yYXRpb25Hcm91cCkgfHxcbiAgICAgICAgICAgIG90aGVyLm1lbWJlcnMubGVuZ3RoICE9IHRoaXMubWVtYmVycy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLm1lbWJlcnNbaV0uZXEob3RoZXIubWVtYmVyc1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbG9jYWxzKG5vZGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCwgc29ydGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsb2NhbHMgPSB0aGlzLm1lbWJlcnNbaV0ubG9jYWxzSW5uZXIobm9kZSk7XG4gICAgICAgICAgICBpZiAoIWxvY2Fscy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxvY2FscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvY2Fscy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobG9jYWxzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ID8gcmVtb3ZlT3ZlcmxhcChzb3J0ZWQgPyByZXN1bHQgOiByZXN1bHQuc29ydChieVBvcykpIDogbm9uZTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgZ3JvdXAgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBkZWNvcmF0aW9uIHNldHMsIG9yIHJldHVyblxuICAgIC8vIGEgc2luZ2xlIHNldCB3aGVuIHBvc3NpYmxlLlxuICAgIHN0YXRpYyBmcm9tKG1lbWJlcnMpIHtcbiAgICAgICAgc3dpdGNoIChtZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gZW1wdHk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBtZW1iZXJzWzBdO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIG5ldyBEZWNvcmF0aW9uR3JvdXAobWVtYmVycy5ldmVyeShtID0+IG0gaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0KSA/IG1lbWJlcnMgOlxuICAgICAgICAgICAgICAgIG1lbWJlcnMucmVkdWNlKChyLCBtKSA9PiByLmNvbmNhdChtIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCA/IG0gOiBtLm1lbWJlcnMpLCBbXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvckVhY2hTZXQoZikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMubWVtYmVyc1tpXS5mb3JFYWNoU2V0KGYpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKG9sZENoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBvbGRDaGlsZHJlbi5zbGljZSgpO1xuICAgIC8vIE1hcmsgdGhlIGNoaWxkcmVuIHRoYXQgYXJlIGRpcmVjdGx5IHRvdWNoZWQgYnkgY2hhbmdlcywgYW5kXG4gICAgLy8gbW92ZSB0aG9zZSB0aGF0IGFyZSBhZnRlciB0aGUgY2hhbmdlcy5cbiAgICBmb3IgKGxldCBpID0gMCwgYmFzZU9mZnNldCA9IG9sZE9mZnNldDsgaSA8IG1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbW92ZWQgPSAwO1xuICAgICAgICBtYXBwaW5nLm1hcHNbaV0uZm9yRWFjaCgob2xkU3RhcnQsIG9sZEVuZCwgbmV3U3RhcnQsIG5ld0VuZCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRTaXplID0gKG5ld0VuZCAtIG5ld1N0YXJ0KSAtIChvbGRFbmQgLSBvbGRTdGFydCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGNoaWxkcmVuW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kIDwgMCB8fCBvbGRTdGFydCA+IGVuZCArIGJhc2VPZmZzZXQgLSBtb3ZlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY2hpbGRyZW5baV0gKyBiYXNlT2Zmc2V0IC0gbW92ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEVuZCA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSBvbGRTdGFydCA8PSBzdGFydCA/IC0yIDogLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9sZFN0YXJ0ID49IGJhc2VPZmZzZXQgJiYgZFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gKz0gZFNpemU7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSArPSBkU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb3ZlZCArPSBkU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJhc2VPZmZzZXQgPSBtYXBwaW5nLm1hcHNbaV0ubWFwKGJhc2VPZmZzZXQsIC0xKTtcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgY2hpbGQgbm9kZXMgdGhhdCBzdGlsbCBjb3JyZXNwb25kIHRvIGEgc2luZ2xlIG5vZGUsXG4gICAgLy8gcmVjdXJzaXZlbHkgY2FsbCBtYXBJbm5lciBvbiB0aGVtIGFuZCB1cGRhdGUgdGhlaXIgcG9zaXRpb25zLlxuICAgIGxldCBtdXN0UmVidWlsZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPCAwKSB7IC8vIFRvdWNoZWQgbm9kZXNcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPT0gLTIpIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gLTE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0KSwgZnJvbUxvY2FsID0gZnJvbSAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChmcm9tTG9jYWwgPCAwIHx8IGZyb21Mb2NhbCA+PSBub2RlLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE11c3QgcmVhZCBvbGRDaGlsZHJlbiBiZWNhdXNlIGNoaWxkcmVuIHdhcyB0YWdnZWQgd2l0aCAtMVxuICAgICAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXAob2xkQ2hpbGRyZW5baSArIDFdICsgb2xkT2Zmc2V0LCAtMSksIHRvTG9jYWwgPSB0byAtIG9mZnNldDtcbiAgICAgICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQ6IGNoaWxkT2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KGZyb21Mb2NhbCk7XG4gICAgICAgICAgICBsZXQgY2hpbGROb2RlID0gbm9kZS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGRPZmZzZXQgPT0gZnJvbUxvY2FsICYmIGNoaWxkT2Zmc2V0ICsgY2hpbGROb2RlLm5vZGVTaXplID09IHRvTG9jYWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFwcGVkID0gY2hpbGRyZW5baSArIDJdXG4gICAgICAgICAgICAgICAgICAgIC5tYXBJbm5lcihtYXBwaW5nLCBjaGlsZE5vZGUsIGZyb20gKyAxLCBvbGRDaGlsZHJlbltpXSArIG9sZE9mZnNldCArIDEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQgIT0gZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gPSBmcm9tTG9jYWw7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IHRvTG9jYWw7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAyXSA9IG1hcHBlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IC0yO1xuICAgICAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgLy8gUmVtYWluaW5nIGNoaWxkcmVuIG11c3QgYmUgY29sbGVjdGVkIGFuZCByZWJ1aWx0IGludG8gdGhlIGFwcHJvcHJpYXRlIHN0cnVjdHVyZVxuICAgIGlmIChtdXN0UmVidWlsZCkge1xuICAgICAgICBsZXQgZGVjb3JhdGlvbnMgPSBtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyhjaGlsZHJlbiwgb2xkQ2hpbGRyZW4sIG5ld0xvY2FsLCBtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucyk7XG4gICAgICAgIGxldCBidWlsdCA9IGJ1aWxkVHJlZShkZWNvcmF0aW9ucywgbm9kZSwgMCwgb3B0aW9ucyk7XG4gICAgICAgIG5ld0xvY2FsID0gYnVpbHQubG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdIDwgMCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAzKTtcbiAgICAgICAgICAgICAgICBpIC09IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGJ1aWx0LmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGJ1aWx0LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5bal0gPCBmcm9tKVxuICAgICAgICAgICAgICAgIGogKz0gMztcbiAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShqLCAwLCBidWlsdC5jaGlsZHJlbltpXSwgYnVpbHQuY2hpbGRyZW5baSArIDFdLCBidWlsdC5jaGlsZHJlbltpICsgMl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGVjb3JhdGlvblNldChuZXdMb2NhbC5zb3J0KGJ5UG9zKSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gbW92ZVNwYW5zKHNwYW5zLCBvZmZzZXQpIHtcbiAgICBpZiAoIW9mZnNldCB8fCAhc3BhbnMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gc3BhbnM7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IERlY29yYXRpb24oc3Bhbi5mcm9tICsgb2Zmc2V0LCBzcGFuLnRvICsgb2Zmc2V0LCBzcGFuLnR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgZGVjb3JhdGlvbnMsIG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgLy8gR2F0aGVyIGFsbCBkZWNvcmF0aW9ucyBmcm9tIHRoZSByZW1haW5pbmcgbWFya2VkIGNoaWxkcmVuXG4gICAgZnVuY3Rpb24gZ2F0aGVyKHNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gc2V0LmxvY2FsW2ldLm1hcChtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCk7XG4gICAgICAgICAgICBpZiAobWFwcGVkKVxuICAgICAgICAgICAgICAgIGRlY29yYXRpb25zLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZShzZXQubG9jYWxbaV0uc3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBnYXRoZXIoc2V0LmNoaWxkcmVuW2kgKyAyXSwgc2V0LmNoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPT0gLTEpXG4gICAgICAgICAgICBnYXRoZXIoY2hpbGRyZW5baSArIDJdLCBvbGRDaGlsZHJlbltpXSArIG9sZE9mZnNldCArIDEpO1xuICAgIHJldHVybiBkZWNvcmF0aW9ucztcbn1cbmZ1bmN0aW9uIHRha2VTcGFuc0Zvck5vZGUoc3BhbnMsIG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGVuZCA9IG9mZnNldCArIG5vZGUubm9kZVNpemUsIGZvdW5kID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMCwgc3BhbjsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoc3BhbiA9IHNwYW5zW2ldKSAmJiBzcGFuLmZyb20gPiBvZmZzZXQgJiYgc3Bhbi50byA8IGVuZCkge1xuICAgICAgICAgICAgKGZvdW5kIHx8IChmb3VuZCA9IFtdKSkucHVzaChzcGFuKTtcbiAgICAgICAgICAgIHNwYW5zW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiB3aXRob3V0TnVsbHMoYXJyYXkpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGFycmF5W2ldICE9IG51bGwpXG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEJ1aWxkIHVwIGEgdHJlZSB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgc2V0IG9mIGRlY29yYXRpb25zLiBgb2Zmc2V0YFxuLy8gaXMgYSBiYXNlIG9mZnNldCB0aGF0IHNob3VsZCBiZSBzdWJ0cmFjdGVkIGZyb20gdGhlIGBmcm9tYCBhbmQgYHRvYFxuLy8gcG9zaXRpb25zIGluIHRoZSBzcGFucyAoc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGFsbG9jYXRlIG5ldyBzcGFuc1xuLy8gZm9yIHJlY3Vyc2l2ZSBjYWxscykuXG5mdW5jdGlvbiBidWlsZFRyZWUoc3BhbnMsIG5vZGUsIG9mZnNldCwgb3B0aW9ucykge1xuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBoYXNOdWxscyA9IGZhbHNlO1xuICAgIG5vZGUuZm9yRWFjaCgoY2hpbGROb2RlLCBsb2NhbFN0YXJ0KSA9PiB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoc3BhbnMsIGNoaWxkTm9kZSwgbG9jYWxTdGFydCArIG9mZnNldCk7XG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgaGFzTnVsbHMgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHN1YnRyZWUgPSBidWlsZFRyZWUoZm91bmQsIGNoaWxkTm9kZSwgb2Zmc2V0ICsgbG9jYWxTdGFydCArIDEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHN1YnRyZWUgIT0gZW1wdHkpXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChsb2NhbFN0YXJ0LCBsb2NhbFN0YXJ0ICsgY2hpbGROb2RlLm5vZGVTaXplLCBzdWJ0cmVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBsb2NhbHMgPSBtb3ZlU3BhbnMoaGFzTnVsbHMgPyB3aXRob3V0TnVsbHMoc3BhbnMpIDogc3BhbnMsIC1vZmZzZXQpLnNvcnQoYnlQb3MpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWxvY2Fsc1tpXS50eXBlLnZhbGlkKG5vZGUsIGxvY2Fsc1tpXSkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZW1vdmUobG9jYWxzW2ldLnNwZWMpO1xuICAgICAgICAgICAgbG9jYWxzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGxvY2Fscy5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWxzLCBjaGlsZHJlbikgOiBlbXB0eTtcbn1cbi8vIFVzZWQgdG8gc29ydCBkZWNvcmF0aW9ucyBzbyB0aGF0IG9uZXMgd2l0aCBhIGxvdyBzdGFydCBwb3NpdGlvblxuLy8gY29tZSBmaXJzdCwgYW5kIHdpdGhpbiBhIHNldCB3aXRoIHRoZSBzYW1lIHN0YXJ0IHBvc2l0aW9uLCB0aG9zZVxuLy8gd2l0aCBhbiBzbWFsbGVyIGVuZCBwb3NpdGlvbiBjb21lIGZpcnN0LlxuZnVuY3Rpb24gYnlQb3MoYSwgYikge1xuICAgIHJldHVybiBhLmZyb20gLSBiLmZyb20gfHwgYS50byAtIGIudG87XG59XG4vLyBTY2FuIGEgc29ydGVkIGFycmF5IG9mIGRlY29yYXRpb25zIGZvciBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgc3BhbnMsXG4vLyBhbmQgc3BsaXQgdGhvc2Ugc28gdGhhdCBvbmx5IGZ1bGx5IG92ZXJsYXBwaW5nIHNwYW5zIGFyZSBsZWZ0ICh0b1xuLy8gbWFrZSBzdWJzZXF1ZW50IHJlbmRlcmluZyBlYXNpZXIpLiBXaWxsIHJldHVybiB0aGUgaW5wdXQgYXJyYXkgaWZcbi8vIG5vIHBhcnRpYWxseSBvdmVybGFwcGluZyBzcGFucyBhcmUgZm91bmQgKHRoZSBjb21tb24gY2FzZSkuXG5mdW5jdGlvbiByZW1vdmVPdmVybGFwKHNwYW5zKSB7XG4gICAgbGV0IHdvcmtpbmcgPSBzcGFucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmtpbmcubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGxldCBzcGFuID0gd29ya2luZ1tpXTtcbiAgICAgICAgaWYgKHNwYW4uZnJvbSAhPSBzcGFuLnRvKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgd29ya2luZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gd29ya2luZ1tqXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5mcm9tID09IHNwYW4uZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC50byAhPSBzcGFuLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya2luZyA9PSBzcGFucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvbGxvd2VkIGJ5IGEgcGFydGlhbGx5IG92ZXJsYXBwaW5nIGxhcmdlciBzcGFuLiBTcGxpdCB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFuLlxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1tqXSA9IG5leHQuY29weShuZXh0LmZyb20sIHNwYW4udG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QWhlYWQod29ya2luZywgaiArIDEsIG5leHQuY29weShzcGFuLnRvLCBuZXh0LnRvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5mcm9tIDwgc3Bhbi50bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcgPT0gc3BhbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IHNwYW5zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW5kIG9mIHRoaXMgb25lIG92ZXJsYXBzIHdpdGggYSBzdWJzZXF1ZW50IHNwYW4uIFNwbGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdbaV0gPSBzcGFuLmNvcHkoc3Bhbi5mcm9tLCBuZXh0LmZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QWhlYWQod29ya2luZywgaiwgc3Bhbi5jb3B5KG5leHQuZnJvbSwgc3Bhbi50bykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdvcmtpbmc7XG59XG5mdW5jdGlvbiBpbnNlcnRBaGVhZChhcnJheSwgaSwgZGVjbykge1xuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoICYmIGJ5UG9zKGRlY28sIGFycmF5W2ldKSA+IDApXG4gICAgICAgIGkrKztcbiAgICBhcnJheS5zcGxpY2UoaSwgMCwgZGVjbyk7XG59XG4vLyBHZXQgdGhlIGRlY29yYXRpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBwcm9wcyBvZiBhIHZpZXcuXG5mdW5jdGlvbiB2aWV3RGVjb3JhdGlvbnModmlldykge1xuICAgIGxldCBmb3VuZCA9IFtdO1xuICAgIHZpZXcuc29tZVByb3AoXCJkZWNvcmF0aW9uc1wiLCBmID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGYodmlldy5zdGF0ZSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0ICE9IGVtcHR5KVxuICAgICAgICAgICAgZm91bmQucHVzaChyZXN1bHQpO1xuICAgIH0pO1xuICAgIGlmICh2aWV3LmN1cnNvcldyYXBwZXIpXG4gICAgICAgIGZvdW5kLnB1c2goRGVjb3JhdGlvblNldC5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIFt2aWV3LmN1cnNvcldyYXBwZXIuZGVjb10pKTtcbiAgICByZXR1cm4gRGVjb3JhdGlvbkdyb3VwLmZyb20oZm91bmQpO1xufVxuXG5jb25zdCBvYnNlcnZlT3B0aW9ucyA9IHtcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWUsXG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlXG59O1xuLy8gSUUxMSBoYXMgdmVyeSBicm9rZW4gbXV0YXRpb24gb2JzZXJ2ZXJzLCBzbyB3ZSBhbHNvIGxpc3RlbiB0byBET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcbmNvbnN0IHVzZUNoYXJEYXRhID0gaWUgJiYgaWVfdmVyc2lvbiA8PSAxMTtcbmNsYXNzIFNlbGVjdGlvblN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBzZXQoc2VsKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IHNlbC5hbmNob3JOb2RlO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICB9XG4gICAgZXEoc2VsKSB7XG4gICAgICAgIHJldHVybiBzZWwuYW5jaG9yTm9kZSA9PSB0aGlzLmFuY2hvck5vZGUgJiYgc2VsLmFuY2hvck9mZnNldCA9PSB0aGlzLmFuY2hvck9mZnNldCAmJlxuICAgICAgICAgICAgc2VsLmZvY3VzTm9kZSA9PSB0aGlzLmZvY3VzTm9kZSAmJiBzZWwuZm9jdXNPZmZzZXQgPT0gdGhpcy5mb2N1c09mZnNldDtcbiAgICB9XG59XG5jbGFzcyBET01PYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IodmlldywgaGFuZGxlRE9NQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuaGFuZGxlRE9NQ2hhbmdlID0gaGFuZGxlRE9NQ2hhbmdlO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIHRoaXMub25DaGFyRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdENoYW5nZWRUZXh0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciAmJlxuICAgICAgICAgICAgbmV3IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXRhdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIC8vIElFMTEgd2lsbCBzb21ldGltZXMgKG9uIGJhY2tzcGFjaW5nIG91dCBhIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAvLyB0ZXh0IG5vZGUgYWZ0ZXIgYSBCUiBub2RlKSBjYWxsIHRoZSBvYnNlcnZlciBjYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIGJlZm9yZSBhY3R1YWxseSB1cGRhdGluZyB0aGUgRE9NLCB3aGljaCB3aWxsIGNhdXNlXG4gICAgICAgICAgICAgICAgLy8gUHJvc2VNaXJyb3IgdG8gbWlzcyB0aGUgY2hhbmdlIChzZWUgIzkzMClcbiAgICAgICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBtdXRhdGlvbnMuc29tZShtID0+IG0udHlwZSA9PSBcImNoaWxkTGlzdFwiICYmIG0ucmVtb3ZlZE5vZGVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbS5vbGRWYWx1ZS5sZW5ndGggPiBtLnRhcmdldC5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFyRGF0YSA9IGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh7IHRhcmdldDogZS50YXJnZXQsIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLCBvbGRWYWx1ZTogZS5wcmV2VmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZmx1c2hTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5mbHVzaGluZ1Nvb24gPCAwKVxuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuZmx1c2hpbmdTb29uID0gLTE7IHRoaXMuZmx1c2goKTsgfSwgMjApO1xuICAgIH1cbiAgICBmb3JjZUZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5mbHVzaGluZ1Nvb24gPiAtMSkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmZsdXNoaW5nU29vbik7XG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IC0xO1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMudmlldy5kb20sIG9ic2VydmVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbkNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICAgIHRoaXMuY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcikge1xuICAgICAgICAgICAgbGV0IHRha2UgPSB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAgICAgICBpZiAodGFrZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2UubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh0YWtlW2ldKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLmZsdXNoKCksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGNvbm5lY3RTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0U2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCkge1xuICAgICAgICB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZSwgNTApO1xuICAgIH1cbiAgICBvblNlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgaWYgKCFoYXNGb2N1c0FuZFNlbGVjdGlvbih0aGlzLnZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMpXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uVG9ET00odGhpcy52aWV3KTtcbiAgICAgICAgLy8gRGVsZXRpb25zIG9uIElFMTEgZmlyZSB0aGVpciBldmVudHMgaW4gdGhlIHdyb25nIG9yZGVyLCBnaXZpbmdcbiAgICAgICAgLy8gdXMgYSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgRE9NIGNoYW5nZXMgYXJlXG4gICAgICAgIC8vIHJlcG9ydGVkLlxuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiAhdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHNlbCA9IHRoaXMudmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgLy8gU2VsZWN0aW9uLmlzQ29sbGFwc2VkIGlzbid0IHJlbGlhYmxlIG9uIElFXG4gICAgICAgICAgICBpZiAoc2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICAgIHNldEN1clNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uLnNldCh0aGlzLnZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSk7XG4gICAgfVxuICAgIGlnbm9yZVNlbGVjdGlvbkNoYW5nZShzZWwpIHtcbiAgICAgICAgaWYgKCFzZWwuZm9jdXNOb2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBhbmNlc3RvcnMgPSBuZXcgU2V0LCBjb250YWluZXI7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBzZWwuZm9jdXNOb2RlOyBzY2FuOyBzY2FuID0gcGFyZW50Tm9kZShzY2FuKSlcbiAgICAgICAgICAgIGFuY2VzdG9ycy5hZGQoc2Nhbik7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBzZWwuYW5jaG9yTm9kZTsgc2Nhbjsgc2NhbiA9IHBhcmVudE5vZGUoc2NhbikpXG4gICAgICAgICAgICBpZiAoYW5jZXN0b3JzLmhhcyhzY2FuKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHNjYW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkZXNjID0gY29udGFpbmVyICYmIHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGNvbnRhaW5lcik7XG4gICAgICAgIGlmIChkZXNjICYmIGRlc2MuaWdub3JlTXV0YXRpb24oe1xuICAgICAgICAgICAgdHlwZTogXCJzZWxlY3Rpb25cIixcbiAgICAgICAgICAgIHRhcmdldDogY29udGFpbmVyLm5vZGVUeXBlID09IDMgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lclxuICAgICAgICB9KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBlbmRpbmdSZWNvcmRzKCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcilcbiAgICAgICAgICAgIGZvciAobGV0IG11dCBvZiB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlO1xuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCF2aWV3LmRvY1ZpZXcgfHwgdGhpcy5mbHVzaGluZ1Nvb24gPiAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG11dGF0aW9ucyA9IHRoaXMucGVuZGluZ1JlY29yZHMoKTtcbiAgICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBuZXdTZWwgPSAhdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgJiYgIXRoaXMuY3VycmVudFNlbGVjdGlvbi5lcShzZWwpICYmIGhhc0ZvY3VzQW5kU2VsZWN0aW9uKHZpZXcpICYmICF0aGlzLmlnbm9yZVNlbGVjdGlvbkNoYW5nZShzZWwpO1xuICAgICAgICBsZXQgZnJvbSA9IC0xLCB0byA9IC0xLCB0eXBlT3ZlciA9IGZhbHNlLCBhZGRlZCA9IFtdO1xuICAgICAgICBpZiAodmlldy5lZGl0YWJsZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5yZWdpc3Rlck11dGF0aW9uKG11dGF0aW9uc1tpXSwgYWRkZWQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IGZyb20gPCAwID8gcmVzdWx0LmZyb20gOiBNYXRoLm1pbihyZXN1bHQuZnJvbSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gdG8gPCAwID8gcmVzdWx0LnRvIDogTWF0aC5tYXgocmVzdWx0LnRvLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZU92ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlT3ZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChnZWNrbyAmJiBhZGRlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBicnMgPSBhZGRlZC5maWx0ZXIobiA9PiBuLm5vZGVOYW1lID09IFwiQlJcIik7XG4gICAgICAgICAgICBpZiAoYnJzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IFthLCBiXSA9IGJycztcbiAgICAgICAgICAgICAgICBpZiAoYS5wYXJlbnROb2RlICYmIGEucGFyZW50Tm9kZS5wYXJlbnROb2RlID09IGIucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGEucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmb2N1c05vZGUgfSA9IHRoaXMuY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiciBvZiBicnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IGJyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVOYW1lID09IFwiTElcIiAmJiAoIWZvY3VzTm9kZSB8fCBibG9ja1BhcmVudCh2aWV3LCBmb2N1c05vZGUpICE9IHBhcmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBici5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlYWRTZWwgPSBudWxsO1xuICAgICAgICAvLyBJZiBpdCBsb29rcyBsaWtlIHRoZSBicm93c2VyIGhhcyByZXNldCB0aGUgc2VsZWN0aW9uIHRvIHRoZVxuICAgICAgICAvLyBzdGFydCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgZm9jdXMsIHJlc3RvcmUgdGhlIHNlbGVjdGlvbiBmcm9tXG4gICAgICAgIC8vIHRoZSBzdGF0ZVxuICAgICAgICBpZiAoZnJvbSA8IDAgJiYgbmV3U2VsICYmIHZpZXcuaW5wdXQubGFzdEZvY3VzID4gRGF0ZS5ub3coKSAtIDIwMCAmJlxuICAgICAgICAgICAgTWF0aC5tYXgodmlldy5pbnB1dC5sYXN0VG91Y2gsIHZpZXcuaW5wdXQubGFzdENsaWNrLnRpbWUpIDwgRGF0ZS5ub3coKSAtIDMwMCAmJlxuICAgICAgICAgICAgc2VsZWN0aW9uQ29sbGFwc2VkKHNlbCkgJiYgKHJlYWRTZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcpKSAmJlxuICAgICAgICAgICAgcmVhZFNlbC5lcShTZWxlY3Rpb24ubmVhcih2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKDApLCAxKSkpIHtcbiAgICAgICAgICAgIHZpZXcuaW5wdXQubGFzdEZvY3VzID0gMDtcbiAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uLnNldChzZWwpO1xuICAgICAgICAgICAgdmlldy5zY3JvbGxUb1NlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZyb20gPiAtMSB8fCBuZXdTZWwpIHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gLTEpIHtcbiAgICAgICAgICAgICAgICB2aWV3LmRvY1ZpZXcubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICBjaGVja0NTUyh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRE9NQ2hhbmdlKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpO1xuICAgICAgICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3LmRvY1ZpZXcuZGlydHkpXG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSlcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3Rlck11dGF0aW9uKG11dCwgYWRkZWQpIHtcbiAgICAgICAgLy8gSWdub3JlIG11dGF0aW9ucyBpbnNpZGUgbm9kZXMgdGhhdCB3ZXJlIGFscmVhZHkgbm90ZWQgYXMgaW5zZXJ0ZWRcbiAgICAgICAgaWYgKGFkZGVkLmluZGV4T2YobXV0LnRhcmdldCkgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZGVzYyA9IHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKG11dC50YXJnZXQpO1xuICAgICAgICBpZiAobXV0LnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIgJiZcbiAgICAgICAgICAgIChkZXNjID09IHRoaXMudmlldy5kb2NWaWV3IHx8IG11dC5hdHRyaWJ1dGVOYW1lID09IFwiY29udGVudGVkaXRhYmxlXCIgfHxcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHNvbWV0aW1lcyBmaXJlcyBzcHVyaW91cyBldmVudHMgZm9yIG51bGwvZW1wdHkgc3R5bGVzXG4gICAgICAgICAgICAgICAgKG11dC5hdHRyaWJ1dGVOYW1lID09IFwic3R5bGVcIiAmJiAhbXV0Lm9sZFZhbHVlICYmICFtdXQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpKSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCFkZXNjIHx8IGRlc2MuaWdub3JlTXV0YXRpb24obXV0KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAobXV0LnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXQuYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gbXV0LmFkZGVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RDaGFuZ2VkVGV4dE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlc2MuY29udGVudERPTSAmJiBkZXNjLmNvbnRlbnRET00gIT0gZGVzYy5kb20gJiYgIWRlc2MuY29udGVudERPTS5jb250YWlucyhtdXQudGFyZ2V0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyBmcm9tOiBkZXNjLnBvc0JlZm9yZSwgdG86IGRlc2MucG9zQWZ0ZXIgfTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbXV0LnByZXZpb3VzU2libGluZywgbmV4dCA9IG11dC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIG11dC5hZGRlZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIElFMTEgZ2l2ZXMgdXMgaW5jb3JyZWN0IG5leHQvcHJldiBzaWJsaW5ncyBmb3Igc29tZVxuICAgICAgICAgICAgICAgIC8vIGluc2VydGlvbnMsIHNvIGlmIHRoZXJlIGFyZSBhZGRlZCBub2RlcywgcmVjb21wdXRlIHRob3NlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXQuYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBwcmV2aW91c1NpYmxpbmcsIG5leHRTaWJsaW5nIH0gPSBtdXQuYWRkZWROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c1NpYmxpbmcgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChtdXQuYWRkZWROb2RlcywgcHJldmlvdXNTaWJsaW5nKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHRTaWJsaW5nIHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobXV0LmFkZGVkTm9kZXMsIG5leHRTaWJsaW5nKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZyb21PZmZzZXQgPSBwcmV2ICYmIHByZXYucGFyZW50Tm9kZSA9PSBtdXQudGFyZ2V0XG4gICAgICAgICAgICAgICAgPyBkb21JbmRleChwcmV2KSArIDEgOiAwO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBkZXNjLmxvY2FsUG9zRnJvbURPTShtdXQudGFyZ2V0LCBmcm9tT2Zmc2V0LCAtMSk7XG4gICAgICAgICAgICBsZXQgdG9PZmZzZXQgPSBuZXh0ICYmIG5leHQucGFyZW50Tm9kZSA9PSBtdXQudGFyZ2V0XG4gICAgICAgICAgICAgICAgPyBkb21JbmRleChuZXh0KSA6IG11dC50YXJnZXQuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgdG8gPSBkZXNjLmxvY2FsUG9zRnJvbURPTShtdXQudGFyZ2V0LCB0b09mZnNldCwgMSk7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tLCB0byB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBkZXNjLnBvc0F0U3RhcnQgLSBkZXNjLmJvcmRlciwgdG86IGRlc2MucG9zQXRFbmQgKyBkZXNjLmJvcmRlciB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBcImNoYXJhY3RlckRhdGFcIlxuICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlZFRleHROb2RlID0gbXV0LnRhcmdldDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogZGVzYy5wb3NBdFN0YXJ0LFxuICAgICAgICAgICAgICAgIHRvOiBkZXNjLnBvc0F0RW5kLFxuICAgICAgICAgICAgICAgIC8vIEFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgZm9yIGEgdGV4dCBjaGFuZ2UgdGhhdCBkaWRuJ3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgLy8gYW55IHRleHQuIE1hcmsgdGhlIGRvbSBjaGFuZ2UgdG8gZmFsbCBiYWNrIHRvIGFzc3VtaW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbiB3YXMgdHlwZWQgb3ZlciB3aXRoIGFuIGlkZW50aWNhbCB2YWx1ZSBpZiBpdCBjYW4ndFxuICAgICAgICAgICAgICAgIC8vIGZpbmQgYW5vdGhlciBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgdHlwZU92ZXI6IG11dC50YXJnZXQubm9kZVZhbHVlID09IG11dC5vbGRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBjc3NDaGVja2VkID0gbmV3IFdlYWtNYXAoKTtcbmxldCBjc3NDaGVja1dhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gY2hlY2tDU1Modmlldykge1xuICAgIGlmIChjc3NDaGVja2VkLmhhcyh2aWV3KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNzc0NoZWNrZWQuc2V0KHZpZXcsIG51bGwpO1xuICAgIGlmIChbJ25vcm1hbCcsICdub3dyYXAnLCAncHJlLWxpbmUnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUodmlldy5kb20pLndoaXRlU3BhY2UpICE9PSAtMSkge1xuICAgICAgICB2aWV3LnJlcXVpcmVzR2Vja29IYWNrTm9kZSA9IGdlY2tvO1xuICAgICAgICBpZiAoY3NzQ2hlY2tXYXJuZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGVbXCJ3YXJuXCJdKFwiUHJvc2VNaXJyb3IgZXhwZWN0cyB0aGUgQ1NTIHdoaXRlLXNwYWNlIHByb3BlcnR5IHRvIGJlIHNldCwgcHJlZmVyYWJseSB0byAncHJlLXdyYXAnLiBJdCBpcyByZWNvbW1lbmRlZCB0byBsb2FkIHN0eWxlL3Byb3NlbWlycm9yLmNzcyBmcm9tIHRoZSBwcm9zZW1pcnJvci12aWV3IHBhY2thZ2UuXCIpO1xuICAgICAgICBjc3NDaGVja1dhcm5lZCA9IHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmFuZ2VUb1NlbGVjdGlvblJhbmdlKHZpZXcsIHJhbmdlKSB7XG4gICAgbGV0IGFuY2hvck5vZGUgPSByYW5nZS5zdGFydENvbnRhaW5lciwgYW5jaG9yT2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgbGV0IGZvY3VzTm9kZSA9IHJhbmdlLmVuZENvbnRhaW5lciwgZm9jdXNPZmZzZXQgPSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgbGV0IGN1cnJlbnRBbmNob3IgPSB2aWV3LmRvbUF0UG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvcik7XG4gICAgLy8gU2luY2Ugc3VjaCBhIHJhbmdlIGRvZXNuJ3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbmNob3IgYW5kIGhlYWQsXG4gICAgLy8gdXNlIGEgaGV1cmlzdGljIHRoYXQgZmxpcHMgaXQgYXJvdW5kIGlmIGl0cyBlbmQgbWF0Y2hlcyB0aGVcbiAgICAvLyBjdXJyZW50IGFuY2hvci5cbiAgICBpZiAoaXNFcXVpdmFsZW50UG9zaXRpb24oY3VycmVudEFuY2hvci5ub2RlLCBjdXJyZW50QW5jaG9yLm9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpXG4gICAgICAgIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdID0gW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXQsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldF07XG4gICAgcmV0dXJuIHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH07XG59XG4vLyBVc2VkIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIFNlbGVjdGlvbi9zaGFkb3cgRE9NIGJ1Z1xuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy80MTQgZml4XG5mdW5jdGlvbiBzYWZhcmlTaGFkb3dTZWxlY3Rpb25SYW5nZSh2aWV3LCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uLmdldENvbXBvc2VkUmFuZ2VzKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbGVjdGlvbi5nZXRDb21wb3NlZFJhbmdlcyh2aWV3LnJvb3QpWzBdO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VUb1NlbGVjdGlvblJhbmdlKHZpZXcsIHJhbmdlKTtcbiAgICB9XG4gICAgbGV0IGZvdW5kO1xuICAgIGZ1bmN0aW9uIHJlYWQoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGZvdW5kID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKClbMF07XG4gICAgfVxuICAgIC8vIEJlY2F1c2UgU2FmYXJpIChhdCBsZWFzdCBpbiAyMDE4LTIwMjIpIGRvZXNuJ3QgcHJvdmlkZSByZWd1bGFyXG4gICAgLy8gYWNjZXNzIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIGEgc2hhZG93Um9vdCwgd2UgaGF2ZSB0byBwZXJmb3JtIGFcbiAgICAvLyByaWRpY3Vsb3VzIGhhY2sgdG8gZ2V0IGF0IGl04oCUdXNpbmcgYGV4ZWNDb21tYW5kYCB0byB0cmlnZ2VyIGFcbiAgICAvLyBgYmVmb3JlSW5wdXRgIGV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlYWQgdGhlIHRhcmdldCByYW5nZSBmcm9tIHRoZVxuICAgIC8vIGV2ZW50LlxuICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcImluZGVudFwiKTtcbiAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZvdW5kID8gcmFuZ2VUb1NlbGVjdGlvblJhbmdlKHZpZXcsIGZvdW5kKSA6IG51bGw7XG59XG5mdW5jdGlvbiBibG9ja1BhcmVudCh2aWV3LCBub2RlKSB7XG4gICAgZm9yIChsZXQgcCA9IG5vZGUucGFyZW50Tm9kZTsgcCAmJiBwICE9IHZpZXcuZG9tOyBwID0gcC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKHAsIHRydWUpO1xuICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUuaXNCbG9jaylcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLy8gTm90ZSB0aGF0IGFsbCByZWZlcmVuY2luZyBhbmQgcGFyc2luZyBpcyBkb25lIHdpdGggdGhlXG4vLyBzdGFydC1vZi1vcGVyYXRpb24gc2VsZWN0aW9uIGFuZCBkb2N1bWVudCwgc2luY2UgdGhhdCdzIHRoZSBvbmVcbi8vIHRoYXQgdGhlIERPTSByZXByZXNlbnRzLiBJZiBhbnkgY2hhbmdlcyBjYW1lIGluIGluIHRoZSBtZWFudGltZSxcbi8vIHRoZSBtb2RpZmljYXRpb24gaXMgbWFwcGVkIG92ZXIgdGhvc2UgYmVmb3JlIGl0IGlzIGFwcGxpZWQsIGluXG4vLyByZWFkRE9NQ2hhbmdlLlxuZnVuY3Rpb24gcGFyc2VCZXR3ZWVuKHZpZXcsIGZyb21fLCB0b18pIHtcbiAgICBsZXQgeyBub2RlOiBwYXJlbnQsIGZyb21PZmZzZXQsIHRvT2Zmc2V0LCBmcm9tLCB0byB9ID0gdmlldy5kb2NWaWV3LnBhcnNlUmFuZ2UoZnJvbV8sIHRvXyk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgZmluZDtcbiAgICBsZXQgYW5jaG9yID0gZG9tU2VsLmFuY2hvck5vZGU7XG4gICAgaWYgKGFuY2hvciAmJiB2aWV3LmRvbS5jb250YWlucyhhbmNob3Iubm9kZVR5cGUgPT0gMSA/IGFuY2hvciA6IGFuY2hvci5wYXJlbnROb2RlKSkge1xuICAgICAgICBmaW5kID0gW3sgbm9kZTogYW5jaG9yLCBvZmZzZXQ6IGRvbVNlbC5hbmNob3JPZmZzZXQgfV07XG4gICAgICAgIGlmICghc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpXG4gICAgICAgICAgICBmaW5kLnB1c2goeyBub2RlOiBkb21TZWwuZm9jdXNOb2RlLCBvZmZzZXQ6IGRvbVNlbC5mb2N1c09mZnNldCB9KTtcbiAgICB9XG4gICAgLy8gV29yayBhcm91bmQgaXNzdWUgaW4gQ2hyb21lIHdoZXJlIGJhY2tzcGFjaW5nIHNvbWV0aW1lcyByZXBsYWNlc1xuICAgIC8vIHRoZSBkZWxldGVkIGNvbnRlbnQgd2l0aCBhIHJhbmRvbSBCUiBub2RlIChpc3N1ZXMgIzc5OSwgIzgzMSlcbiAgICBpZiAoY2hyb21lICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDgpIHtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdG9PZmZzZXQ7IG9mZiA+IGZyb21PZmZzZXQ7IG9mZi0tKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHBhcmVudC5jaGlsZE5vZGVzW29mZiAtIDFdLCBkZXNjID0gbm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiICYmICFkZXNjKSB7XG4gICAgICAgICAgICAgICAgdG9PZmZzZXQgPSBvZmY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgZGVzYy5zaXplKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGxldCBwYXJzZXIgPSB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICBsZXQgJGZyb20gPSBzdGFydERvYy5yZXNvbHZlKGZyb20pO1xuICAgIGxldCBzZWwgPSBudWxsLCBkb2MgPSBwYXJzZXIucGFyc2UocGFyZW50LCB7XG4gICAgICAgIHRvcE5vZGU6ICRmcm9tLnBhcmVudCxcbiAgICAgICAgdG9wTWF0Y2g6ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKSxcbiAgICAgICAgdG9wT3BlbjogdHJ1ZSxcbiAgICAgICAgZnJvbTogZnJvbU9mZnNldCxcbiAgICAgICAgdG86IHRvT2Zmc2V0LFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICRmcm9tLnBhcmVudC50eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiA/IFwiZnVsbFwiIDogdHJ1ZSxcbiAgICAgICAgZmluZFBvc2l0aW9uczogZmluZCxcbiAgICAgICAgcnVsZUZyb21Ob2RlLFxuICAgICAgICBjb250ZXh0OiAkZnJvbVxuICAgIH0pO1xuICAgIGlmIChmaW5kICYmIGZpbmRbMF0ucG9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGFuY2hvciA9IGZpbmRbMF0ucG9zLCBoZWFkID0gZmluZFsxXSAmJiBmaW5kWzFdLnBvcztcbiAgICAgICAgaWYgKGhlYWQgPT0gbnVsbClcbiAgICAgICAgICAgIGhlYWQgPSBhbmNob3I7XG4gICAgICAgIHNlbCA9IHsgYW5jaG9yOiBhbmNob3IgKyBmcm9tLCBoZWFkOiBoZWFkICsgZnJvbSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBkb2MsIHNlbCwgZnJvbSwgdG8gfTtcbn1cbmZ1bmN0aW9uIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIGlmIChkZXNjKSB7XG4gICAgICAgIHJldHVybiBkZXNjLnBhcnNlUnVsZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmIGRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIC8vIFNhZmFyaSByZXBsYWNlcyB0aGUgbGlzdCBpdGVtIG9yIHRhYmxlIGNlbGwgd2l0aCBhIEJSXG4gICAgICAgIC8vIGRpcmVjdGx5IGluIHRoZSBsaXN0IG5vZGUgKD8hKSBpZiB5b3UgZGVsZXRlIHRoZSBsYXN0XG4gICAgICAgIC8vIGNoYXJhY3RlciBpbiBhIGxpc3QgaXRlbSBvciB0YWJsZSBjZWxsICgjNzA4LCAjODYyKVxuICAgICAgICBpZiAoc2FmYXJpICYmIC9eKHVsfG9sKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgbGV0IHNraXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgc2tpcC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc2tpcCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvbS5wYXJlbnROb2RlLmxhc3RDaGlsZCA9PSBkb20gfHwgc2FmYXJpICYmIC9eKHRyfHRhYmxlKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiSU1HXCIgJiYgZG9tLmdldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIikpIHtcbiAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgaXNJbmxpbmUgPSAvXihhfGFiYnJ8YWNyb255bXxifGJkW2lvXXxiaWd8YnJ8YnV0dG9ufGNpdGV8Y29kZXxkYXRhKGxpc3QpP3xkZWx8ZGZufGVtfGl8aW5zfGtiZHxsYWJlbHxtYXB8bWFya3xtZXRlcnxvdXRwdXR8cXxydWJ5fHN8c2FtcHxzbWFsbHxzcGFufHN0cm9uZ3xzdVticF18dGltZXx1fHR0fHZhcikkL2k7XG5mdW5jdGlvbiByZWFkRE9NQ2hhbmdlKHZpZXcsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWROb2Rlcykge1xuICAgIGxldCBjb21wb3NpdGlvbklEID0gdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzIHx8ICh2aWV3LmNvbXBvc2luZyA/IHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCA6IDApO1xuICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IDA7XG4gICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGxldCBvcmlnaW4gPSB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwID8gdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luIDogbnVsbDtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldywgb3JpZ2luKTtcbiAgICAgICAgaWYgKG5ld1NlbCAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24uZXEobmV3U2VsKSkge1xuICAgICAgICAgICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmXG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gMTMgJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lICYmXG4gICAgICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3U2VsKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcInBvaW50ZXJcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcmlnaW4gPT0gXCJrZXlcIilcbiAgICAgICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uSUQpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgJGJlZm9yZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgbGV0IHNoYXJlZCA9ICRiZWZvcmUuc2hhcmVkRGVwdGgodG8pO1xuICAgIGZyb20gPSAkYmVmb3JlLmJlZm9yZShzaGFyZWQgKyAxKTtcbiAgICB0byA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUodG8pLmFmdGVyKHNoYXJlZCArIDEpO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcGFyc2UgPSBwYXJzZUJldHdlZW4odmlldywgZnJvbSwgdG8pO1xuICAgIGxldCBkb2MgPSB2aWV3LnN0YXRlLmRvYywgY29tcGFyZSA9IGRvYy5zbGljZShwYXJzZS5mcm9tLCBwYXJzZS50byk7XG4gICAgbGV0IHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZTtcbiAgICAvLyBQcmVmZXIgYW5jaG9yaW5nIHRvIGVuZCB3aGVuIEJhY2tzcGFjZSBpcyBwcmVzc2VkXG4gICAgaWYgKHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDggJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lKSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb207XG4gICAgICAgIHByZWZlcnJlZFNpZGUgPSBcInN0YXJ0XCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBudWxsO1xuICAgIGxldCBjaGFuZ2UgPSBmaW5kRGlmZihjb21wYXJlLmNvbnRlbnQsIHBhcnNlLmRvYy5jb250ZW50LCBwYXJzZS5mcm9tLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpO1xuICAgIGlmIChjaGFuZ2UpXG4gICAgICAgIHZpZXcuaW5wdXQuZG9tQ2hhbmdlQ291bnQrKztcbiAgICBpZiAoKGlvcyAmJiB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA+IERhdGUubm93KCkgLSAyMjUgfHwgYW5kcm9pZCkgJiZcbiAgICAgICAgYWRkZWROb2Rlcy5zb21lKG4gPT4gbi5ub2RlVHlwZSA9PSAxICYmICFpc0lubGluZS50ZXN0KG4ubm9kZU5hbWUpKSAmJlxuICAgICAgICAoIWNoYW5nZSB8fCBjaGFuZ2UuZW5kQSA+PSBjaGFuZ2UuZW5kQikgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpIHtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIGlmICh0eXBlT3ZlciAmJiBzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgJiYgc2VsLiRoZWFkLnNhbWVQYXJlbnQoc2VsLiRhbmNob3IpICYmXG4gICAgICAgICAgICAhdmlldy5jb21wb3NpbmcgJiYgIShwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciAhPSBwYXJzZS5zZWwuaGVhZCkpIHtcbiAgICAgICAgICAgIGNoYW5nZSA9IHsgc3RhcnQ6IHNlbC5mcm9tLCBlbmRBOiBzZWwudG8sIGVuZEI6IHNlbC50byB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhcnNlLnNlbCkge1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuZG9jLCBwYXJzZS5zZWwpO1xuICAgICAgICAgICAgICAgIGlmIChzZWwgJiYgIXNlbC5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uSUQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiY29tcG9zaXRpb25cIiwgY29tcG9zaXRpb25JRCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgb3ZlcndyaXRpbmcgYSBzZWxlY3Rpb24gYnkgdHlwaW5nIG1hdGNoZXNcbiAgICAvLyB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBzZWxlY3RlZCBjb250ZW50LCBjcmVhdGluZyBhIGNoYW5nZVxuICAgIC8vIHRoYXQncyBzbWFsbGVyIHRoYW4gd2hhdCB3YXMgYWN0dWFsbHkgb3ZlcndyaXR0ZW4uXG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJlxuICAgICAgICBjaGFuZ2Uuc3RhcnQgPT0gY2hhbmdlLmVuZEIgJiZcbiAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChjaGFuZ2Uuc3RhcnQgPiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICYmIGNoYW5nZS5zdGFydCA8PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICsgMiAmJlxuICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+PSBwYXJzZS5mcm9tKSB7XG4gICAgICAgICAgICBjaGFuZ2Uuc3RhcnQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS5lbmRBIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiYgY2hhbmdlLmVuZEEgPj0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gLSAyICYmXG4gICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byA8PSBwYXJzZS50bykge1xuICAgICAgICAgICAgY2hhbmdlLmVuZEIgKz0gKHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIC0gY2hhbmdlLmVuZEEpO1xuICAgICAgICAgICAgY2hhbmdlLmVuZEEgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJRTExIHdpbGwgaW5zZXJ0IGEgbm9uLWJyZWFraW5nIHNwYWNlIF9haGVhZF8gb2YgdGhlIHNwYWNlIGFmdGVyXG4gICAgLy8gdGhlIGN1cnNvciBzcGFjZSB3aGVuIGFkZGluZyBhIHNwYWNlIGJlZm9yZSBhbm90aGVyIHNwYWNlLiBXaGVuXG4gICAgLy8gdGhhdCBoYXBwZW5lZCwgYWRqdXN0IHRoZSBjaGFuZ2UgdG8gY292ZXIgdGhlIHNwYWNlIGluc3RlYWQuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0ICsgMSAmJlxuICAgICAgICBjaGFuZ2UuZW5kQSA9PSBjaGFuZ2Uuc3RhcnQgJiYgY2hhbmdlLnN0YXJ0ID4gcGFyc2UuZnJvbSAmJlxuICAgICAgICBwYXJzZS5kb2MudGV4dEJldHdlZW4oY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSAtIDEsIGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20gKyAxKSA9PSBcIiBcXHUwMGEwXCIpIHtcbiAgICAgICAgY2hhbmdlLnN0YXJ0LS07XG4gICAgICAgIGNoYW5nZS5lbmRBLS07XG4gICAgICAgIGNoYW5nZS5lbmRCLS07XG4gICAgfVxuICAgIGxldCAkZnJvbSA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tKTtcbiAgICBsZXQgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgbGV0ICRmcm9tQSA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCk7XG4gICAgbGV0IGlubGluZUNoYW5nZSA9ICRmcm9tLnNhbWVQYXJlbnQoJHRvKSAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkZnJvbUEuZW5kKCkgPj0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IG5leHRTZWw7XG4gICAgLy8gSWYgdGhpcyBsb29rcyBsaWtlIHRoZSBlZmZlY3Qgb2YgcHJlc3NpbmcgRW50ZXIgKG9yIHdhcyByZWNvcmRlZFxuICAgIC8vIGFzIGJlaW5nIGFuIGlPUyBlbnRlciBwcmVzcyksIGp1c3QgZGlzcGF0Y2ggYW4gRW50ZXIga2V5IGluc3RlYWQuXG4gICAgaWYgKCgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSAmJlxuICAgICAgICAoIWlubGluZUNoYW5nZSB8fCBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVOYW1lID09IFwiRElWXCIgfHwgbi5ub2RlTmFtZSA9PSBcIlBcIikpKSB8fFxuICAgICAgICAoIWlubGluZUNoYW5nZSAmJiAkZnJvbS5wb3MgPCBwYXJzZS5kb2MuY29udGVudC5zaXplICYmXG4gICAgICAgICAgICAoISRmcm9tLnNhbWVQYXJlbnQoJHRvKSB8fCAhJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpICYmXG4gICAgICAgICAgICAobmV4dFNlbCA9IFNlbGVjdGlvbi5maW5kRnJvbShwYXJzZS5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSwgMSwgdHJ1ZSkpICYmXG4gICAgICAgICAgICBuZXh0U2VsLmhlYWQgPiAkZnJvbS5wb3MpKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSkge1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU2FtZSBmb3IgYmFja3NwYWNlXG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciA+IGNoYW5nZS5zdGFydCAmJlxuICAgICAgICBsb29rc0xpa2VCYWNrc3BhY2UoZG9jLCBjaGFuZ2Uuc3RhcnQsIGNoYW5nZS5lbmRBLCAkZnJvbSwgJHRvKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoOCwgXCJCYWNrc3BhY2VcIikpKSkge1xuICAgICAgICBpZiAoYW5kcm9pZCAmJiBjaHJvbWUpXG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpOyAvLyAjODIwXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2hyb21lIHdpbGwgb2NjYXNpb25hbGx5LCBkdXJpbmcgY29tcG9zaXRpb24sIGRlbGV0ZSB0aGVcbiAgICAvLyBlbnRpcmUgY29tcG9zaXRpb24gYW5kIHRoZW4gaW1tZWRpYXRlbHkgaW5zZXJ0IGl0IGFnYWluLiBUaGlzIGlzXG4gICAgLy8gdXNlZCB0byBkZXRlY3QgdGhhdCBzaXR1YXRpb24uXG4gICAgaWYgKGNocm9tZSAmJiBjaGFuZ2UuZW5kQiA9PSBjaGFuZ2Uuc3RhcnQpXG4gICAgICAgIHZpZXcuaW5wdXQubGFzdENocm9tZURlbGV0ZSA9IERhdGUubm93KCk7XG4gICAgLy8gVGhpcyB0cmllcyB0byBkZXRlY3QgQW5kcm9pZCB2aXJ0dWFsIGtleWJvYXJkXG4gICAgLy8gZW50ZXItYW5kLXBpY2stc3VnZ2VzdGlvbiBhY3Rpb24uIFRoYXQgc29tZXRpbWVzIChzZWUgaXNzdWVcbiAgICAvLyAjMTA1OSkgZmlyc3QgZmlyZXMgYSBET00gbXV0YXRpb24sIGJlZm9yZSBtb3ZpbmcgdGhlIHNlbGVjdGlvbiB0b1xuICAgIC8vIHRoZSBuZXdseSBjcmVhdGVkIGJsb2NrLiBBbmQgdGhlbiwgYmVjYXVzZSBQcm9zZU1pcnJvciBjbGVhbnMgdXBcbiAgICAvLyB0aGUgRE9NIHNlbGVjdGlvbiwgaXQgZ2l2ZXMgdXAgbW92aW5nIHRoZSBzZWxlY3Rpb24gZW50aXJlbHksXG4gICAgLy8gbGVhdmluZyB0aGUgY3Vyc29yIGluIHRoZSB3cm9uZyBwbGFjZS4gV2hlbiB0aGF0IGhhcHBlbnMsIHdlIGRyb3BcbiAgICAvLyB0aGUgbmV3IHBhcmFncmFwaCBmcm9tIHRoZSBpbml0aWFsIGNoYW5nZSwgYW5kIGZpcmUgYSBzaW11bGF0ZWRcbiAgICAvLyBlbnRlciBrZXkgYWZ0ZXJ3YXJkcy5cbiAgICBpZiAoYW5kcm9pZCAmJiAhaW5saW5lQ2hhbmdlICYmICRmcm9tLnN0YXJ0KCkgIT0gJHRvLnN0YXJ0KCkgJiYgJHRvLnBhcmVudE9mZnNldCA9PSAwICYmICRmcm9tLmRlcHRoID09ICR0by5kZXB0aCAmJlxuICAgICAgICBwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciA9PSBwYXJzZS5zZWwuaGVhZCAmJiBwYXJzZS5zZWwuaGVhZCA9PSBjaGFuZ2UuZW5kQSkge1xuICAgICAgICBjaGFuZ2UuZW5kQiAtPSAyO1xuICAgICAgICAkdG8gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSk7IH0pO1xuICAgICAgICB9LCAyMCk7XG4gICAgfVxuICAgIGxldCBjaEZyb20gPSBjaGFuZ2Uuc3RhcnQsIGNoVG8gPSBjaGFuZ2UuZW5kQTtcbiAgICBsZXQgdHIsIHN0b3JlZE1hcmtzLCBtYXJrQ2hhbmdlO1xuICAgIGlmIChpbmxpbmVDaGFuZ2UpIHtcbiAgICAgICAgaWYgKCRmcm9tLnBvcyA9PSAkdG8ucG9zKSB7IC8vIERlbGV0aW9uXG4gICAgICAgICAgICAvLyBJRTExIHNvbWV0aW1lcyB3ZWlyZGx5IG1vdmVzIHRoZSBET00gc2VsZWN0aW9uIGFyb3VuZCBhZnRlclxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgb3V0IHRoZSBmaXJzdCBlbGVtZW50IGluIGEgdGV4dGJsb2NrXG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiAkZnJvbS5wYXJlbnRPZmZzZXQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZWxlY3Rpb25Ub0RPTSh2aWV3KSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLmRlbGV0ZShjaEZyb20sIGNoVG8pO1xuICAgICAgICAgICAgc3RvcmVkTWFya3MgPSBkb2MucmVzb2x2ZShjaGFuZ2Uuc3RhcnQpLm1hcmtzQWNyb3NzKGRvYy5yZXNvbHZlKGNoYW5nZS5lbmRBKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIC8vIEFkZGluZyBvciByZW1vdmluZyBhIG1hcmtcbiAgICAgICAgY2hhbmdlLmVuZEEgPT0gY2hhbmdlLmVuZEIgJiZcbiAgICAgICAgICAgIChtYXJrQ2hhbmdlID0gaXNNYXJrQ2hhbmdlKCRmcm9tLnBhcmVudC5jb250ZW50LmN1dCgkZnJvbS5wYXJlbnRPZmZzZXQsICR0by5wYXJlbnRPZmZzZXQpLCAkZnJvbUEucGFyZW50LmNvbnRlbnQuY3V0KCRmcm9tQS5wYXJlbnRPZmZzZXQsIGNoYW5nZS5lbmRBIC0gJGZyb21BLnN0YXJ0KCkpKSkpIHtcbiAgICAgICAgICAgIHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICAgICAgICAgIGlmIChtYXJrQ2hhbmdlLnR5cGUgPT0gXCJhZGRcIilcbiAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGNoRnJvbSwgY2hUbywgbWFya0NoYW5nZS5tYXJrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0ci5yZW1vdmVNYXJrKGNoRnJvbSwgY2hUbywgbWFya0NoYW5nZS5tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgkZnJvbS5wYXJlbnQuY2hpbGQoJGZyb20uaW5kZXgoKSkuaXNUZXh0ICYmICRmcm9tLmluZGV4KCkgPT0gJHRvLmluZGV4KCkgLSAoJHRvLnRleHRPZmZzZXQgPyAwIDogMSkpIHtcbiAgICAgICAgICAgIC8vIEJvdGggcG9zaXRpb25zIGluIHRoZSBzYW1lIHRleHQgbm9kZSAtLSBzaW1wbHkgaW5zZXJ0IHRleHRcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gJGZyb20ucGFyZW50LnRleHRCZXR3ZWVuKCRmcm9tLnBhcmVudE9mZnNldCwgJHRvLnBhcmVudE9mZnNldCk7XG4gICAgICAgICAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmID0+IGYodmlldywgY2hGcm9tLCBjaFRvLCB0ZXh0KSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLmluc2VydFRleHQodGV4dCwgY2hGcm9tLCBjaFRvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRyKVxuICAgICAgICB0ciA9IHZpZXcuc3RhdGUudHIucmVwbGFjZShjaEZyb20sIGNoVG8sIHBhcnNlLmRvYy5zbGljZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tLCBjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pKTtcbiAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgIGxldCBzZWwgPSByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIHRyLmRvYywgcGFyc2Uuc2VsKTtcbiAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzLCBkdXJpbmcgY29tcG9zaXRpb24sIHJlcG9ydCB0aGVcbiAgICAgICAgLy8gc2VsZWN0aW9uIGluIHRoZSB3cm9uZyBwbGFjZS4gSWYgaXQgbG9va3MgbGlrZSB0aGF0IGlzXG4gICAgICAgIC8vIGhhcHBlbmluZywgZG9uJ3QgdXBkYXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgIC8vIEVkZ2UganVzdCBkb2Vzbid0IG1vdmUgdGhlIGN1cnNvciBmb3J3YXJkIHdoZW4geW91IHN0YXJ0IHR5cGluZ1xuICAgICAgICAvLyBpbiBhbiBlbXB0eSBibG9jayBvciBiZXR3ZWVuIGJyIG5vZGVzLlxuICAgICAgICBpZiAoc2VsICYmICEoY2hyb21lICYmIHZpZXcuY29tcG9zaW5nICYmIHNlbC5lbXB0eSAmJlxuICAgICAgICAgICAgKGNoYW5nZS5zdGFydCAhPSBjaGFuZ2UuZW5kQiB8fCB2aWV3LmlucHV0Lmxhc3RDaHJvbWVEZWxldGUgPCBEYXRlLm5vdygpIC0gMTAwKSAmJlxuICAgICAgICAgICAgKHNlbC5oZWFkID09IGNoRnJvbSB8fCBzZWwuaGVhZCA9PSB0ci5tYXBwaW5nLm1hcChjaFRvKSAtIDEpIHx8XG4gICAgICAgICAgICBpZSAmJiBzZWwuZW1wdHkgJiYgc2VsLmhlYWQgPT0gY2hGcm9tKSlcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgIH1cbiAgICBpZiAoc3RvcmVkTWFya3MpXG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKHN0b3JlZE1hcmtzKTtcbiAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG59XG5mdW5jdGlvbiByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIGRvYywgcGFyc2VkU2VsKSB7XG4gICAgaWYgKE1hdGgubWF4KHBhcnNlZFNlbC5hbmNob3IsIHBhcnNlZFNlbC5oZWFkKSA+IGRvYy5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5hbmNob3IpLCBkb2MucmVzb2x2ZShwYXJzZWRTZWwuaGVhZCkpO1xufVxuLy8gR2l2ZW4gdHdvIHNhbWUtbGVuZ3RoLCBub24tZW1wdHkgZnJhZ21lbnRzIG9mIGlubGluZSBjb250ZW50LFxuLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGZpcnN0IGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgc2Vjb25kIGJ5XG4vLyByZW1vdmluZyBvciBhZGRpbmcgYSBzaW5nbGUgbWFyayB0eXBlLlxuZnVuY3Rpb24gaXNNYXJrQ2hhbmdlKGN1ciwgcHJldikge1xuICAgIGxldCBjdXJNYXJrcyA9IGN1ci5maXJzdENoaWxkLm1hcmtzLCBwcmV2TWFya3MgPSBwcmV2LmZpcnN0Q2hpbGQubWFya3M7XG4gICAgbGV0IGFkZGVkID0gY3VyTWFya3MsIHJlbW92ZWQgPSBwcmV2TWFya3MsIHR5cGUsIG1hcmssIHVwZGF0ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgYWRkZWQgPSBwcmV2TWFya3NbaV0ucmVtb3ZlRnJvbVNldChhZGRlZCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVtb3ZlZCA9IGN1ck1hcmtzW2ldLnJlbW92ZUZyb21TZXQocmVtb3ZlZCk7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA9PSAxICYmIHJlbW92ZWQubGVuZ3RoID09IDApIHtcbiAgICAgICAgbWFyayA9IGFkZGVkWzBdO1xuICAgICAgICB0eXBlID0gXCJhZGRcIjtcbiAgICAgICAgdXBkYXRlID0gKG5vZGUpID0+IG5vZGUubWFyayhtYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWRkZWQubGVuZ3RoID09IDAgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMSkge1xuICAgICAgICBtYXJrID0gcmVtb3ZlZFswXTtcbiAgICAgICAgdHlwZSA9IFwicmVtb3ZlXCI7XG4gICAgICAgIHVwZGF0ZSA9IChub2RlKSA9PiBub2RlLm1hcmsobWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5jaGlsZENvdW50OyBpKyspXG4gICAgICAgIHVwZGF0ZWQucHVzaCh1cGRhdGUocHJldi5jaGlsZChpKSkpO1xuICAgIGlmIChGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLmVxKGN1cikpXG4gICAgICAgIHJldHVybiB7IG1hcmssIHR5cGUgfTtcbn1cbmZ1bmN0aW9uIGxvb2tzTGlrZUJhY2tzcGFjZShvbGQsIHN0YXJ0LCBlbmQsICRuZXdTdGFydCwgJG5ld0VuZCkge1xuICAgIGlmICggLy8gVGhlIGNvbnRlbnQgbXVzdCBoYXZlIHNocnVua1xuICAgIGVuZCAtIHN0YXJ0IDw9ICRuZXdFbmQucG9zIC0gJG5ld1N0YXJ0LnBvcyB8fFxuICAgICAgICAvLyBuZXdFbmQgbXVzdCBwb2ludCBkaXJlY3RseSBhdCBvciBhZnRlciB0aGUgZW5kIG9mIHRoZSBibG9jayB0aGF0IG5ld1N0YXJ0IHBvaW50cyBpbnRvXG4gICAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV3U3RhcnQsIHRydWUsIGZhbHNlKSA8ICRuZXdFbmQucG9zKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRzdGFydCA9IG9sZC5yZXNvbHZlKHN0YXJ0KTtcbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUsIHJhdGhlciB0aGFuIGpvaW5pbmcgYmxvY2tzLCB0aGUgY2hhbmdlIGp1c3QgcmVtb3ZlZCBhbiBlbnRpcmUgYmxvY2tcbiAgICBpZiAoISRuZXdTdGFydC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgbGV0IGFmdGVyID0gJHN0YXJ0Lm5vZGVBZnRlcjtcbiAgICAgICAgcmV0dXJuIGFmdGVyICE9IG51bGwgJiYgZW5kID09IHN0YXJ0ICsgYWZ0ZXIubm9kZVNpemU7XG4gICAgfVxuICAgIC8vIFN0YXJ0IG11c3QgYmUgYXQgdGhlIGVuZCBvZiBhIGJsb2NrXG4gICAgaWYgKCRzdGFydC5wYXJlbnRPZmZzZXQgPCAkc3RhcnQucGFyZW50LmNvbnRlbnQuc2l6ZSB8fCAhJHN0YXJ0LnBhcmVudC5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkbmV4dCA9IG9sZC5yZXNvbHZlKHNraXBDbG9zaW5nQW5kT3BlbmluZygkc3RhcnQsIHRydWUsIHRydWUpKTtcbiAgICAvLyBUaGUgbmV4dCB0ZXh0YmxvY2sgbXVzdCBzdGFydCBiZWZvcmUgZW5kIGFuZCBlbmQgbmVhciBpdFxuICAgIGlmICghJG5leHQucGFyZW50LmlzVGV4dGJsb2NrIHx8ICRuZXh0LnBvcyA+IGVuZCB8fFxuICAgICAgICBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJG5leHQsIHRydWUsIGZhbHNlKSA8IGVuZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFRoZSBmcmFnbWVudHMgYWZ0ZXIgdGhlIGpvaW4gcG9pbnQgbXVzdCBtYXRjaFxuICAgIHJldHVybiAkbmV3U3RhcnQucGFyZW50LmNvbnRlbnQuY3V0KCRuZXdTdGFydC5wYXJlbnRPZmZzZXQpLmVxKCRuZXh0LnBhcmVudC5jb250ZW50KTtcbn1cbmZ1bmN0aW9uIHNraXBDbG9zaW5nQW5kT3BlbmluZygkcG9zLCBmcm9tRW5kLCBtYXlPcGVuKSB7XG4gICAgbGV0IGRlcHRoID0gJHBvcy5kZXB0aCwgZW5kID0gZnJvbUVuZCA/ICRwb3MuZW5kKCkgOiAkcG9zLnBvcztcbiAgICB3aGlsZSAoZGVwdGggPiAwICYmIChmcm9tRW5kIHx8ICRwb3MuaW5kZXhBZnRlcihkZXB0aCkgPT0gJHBvcy5ub2RlKGRlcHRoKS5jaGlsZENvdW50KSkge1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgICBlbmQrKztcbiAgICAgICAgZnJvbUVuZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobWF5T3Blbikge1xuICAgICAgICBsZXQgbmV4dCA9ICRwb3Mubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkcG9zLmluZGV4QWZ0ZXIoZGVwdGgpKTtcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgIW5leHQuaXNMZWFmKSB7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIGZpbmREaWZmKGEsIGIsIHBvcywgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IHN0YXJ0ID0gYS5maW5kRGlmZlN0YXJ0KGIsIHBvcyk7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB7IGE6IGVuZEEsIGI6IGVuZEIgfSA9IGEuZmluZERpZmZFbmQoYiwgcG9zICsgYS5zaXplLCBwb3MgKyBiLnNpemUpO1xuICAgIGlmIChwcmVmZXJyZWRTaWRlID09IFwiZW5kXCIpIHtcbiAgICAgICAgbGV0IGFkanVzdCA9IE1hdGgubWF4KDAsIHN0YXJ0IC0gTWF0aC5taW4oZW5kQSwgZW5kQikpO1xuICAgICAgICBwcmVmZXJyZWRQb3MgLT0gZW5kQSArIGFkanVzdCAtIHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZW5kQSA8IHN0YXJ0ICYmIGEuc2l6ZSA8IGIuc2l6ZSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQSA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgc3RhcnQgLT0gbW92ZTtcbiAgICAgICAgaWYgKHN0YXJ0ICYmIHN0YXJ0IDwgYi5zaXplICYmIGlzU3Vycm9nYXRlUGFpcihiLnRleHRCZXR3ZWVuKHN0YXJ0IC0gMSwgc3RhcnQgKyAxKSkpXG4gICAgICAgICAgICBzdGFydCArPSBtb3ZlID8gMSA6IC0xO1xuICAgICAgICBlbmRCID0gc3RhcnQgKyAoZW5kQiAtIGVuZEEpO1xuICAgICAgICBlbmRBID0gc3RhcnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuZEIgPCBzdGFydCkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQiA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgc3RhcnQgLT0gbW92ZTtcbiAgICAgICAgaWYgKHN0YXJ0ICYmIHN0YXJ0IDwgYS5zaXplICYmIGlzU3Vycm9nYXRlUGFpcihhLnRleHRCZXR3ZWVuKHN0YXJ0IC0gMSwgc3RhcnQgKyAxKSkpXG4gICAgICAgICAgICBzdGFydCArPSBtb3ZlID8gMSA6IC0xO1xuICAgICAgICBlbmRBID0gc3RhcnQgKyAoZW5kQSAtIGVuZEIpO1xuICAgICAgICBlbmRCID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmRBLCBlbmRCIH07XG59XG5mdW5jdGlvbiBpc1N1cnJvZ2F0ZVBhaXIoc3RyKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggIT0gMilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhID0gc3RyLmNoYXJDb2RlQXQoMCksIGIgPSBzdHIuY2hhckNvZGVBdCgxKTtcbiAgICByZXR1cm4gYSA+PSAweERDMDAgJiYgYSA8PSAweERGRkYgJiYgYiA+PSAweEQ4MDAgJiYgYiA8PSAweERCRkY7XG59XG5cbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19wYXJzZUZyb21DbGlwYm9hcmQgPSBwYXJzZUZyb21DbGlwYm9hcmQ7XG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fZW5kQ29tcG9zaXRpb24gPSBlbmRDb21wb3NpdGlvbjtcbi8qKlxuQW4gZWRpdG9yIHZpZXcgbWFuYWdlcyB0aGUgRE9NIHN0cnVjdHVyZSB0aGF0IHJlcHJlc2VudHMgYW5cbmVkaXRhYmxlIGRvY3VtZW50LiBJdHMgc3RhdGUgYW5kIGJlaGF2aW9yIGFyZSBkZXRlcm1pbmVkIGJ5IGl0c1xuW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EaXJlY3RFZGl0b3JQcm9wcykuXG4qL1xuY2xhc3MgRWRpdG9yVmlldyB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdmlldy4gYHBsYWNlYCBtYXkgYmUgYSBET00gbm9kZSB0aGF0IHRoZSBlZGl0b3Igc2hvdWxkXG4gICAgYmUgYXBwZW5kZWQgdG8sIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHBsYWNlIGl0IGludG8gdGhlIGRvY3VtZW50LFxuICAgIG9yIGFuIG9iamVjdCB3aG9zZSBgbW91bnRgIHByb3BlcnR5IGhvbGRzIHRoZSBub2RlIHRvIHVzZSBhcyB0aGVcbiAgICBkb2N1bWVudCBjb250YWluZXIuIElmIGl0IGlzIGBudWxsYCwgdGhlIGVkaXRvciB3aWxsIG5vdCBiZVxuICAgIGFkZGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlLCBwcm9wcykge1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEtsdWRnZSB1c2VkIHRvIHdvcmsgYXJvdW5kIGEgQ2hyb21lIGJ1ZyBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya0N1cnNvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgSW5wdXRTdGF0ZTtcbiAgICAgICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpblZpZXdzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBIb2xkcyBgdHJ1ZWAgd2hlbiBhIGhhY2sgbm9kZSBpcyBuZWVkZWQgaW4gRmlyZWZveCB0byBwcmV2ZW50IHRoZVxuICAgICAgICBbc3BhY2UgaXMgZWF0ZW4gaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci9pc3N1ZXMvNjUxKVxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZW4gZWRpdG9yIGNvbnRlbnQgaXMgYmVpbmcgZHJhZ2dlZCwgdGhpcyBvYmplY3QgY29udGFpbnNcbiAgICAgICAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGRyYWdnZWQgc2xpY2UgYW5kIHdoZXRoZXIgaXQgaXMgYmVpbmdcbiAgICAgICAgY29waWVkIG9yIG1vdmVkLiBBdCBhbnkgb3RoZXIgdGltZSwgaXQgaXMgbnVsbC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBwcm9wcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucyB8fCBbXTtcbiAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZG9tID0gKHBsYWNlICYmIHBsYWNlLm1vdW50KSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpZiAocGxhY2UpIHtcbiAgICAgICAgICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZClcbiAgICAgICAgICAgICAgICBwbGFjZS5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGxhY2UgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHBsYWNlKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYWNlLm1vdW50KVxuICAgICAgICAgICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGVWaWV3cyA9IGJ1aWxkTm9kZVZpZXdzKHRoaXMpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBkb2NWaWV3RGVzYyh0aGlzLnN0YXRlLmRvYywgY29tcHV0ZURvY0RlY28odGhpcyksIHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgdGhpcy5kb20sIHRoaXMpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMsIChmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKSA9PiByZWFkRE9NQ2hhbmdlKHRoaXMsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICBpbml0SW5wdXQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSG9sZHMgYHRydWVgIHdoZW4gYVxuICAgIFtjb21wb3NpdGlvbl0oaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3VpZXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHMpXG4gICAgaXMgYWN0aXZlLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuIHRoaXMuaW5wdXQuY29tcG9zaW5nOyB9XG4gICAgLyoqXG4gICAgVGhlIHZpZXcncyBjdXJyZW50IFtwcm9wc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMpLlxuICAgICovXG4gICAgZ2V0IHByb3BzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvcHMuc3RhdGUgIT0gdGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLl9wcm9wcztcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcHNbbmFtZV0gPSBwcmV2W25hbWVdO1xuICAgICAgICAgICAgdGhpcy5fcHJvcHMuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wcztcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3J3MgcHJvcHMuIFdpbGwgaW1tZWRpYXRlbHkgY2F1c2UgYW4gdXBkYXRlIHRvXG4gICAgdGhlIERPTS5cbiAgICAqL1xuICAgIHVwZGF0ZShwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMuaGFuZGxlRE9NRXZlbnRzICE9IHRoaXMuX3Byb3BzLmhhbmRsZURPTUV2ZW50cylcbiAgICAgICAgICAgIGVuc3VyZUxpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgbGV0IHByZXZQcm9wcyA9IHRoaXMuX3Byb3BzO1xuICAgICAgICB0aGlzLl9wcm9wcyA9IHByb3BzO1xuICAgICAgICBpZiAocHJvcHMucGx1Z2lucykge1xuICAgICAgICAgICAgcHJvcHMucGx1Z2lucy5mb3JFYWNoKGNoZWNrU3RhdGVDb21wb25lbnQpO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlSW5uZXIocHJvcHMuc3RhdGUsIHByZXZQcm9wcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldyBieSB1cGRhdGluZyBleGlzdGluZyBwcm9wcyBvYmplY3Qgd2l0aCB0aGUgb2JqZWN0XG4gICAgZ2l2ZW4gYXMgYXJndW1lbnQuIEVxdWl2YWxlbnQgdG8gYHZpZXcudXBkYXRlKE9iamVjdC5hc3NpZ24oe30sXG4gICAgdmlldy5wcm9wcywgcHJvcHMpKWAuXG4gICAgKi9cbiAgICBzZXRQcm9wcyhwcm9wcykge1xuICAgICAgICBsZXQgdXBkYXRlZCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuX3Byb3BzKVxuICAgICAgICAgICAgdXBkYXRlZFtuYW1lXSA9IHRoaXMuX3Byb3BzW25hbWVdO1xuICAgICAgICB1cGRhdGVkLnN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcylcbiAgICAgICAgICAgIHVwZGF0ZWRbbmFtZV0gPSBwcm9wc1tuYW1lXTtcbiAgICAgICAgdGhpcy51cGRhdGUodXBkYXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgZWRpdG9yJ3MgYHN0YXRlYCBwcm9wLCB3aXRob3V0IHRvdWNoaW5nIGFueSBvZiB0aGVcbiAgICBvdGhlciBwcm9wcy5cbiAgICAqL1xuICAgIHVwZGF0ZVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihzdGF0ZSwgdGhpcy5fcHJvcHMpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZUlubmVyKHN0YXRlLCBwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcHJldiA9IHRoaXMuc3RhdGUsIHJlZHJhdyA9IGZhbHNlLCB1cGRhdGVTZWwgPSBmYWxzZTtcbiAgICAgICAgLy8gV2hlbiBzdG9yZWQgbWFya3MgYXJlIGFkZGVkLCBzdG9wIGNvbXBvc2l0aW9uLCBzbyB0aGF0IHRoZXkgY2FuXG4gICAgICAgIC8vIGJlIGRpc3BsYXllZC5cbiAgICAgICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzICYmIHRoaXMuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICBjbGVhckNvbXBvc2l0aW9uKHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIGxldCBwbHVnaW5zQ2hhbmdlZCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLnBsdWdpbnMgIT0gcHJldlByb3BzLnBsdWdpbnM7XG4gICAgICAgIGlmIChwbHVnaW5zQ2hhbmdlZCB8fCB0aGlzLl9wcm9wcy5wbHVnaW5zICE9IHByZXZQcm9wcy5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLm5vZGVWaWV3cyAhPSBwcmV2UHJvcHMubm9kZVZpZXdzKSB7XG4gICAgICAgICAgICBsZXQgbm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVWaWV3cyhub2RlVmlld3MsIHRoaXMubm9kZVZpZXdzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVZpZXdzID0gbm9kZVZpZXdzO1xuICAgICAgICAgICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsdWdpbnNDaGFuZ2VkIHx8IHByZXZQcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKSB7XG4gICAgICAgICAgICBlbnN1cmVMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsZXQgaW5uZXJEZWNvID0gdmlld0RlY29yYXRpb25zKHRoaXMpLCBvdXRlckRlY28gPSBjb21wdXRlRG9jRGVjbyh0aGlzKTtcbiAgICAgICAgbGV0IHNjcm9sbCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zICYmICFwcmV2LmRvYy5lcShzdGF0ZS5kb2MpID8gXCJyZXNldFwiXG4gICAgICAgICAgICA6IHN0YXRlLnNjcm9sbFRvU2VsZWN0aW9uID4gcHJldi5zY3JvbGxUb1NlbGVjdGlvbiA/IFwidG8gc2VsZWN0aW9uXCIgOiBcInByZXNlcnZlXCI7XG4gICAgICAgIGxldCB1cGRhdGVEb2MgPSByZWRyYXcgfHwgIXRoaXMuZG9jVmlldy5tYXRjaGVzTm9kZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgaWYgKHVwZGF0ZURvYyB8fCAhc3RhdGUuc2VsZWN0aW9uLmVxKHByZXYuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHVwZGF0ZVNlbCA9IHRydWU7XG4gICAgICAgIGxldCBvbGRTY3JvbGxQb3MgPSBzY3JvbGwgPT0gXCJwcmVzZXJ2ZVwiICYmIHVwZGF0ZVNlbCAmJiB0aGlzLmRvbS5zdHlsZS5vdmVyZmxvd0FuY2hvciA9PSBudWxsICYmIHN0b3JlU2Nyb2xsUG9zKHRoaXMpO1xuICAgICAgICBpZiAodXBkYXRlU2VsKSB7XG4gICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGFuIGlzc3VlIGluIENocm9tZSwgSUUsIGFuZCBFZGdlIHdoZXJlIGNoYW5naW5nXG4gICAgICAgICAgICAvLyB0aGUgRE9NIGFyb3VuZCBhbiBhY3RpdmUgc2VsZWN0aW9uIHB1dHMgaXQgaW50byBhIGJyb2tlblxuICAgICAgICAgICAgLy8gc3RhdGUgd2hlcmUgdGhlIHRoaW5nIHRoZSB1c2VyIHNlZXMgZGlmZmVycyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIHJlcG9ydGVkIGJ5IHRoZSBTZWxlY3Rpb24gb2JqZWN0ICgjNzEwLCAjOTczLFxuICAgICAgICAgICAgLy8gIzEwMTEsICMxMDEzLCAjMTAzNSkuXG4gICAgICAgICAgICBsZXQgZm9yY2VTZWxVcGRhdGUgPSB1cGRhdGVEb2MgJiYgKGllIHx8IGNocm9tZSkgJiYgIXRoaXMuY29tcG9zaW5nICYmXG4gICAgICAgICAgICAgICAgIXByZXYuc2VsZWN0aW9uLmVtcHR5ICYmICFzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgc2VsZWN0aW9uQ29udGV4dENoYW5nZWQocHJldi5zZWxlY3Rpb24sIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAodXBkYXRlRG9jKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgdGhhdCB0aGUgc2VsZWN0aW9uIHBvaW50cyBpbnRvIGlzIHdyaXR0ZW4gdG8sXG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHNvbWV0aW1lcyBzdGFydHMgbWlzcmVwb3J0aW5nIHRoZSBzZWxlY3Rpb24sIHNvIHRoaXNcbiAgICAgICAgICAgICAgICAvLyB0cmFja3MgdGhhdCBhbmQgZm9yY2VzIGEgc2VsZWN0aW9uIHJlc2V0IHdoZW4gb3VyIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIGRpZCB3cml0ZSB0byB0aGUgbm9kZS5cbiAgICAgICAgICAgICAgICBsZXQgY2hyb21lS2x1ZGdlID0gY2hyb21lID8gKHRoaXMudHJhY2tXcml0ZXMgPSB0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkuZm9jdXNOb2RlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmNvbXBvc2l0aW9uTm9kZSA9IGZpbmRDb21wb3NpdGlvbk5vZGUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhdyB8fCAhdGhpcy5kb2NWaWV3LnVwZGF0ZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHRoaXMuZG9tLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNocm9tZUtsdWRnZSAmJiAhdGhpcy50cmFja1dyaXRlcylcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VTZWxVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV29yayBhcm91bmQgZm9yIGFuIGlzc3VlIHdoZXJlIGFuIHVwZGF0ZSBhcnJpdmluZyByaWdodCBiZXR3ZWVuXG4gICAgICAgICAgICAvLyBhIERPTSBzZWxlY3Rpb24gY2hhbmdlIGFuZCB0aGUgXCJzZWxlY3Rpb25jaGFuZ2VcIiBldmVudCBmb3IgaXRcbiAgICAgICAgICAgIC8vIGNhbiBjYXVzZSBhIHNwdXJpb3VzIERPTSBzZWxlY3Rpb24gdXBkYXRlLCBkaXNydXB0aW5nIG1vdXNlXG4gICAgICAgICAgICAvLyBkcmFnIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIGlmIChmb3JjZVNlbFVwZGF0ZSB8fFxuICAgICAgICAgICAgICAgICEodGhpcy5pbnB1dC5tb3VzZURvd24gJiYgdGhpcy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmVxKHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9ySW5SaWdodFBsYWNlKHRoaXMpKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMsIGZvcmNlU2VsVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bmNOb2RlU2VsZWN0aW9uKHRoaXMsIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpblZpZXdzKHByZXYpO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuZHJhZ2dpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlKSAmJiAhcHJldi5kb2MuZXEoc3RhdGUuZG9jKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRHJhZ2dlZE5vZGUodGhpcy5kcmFnZ2luZywgcHJldik7XG4gICAgICAgIGlmIChzY3JvbGwgPT0gXCJyZXNldFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5zY3JvbGxUb3AgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjcm9sbCA9PSBcInRvIHNlbGVjdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkU2Nyb2xsUG9zKSB7XG4gICAgICAgICAgICByZXNldFNjcm9sbFBvcyhvbGRTY3JvbGxQb3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2Nyb2xsVG9TZWxlY3Rpb24oKSB7XG4gICAgICAgIGxldCBzdGFydERPTSA9IHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKS5mb2N1c05vZGU7XG4gICAgICAgIGlmICghc3RhcnRET00gfHwgIXRoaXMuZG9tLmNvbnRhaW5zKHN0YXJ0RE9NLm5vZGVUeXBlID09IDEgPyBzdGFydERPTSA6IHN0YXJ0RE9NLnBhcmVudE5vZGUpKSA7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc29tZVByb3AoXCJoYW5kbGVTY3JvbGxUb1NlbGVjdGlvblwiLCBmID0+IGYodGhpcykpKSA7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuZG9jVmlldy5kb21BZnRlclBvcyh0aGlzLnN0YXRlLnNlbGVjdGlvbi5mcm9tKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcywgdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzdGFydERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcywgdGhpcy5jb29yZHNBdFBvcyh0aGlzLnN0YXRlLnNlbGVjdGlvbi5oZWFkLCAxKSwgc3RhcnRET00pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3lQbHVnaW5WaWV3cygpIHtcbiAgICAgICAgbGV0IHZpZXc7XG4gICAgICAgIHdoaWxlICh2aWV3ID0gdGhpcy5wbHVnaW5WaWV3cy5wb3AoKSlcbiAgICAgICAgICAgIGlmICh2aWV3LmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgfVxuICAgIHVwZGF0ZVBsdWdpblZpZXdzKHByZXZTdGF0ZSkge1xuICAgICAgICBpZiAoIXByZXZTdGF0ZSB8fCBwcmV2U3RhdGUucGx1Z2lucyAhPSB0aGlzLnN0YXRlLnBsdWdpbnMgfHwgdGhpcy5kaXJlY3RQbHVnaW5zICE9IHRoaXMucHJldkRpcmVjdFBsdWdpbnMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkRpcmVjdFBsdWdpbnMgPSB0aGlzLmRpcmVjdFBsdWdpbnM7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lQbHVnaW5WaWV3cygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRpcmVjdFBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5kaXJlY3RQbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy52aWV3KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpblZpZXdzLnB1c2gocGx1Z2luLnNwZWMudmlldyh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGUucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLnN0YXRlLnBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4uc3BlYy52aWV3KHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5WaWV3cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW5WaWV3ID0gdGhpcy5wbHVnaW5WaWV3c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luVmlldy51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpblZpZXcudXBkYXRlKHRoaXMsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlRHJhZ2dlZE5vZGUoZHJhZ2dpbmcsIHByZXYpIHtcbiAgICAgICAgbGV0IHNlbCA9IGRyYWdnaW5nLm5vZGUsIGZvdW5kID0gLTE7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRvYy5ub2RlQXQoc2VsLmZyb20pID09IHNlbC5ub2RlKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHNlbC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1vdmVkUG9zID0gc2VsLmZyb20gKyAodGhpcy5zdGF0ZS5kb2MuY29udGVudC5zaXplIC0gcHJldi5kb2MuY29udGVudC5zaXplKTtcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IG1vdmVkUG9zID4gMCAmJiB0aGlzLnN0YXRlLmRvYy5ub2RlQXQobW92ZWRQb3MpO1xuICAgICAgICAgICAgaWYgKG1vdmVkID09IHNlbC5ub2RlKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gbW92ZWRQb3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG5ldyBEcmFnZ2luZyhkcmFnZ2luZy5zbGljZSwgZHJhZ2dpbmcubW92ZSwgZm91bmQgPCAwID8gdW5kZWZpbmVkIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodGhpcy5zdGF0ZS5kb2MsIGZvdW5kKSk7XG4gICAgfVxuICAgIHNvbWVQcm9wKHByb3BOYW1lLCBmKSB7XG4gICAgICAgIGxldCBwcm9wID0gdGhpcy5fcHJvcHMgJiYgdGhpcy5fcHJvcHNbcHJvcE5hbWVdLCB2YWx1ZTtcbiAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHByb3AgPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGx1Z2lucyA9IHRoaXMuc3RhdGUucGx1Z2lucztcbiAgICAgICAgaWYgKHBsdWdpbnMpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHBsdWdpbnNbaV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoZSB2aWV3IGhhcyBmb2N1cy5cbiAgICAqL1xuICAgIGhhc0ZvY3VzKCkge1xuICAgICAgICAvLyBXb3JrIGFyb3VuZCBJRSBub3QgaGFuZGxpbmcgZm9jdXMgY29ycmVjdGx5IGlmIHJlc2l6ZSBoYW5kbGVzIGFyZSBzaG93bi5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnNvciBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHJlc2l6ZSBoYW5kbGVzLCBhY3RpdmVFbGVtZW50XG4gICAgICAgIC8vIHdpbGwgYmUgdGhhdCBlbGVtZW50IGluc3RlYWQgb2YgdGhpcy5kb20uXG4gICAgICAgIGlmIChpZSkge1xuICAgICAgICAgICAgLy8gSWYgYWN0aXZlRWxlbWVudCBpcyB3aXRoaW4gdGhpcy5kb20sIGFuZCB0aGVyZSBhcmUgbm8gb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIHNldHRpbmcgYGNvbnRlbnRlZGl0YWJsZWAgdG8gZmFsc2UgaW4gYmV0d2VlbiwgdHJlYXQgaXQgYXMgZm9jdXNlZC5cbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCAhdGhpcy5kb20uY29udGFpbnMobm9kZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgJiYgdGhpcy5kb20gIT0gbm9kZSAmJiB0aGlzLmRvbS5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSAnZmFsc2UnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgRm9jdXMgdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdGFibGUpXG4gICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5kb20pO1xuICAgICAgICBzZWxlY3Rpb25Ub0RPTSh0aGlzKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGRvY3VtZW50IHJvb3QgaW4gd2hpY2ggdGhlIGVkaXRvciBleGlzdHMuIFRoaXMgd2lsbFxuICAgIHVzdWFsbHkgYmUgdGhlIHRvcC1sZXZlbCBgZG9jdW1lbnRgLCBidXQgbWlnaHQgYmUgYSBbc2hhZG93XG4gICAgRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9XZWJfQ29tcG9uZW50cy9TaGFkb3dfRE9NKVxuICAgIHJvb3QgaWYgdGhlIGVkaXRvciBpcyBpbnNpZGUgb25lLlxuICAgICovXG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9yb290O1xuICAgICAgICBpZiAoY2FjaGVkID09IG51bGwpXG4gICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSB0aGlzLmRvbS5wYXJlbnROb2RlOyBzZWFyY2g7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5ub2RlVHlwZSA9PSA5IHx8IChzZWFyY2gubm9kZVR5cGUgPT0gMTEgJiYgc2VhcmNoLmhvc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VhcmNoLmdldFNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihzZWFyY2gpLmdldFNlbGVjdGlvbiA9ICgpID0+IHNlYXJjaC5vd25lckRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdCA9IHNlYXJjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWQgfHwgZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gYW4gZXhpc3RpbmcgZWRpdG9yIHZpZXcgaXMgbW92ZWQgdG8gYSBuZXcgZG9jdW1lbnQgb3JcbiAgICBzaGFkb3cgdHJlZSwgY2FsbCB0aGlzIHRvIG1ha2UgaXQgcmVjb21wdXRlIGl0cyByb290LlxuICAgICovXG4gICAgdXBkYXRlUm9vdCgpIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEdpdmVuIGEgcGFpciBvZiB2aWV3cG9ydCBjb29yZGluYXRlcywgcmV0dXJuIHRoZSBkb2N1bWVudFxuICAgIHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlbS4gTWF5IHJldHVybiBudWxsIGlmIHRoZSBnaXZlblxuICAgIGNvb3JkaW5hdGVzIGFyZW4ndCBpbnNpZGUgb2YgdGhlIGVkaXRvci4gV2hlbiBhbiBvYmplY3QgaXNcbiAgICByZXR1cm5lZCwgaXRzIGBwb3NgIHByb3BlcnR5IGlzIHRoZSBwb3NpdGlvbiBuZWFyZXN0IHRvIHRoZVxuICAgIGNvb3JkaW5hdGVzLCBhbmQgaXRzIGBpbnNpZGVgIHByb3BlcnR5IGhvbGRzIHRoZSBwb3NpdGlvbiBvZiB0aGVcbiAgICBpbm5lciBub2RlIHRoYXQgdGhlIHBvc2l0aW9uIGZhbGxzIGluc2lkZSBvZiwgb3IgLTEgaWYgaXQgaXMgYXRcbiAgICB0aGUgdG9wIGxldmVsLCBub3QgaW4gYW55IG5vZGUuXG4gICAgKi9cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHBvc0F0Q29vcmRzKHRoaXMsIGNvb3Jkcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIHZpZXdwb3J0IHJlY3RhbmdsZSBhdCBhIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIGBsZWZ0YCBhbmQgYHJpZ2h0YCB3aWxsIGJlIHRoZSBzYW1lIG51bWJlciwgYXMgdGhpcyByZXR1cm5zIGFcbiAgICBmbGF0IGN1cnNvci1pc2ggcmVjdGFuZ2xlLiBJZiB0aGUgcG9zaXRpb24gaXMgYmV0d2VlbiB0d28gdGhpbmdzXG4gICAgdGhhdCBhcmVuJ3QgZGlyZWN0bHkgYWRqYWNlbnQsIGBzaWRlYCBkZXRlcm1pbmVzIHdoaWNoIGVsZW1lbnRcbiAgICBpcyB1c2VkLiBXaGVuIDwgMCwgdGhlIGVsZW1lbnQgYmVmb3JlIHRoZSBwb3NpdGlvbiBpcyB1c2VkLFxuICAgIG90aGVyd2lzZSB0aGUgZWxlbWVudCBhZnRlci5cbiAgICAqL1xuICAgIGNvb3Jkc0F0UG9zKHBvcywgc2lkZSA9IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0F0UG9zKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBkb2N1bWVudFxuICAgIHBvc2l0aW9uLiBXaGVuIGBzaWRlYCBpcyBuZWdhdGl2ZSwgZmluZCB0aGUgcG9zaXRpb24gYXMgY2xvc2UgYXNcbiAgICBwb3NzaWJsZSB0byB0aGUgY29udGVudCBiZWZvcmUgdGhlIHBvc2l0aW9uLiBXaGVuIHBvc2l0aXZlLFxuICAgIHByZWZlciBwb3NpdGlvbnMgY2xvc2UgdG8gdGhlIGNvbnRlbnQgYWZ0ZXIgdGhlIHBvc2l0aW9uLiBXaGVuXG4gICAgemVybywgcHJlZmVyIGFzIHNoYWxsb3cgYSBwb3NpdGlvbiBhcyBwb3NzaWJsZS5cbiAgICBcbiAgICBOb3RlIHRoYXQgeW91IHNob3VsZCAqKm5vdCoqIG11dGF0ZSB0aGUgZWRpdG9yJ3MgaW50ZXJuYWwgRE9NLFxuICAgIG9ubHkgaW5zcGVjdCBpdCAoYW5kIGV2ZW4gdGhhdCBpcyB1c3VhbGx5IG5vdCBuZWNlc3NhcnkpLlxuICAgICovXG4gICAgZG9tQXRQb3MocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgRE9NIG5vZGUgdGhhdCByZXByZXNlbnRzIHRoZSBkb2N1bWVudCBub2RlIGFmdGVyIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uLiBNYXkgcmV0dXJuIGBudWxsYCB3aGVuIHRoZSBwb3NpdGlvbiBkb2Vzbid0IHBvaW50XG4gICAgaW4gZnJvbnQgb2YgYSBub2RlIG9yIGlmIHRoZSBub2RlIGlzIGluc2lkZSBhbiBvcGFxdWUgbm9kZSB2aWV3LlxuICAgIFxuICAgIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYWJsZSB0byBjYWxsIHRoaW5ncyBsaWtlXG4gICAgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgb24gdGhhdCBET00gbm9kZS4gRG8gKipub3QqKiBtdXRhdGUgdGhlXG4gICAgZWRpdG9yIERPTSBkaXJlY3RseSwgb3IgYWRkIHN0eWxpbmcgdGhpcyB3YXksIHNpbmNlIHRoYXQgd2lsbCBiZVxuICAgIGltbWVkaWF0ZWx5IG92ZXJyaWRlbiBieSB0aGUgZWRpdG9yIGFzIGl0IHJlZHJhd3MgdGhlIG5vZGUuXG4gICAgKi9cbiAgICBub2RlRE9NKHBvcykge1xuICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZG9jVmlldy5kZXNjQXQocG9zKTtcbiAgICAgICAgcmV0dXJuIGRlc2MgPyBkZXNjLm5vZGVET00gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgZ2l2ZW4gRE9NXG4gICAgcG9zaXRpb24uIChXaGVuZXZlciBwb3NzaWJsZSwgaXQgaXMgcHJlZmVyYWJsZSB0byBpbnNwZWN0IHRoZVxuICAgIGRvY3VtZW50IHN0cnVjdHVyZSBkaXJlY3RseSwgcmF0aGVyIHRoYW4gcG9raW5nIGFyb3VuZCBpbiB0aGVcbiAgICBET00sIGJ1dCBzb21ldGltZXPigJRmb3IgZXhhbXBsZSB3aGVuIGludGVycHJldGluZyBhbiBldmVudFxuICAgIHRhcmdldOKAlHlvdSBkb24ndCBoYXZlIGEgY2hvaWNlLilcbiAgICBcbiAgICBUaGUgYGJpYXNgIHBhcmFtZXRlciBjYW4gYmUgdXNlZCB0byBpbmZsdWVuY2Ugd2hpY2ggc2lkZSBvZiBhIERPTVxuICAgIG5vZGUgdG8gdXNlIHdoZW4gdGhlIHBvc2l0aW9uIGlzIGluc2lkZSBhIGxlYWYgbm9kZS5cbiAgICAqL1xuICAgIHBvc0F0RE9NKG5vZGUsIG9mZnNldCwgYmlhcyA9IC0xKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIGJpYXMpO1xuICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRPTSBwb3NpdGlvbiBub3QgaW5zaWRlIHRoZSBlZGl0b3JcIik7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgb3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrIHdoZW5cbiAgICBtb3ZpbmcgaW4gYSBnaXZlbiBkaXJlY3Rpb24uIFdoZW4sIGZvciBleGFtcGxlLCBnaXZlbiBgXCJsZWZ0XCJgLFxuICAgIGl0IHdpbGwgcmV0dXJuIHRydWUgaWYgbW92aW5nIGxlZnQgZnJvbSB0aGUgY3VycmVudCBjdXJzb3JcbiAgICBwb3NpdGlvbiB3b3VsZCBsZWF2ZSB0aGF0IHBvc2l0aW9uJ3MgcGFyZW50IHRleHRibG9jay4gV2lsbCBhcHBseVxuICAgIHRvIHRoZSB2aWV3J3MgY3VycmVudCBzdGF0ZSBieSBkZWZhdWx0LCBidXQgaXQgaXMgcG9zc2libGUgdG9cbiAgICBwYXNzIGEgZGlmZmVyZW50IHN0YXRlLlxuICAgICovXG4gICAgZW5kT2ZUZXh0YmxvY2soZGlyLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gZW5kT2ZUZXh0YmxvY2sodGhpcywgc3RhdGUgfHwgdGhpcy5zdGF0ZSwgZGlyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUnVuIHRoZSBlZGl0b3IncyBwYXN0ZSBsb2dpYyB3aXRoIHRoZSBnaXZlbiBIVE1MIHN0cmluZy4gVGhlXG4gICAgYGV2ZW50YCwgaWYgZ2l2ZW4sIHdpbGwgYmUgcGFzc2VkIHRvIHRoZVxuICAgIFtgaGFuZGxlUGFzdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5oYW5kbGVQYXN0ZSkgaG9vay5cbiAgICAqL1xuICAgIHBhc3RlSFRNTChodG1sLCBldmVudCkge1xuICAgICAgICByZXR1cm4gZG9QYXN0ZSh0aGlzLCBcIlwiLCBodG1sLCBmYWxzZSwgZXZlbnQgfHwgbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gdGhlIGVkaXRvcidzIHBhc3RlIGxvZ2ljIHdpdGggdGhlIGdpdmVuIHBsYWluLXRleHQgaW5wdXQuXG4gICAgKi9cbiAgICBwYXN0ZVRleHQodGV4dCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFzdGUodGhpcywgdGV4dCwgbnVsbCwgdHJ1ZSwgZXZlbnQgfHwgbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhlIGdpdmVuIHNsaWNlIGFzIGl0IHdvdWxkIGJlIGlmIGl0IHdhcyBjb3BpZWQgZnJvbVxuICAgIHRoaXMgZWRpdG9yLiBSZXR1cm5zIGEgRE9NIGVsZW1lbnQgdGhhdCBjb250YWlucyBhXG4gICAgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNsaWNlIGFzIGl0cyBjaGlsZHJlbiwgYSB0ZXh0dWFsXG4gICAgcmVwcmVzZW50YXRpb24sIGFuZCB0aGUgdHJhbnNmb3JtZWQgc2xpY2UgKHdoaWNoIGNhbiBiZVxuICAgIGRpZmZlcmVudCBmcm9tIHRoZSBnaXZlbiBpbnB1dCBkdWUgdG8gaG9va3MgbGlrZVxuICAgIFtgdHJhbnNmb3JtQ29waWVkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMudHJhbnNmb3JtQ29waWVkKSkuXG4gICAgKi9cbiAgICBzZXJpYWxpemVGb3JDbGlwYm9hcmQoc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUZvckNsaXBib2FyZCh0aGlzLCBzbGljZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgdGhlIGVkaXRvciBmcm9tIHRoZSBET00gYW5kIGRlc3Ryb3lzIGFsbCBbbm9kZVxuICAgIHZpZXdzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5Ob2RlVmlldykuXG4gICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9jVmlldylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGVzdHJveUlucHV0KHRoaXMpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lQbHVnaW5WaWV3cygpO1xuICAgICAgICBpZiAodGhpcy5tb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlKHRoaXMuc3RhdGUuZG9jLCBbXSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBudWxsO1xuICAgICAgICBjbGVhclJldXNlZFJhbmdlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgdHJ1ZSB3aGVuIHRoZSB2aWV3IGhhcyBiZWVuXG4gICAgW2Rlc3Ryb3llZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kZXN0cm95KSAoYW5kIHRodXMgc2hvdWxkIG5vdCBiZVxuICAgIHVzZWQgYW55bW9yZSkuXG4gICAgKi9cbiAgICBnZXQgaXNEZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcgPT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNlZCBmb3IgdGVzdGluZy5cbiAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBEaXNwYXRjaCBhIHRyYW5zYWN0aW9uLiBXaWxsIGNhbGxcbiAgICBbYGRpc3BhdGNoVHJhbnNhY3Rpb25gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EaXJlY3RFZGl0b3JQcm9wcy5kaXNwYXRjaFRyYW5zYWN0aW9uKVxuICAgIHdoZW4gZ2l2ZW4sIGFuZCBvdGhlcndpc2UgZGVmYXVsdHMgdG8gYXBwbHlpbmcgdGhlIHRyYW5zYWN0aW9uIHRvXG4gICAgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGNhbGxpbmdcbiAgICBbYHVwZGF0ZVN0YXRlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy51cGRhdGVTdGF0ZSkgd2l0aCB0aGUgcmVzdWx0LlxuICAgIFRoaXMgbWV0aG9kIGlzIGJvdW5kIHRvIHRoZSB2aWV3IGluc3RhbmNlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgIGVhc2lseSBwYXNzZWQgYXJvdW5kLlxuICAgICovXG4gICAgZGlzcGF0Y2godHIpIHtcbiAgICAgICAgbGV0IGRpc3BhdGNoVHJhbnNhY3Rpb24gPSB0aGlzLl9wcm9wcy5kaXNwYXRjaFRyYW5zYWN0aW9uO1xuICAgICAgICBpZiAoZGlzcGF0Y2hUcmFuc2FjdGlvbilcbiAgICAgICAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb24uY2FsbCh0aGlzLCB0cik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5zdGF0ZS5hcHBseSh0cikpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbVNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5kb21TZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCFzZWwpXG4gICAgICAgICAgICByZXR1cm4geyBmb2N1c05vZGU6IG51bGwsIGZvY3VzT2Zmc2V0OiAwLCBhbmNob3JOb2RlOiBudWxsLCBhbmNob3JPZmZzZXQ6IDAgfTtcbiAgICAgICAgcmV0dXJuIHNhZmFyaSAmJiB0aGlzLnJvb3Qubm9kZVR5cGUgPT09IDExICYmXG4gICAgICAgICAgICBkZWVwQWN0aXZlRWxlbWVudCh0aGlzLmRvbS5vd25lckRvY3VtZW50KSA9PSB0aGlzLmRvbSAmJiBzYWZhcmlTaGFkb3dTZWxlY3Rpb25SYW5nZSh0aGlzLCBzZWwpIHx8IHNlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21TZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZURvY0RlY28odmlldykge1xuICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgYXR0cnMuY2xhc3MgPSBcIlByb3NlTWlycm9yXCI7XG4gICAgYXR0cnMuY29udGVudGVkaXRhYmxlID0gU3RyaW5nKHZpZXcuZWRpdGFibGUpO1xuICAgIHZpZXcuc29tZVByb3AoXCJhdHRyaWJ1dGVzXCIsIHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKHZpZXcuc3RhdGUpO1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICBmb3IgKGxldCBhdHRyIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIgPT0gXCJjbGFzc1wiKVxuICAgICAgICAgICAgICAgICAgICBhdHRycy5jbGFzcyArPSBcIiBcIiArIHZhbHVlW2F0dHJdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0dHIgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgICAgICBhdHRycy5zdHlsZSA9IChhdHRycy5zdHlsZSA/IGF0dHJzLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbHVlW2F0dHJdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdHRyc1thdHRyXSAmJiBhdHRyICE9IFwiY29udGVudGVkaXRhYmxlXCIgJiYgYXR0ciAhPSBcIm5vZGVOYW1lXCIpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzW2F0dHJdID0gU3RyaW5nKHZhbHVlW2F0dHJdKTtcbiAgICAgICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWF0dHJzLnRyYW5zbGF0ZSlcbiAgICAgICAgYXR0cnMudHJhbnNsYXRlID0gXCJub1wiO1xuICAgIHJldHVybiBbRGVjb3JhdGlvbi5ub2RlKDAsIHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSwgYXR0cnMpXTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUN1cnNvcldyYXBwZXIodmlldykge1xuICAgIGlmICh2aWV3Lm1hcmtDdXJzb3IpIHtcbiAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXNlcGFyYXRvclwiO1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwibWFyay1wbGFjZWhvbGRlclwiLCBcInRydWVcIik7XG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJhbHRcIiwgXCJcIik7XG4gICAgICAgIHZpZXcuY3Vyc29yV3JhcHBlciA9IHsgZG9tLCBkZWNvOiBEZWNvcmF0aW9uLndpZGdldCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tLCBkb20sIHsgcmF3OiB0cnVlLCBtYXJrczogdmlldy5tYXJrQ3Vyc29yIH0pIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVkaXRhYmxlKHZpZXcpIHtcbiAgICByZXR1cm4gIXZpZXcuc29tZVByb3AoXCJlZGl0YWJsZVwiLCB2YWx1ZSA9PiB2YWx1ZSh2aWV3LnN0YXRlKSA9PT0gZmFsc2UpO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uQ29udGV4dENoYW5nZWQoc2VsMSwgc2VsMikge1xuICAgIGxldCBkZXB0aCA9IE1hdGgubWluKHNlbDEuJGFuY2hvci5zaGFyZWREZXB0aChzZWwxLmhlYWQpLCBzZWwyLiRhbmNob3Iuc2hhcmVkRGVwdGgoc2VsMi5oZWFkKSk7XG4gICAgcmV0dXJuIHNlbDEuJGFuY2hvci5zdGFydChkZXB0aCkgIT0gc2VsMi4kYW5jaG9yLnN0YXJ0KGRlcHRoKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTm9kZVZpZXdzKHZpZXcpIHtcbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmdW5jdGlvbiBhZGQob2JqKSB7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBwcm9wKSlcbiAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgfVxuICAgIHZpZXcuc29tZVByb3AoXCJub2RlVmlld3NcIiwgYWRkKTtcbiAgICB2aWV3LnNvbWVQcm9wKFwibWFya1ZpZXdzXCIsIGFkZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNoYW5nZWROb2RlVmlld3MoYSwgYikge1xuICAgIGxldCBuQSA9IDAsIG5CID0gMDtcbiAgICBmb3IgKGxldCBwcm9wIGluIGEpIHtcbiAgICAgICAgaWYgKGFbcHJvcF0gIT0gYltwcm9wXSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBuQSsrO1xuICAgIH1cbiAgICBmb3IgKGxldCBfIGluIGIpXG4gICAgICAgIG5CKys7XG4gICAgcmV0dXJuIG5BICE9IG5CO1xufVxuZnVuY3Rpb24gY2hlY2tTdGF0ZUNvbXBvbmVudChwbHVnaW4pIHtcbiAgICBpZiAocGx1Z2luLnNwZWMuc3RhdGUgfHwgcGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24gfHwgcGx1Z2luLnNwZWMuYXBwZW5kVHJhbnNhY3Rpb24pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUGx1Z2lucyBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIHZpZXcgbXVzdCBub3QgaGF2ZSBhIHN0YXRlIGNvbXBvbmVudFwiKTtcbn1cblxuZXhwb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCwgRWRpdG9yVmlldywgX19lbmRDb21wb3NpdGlvbiwgX19wYXJzZUZyb21DbGlwYm9hcmQgfTtcbiJdLCJuYW1lcyI6WyJUZXh0U2VsZWN0aW9uIiwiTm9kZVNlbGVjdGlvbiIsIkFsbFNlbGVjdGlvbiIsIlNlbGVjdGlvbiIsIkRPTVNlcmlhbGl6ZXIiLCJGcmFnbWVudCIsIk1hcmsiLCJTbGljZSIsIkRPTVBhcnNlciIsImRyb3BQb2ludCIsImRvbUluZGV4Iiwibm9kZSIsImluZGV4IiwicHJldmlvdXNTaWJsaW5nIiwicGFyZW50Tm9kZSIsInBhcmVudCIsImFzc2lnbmVkU2xvdCIsIm5vZGVUeXBlIiwiaG9zdCIsInJldXNlZFJhbmdlIiwidGV4dFJhbmdlIiwiZnJvbSIsInRvIiwicmFuZ2UiLCJkb2N1bWVudCIsImNyZWF0ZVJhbmdlIiwic2V0RW5kIiwibm9kZVZhbHVlIiwibGVuZ3RoIiwic2V0U3RhcnQiLCJjbGVhclJldXNlZFJhbmdlIiwiaXNFcXVpdmFsZW50UG9zaXRpb24iLCJvZmYiLCJ0YXJnZXROb2RlIiwidGFyZ2V0T2ZmIiwic2NhbkZvciIsImF0b21FbGVtZW50cyIsImRpciIsIm5vZGVTaXplIiwiaGFzQmxvY2tEZXNjIiwidGVzdCIsIm5vZGVOYW1lIiwiY29udGVudEVkaXRhYmxlIiwiY2hpbGROb2RlcyIsInRleHROb2RlQmVmb3JlJDEiLCJvZmZzZXQiLCJ0ZXh0Tm9kZUFmdGVyJDEiLCJpc09uRWRnZSIsImF0U3RhcnQiLCJhdEVuZCIsImRvbSIsImRlc2MiLCJjdXIiLCJwbVZpZXdEZXNjIiwiaXNCbG9jayIsImNvbnRlbnRET00iLCJzZWxlY3Rpb25Db2xsYXBzZWQiLCJkb21TZWwiLCJmb2N1c05vZGUiLCJmb2N1c09mZnNldCIsImFuY2hvck5vZGUiLCJhbmNob3JPZmZzZXQiLCJrZXlFdmVudCIsImtleUNvZGUiLCJrZXkiLCJldmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiY29kZSIsImRlZXBBY3RpdmVFbGVtZW50IiwiZG9jIiwiZWx0IiwiYWN0aXZlRWxlbWVudCIsInNoYWRvd1Jvb3QiLCJjYXJldEZyb21Qb2ludCIsIngiLCJ5IiwiY2FyZXRQb3NpdGlvbkZyb21Qb2ludCIsInBvcyIsIm9mZnNldE5vZGUiLCJNYXRoIiwibWluIiwiXyIsImNhcmV0UmFuZ2VGcm9tUG9pbnQiLCJzdGFydENvbnRhaW5lciIsInN0YXJ0T2Zmc2V0IiwibmF2IiwibmF2aWdhdG9yIiwiYWdlbnQiLCJ1c2VyQWdlbnQiLCJpZV9lZGdlIiwiZXhlYyIsImllX3VwdG8xMCIsImllXzExdXAiLCJpZSIsImllX3ZlcnNpb24iLCJkb2N1bWVudE1vZGUiLCJnZWNrbyIsIl9jaHJvbWUiLCJjaHJvbWUiLCJjaHJvbWVfdmVyc2lvbiIsInNhZmFyaSIsInZlbmRvciIsImlvcyIsIm1heFRvdWNoUG9pbnRzIiwibWFjIiwicGxhdGZvcm0iLCJ3aW5kb3dzIiwiYW5kcm9pZCIsIndlYmtpdCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwid2Via2l0X3ZlcnNpb24iLCJ3aW5kb3dSZWN0IiwidnAiLCJkZWZhdWx0VmlldyIsInZpc3VhbFZpZXdwb3J0IiwibGVmdCIsInJpZ2h0Iiwid2lkdGgiLCJ0b3AiLCJib3R0b20iLCJoZWlnaHQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImdldFNpZGUiLCJ2YWx1ZSIsInNpZGUiLCJjbGllbnRSZWN0IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjYWxlWCIsIm9mZnNldFdpZHRoIiwic2NhbGVZIiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsUmVjdEludG9WaWV3IiwidmlldyIsInN0YXJ0RE9NIiwic2Nyb2xsVGhyZXNob2xkIiwic29tZVByb3AiLCJzY3JvbGxNYXJnaW4iLCJvd25lckRvY3VtZW50IiwiYXRUb3AiLCJib2R5IiwiYm91bmRpbmciLCJtb3ZlWCIsIm1vdmVZIiwic2Nyb2xsQnkiLCJzdGFydFgiLCJzY3JvbGxMZWZ0Iiwic3RhcnRZIiwic2Nyb2xsVG9wIiwiZFgiLCJkWSIsImdldENvbXB1dGVkU3R5bGUiLCJwb3NpdGlvbiIsIm9mZnNldFBhcmVudCIsInN0b3JlU2Nyb2xsUG9zIiwibWF4IiwicmVmRE9NIiwicmVmVG9wIiwiaW5uZXJIZWlnaHQiLCJyb290IiwiZWxlbWVudEZyb21Qb2ludCIsImNvbnRhaW5zIiwibG9jYWxSZWN0Iiwic3RhY2siLCJzY3JvbGxTdGFjayIsInB1c2giLCJyZXNldFNjcm9sbFBvcyIsIm5ld1JlZlRvcCIsInJlc3RvcmVTY3JvbGxTdGFjayIsImRUb3AiLCJpIiwicHJldmVudFNjcm9sbFN1cHBvcnRlZCIsImZvY3VzUHJldmVudFNjcm9sbCIsInNldEFjdGl2ZSIsImZvY3VzIiwic3RvcmVkIiwicHJldmVudFNjcm9sbCIsInVuZGVmaW5lZCIsImZpbmRPZmZzZXRJbk5vZGUiLCJjb29yZHMiLCJjbG9zZXN0IiwiZHhDbG9zZXN0IiwiY29vcmRzQ2xvc2VzdCIsInJvd0JvdCIsInJvd1RvcCIsImZpcnN0QmVsb3ciLCJjb29yZHNCZWxvdyIsImNoaWxkIiwiZmlyc3RDaGlsZCIsImNoaWxkSW5kZXgiLCJuZXh0U2libGluZyIsInJlY3RzIiwiZ2V0Q2xpZW50UmVjdHMiLCJkeCIsImZpbmRPZmZzZXRJblRleHQiLCJsZW4iLCJzaW5nbGVSZWN0IiwiaW5SZWN0IiwidGFyZ2V0S2x1ZGdlIiwicG9zRnJvbUVsZW1lbnQiLCJiaWFzIiwiZG9jVmlldyIsInBvc0Zyb21ET00iLCJwb3NGcm9tQ2FyZXQiLCJvdXRzaWRlQmxvY2siLCJzYXdCbG9jayIsIm5lYXJlc3REZXNjIiwicG9zQmVmb3JlIiwicG9zQWZ0ZXIiLCJpc1RleHQiLCJiZWZvcmUiLCJlbGVtZW50IiwiYm94Iiwic3RhcnRJIiwiZmxvb3IiLCJqIiwicG9zQXRDb29yZHMiLCJjYXJldCIsInAiLCJkcmFnZ2FibGUiLCJuZXh0IiwicHJldiIsImxhc3RDaGlsZCIsInN0YXRlIiwiY29udGVudCIsInNpemUiLCJpbnNpZGUiLCJwb3NBdFN0YXJ0IiwiYm9yZGVyIiwibm9uWmVybyIsInRhcmdldCIsImZpcnN0IiwiQXJyYXkiLCJwcm90b3R5cGUiLCJmaW5kIiwiY2FsbCIsIkJJREkiLCJjb29yZHNBdFBvcyIsImF0b20iLCJkb21Gcm9tUG9zIiwic3VwcG9ydEVtcHR5UmFuZ2UiLCJyZWN0QmVmb3JlIiwicmVjdEFmdGVyIiwiZmxhdHRlblYiLCJ0YWtlU2lkZSIsIiRkb20iLCJyZXNvbHZlIiwiaW5saW5lQ29udGVudCIsImZsYXR0ZW5IIiwiYWZ0ZXIiLCJpZ25vcmVGb3JDb29yZHMiLCJ3aXRoRmx1c2hlZFN0YXRlIiwiZiIsInZpZXdTdGF0ZSIsImFjdGl2ZSIsInVwZGF0ZVN0YXRlIiwiZW5kT2ZUZXh0YmxvY2tWZXJ0aWNhbCIsInNlbCIsInNlbGVjdGlvbiIsIiRwb3MiLCIkZnJvbSIsIiR0byIsIm5lYXJlc3QiLCJib3hlcyIsIm1heWJlUlRMIiwiZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsIiwiJGhlYWQiLCJpc1RleHRibG9jayIsInBhcmVudE9mZnNldCIsImRvbVNlbGVjdGlvbiIsInN0YXJ0IiwiZW5kIiwidGV4dENvbnRlbnQiLCJtb2RpZnkiLCJvbGROb2RlIiwib2xkT2ZmIiwiZG9tU2VsZWN0aW9uUmFuZ2UiLCJvbGRCaWRpTGV2ZWwiLCJjYXJldEJpZGlMZXZlbCIsInBhcmVudERPTSIsImRlcHRoIiwiZG9tQWZ0ZXJQb3MiLCJuZXdOb2RlIiwibmV3T2ZmIiwicmVzdWx0IiwiY29sbGFwc2UiLCJleHRlbmQiLCJjYWNoZWRTdGF0ZSIsImNhY2hlZERpciIsImNhY2hlZFJlc3VsdCIsImVuZE9mVGV4dGJsb2NrIiwiTk9UX0RJUlRZIiwiQ0hJTERfRElSVFkiLCJDT05URU5UX0RJUlRZIiwiTk9ERV9ESVJUWSIsIlZpZXdEZXNjIiwiY29uc3RydWN0b3IiLCJjaGlsZHJlbiIsImRpcnR5IiwibWF0Y2hlc1dpZGdldCIsIndpZGdldCIsIm1hdGNoZXNNYXJrIiwibWFyayIsIm1hdGNoZXNOb2RlIiwib3V0ZXJEZWNvIiwiaW5uZXJEZWNvIiwibWF0Y2hlc0hhY2siLCJwYXJzZVJ1bGUiLCJzdG9wRXZlbnQiLCJkZXN0cm95IiwicG9zQmVmb3JlQ2hpbGQiLCJwb3NBdEVuZCIsImxvY2FsUG9zRnJvbURPTSIsImRvbUJlZm9yZSIsImRvbUFmdGVyIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJzZWFyY2giLCJvbmx5Tm9kZXMiLCJnZXREZXNjIiwibm9kZURPTSIsInNjYW4iLCJkZXNjQXQiLCJpbm5lciIsImN1clBvcyIsIlRyYWlsaW5nSGFja1ZpZXdEZXNjIiwiV2lkZ2V0Vmlld0Rlc2MiLCJlbnRlciIsImRvbUF0b20iLCJwYXJzZVJhbmdlIiwiYmFzZSIsImZyb21PZmZzZXQiLCJ0b09mZnNldCIsImNoaWxkQmFzZSIsImVtcHR5Q2hpbGRBdCIsIlJhbmdlRXJyb3IiLCJzZXRTZWxlY3Rpb24iLCJhbmNob3IiLCJoZWFkIiwiZm9yY2UiLCJhbmNob3JET00iLCJoZWFkRE9NIiwiZ2V0U2VsZWN0aW9uIiwic2VsUmFuZ2UiLCJicktsdWRnZSIsImRvbVNlbEV4dGVuZGVkIiwidG1wIiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJpZ25vcmVNdXRhdGlvbiIsIm11dGF0aW9uIiwidHlwZSIsImNvbnRlbnRMb3N0IiwibWFya0RpcnR5Iiwic3RhcnRJbnNpZGUiLCJlbmRJbnNpZGUiLCJtYXJrUGFyZW50c0RpcnR5IiwibGV2ZWwiLCJ0ZXh0Iiwic2VsZiIsInRvRE9NIiwic3BlYyIsInJhdyIsIndyYXAiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJjbGFzc0xpc3QiLCJhZGQiLCJlcSIsImlnbm9yZSIsInN0b3AiLCJpZ25vcmVTZWxlY3Rpb24iLCJDb21wb3NpdGlvblZpZXdEZXNjIiwidGV4dERPTSIsIm11dCIsIm9sZFZhbHVlIiwiTWFya1ZpZXdEZXNjIiwiY3JlYXRlIiwiaW5saW5lIiwiY3VzdG9tIiwibm9kZVZpZXdzIiwibmFtZSIsInJlbmRlclNwZWMiLCJhdHRycyIsInJlcGFyc2VJblZpZXciLCJjb250ZW50RWxlbWVudCIsInNsaWNlIiwiY29weSIsIm5vZGVzIiwicmVwbGFjZU5vZGVzIiwiTm9kZVZpZXdEZXNjIiwiZGVzY09iaiIsImNyZWF0ZVRleHROb2RlIiwiaGFzQXR0cmlidXRlIiwiYXBwbHlPdXRlckRlY28iLCJDdXN0b21Ob2RlVmlld0Rlc2MiLCJUZXh0Vmlld0Rlc2MiLCJydWxlIiwid2hpdGVzcGFjZSIsInByZXNlcnZlV2hpdGVzcGFjZSIsImdldENvbnRlbnQiLCJlbXB0eSIsInNhbWVPdXRlckRlY28iLCJpc0xlYWYiLCJ1cGRhdGVDaGlsZHJlbiIsImNvbXBvc2l0aW9uIiwiY29tcG9zaW5nIiwibG9jYWxDb21wb3NpdGlvbkluZm8iLCJsb2NhbENvbXBvc2l0aW9uIiwiY29tcG9zaXRpb25JbkNoaWxkIiwidXBkYXRlciIsIlZpZXdUcmVlVXBkYXRlciIsIml0ZXJEZWNvIiwiaW5zaWRlTm9kZSIsIm1hcmtzIiwic3luY1RvTWFya3MiLCJjaGlsZENvdW50Iiwibm9uZSIsInBsYWNlV2lkZ2V0IiwiY29tcEluZGV4IiwiZmluZE5vZGVNYXRjaCIsImZpbmRJbmRleFdpdGhDaGlsZCIsInVwZGF0ZU5vZGVBdCIsInVwZGF0ZU5leHROb2RlIiwiYWRkTm9kZSIsImFkZFRleHRibG9ja0hhY2tzIiwiZGVzdHJveVJlc3QiLCJjaGFuZ2VkIiwicHJvdGVjdExvY2FsQ29tcG9zaXRpb24iLCJyZW5kZXJEZXNjcyIsImlvc0hhY2tzIiwidGV4dE5vZGUiLCJpbnB1dCIsImNvbXBvc2l0aW9uTm9kZSIsInRleHRQb3MiLCJmaW5kVGV4dEluRnJhZ21lbnQiLCJ0b3BOb2RlIiwicmVtb3ZlQ2hpbGQiLCJjb21wb3NpdGlvbk5vZGVzIiwidXBkYXRlIiwic2FtZU1hcmt1cCIsInVwZGF0ZUlubmVyIiwidXBkYXRlT3V0ZXJEZWNvIiwibmVlZHNXcmFwIiwib2xkRE9NIiwicGF0Y2hPdXRlckRlY28iLCJjb21wdXRlT3V0ZXJEZWNvIiwic2VsZWN0Tm9kZSIsImRlc2VsZWN0Tm9kZSIsInJlbW92ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImlzQXRvbSIsImRvY1ZpZXdEZXNjIiwic2tpcCIsInBtSXNEZWNvIiwiaW5QYXJlbnQiLCJ0cmFja1dyaXRlcyIsIm4iLCJjdXQiLCJtdWx0aVR5cGUiLCJkZXNjcyIsIndyaXR0ZW4iLCJjaGlsZERPTSIsInJtIiwiaW5zZXJ0QmVmb3JlIiwiT3V0ZXJEZWNvTGV2ZWwiLCJPYmplY3QiLCJub0RlY28iLCJ2YWwiLCJpc0lubGluZSIsImNsYXNzIiwib3V0ZXJET00iLCJwcmV2Q29tcHV0ZWQiLCJjdXJDb21wdXRlZCIsImN1ckRPTSIsImRlY28iLCJ0b0xvd2VyQ2FzZSIsInBhdGNoQXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsInByZXZMaXN0Iiwic3BsaXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiY3VyTGlzdCIsImluZGV4T2YiLCJwcm9wIiwibSIsInJlbW92ZVByb3BlcnR5IiwiY3NzVGV4dCIsImEiLCJiIiwibG9jayIsInByZU1hdGNoIiwiZGVzdHJveUJldHdlZW4iLCJzcGxpY2UiLCJrZWVwIiwibWF4S2VlcCIsInNwYW5uaW5nIiwicG9wIiwiZm91bmQiLCJpc0xvY2tlZCIsIm1hcmtEZXNjIiwidGFyZ2V0RGVzYyIsIm1hdGNoZXMiLCJlIiwibWF0Y2hlZCIsImhhcyIsImRvbU5vZGUiLCJnZXQiLCJuZXh0RE9NIiwidXBkYXRlZCIsImxvY2tlZCIsInJlY3JlYXRlV3JhcHBlciIsIndyYXBwZXIiLCJjaCIsInJlcXVpcmVzR2Vja29IYWNrTm9kZSIsImFkZEhhY2tOb2RlIiwiY2xhc3NOYW1lIiwiYWx0IiwiaGFjayIsImZyYWciLCJwYXJlbnREZXNjIiwiY3VyRGVzYyIsImRlc2NJIiwiZkkiLCJNYXAiLCJvdXRlciIsInNldCIsInJldmVyc2UiLCJjb21wYXJlU2lkZSIsIm9uV2lkZ2V0Iiwib25Ob2RlIiwibG9jYWxzIiwiZm9yQ2hpbGQiLCJkZWNvSW5kZXgiLCJyZXN0Tm9kZSIsInBhcmVudEluZGV4Iiwid2lkZ2V0cyIsInNvcnQiLCJjdXRBdCIsImQiLCJvbGRDU1MiLCJ3aW5kb3ciLCJsaXN0U3R5bGUiLCJjaGlsZFN0YXJ0Iiwic3RyIiwibGFzdEluZGV4T2YiLCJyZXBsYWNlbWVudCIsInNlbGVjdGlvbkZyb21ET00iLCJvcmlnaW4iLCJpbldpZGdldCIsIm5lYXJlc3REZXNjTm9kZSIsImlzU2VsZWN0YWJsZSIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0IiwiZW5kQ29udGFpbmVyIiwiZW5kT2Zmc2V0IiwiJGFuY2hvciIsInNlbGVjdGlvbkJldHdlZW4iLCJlZGl0b3JPd25zU2VsZWN0aW9uIiwiZWRpdGFibGUiLCJoYXNGb2N1cyIsImhhc1NlbGVjdGlvbiIsInNlbGVjdGlvblRvRE9NIiwic3luY05vZGVTZWxlY3Rpb24iLCJtb3VzZURvd24iLCJhbGxvd0RlZmF1bHQiLCJjdXJTZWwiLCJkb21PYnNlcnZlciIsImN1cnJlbnRTZWxlY3Rpb24iLCJkZWxheWVkU2VsZWN0aW9uU3luYyIsInNldEN1clNlbGVjdGlvbiIsImRpc2Nvbm5lY3RTZWxlY3Rpb24iLCJjdXJzb3JXcmFwcGVyIiwic2VsZWN0Q3Vyc29yV3JhcHBlciIsInJlc2V0RWRpdGFibGVGcm9tIiwicmVzZXRFZGl0YWJsZVRvIiwiYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUiLCJ0ZW1wb3JhcmlseUVkaXRhYmxlTmVhciIsInJlc2V0RWRpdGFibGUiLCJ2aXNpYmxlIiwicmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSIsImNvbm5lY3RTZWxlY3Rpb24iLCJzZXRFZGl0YWJsZSIsIndhc0RyYWdnYWJsZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoaWRlU2VsZWN0aW9uR3VhcmQiLCJhZGRFdmVudExpc3RlbmVyIiwic2V0VGltZW91dCIsImltZyIsImRpc2FibGVkIiwibGFzdFNlbGVjdGVkVmlld0Rlc2MiLCJjbGVhck5vZGVTZWxlY3Rpb24iLCJiZXR3ZWVuIiwiaGFzRm9jdXNBbmRTZWxlY3Rpb24iLCJhbmNob3JJblJpZ2h0UGxhY2UiLCJtb3ZlU2VsZWN0aW9uQmxvY2siLCIkc2lkZSIsIiRzdGFydCIsImZpbmRGcm9tIiwiYXBwbHkiLCJkaXNwYXRjaCIsInRyIiwic2Nyb2xsSW50b1ZpZXciLCJzZWxlY3RIb3Jpem9udGFsbHkiLCJtb2RzIiwidGV4dE9mZnNldCIsIm5vZGVCZWZvcmUiLCJub2RlQWZ0ZXIiLCIkbmV3SGVhZCIsIm5vZGVQb3MiLCJub2RlTGVuIiwiaXNJZ25vcmFibGUiLCJza2lwSWdub3JlZE5vZGVzIiwic2tpcElnbm9yZWROb2Rlc0JlZm9yZSIsInNraXBJZ25vcmVkTm9kZXNBZnRlciIsIm1vdmVOb2RlIiwibW92ZU9mZnNldCIsImlzQmxvY2tOb2RlIiwic2V0U2VsRm9jdXMiLCJ0ZXh0Tm9kZUFmdGVyIiwidGV4dE5vZGVCZWZvcmUiLCJmaW5kRGlyZWN0aW9uIiwibWlkIiwiYWJzIiwiY29tcHV0ZWQiLCJkaXJlY3Rpb24iLCJzZWxlY3RWZXJ0aWNhbGx5IiwiYmV5b25kIiwibmVhciIsInN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlIiwic2FtZVBhcmVudCIsIm5leHROb2RlIiwiZGVsZXRlIiwic3dpdGNoRWRpdGFibGUiLCJzYWZhcmlEb3duQXJyb3dCdWciLCJnZXRNb2RzIiwiY3RybEtleSIsIm1ldGFLZXkiLCJhbHRLZXkiLCJzaGlmdEtleSIsImNhcHR1cmVLZXlEb3duIiwic2VyaWFsaXplRm9yQ2xpcGJvYXJkIiwiY29udGV4dCIsIm9wZW5TdGFydCIsIm9wZW5FbmQiLCJkZWZhdWx0QXR0cnMiLCJzZXJpYWxpemVyIiwiZnJvbVNjaGVtYSIsInNjaGVtYSIsImRldGFjaGVkRG9jIiwic2VyaWFsaXplRnJhZ21lbnQiLCJ3cmFwcGVycyIsIndyYXBNYXAiLCJKU09OIiwic3RyaW5naWZ5IiwidGV4dEJldHdlZW4iLCJwYXJzZUZyb21DbGlwYm9hcmQiLCJodG1sIiwicGxhaW5UZXh0IiwiJGNvbnRleHQiLCJpbkNvZGUiLCJhc1RleHQiLCJyZXBsYWNlIiwicGFyc2VkIiwiZm9yRWFjaCIsImJsb2NrIiwic2VyaWFsaXplTm9kZSIsInJlYWRIVE1MIiwicmVzdG9yZVJlcGxhY2VkU3BhY2VzIiwiY29udGV4dE5vZGUiLCJxdWVyeVNlbGVjdG9yIiwic2xpY2VEYXRhIiwiZ2V0QXR0cmlidXRlIiwicGFyc2VyIiwicGFyc2VTbGljZSIsInJ1bGVGcm9tTm9kZSIsImlubGluZVBhcmVudHMiLCJhZGRDb250ZXh0IiwiY2xvc2VTbGljZSIsIm1heE9wZW4iLCJub3JtYWxpemVTaWJsaW5ncyIsImlzb2xhdGluZyIsImZyYWdtZW50IiwibWF0Y2giLCJjb250ZW50TWF0Y2hBdCIsImxhc3RXcmFwIiwiZmluZFdyYXBwaW5nIiwiaW5MYXN0IiwiYWRkVG9TaWJsaW5nIiwiY2xvc2VSaWdodCIsIndyYXBwZWQiLCJ3aXRoV3JhcHBlcnMiLCJtYXRjaFR5cGUiLCJzaWJsaW5nIiwicmVwbGFjZUNoaWxkIiwiYXBwZW5kIiwiZmlsbCIsImZpbGxCZWZvcmUiLCJjbG9zZVJhbmdlIiwidGhlYWQiLCJ0Ym9keSIsInRmb290IiwiY2FwdGlvbiIsImNvbGdyb3VwIiwiY29sIiwidGQiLCJ0aCIsIl9kZXRhY2hlZERvYyIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlSFRNTERvY3VtZW50IiwiX3BvbGljeSIsIm1heWJlV3JhcFRydXN0ZWQiLCJ0cnVzdGVkVHlwZXMiLCJjcmVhdGVQb2xpY3kiLCJjcmVhdGVIVE1MIiwicyIsIm1ldGFzIiwiZmlyc3RUYWciLCJtYXAiLCJqb2luIiwiaW5uZXJIVE1MIiwicXVlcnlTZWxlY3RvckFsbCIsImFycmF5IiwicGFyc2UiLCJoYXNSZXF1aXJlZEF0dHJzIiwiaGFuZGxlcnMiLCJlZGl0SGFuZGxlcnMiLCJwYXNzaXZlSGFuZGxlcnMiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwiSW5wdXRTdGF0ZSIsImxhc3RLZXlDb2RlIiwibGFzdEtleUNvZGVUaW1lIiwibGFzdENsaWNrIiwidGltZSIsImxhc3RTZWxlY3Rpb25PcmlnaW4iLCJsYXN0U2VsZWN0aW9uVGltZSIsImxhc3RJT1NFbnRlciIsImxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCIsImxhc3RGb2N1cyIsImxhc3RUb3VjaCIsImxhc3RDaHJvbWVEZWxldGUiLCJjb21wb3NpbmdUaW1lb3V0IiwiY29tcG9zaXRpb25FbmRlZEF0IiwiY29tcG9zaXRpb25JRCIsImNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMiLCJkb21DaGFuZ2VDb3VudCIsImV2ZW50SGFuZGxlcnMiLCJpbml0SW5wdXQiLCJoYW5kbGVyIiwiZXZlbnRCZWxvbmdzVG9WaWV3IiwicnVuQ3VzdG9tSGFuZGxlciIsInBhc3NpdmUiLCJlbnN1cmVMaXN0ZW5lcnMiLCJzZXRTZWxlY3Rpb25PcmlnaW4iLCJEYXRlIiwibm93IiwiZGVzdHJveUlucHV0IiwiY2xlYXJUaW1lb3V0IiwiY3VycmVudEhhbmRsZXJzIiwiZGVmYXVsdFByZXZlbnRlZCIsImJ1YmJsZXMiLCJkaXNwYXRjaEV2ZW50Iiwia2V5ZG93biIsIl9ldmVudCIsImluT3JOZWFyQ29tcG9zaXRpb24iLCJmb3JjZUZsdXNoIiwicHJldmVudERlZmF1bHQiLCJrZXl1cCIsImtleXByZXNzIiwiY2hhckNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJpbnNlcnRUZXh0IiwiZXZlbnRDb29yZHMiLCJjbGllbnRYIiwiY2xpZW50WSIsImlzTmVhciIsImNsaWNrIiwiZHkiLCJydW5IYW5kbGVyT25Db250ZXh0IiwicHJvcE5hbWUiLCJ1cGRhdGVTZWxlY3Rpb24iLCJmb2N1c2VkIiwic2V0TWV0YSIsInNlbGVjdENsaWNrZWRMZWFmIiwic2VsZWN0Q2xpY2tlZE5vZGUiLCJzZWxlY3RlZE5vZGUiLCJzZWxlY3RBdCIsImhhbmRsZVNpbmdsZUNsaWNrIiwiaGFuZGxlRG91YmxlQ2xpY2siLCJoYW5kbGVUcmlwbGVDbGljayIsImRlZmF1bHRUcmlwbGVDbGljayIsImJ1dHRvbiIsImZvcmNlRE9NRmx1c2giLCJlbmRDb21wb3NpdGlvbiIsInNlbGVjdE5vZGVNb2RpZmllciIsIm1vdXNlZG93biIsImZsdXNoZWQiLCJkb25lIiwiTW91c2VEb3duIiwibWlnaHREcmFnIiwic3RhcnREb2MiLCJ0YXJnZXRQb3MiLCJub2RlQXQiLCJzZWxlY3RhYmxlIiwiYWRkQXR0ciIsInNldFVuZWRpdGFibGUiLCJ1cCIsImJpbmQiLCJtb3ZlIiwidXBkYXRlQWxsb3dEZWZhdWx0IiwiYnV0dG9ucyIsImNvbnRleHRtZW51IiwidGltZVN0YW1wIiwidGltZW91dENvbXBvc2l0aW9uIiwiY29tcG9zaXRpb25zdGFydCIsImNvbXBvc2l0aW9udXBkYXRlIiwiZmx1c2giLCJzdG9yZWRNYXJrcyIsInNvbWUiLCJpbmNsdXNpdmUiLCJtYXJrQ3Vyc29yIiwic2NoZWR1bGVDb21wb3NlRW5kIiwiY29tcG9zaXRpb25lbmQiLCJwZW5kaW5nUmVjb3JkcyIsIlByb21pc2UiLCJ0aGVuIiwiZGVsYXkiLCJjbGVhckNvbXBvc2l0aW9uIiwidGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50IiwiZmluZENvbXBvc2l0aW9uTm9kZSIsInRleHRCZWZvcmUiLCJ0ZXh0QWZ0ZXIiLCJkZXNjQWZ0ZXIiLCJsYXN0Q2hhbmdlZCIsImxhc3RDaGFuZ2VkVGV4dE5vZGUiLCJkZXNjQmVmb3JlIiwicmVzdGFydGluZyIsImZsdXNoaW5nU29vbiIsImRlbGV0ZVNlbGVjdGlvbiIsImNhcHR1cmVDb3B5Iiwic2VsZWN0Tm9kZUNvbnRlbnRzIiwiYmx1ciIsImJyb2tlbkNsaXBib2FyZEFQSSIsImRhdGEiLCJjbGlwYm9hcmREYXRhIiwiY2xlYXJEYXRhIiwic2V0RGF0YSIsInNsaWNlU2luZ2xlTm9kZSIsImNhcHR1cmVQYXN0ZSIsInBsYWluIiwiZG9QYXN0ZSIsInByZWZlclBsYWluIiwic2luZ2xlTm9kZSIsInJlcGxhY2VTZWxlY3Rpb25XaXRoIiwicmVwbGFjZVNlbGVjdGlvbiIsImdldFRleHQiLCJnZXREYXRhIiwidXJpcyIsInBhc3RlIiwiRHJhZ2dpbmciLCJkcmFnQ29weU1vZGlmaWVyIiwiZHJhZ01vdmVzIiwibW92ZXMiLCJkcmFnc3RhcnQiLCJkYXRhVHJhbnNmZXIiLCJkcmFnZ2VkU2xpY2UiLCJmaWxlcyIsImVmZmVjdEFsbG93ZWQiLCJkcmFnZ2luZyIsImRyYWdlbmQiLCJkcmFnb3ZlciIsImRyYWdlbnRlciIsImRyb3AiLCJldmVudFBvcyIsIiRtb3VzZSIsImluc2VydFBvcyIsIm1hcHBpbmciLCJpc05vZGUiLCJiZWZvcmVJbnNlcnQiLCJyZXBsYWNlUmFuZ2VXaXRoIiwicmVwbGFjZVJhbmdlIiwibWFwcyIsIl9mcm9tIiwiX3RvIiwiX25ld0Zyb20iLCJuZXdUbyIsInJlbGF0ZWRUYXJnZXQiLCJjbGVhciIsImJlZm9yZWlucHV0IiwiaW5wdXRUeXBlIiwiZmx1c2hTb29uIiwiJGN1cnNvciIsImNvbXBhcmVPYmpzIiwiV2lkZ2V0VHlwZSIsIm5vU3BlYyIsInNwYW4iLCJvbGRPZmZzZXQiLCJkZWxldGVkIiwibWFwUmVzdWx0IiwiRGVjb3JhdGlvbiIsInZhbGlkIiwib3RoZXIiLCJJbmxpbmVUeXBlIiwiaW5jbHVzaXZlU3RhcnQiLCJpbmNsdXNpdmVFbmQiLCJpcyIsIk5vZGVUeXBlIiwiZmluZEluZGV4IiwiRGVjb3JhdGlvblNldCIsImxvY2FsIiwiZGVjb3JhdGlvbnMiLCJidWlsZFRyZWUiLCJwcmVkaWNhdGUiLCJmaW5kSW5uZXIiLCJjaGlsZE9mZiIsIm9wdGlvbnMiLCJtYXBJbm5lciIsIm5ld0xvY2FsIiwibWFwcGVkIiwib25SZW1vdmUiLCJtYXBDaGlsZHJlbiIsImJ5UG9zIiwiYWRkSW5uZXIiLCJjaGlsZE5vZGUiLCJjaGlsZE9mZnNldCIsImJhc2VPZmZzZXQiLCJ0YWtlU3BhbnNGb3JOb2RlIiwibW92ZVNwYW5zIiwid2l0aG91dE51bGxzIiwiY29uY2F0IiwicmVtb3ZlSW5uZXIiLCJyZW1vdmVkIiwiZGVjIiwibG9jYWxTZXQiLCJEZWNvcmF0aW9uR3JvdXAiLCJyZW1vdmVPdmVybGFwIiwibG9jYWxzSW5uZXIiLCJmb3JFYWNoU2V0IiwibWVtYmVycyIsIm1hcHBlZERlY29zIiwibWVtYmVyIiwic29ydGVkIiwiZXZlcnkiLCJyZWR1Y2UiLCJyIiwib2xkQ2hpbGRyZW4iLCJtb3ZlZCIsIm9sZFN0YXJ0Iiwib2xkRW5kIiwibmV3U3RhcnQiLCJuZXdFbmQiLCJkU2l6ZSIsIm11c3RSZWJ1aWxkIiwiZnJvbUxvY2FsIiwidG9Mb2NhbCIsIm1heWJlQ2hpbGQiLCJtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyIsImJ1aWx0Iiwic3BhbnMiLCJnYXRoZXIiLCJoYXNOdWxscyIsImxvY2FsU3RhcnQiLCJzdWJ0cmVlIiwid29ya2luZyIsImluc2VydEFoZWFkIiwidmlld0RlY29yYXRpb25zIiwib2JzZXJ2ZU9wdGlvbnMiLCJjaGlsZExpc3QiLCJjaGFyYWN0ZXJEYXRhIiwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZU9sZFZhbHVlIiwidXNlQ2hhckRhdGEiLCJTZWxlY3Rpb25TdGF0ZSIsIkRPTU9ic2VydmVyIiwiaGFuZGxlRE9NQ2hhbmdlIiwicXVldWUiLCJvYnNlcnZlciIsIm9uQ2hhckRhdGEiLCJzdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMiLCJNdXRhdGlvbk9ic2VydmVyIiwibXV0YXRpb25zIiwicmVtb3ZlZE5vZGVzIiwicHJldlZhbHVlIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJ0YWtlUmVjb3JkcyIsIm9ic2VydmUiLCJ0YWtlIiwiZGlzY29ubmVjdCIsInN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcyIsImlnbm9yZVNlbGVjdGlvbkNoYW5nZSIsImFuY2VzdG9ycyIsIlNldCIsImNvbnRhaW5lciIsIm5ld1NlbCIsInR5cGVPdmVyIiwiYWRkZWQiLCJyZWdpc3Rlck11dGF0aW9uIiwiYnJzIiwiYnIiLCJibG9ja1BhcmVudCIsInJlYWRTZWwiLCJzY3JvbGxUb1NlbGVjdGlvbiIsImNoZWNrQ1NTIiwiYXR0cmlidXRlTmFtZSIsImFkZGVkTm9kZXMiLCJjc3NDaGVja2VkIiwiV2Vha01hcCIsImNzc0NoZWNrV2FybmVkIiwid2hpdGVTcGFjZSIsImNvbnNvbGUiLCJyYW5nZVRvU2VsZWN0aW9uUmFuZ2UiLCJjdXJyZW50QW5jaG9yIiwiZG9tQXRQb3MiLCJzYWZhcmlTaGFkb3dTZWxlY3Rpb25SYW5nZSIsImdldENvbXBvc2VkUmFuZ2VzIiwicmVhZCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsImdldFRhcmdldFJhbmdlcyIsImV4ZWNDb21tYW5kIiwicGFyc2VCZXR3ZWVuIiwiZnJvbV8iLCJ0b18iLCJ0b3BNYXRjaCIsInRvcE9wZW4iLCJmaW5kUG9zaXRpb25zIiwicmVhZERPTUNoYW5nZSIsIiRiZWZvcmUiLCJzaGFyZWQiLCJzaGFyZWREZXB0aCIsImNvbXBhcmUiLCJwcmVmZXJyZWRQb3MiLCJwcmVmZXJyZWRTaWRlIiwiY2hhbmdlIiwiZmluZERpZmYiLCJlbmRBIiwiZW5kQiIsInJlc29sdmVTZWxlY3Rpb24iLCJyZXNvbHZlTm9DYWNoZSIsIiRmcm9tQSIsImlubGluZUNoYW5nZSIsIm5leHRTZWwiLCJsb29rc0xpa2VCYWNrc3BhY2UiLCJjaEZyb20iLCJjaFRvIiwibWFya0NoYW5nZSIsIm1hcmtzQWNyb3NzIiwiaXNNYXJrQ2hhbmdlIiwiYWRkTWFyayIsInJlbW92ZU1hcmsiLCJlbnN1cmVNYXJrcyIsInBhcnNlZFNlbCIsImN1ck1hcmtzIiwicHJldk1hcmtzIiwicmVtb3ZlRnJvbVNldCIsImFkZFRvU2V0Iiwib2xkIiwiJG5ld1N0YXJ0IiwiJG5ld0VuZCIsInNraXBDbG9zaW5nQW5kT3BlbmluZyIsIiRuZXh0IiwiZnJvbUVuZCIsIm1heU9wZW4iLCJpbmRleEFmdGVyIiwiZmluZERpZmZTdGFydCIsImZpbmREaWZmRW5kIiwiYWRqdXN0IiwiaXNTdXJyb2dhdGVQYWlyIiwiY2hhckNvZGVBdCIsIl9fcGFyc2VGcm9tQ2xpcGJvYXJkIiwiX19lbmRDb21wb3NpdGlvbiIsIkVkaXRvclZpZXciLCJwbGFjZSIsInByb3BzIiwiX3Jvb3QiLCJtb3VudGVkIiwicHJldkRpcmVjdFBsdWdpbnMiLCJwbHVnaW5WaWV3cyIsIl9wcm9wcyIsImRpcmVjdFBsdWdpbnMiLCJwbHVnaW5zIiwiY2hlY2tTdGF0ZUNvbXBvbmVudCIsIm1vdW50IiwiZ2V0RWRpdGFibGUiLCJ1cGRhdGVDdXJzb3JXcmFwcGVyIiwiYnVpbGROb2RlVmlld3MiLCJjb21wdXRlRG9jRGVjbyIsInVwZGF0ZVBsdWdpblZpZXdzIiwiaGFuZGxlRE9NRXZlbnRzIiwicHJldlByb3BzIiwidXBkYXRlU3RhdGVJbm5lciIsInNldFByb3BzIiwiX2EiLCJyZWRyYXciLCJ1cGRhdGVTZWwiLCJwbHVnaW5zQ2hhbmdlZCIsImNoYW5nZWROb2RlVmlld3MiLCJzY3JvbGwiLCJ1cGRhdGVEb2MiLCJvbGRTY3JvbGxQb3MiLCJvdmVyZmxvd0FuY2hvciIsImZvcmNlU2VsVXBkYXRlIiwic2VsZWN0aW9uQ29udGV4dENoYW5nZWQiLCJjaHJvbWVLbHVkZ2UiLCJ1cGRhdGVEcmFnZ2VkTm9kZSIsImRlc3Ryb3lQbHVnaW5WaWV3cyIsInByZXZTdGF0ZSIsInBsdWdpbiIsInBsdWdpblZpZXciLCJtb3ZlZFBvcyIsInBhcmVudEVsZW1lbnQiLCJjYWNoZWQiLCJnZXRQcm90b3R5cGVPZiIsInVwZGF0ZVJvb3QiLCJwb3NBdERPTSIsInBhc3RlSFRNTCIsIkNsaXBib2FyZEV2ZW50IiwicGFzdGVUZXh0IiwiaXNEZXN0cm95ZWQiLCJkaXNwYXRjaFRyYW5zYWN0aW9uIiwiY29udGVudGVkaXRhYmxlIiwiYXR0ciIsInRyYW5zbGF0ZSIsInNlbDEiLCJzZWwyIiwib2JqIiwiaGFzT3duUHJvcGVydHkiLCJuQSIsIm5CIiwiZmlsdGVyVHJhbnNhY3Rpb24iLCJhcHBlbmRUcmFuc2FjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-view/dist/index.js\n");

/***/ })

};
;