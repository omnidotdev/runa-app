"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tiptap";
exports.ids = ["vendor-chunks/@tiptap"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tiptap/core/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: () => (/* binding */ CommandManager),\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Extension: () => (/* binding */ Extension),\n/* harmony export */   InputRule: () => (/* binding */ InputRule),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   NodePos: () => (/* binding */ NodePos),\n/* harmony export */   NodeView: () => (/* binding */ NodeView),\n/* harmony export */   PasteRule: () => (/* binding */ PasteRule),\n/* harmony export */   Tracker: () => (/* binding */ Tracker),\n/* harmony export */   callOrReturn: () => (/* binding */ callOrReturn),\n/* harmony export */   combineTransactionSteps: () => (/* binding */ combineTransactionSteps),\n/* harmony export */   createChainableState: () => (/* binding */ createChainableState),\n/* harmony export */   createDocument: () => (/* binding */ createDocument),\n/* harmony export */   createNodeFromContent: () => (/* binding */ createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* binding */ createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* binding */ defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* binding */ deleteProps),\n/* harmony export */   elementFromString: () => (/* binding */ elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* binding */ escapeForRegEx),\n/* harmony export */   extensions: () => (/* binding */ index),\n/* harmony export */   findChildren: () => (/* binding */ findChildren),\n/* harmony export */   findChildrenInRange: () => (/* binding */ findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* binding */ findDuplicates),\n/* harmony export */   findParentNode: () => (/* binding */ findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* binding */ findParentNodeClosestToPos),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   generateHTML: () => (/* binding */ generateHTML),\n/* harmony export */   generateJSON: () => (/* binding */ generateJSON),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getAttributes: () => (/* binding */ getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* binding */ getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* binding */ getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* binding */ getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* binding */ getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* binding */ getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* binding */ getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* binding */ getMarkRange),\n/* harmony export */   getMarkType: () => (/* binding */ getMarkType),\n/* harmony export */   getMarksBetween: () => (/* binding */ getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* binding */ getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* binding */ getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* binding */ getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* binding */ getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* binding */ getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* binding */ getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* binding */ getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* binding */ getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* binding */ getSplittedAttributes),\n/* harmony export */   getText: () => (/* binding */ getText),\n/* harmony export */   getTextBetween: () => (/* binding */ getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* binding */ getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* binding */ getTextSerializersFromSchema),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* binding */ injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* binding */ inputRulesPlugin),\n/* harmony export */   isActive: () => (/* binding */ isActive),\n/* harmony export */   isAtEndOfNode: () => (/* binding */ isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* binding */ isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* binding */ isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isList: () => (/* binding */ isList),\n/* harmony export */   isMacOS: () => (/* binding */ isMacOS),\n/* harmony export */   isMarkActive: () => (/* binding */ isMarkActive),\n/* harmony export */   isNodeActive: () => (/* binding */ isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* binding */ isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* binding */ isNodeSelection),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isTextSelection: () => (/* binding */ isTextSelection),\n/* harmony export */   isiOS: () => (/* binding */ isiOS),\n/* harmony export */   markInputRule: () => (/* binding */ markInputRule),\n/* harmony export */   markPasteRule: () => (/* binding */ markPasteRule),\n/* harmony export */   mergeAttributes: () => (/* binding */ mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* binding */ mergeDeep),\n/* harmony export */   minMax: () => (/* binding */ minMax),\n/* harmony export */   nodeInputRule: () => (/* binding */ nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* binding */ nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* binding */ objectIncludes),\n/* harmony export */   pasteRulesPlugin: () => (/* binding */ pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* binding */ posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* binding */ removeDuplicates),\n/* harmony export */   resolveFocusPosition: () => (/* binding */ resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* binding */ rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* binding */ selectionToInsertionEnd),\n/* harmony export */   splitExtensions: () => (/* binding */ splitExtensions),\n/* harmony export */   textInputRule: () => (/* binding */ textInputRule),\n/* harmony export */   textPasteRule: () => (/* binding */ textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* binding */ textblockTypeInputRule),\n/* harmony export */   wrappingInputRule: () => (/* binding */ wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/view/dist/index.js\");\n/* harmony import */ var _tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/keymap */ \"(ssr)/./node_modules/@tiptap/pm/keymap/dist/index.js\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/model */ \"(ssr)/./node_modules/@tiptap/pm/model/dist/index.js\");\n/* harmony import */ var _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/transform */ \"(ssr)/./node_modules/@tiptap/pm/transform/dist/index.js\");\n/* harmony import */ var _tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/commands */ \"(ssr)/./node_modules/@tiptap/pm/commands/dist/index.js\");\n/* harmony import */ var _tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/pm/schema-list */ \"(ssr)/./node_modules/@tiptap/pm/schema-list/dist/index.js\");\n\n\n\n\n\n\n\n/**\n * Takes a Transaction & Editor State and turns it into a chainable state object\n * @param config The transaction and state to create the chainable state from\n * @returns A chainable Editor state object\n */ function createChainableState(config) {\n    const { state, transaction } = config;\n    let { selection } = transaction;\n    let { doc } = transaction;\n    let { storedMarks } = transaction;\n    return {\n        ...state,\n        apply: state.apply.bind(state),\n        applyTransaction: state.applyTransaction.bind(state),\n        plugins: state.plugins,\n        schema: state.schema,\n        reconfigure: state.reconfigure.bind(state),\n        toJSON: state.toJSON.bind(state),\n        get storedMarks () {\n            return storedMarks;\n        },\n        get selection () {\n            return selection;\n        },\n        get doc () {\n            return doc;\n        },\n        get tr () {\n            selection = transaction.selection;\n            doc = transaction.doc;\n            storedMarks = transaction.storedMarks;\n            return transaction;\n        }\n    };\n}\nclass CommandManager {\n    constructor(props){\n        this.editor = props.editor;\n        this.rawCommands = this.editor.extensionManager.commands;\n        this.customState = props.state;\n    }\n    get hasCustomState() {\n        return !!this.customState;\n    }\n    get state() {\n        return this.customState || this.editor.state;\n    }\n    get commands() {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const { tr } = state;\n        const props = this.buildProps(tr);\n        return Object.fromEntries(Object.entries(rawCommands).map(([name, command])=>{\n            const method = (...args)=>{\n                const callback = command(...args)(props);\n                if (!tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n                    view.dispatch(tr);\n                }\n                return callback;\n            };\n            return [\n                name,\n                method\n            ];\n        }));\n    }\n    get chain() {\n        return ()=>this.createChain();\n    }\n    get can() {\n        return ()=>this.createCan();\n    }\n    createChain(startTr, shouldDispatch = true) {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const callbacks = [];\n        const hasStartTransaction = !!startTr;\n        const tr = startTr || state.tr;\n        const run = ()=>{\n            if (!hasStartTransaction && shouldDispatch && !tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n                view.dispatch(tr);\n            }\n            return callbacks.every((callback)=>callback === true);\n        };\n        const chain = {\n            ...Object.fromEntries(Object.entries(rawCommands).map(([name, command])=>{\n                const chainedCommand = (...args)=>{\n                    const props = this.buildProps(tr, shouldDispatch);\n                    const callback = command(...args)(props);\n                    callbacks.push(callback);\n                    return chain;\n                };\n                return [\n                    name,\n                    chainedCommand\n                ];\n            })),\n            run\n        };\n        return chain;\n    }\n    createCan(startTr) {\n        const { rawCommands, state } = this;\n        const dispatch = false;\n        const tr = startTr || state.tr;\n        const props = this.buildProps(tr, dispatch);\n        const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command])=>{\n            return [\n                name,\n                (...args)=>command(...args)({\n                        ...props,\n                        dispatch: undefined\n                    })\n            ];\n        }));\n        return {\n            ...formattedCommands,\n            chain: ()=>this.createChain(tr, dispatch)\n        };\n    }\n    buildProps(tr, shouldDispatch = true) {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const props = {\n            tr,\n            editor,\n            view,\n            state: createChainableState({\n                state,\n                transaction: tr\n            }),\n            dispatch: shouldDispatch ? ()=>undefined : undefined,\n            chain: ()=>this.createChain(tr, shouldDispatch),\n            can: ()=>this.createCan(tr),\n            get commands () {\n                return Object.fromEntries(Object.entries(rawCommands).map(([name, command])=>{\n                    return [\n                        name,\n                        (...args)=>command(...args)(props)\n                    ];\n                }));\n            }\n        };\n        return props;\n    }\n}\nclass EventEmitter {\n    constructor(){\n        this.callbacks = {};\n    }\n    on(event, fn) {\n        if (!this.callbacks[event]) {\n            this.callbacks[event] = [];\n        }\n        this.callbacks[event].push(fn);\n        return this;\n    }\n    emit(event, ...args) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            callbacks.forEach((callback)=>callback.apply(this, args));\n        }\n        return this;\n    }\n    off(event, fn) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            if (fn) {\n                this.callbacks[event] = callbacks.filter((callback)=>callback !== fn);\n            } else {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    }\n    once(event, fn) {\n        const onceFn = (...args)=>{\n            this.off(event, onceFn);\n            fn.apply(this, args);\n        };\n        return this.on(event, onceFn);\n    }\n    removeAllListeners() {\n        this.callbacks = {};\n    }\n}\n/**\n * Returns a field from an extension\n * @param extension The Tiptap extension\n * @param field The field, for example `renderHTML` or `priority`\n * @param context The context object that should be passed as `this` into the function\n * @returns The field value\n */ function getExtensionField(extension, field, context) {\n    if (extension.config[field] === undefined && extension.parent) {\n        return getExtensionField(extension.parent, field, context);\n    }\n    if (typeof extension.config[field] === \"function\") {\n        const value = extension.config[field].bind({\n            ...context,\n            parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n        });\n        return value;\n    }\n    return extension.config[field];\n}\nfunction splitExtensions(extensions) {\n    const baseExtensions = extensions.filter((extension)=>extension.type === \"extension\");\n    const nodeExtensions = extensions.filter((extension)=>extension.type === \"node\");\n    const markExtensions = extensions.filter((extension)=>extension.type === \"mark\");\n    return {\n        baseExtensions,\n        nodeExtensions,\n        markExtensions\n    };\n}\n/**\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\n * @param extensions List of extensions\n */ function getAttributesFromExtensions(extensions) {\n    const extensionAttributes = [];\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n    const nodeAndMarkExtensions = [\n        ...nodeExtensions,\n        ...markExtensions\n    ];\n    const defaultAttribute = {\n        default: null,\n        rendered: true,\n        renderHTML: null,\n        parseHTML: null,\n        keepOnSplit: true,\n        isRequired: false\n    };\n    extensions.forEach((extension)=>{\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            extensions: nodeAndMarkExtensions\n        };\n        const addGlobalAttributes = getExtensionField(extension, \"addGlobalAttributes\", context);\n        if (!addGlobalAttributes) {\n            return;\n        }\n        const globalAttributes = addGlobalAttributes();\n        globalAttributes.forEach((globalAttribute)=>{\n            globalAttribute.types.forEach((type)=>{\n                Object.entries(globalAttribute.attributes).forEach(([name, attribute])=>{\n                    extensionAttributes.push({\n                        type,\n                        name,\n                        attribute: {\n                            ...defaultAttribute,\n                            ...attribute\n                        }\n                    });\n                });\n            });\n        });\n    });\n    nodeAndMarkExtensions.forEach((extension)=>{\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage\n        };\n        const addAttributes = getExtensionField(extension, \"addAttributes\", context);\n        if (!addAttributes) {\n            return;\n        }\n        // TODO: remove `as Attributes`\n        const attributes = addAttributes();\n        Object.entries(attributes).forEach(([name, attribute])=>{\n            const mergedAttr = {\n                ...defaultAttribute,\n                ...attribute\n            };\n            if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === \"function\") {\n                mergedAttr.default = mergedAttr.default();\n            }\n            if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === undefined) {\n                delete mergedAttr.default;\n            }\n            extensionAttributes.push({\n                type: extension.name,\n                name,\n                attribute: mergedAttr\n            });\n        });\n    });\n    return extensionAttributes;\n}\nfunction getNodeType(nameOrType, schema) {\n    if (typeof nameOrType === \"string\") {\n        if (!schema.nodes[nameOrType]) {\n            throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n        }\n        return schema.nodes[nameOrType];\n    }\n    return nameOrType;\n}\nfunction mergeAttributes(...objects) {\n    return objects.filter((item)=>!!item).reduce((items, item)=>{\n        const mergedAttributes = {\n            ...items\n        };\n        Object.entries(item).forEach(([key, value])=>{\n            const exists = mergedAttributes[key];\n            if (!exists) {\n                mergedAttributes[key] = value;\n                return;\n            }\n            if (key === \"class\") {\n                const valueClasses = value ? String(value).split(\" \") : [];\n                const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(\" \") : [];\n                const insertClasses = valueClasses.filter((valueClass)=>!existingClasses.includes(valueClass));\n                mergedAttributes[key] = [\n                    ...existingClasses,\n                    ...insertClasses\n                ].join(\" \");\n            } else if (key === \"style\") {\n                const newStyles = value ? value.split(\";\").map((style)=>style.trim()).filter(Boolean) : [];\n                const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(\";\").map((style)=>style.trim()).filter(Boolean) : [];\n                const styleMap = new Map();\n                existingStyles.forEach((style)=>{\n                    const [property, val] = style.split(\":\").map((part)=>part.trim());\n                    styleMap.set(property, val);\n                });\n                newStyles.forEach((style)=>{\n                    const [property, val] = style.split(\":\").map((part)=>part.trim());\n                    styleMap.set(property, val);\n                });\n                mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val])=>`${property}: ${val}`).join(\"; \");\n            } else {\n                mergedAttributes[key] = value;\n            }\n        });\n        return mergedAttributes;\n    }, {});\n}\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n    return extensionAttributes.filter((attribute)=>attribute.type === nodeOrMark.type.name).filter((item)=>item.attribute.rendered).map((item)=>{\n        if (!item.attribute.renderHTML) {\n            return {\n                [item.name]: nodeOrMark.attrs[item.name]\n            };\n        }\n        return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n    }).reduce((attributes, attribute)=>mergeAttributes(attributes, attribute), {});\n}\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\n/**\n * Optionally calls `value` as a function.\n * Otherwise it is returned directly.\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */ function callOrReturn(value, context = undefined, ...props) {\n    if (isFunction(value)) {\n        if (context) {\n            return value.bind(context)(...props);\n        }\n        return value(...props);\n    }\n    return value;\n}\nfunction isEmptyObject(value = {}) {\n    return Object.keys(value).length === 0 && value.constructor === Object;\n}\nfunction fromString(value) {\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n        return Number(value);\n    }\n    if (value === \"true\") {\n        return true;\n    }\n    if (value === \"false\") {\n        return false;\n    }\n    return value;\n}\n/**\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\n * Cancels when `getAttrs` returned `false`.\n * @param parseRule ProseMirror ParseRule\n * @param extensionAttributes List of attributes to inject\n */ function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n    if (\"style\" in parseRule) {\n        return parseRule;\n    }\n    return {\n        ...parseRule,\n        getAttrs: (node)=>{\n            const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n            if (oldAttributes === false) {\n                return false;\n            }\n            const newAttributes = extensionAttributes.reduce((items, item)=>{\n                const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n                if (value === null || value === undefined) {\n                    return items;\n                }\n                return {\n                    ...items,\n                    [item.name]: value\n                };\n            }, {});\n            return {\n                ...oldAttributes,\n                ...newAttributes\n            };\n        }\n    };\n}\nfunction cleanUpSchemaItem(data) {\n    return Object.fromEntries(// @ts-ignore\n    Object.entries(data).filter(([key, value])=>{\n        if (key === \"attrs\" && isEmptyObject(value)) {\n            return false;\n        }\n        return value !== null && value !== undefined;\n    }));\n}\n/**\n * Creates a new Prosemirror schema based on the given extensions.\n * @param extensions An array of Tiptap extensions\n * @param editor The editor instance\n * @returns A Prosemirror schema\n */ function getSchemaByResolvedExtensions(extensions, editor) {\n    var _a;\n    const allAttributes = getAttributesFromExtensions(extensions);\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n    const topNode = (_a = nodeExtensions.find((extension)=>getExtensionField(extension, \"topNode\"))) === null || _a === void 0 ? void 0 : _a.name;\n    const nodes = Object.fromEntries(nodeExtensions.map((extension)=>{\n        const extensionAttributes = allAttributes.filter((attribute)=>attribute.type === extension.name);\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor\n        };\n        const extraNodeFields = extensions.reduce((fields, e)=>{\n            const extendNodeSchema = getExtensionField(e, \"extendNodeSchema\", context);\n            return {\n                ...fields,\n                ...extendNodeSchema ? extendNodeSchema(extension) : {}\n            };\n        }, {});\n        const schema = cleanUpSchemaItem({\n            ...extraNodeFields,\n            content: callOrReturn(getExtensionField(extension, \"content\", context)),\n            marks: callOrReturn(getExtensionField(extension, \"marks\", context)),\n            group: callOrReturn(getExtensionField(extension, \"group\", context)),\n            inline: callOrReturn(getExtensionField(extension, \"inline\", context)),\n            atom: callOrReturn(getExtensionField(extension, \"atom\", context)),\n            selectable: callOrReturn(getExtensionField(extension, \"selectable\", context)),\n            draggable: callOrReturn(getExtensionField(extension, \"draggable\", context)),\n            code: callOrReturn(getExtensionField(extension, \"code\", context)),\n            whitespace: callOrReturn(getExtensionField(extension, \"whitespace\", context)),\n            linebreakReplacement: callOrReturn(getExtensionField(extension, \"linebreakReplacement\", context)),\n            defining: callOrReturn(getExtensionField(extension, \"defining\", context)),\n            isolating: callOrReturn(getExtensionField(extension, \"isolating\", context)),\n            attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute)=>{\n                var _a;\n                return [\n                    extensionAttribute.name,\n                    {\n                        default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n                    }\n                ];\n            }))\n        });\n        const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n        if (parseHTML) {\n            schema.parseDOM = parseHTML.map((parseRule)=>injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n        }\n        const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n        if (renderHTML) {\n            schema.toDOM = (node)=>renderHTML({\n                    node,\n                    HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n                });\n        }\n        const renderText = getExtensionField(extension, \"renderText\", context);\n        if (renderText) {\n            schema.toText = renderText;\n        }\n        return [\n            extension.name,\n            schema\n        ];\n    }));\n    const marks = Object.fromEntries(markExtensions.map((extension)=>{\n        const extensionAttributes = allAttributes.filter((attribute)=>attribute.type === extension.name);\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor\n        };\n        const extraMarkFields = extensions.reduce((fields, e)=>{\n            const extendMarkSchema = getExtensionField(e, \"extendMarkSchema\", context);\n            return {\n                ...fields,\n                ...extendMarkSchema ? extendMarkSchema(extension) : {}\n            };\n        }, {});\n        const schema = cleanUpSchemaItem({\n            ...extraMarkFields,\n            inclusive: callOrReturn(getExtensionField(extension, \"inclusive\", context)),\n            excludes: callOrReturn(getExtensionField(extension, \"excludes\", context)),\n            group: callOrReturn(getExtensionField(extension, \"group\", context)),\n            spanning: callOrReturn(getExtensionField(extension, \"spanning\", context)),\n            code: callOrReturn(getExtensionField(extension, \"code\", context)),\n            attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute)=>{\n                var _a;\n                return [\n                    extensionAttribute.name,\n                    {\n                        default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n                    }\n                ];\n            }))\n        });\n        const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n        if (parseHTML) {\n            schema.parseDOM = parseHTML.map((parseRule)=>injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n        }\n        const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n        if (renderHTML) {\n            schema.toDOM = (mark)=>renderHTML({\n                    mark,\n                    HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n                });\n        }\n        return [\n            extension.name,\n            schema\n        ];\n    }));\n    return new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n        topNode,\n        nodes,\n        marks\n    });\n}\n/**\n * Tries to get a node or mark type by its name.\n * @param name The name of the node or mark type\n * @param schema The Prosemiror schema to search in\n * @returns The node or mark type, or null if it doesn't exist\n */ function getSchemaTypeByName(name, schema) {\n    return schema.nodes[name] || schema.marks[name] || null;\n}\nfunction isExtensionRulesEnabled(extension, enabled) {\n    if (Array.isArray(enabled)) {\n        return enabled.some((enabledExtension)=>{\n            const name = typeof enabledExtension === \"string\" ? enabledExtension : enabledExtension.name;\n            return name === extension.name;\n        });\n    }\n    return enabled;\n}\nfunction getHTMLFromFragment(fragment, schema) {\n    const documentFragment = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n    const temporaryDocument = document.implementation.createHTMLDocument();\n    const container = temporaryDocument.createElement(\"div\");\n    container.appendChild(documentFragment);\n    return container.innerHTML;\n}\n/**\n * Returns the text content of a resolved prosemirror position\n * @param $from The resolved position to get the text content from\n * @param maxMatch The maximum number of characters to match\n * @returns The text content\n */ const getTextContentFromNodes = ($from, maxMatch = 500)=>{\n    let textBefore = \"\";\n    const sliceEndPos = $from.parentOffset;\n    $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index)=>{\n        var _a, _b;\n        const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            node,\n            pos,\n            parent,\n            index\n        })) || node.textContent || \"%leaf%\";\n        textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));\n    });\n    return textBefore;\n};\nfunction isRegExp(value) {\n    return Object.prototype.toString.call(value) === \"[object RegExp]\";\n}\nclass InputRule {\n    constructor(config){\n        this.find = config.find;\n        this.handler = config.handler;\n    }\n}\nconst inputRuleMatcherHandler = (text, find)=>{\n    if (isRegExp(find)) {\n        return find.exec(text);\n    }\n    const inputRuleMatch = find(text);\n    if (!inputRuleMatch) {\n        return null;\n    }\n    const result = [\n        inputRuleMatch.text\n    ];\n    result.index = inputRuleMatch.index;\n    result.input = text;\n    result.data = inputRuleMatch.data;\n    if (inputRuleMatch.replaceWith) {\n        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n            console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n        }\n        result.push(inputRuleMatch.replaceWith);\n    }\n    return result;\n};\nfunction run$1(config) {\n    var _a;\n    const { editor, from, to, text, rules, plugin } = config;\n    const { view } = editor;\n    if (view.composing) {\n        return false;\n    }\n    const $from = view.state.doc.resolve(from);\n    if (// check for code node\n    $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark)=>mark.type.spec.code))) {\n        return false;\n    }\n    let matched = false;\n    const textBefore = getTextContentFromNodes($from) + text;\n    rules.forEach((rule)=>{\n        if (matched) {\n            return;\n        }\n        const match = inputRuleMatcherHandler(textBefore, rule.find);\n        if (!match) {\n            return;\n        }\n        const tr = view.state.tr;\n        const state = createChainableState({\n            state: view.state,\n            transaction: tr\n        });\n        const range = {\n            from: from - (match[0].length - text.length),\n            to\n        };\n        const { commands, chain, can } = new CommandManager({\n            editor,\n            state\n        });\n        const handler = rule.handler({\n            state,\n            range,\n            match,\n            commands,\n            chain,\n            can\n        });\n        // stop if there are no changes\n        if (handler === null || !tr.steps.length) {\n            return;\n        }\n        // store transform as meta data\n        // so we can undo input rules within the `undoInputRules` command\n        tr.setMeta(plugin, {\n            transform: tr,\n            from,\n            to,\n            text\n        });\n        view.dispatch(tr);\n        matched = true;\n    });\n    return matched;\n}\n/**\n * Create an input rules plugin. When enabled, it will cause text\n * input that matches any of the given rules to trigger the rule’s\n * action.\n */ function inputRulesPlugin(props) {\n    const { editor, rules } = props;\n    const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        state: {\n            init () {\n                return null;\n            },\n            apply (tr, prev, state) {\n                const stored = tr.getMeta(plugin);\n                if (stored) {\n                    return stored;\n                }\n                // if InputRule is triggered by insertContent()\n                const simulatedInputMeta = tr.getMeta(\"applyInputRules\");\n                const isSimulatedInput = !!simulatedInputMeta;\n                if (isSimulatedInput) {\n                    setTimeout(()=>{\n                        let { text } = simulatedInputMeta;\n                        if (typeof text === \"string\") {\n                            text = text;\n                        } else {\n                            text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n                        }\n                        const { from } = simulatedInputMeta;\n                        const to = from + text.length;\n                        run$1({\n                            editor,\n                            from,\n                            to,\n                            text,\n                            rules,\n                            plugin\n                        });\n                    });\n                }\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            }\n        },\n        props: {\n            handleTextInput (view, from, to, text) {\n                return run$1({\n                    editor,\n                    from,\n                    to,\n                    text,\n                    rules,\n                    plugin\n                });\n            },\n            handleDOMEvents: {\n                compositionend: (view)=>{\n                    setTimeout(()=>{\n                        const { $cursor } = view.state.selection;\n                        if ($cursor) {\n                            run$1({\n                                editor,\n                                from: $cursor.pos,\n                                to: $cursor.pos,\n                                text: \"\",\n                                rules,\n                                plugin\n                            });\n                        }\n                    });\n                    return false;\n                }\n            },\n            // add support for input rules to trigger on enter\n            // this is useful for example for code blocks\n            handleKeyDown (view, event) {\n                if (event.key !== \"Enter\") {\n                    return false;\n                }\n                const { $cursor } = view.state.selection;\n                if ($cursor) {\n                    return run$1({\n                        editor,\n                        from: $cursor.pos,\n                        to: $cursor.pos,\n                        text: \"\\n\",\n                        rules,\n                        plugin\n                    });\n                }\n                return false;\n            }\n        },\n        // @ts-ignore\n        isInputRules: true\n    });\n    return plugin;\n}\n// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\nfunction getType(value) {\n    return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n    if (getType(value) !== \"Object\") {\n        return false;\n    }\n    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction mergeDeep(target, source) {\n    const output = {\n        ...target\n    };\n    if (isPlainObject(target) && isPlainObject(source)) {\n        Object.keys(source).forEach((key)=>{\n            if (isPlainObject(source[key]) && isPlainObject(target[key])) {\n                output[key] = mergeDeep(target[key], source[key]);\n            } else {\n                output[key] = source[key];\n            }\n        });\n    }\n    return output;\n}\n/**\n * The Mark class is used to create custom mark extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */ class Mark {\n    constructor(config = {}){\n        this.type = \"mark\";\n        this.name = \"mark\";\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {}\n        };\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, \"addOptions\", {\n                name: this.name\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, \"addStorage\", {\n            name: this.name,\n            options: this.options\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Mark(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend({\n            ...this.config,\n            addOptions: ()=>{\n                return mergeDeep(this.options, options);\n            }\n        });\n        // Always preserve the current name\n        extension.name = this.name;\n        // Set the parent to be our parent\n        extension.parent = this.parent;\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Mark(extendedConfig);\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, \"addOptions\", {\n            name: extension.name\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n            name: extension.name,\n            options: extension.options\n        }));\n        return extension;\n    }\n    static handleExit({ editor, mark }) {\n        const { tr } = editor.state;\n        const currentPos = editor.state.selection.$from;\n        const isAtEnd = currentPos.pos === currentPos.end();\n        if (isAtEnd) {\n            const currentMarks = currentPos.marks();\n            const isInMark = !!currentMarks.find((m)=>(m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n            if (!isInMark) {\n                return false;\n            }\n            const removeMark = currentMarks.find((m)=>(m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n            if (removeMark) {\n                tr.removeStoredMark(removeMark);\n            }\n            tr.insertText(\" \", currentPos.pos);\n            editor.view.dispatch(tr);\n            return true;\n        }\n        return false;\n    }\n}\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\n/**\n * Paste rules are used to react to pasted content.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */ class PasteRule {\n    constructor(config){\n        this.find = config.find;\n        this.handler = config.handler;\n    }\n}\nconst pasteRuleMatcherHandler = (text, find, event)=>{\n    if (isRegExp(find)) {\n        return [\n            ...text.matchAll(find)\n        ];\n    }\n    const matches = find(text, event);\n    if (!matches) {\n        return [];\n    }\n    return matches.map((pasteRuleMatch)=>{\n        const result = [\n            pasteRuleMatch.text\n        ];\n        result.index = pasteRuleMatch.index;\n        result.input = text;\n        result.data = pasteRuleMatch.data;\n        if (pasteRuleMatch.replaceWith) {\n            if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n                console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n            }\n            result.push(pasteRuleMatch.replaceWith);\n        }\n        return result;\n    });\n};\nfunction run(config) {\n    const { editor, state, from, to, rule, pasteEvent, dropEvent } = config;\n    const { commands, chain, can } = new CommandManager({\n        editor,\n        state\n    });\n    const handlers = [];\n    state.doc.nodesBetween(from, to, (node, pos)=>{\n        if (!node.isTextblock || node.type.spec.code) {\n            return;\n        }\n        const resolvedFrom = Math.max(from, pos);\n        const resolvedTo = Math.min(to, pos + node.content.size);\n        const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, \"￼\");\n        const matches = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);\n        matches.forEach((match)=>{\n            if (match.index === undefined) {\n                return;\n            }\n            const start = resolvedFrom + match.index + 1;\n            const end = start + match[0].length;\n            const range = {\n                from: state.tr.mapping.map(start),\n                to: state.tr.mapping.map(end)\n            };\n            const handler = rule.handler({\n                state,\n                range,\n                match,\n                commands,\n                chain,\n                can,\n                pasteEvent,\n                dropEvent\n            });\n            handlers.push(handler);\n        });\n    });\n    const success = handlers.every((handler)=>handler !== null);\n    return success;\n}\n// When dragging across editors, must get another editor instance to delete selection content.\nlet tiptapDragFromOtherEditor = null;\nconst createClipboardPasteEvent = (text)=>{\n    var _a;\n    const event = new ClipboardEvent(\"paste\", {\n        clipboardData: new DataTransfer()\n    });\n    (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.setData(\"text/html\", text);\n    return event;\n};\n/**\n * Create an paste rules plugin. When enabled, it will cause pasted\n * text that matches any of the given rules to trigger the rule’s\n * action.\n */ function pasteRulesPlugin(props) {\n    const { editor, rules } = props;\n    let dragSourceElement = null;\n    let isPastedFromProseMirror = false;\n    let isDroppedFromProseMirror = false;\n    let pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n    let dropEvent;\n    try {\n        dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n    } catch  {\n        dropEvent = null;\n    }\n    const processEvent = ({ state, from, to, rule, pasteEvt })=>{\n        const tr = state.tr;\n        const chainableState = createChainableState({\n            state,\n            transaction: tr\n        });\n        const handler = run({\n            editor,\n            state: chainableState,\n            from: Math.max(from - 1, 0),\n            to: to.b - 1,\n            rule,\n            pasteEvent: pasteEvt,\n            dropEvent\n        });\n        if (!handler || !tr.steps.length) {\n            return;\n        }\n        try {\n            dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n        } catch  {\n            dropEvent = null;\n        }\n        pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n        return tr;\n    };\n    const plugins = rules.map((rule)=>{\n        return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n            // we register a global drag handler to track the current drag source element\n            view (view) {\n                const handleDragstart = (event)=>{\n                    var _a;\n                    dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n                    if (dragSourceElement) {\n                        tiptapDragFromOtherEditor = editor;\n                    }\n                };\n                const handleDragend = ()=>{\n                    if (tiptapDragFromOtherEditor) {\n                        tiptapDragFromOtherEditor = null;\n                    }\n                };\n                window.addEventListener(\"dragstart\", handleDragstart);\n                window.addEventListener(\"dragend\", handleDragend);\n                return {\n                    destroy () {\n                        window.removeEventListener(\"dragstart\", handleDragstart);\n                        window.removeEventListener(\"dragend\", handleDragend);\n                    }\n                };\n            },\n            props: {\n                handleDOMEvents: {\n                    drop: (view, event)=>{\n                        isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n                        dropEvent = event;\n                        if (!isDroppedFromProseMirror) {\n                            const dragFromOtherEditor = tiptapDragFromOtherEditor;\n                            if (dragFromOtherEditor) {\n                                // setTimeout to avoid the wrong content after drop, timeout arg can't be empty or 0\n                                setTimeout(()=>{\n                                    const selection = dragFromOtherEditor.state.selection;\n                                    if (selection) {\n                                        dragFromOtherEditor.commands.deleteRange({\n                                            from: selection.from,\n                                            to: selection.to\n                                        });\n                                    }\n                                }, 10);\n                            }\n                        }\n                        return false;\n                    },\n                    paste: (_view, event)=>{\n                        var _a;\n                        const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData(\"text/html\");\n                        pasteEvent = event;\n                        isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes(\"data-pm-slice\"));\n                        return false;\n                    }\n                }\n            },\n            appendTransaction: (transactions, oldState, state)=>{\n                const transaction = transactions[0];\n                const isPaste = transaction.getMeta(\"uiEvent\") === \"paste\" && !isPastedFromProseMirror;\n                const isDrop = transaction.getMeta(\"uiEvent\") === \"drop\" && !isDroppedFromProseMirror;\n                // if PasteRule is triggered by insertContent()\n                const simulatedPasteMeta = transaction.getMeta(\"applyPasteRules\");\n                const isSimulatedPaste = !!simulatedPasteMeta;\n                if (!isPaste && !isDrop && !isSimulatedPaste) {\n                    return;\n                }\n                // Handle simulated paste\n                if (isSimulatedPaste) {\n                    let { text } = simulatedPasteMeta;\n                    if (typeof text === \"string\") {\n                        text = text;\n                    } else {\n                        text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n                    }\n                    const { from } = simulatedPasteMeta;\n                    const to = from + text.length;\n                    const pasteEvt = createClipboardPasteEvent(text);\n                    return processEvent({\n                        rule,\n                        state,\n                        from,\n                        to: {\n                            b: to\n                        },\n                        pasteEvt\n                    });\n                }\n                // handle actual paste/drop\n                const from = oldState.doc.content.findDiffStart(state.doc.content);\n                const to = oldState.doc.content.findDiffEnd(state.doc.content);\n                // stop if there is no changed range\n                if (!isNumber(from) || !to || from === to.b) {\n                    return;\n                }\n                return processEvent({\n                    rule,\n                    state,\n                    from,\n                    to,\n                    pasteEvt: pasteEvent\n                });\n            }\n        });\n    });\n    return plugins;\n}\nfunction findDuplicates(items) {\n    const filtered = items.filter((el, index)=>items.indexOf(el) !== index);\n    return Array.from(new Set(filtered));\n}\nclass ExtensionManager {\n    constructor(extensions, editor){\n        this.splittableMarks = [];\n        this.editor = editor;\n        this.extensions = ExtensionManager.resolve(extensions);\n        this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\n        this.setupExtensions();\n    }\n    /**\n     * Returns a flattened and sorted extension list while\n     * also checking for duplicated extensions and warns the user.\n     * @param extensions An array of Tiptap extensions\n     * @returns An flattened and sorted array of Tiptap extensions\n     */ static resolve(extensions) {\n        const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\n        const duplicatedNames = findDuplicates(resolvedExtensions.map((extension)=>extension.name));\n        if (duplicatedNames.length) {\n            console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item)=>`'${item}'`).join(\", \")}]. This can lead to issues.`);\n        }\n        return resolvedExtensions;\n    }\n    /**\n     * Create a flattened array of extensions by traversing the `addExtensions` field.\n     * @param extensions An array of Tiptap extensions\n     * @returns A flattened array of Tiptap extensions\n     */ static flatten(extensions) {\n        return extensions.map((extension)=>{\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage\n            };\n            const addExtensions = getExtensionField(extension, \"addExtensions\", context);\n            if (addExtensions) {\n                return [\n                    extension,\n                    ...this.flatten(addExtensions())\n                ];\n            }\n            return extension;\n        })// `Infinity` will break TypeScript so we set a number that is probably high enough\n        .flat(10);\n    }\n    /**\n     * Sort extensions by priority.\n     * @param extensions An array of Tiptap extensions\n     * @returns A sorted array of Tiptap extensions by priority\n     */ static sort(extensions) {\n        const defaultPriority = 100;\n        return extensions.sort((a, b)=>{\n            const priorityA = getExtensionField(a, \"priority\") || defaultPriority;\n            const priorityB = getExtensionField(b, \"priority\") || defaultPriority;\n            if (priorityA > priorityB) {\n                return -1;\n            }\n            if (priorityA < priorityB) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n    /**\n     * Get all commands from the extensions.\n     * @returns An object with all commands where the key is the command name and the value is the command function\n     */ get commands() {\n        return this.extensions.reduce((commands, extension)=>{\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor: this.editor,\n                type: getSchemaTypeByName(extension.name, this.schema)\n            };\n            const addCommands = getExtensionField(extension, \"addCommands\", context);\n            if (!addCommands) {\n                return commands;\n            }\n            return {\n                ...commands,\n                ...addCommands()\n            };\n        }, {});\n    }\n    /**\n     * Get all registered Prosemirror plugins from the extensions.\n     * @returns An array of Prosemirror plugins\n     */ get plugins() {\n        const { editor } = this;\n        // With ProseMirror, first plugins within an array are executed first.\n        // In Tiptap, we provide the ability to override plugins,\n        // so it feels more natural to run plugins at the end of an array first.\n        // That’s why we have to reverse the `extensions` array and sort again\n        // based on the `priority` option.\n        const extensions = ExtensionManager.sort([\n            ...this.extensions\n        ].reverse());\n        const inputRules = [];\n        const pasteRules = [];\n        const allPlugins = extensions.map((extension)=>{\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor,\n                type: getSchemaTypeByName(extension.name, this.schema)\n            };\n            const plugins = [];\n            const addKeyboardShortcuts = getExtensionField(extension, \"addKeyboardShortcuts\", context);\n            let defaultBindings = {};\n            // bind exit handling\n            if (extension.type === \"mark\" && getExtensionField(extension, \"exitable\", context)) {\n                defaultBindings.ArrowRight = ()=>Mark.handleExit({\n                        editor,\n                        mark: extension\n                    });\n            }\n            if (addKeyboardShortcuts) {\n                const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method])=>{\n                    return [\n                        shortcut,\n                        ()=>method({\n                                editor\n                            })\n                    ];\n                }));\n                defaultBindings = {\n                    ...defaultBindings,\n                    ...bindings\n                };\n            }\n            const keyMapPlugin = (0,_tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__.keymap)(defaultBindings);\n            plugins.push(keyMapPlugin);\n            const addInputRules = getExtensionField(extension, \"addInputRules\", context);\n            if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n                inputRules.push(...addInputRules());\n            }\n            const addPasteRules = getExtensionField(extension, \"addPasteRules\", context);\n            if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n                pasteRules.push(...addPasteRules());\n            }\n            const addProseMirrorPlugins = getExtensionField(extension, \"addProseMirrorPlugins\", context);\n            if (addProseMirrorPlugins) {\n                const proseMirrorPlugins = addProseMirrorPlugins();\n                plugins.push(...proseMirrorPlugins);\n            }\n            return plugins;\n        }).flat();\n        return [\n            inputRulesPlugin({\n                editor,\n                rules: inputRules\n            }),\n            ...pasteRulesPlugin({\n                editor,\n                rules: pasteRules\n            }),\n            ...allPlugins\n        ];\n    }\n    /**\n     * Get all attributes from the extensions.\n     * @returns An array of attributes\n     */ get attributes() {\n        return getAttributesFromExtensions(this.extensions);\n    }\n    /**\n     * Get all node views from the extensions.\n     * @returns An object with all node views where the key is the node name and the value is the node view function\n     */ get nodeViews() {\n        const { editor } = this;\n        const { nodeExtensions } = splitExtensions(this.extensions);\n        return Object.fromEntries(nodeExtensions.filter((extension)=>!!getExtensionField(extension, \"addNodeView\")).map((extension)=>{\n            const extensionAttributes = this.attributes.filter((attribute)=>attribute.type === extension.name);\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor,\n                type: getNodeType(extension.name, this.schema)\n            };\n            const addNodeView = getExtensionField(extension, \"addNodeView\", context);\n            if (!addNodeView) {\n                return [];\n            }\n            const nodeview = (node, view, getPos, decorations, innerDecorations)=>{\n                const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n                return addNodeView()({\n                    // pass-through\n                    node,\n                    view,\n                    getPos: getPos,\n                    decorations,\n                    innerDecorations,\n                    // tiptap-specific\n                    editor,\n                    extension,\n                    HTMLAttributes\n                });\n            };\n            return [\n                extension.name,\n                nodeview\n            ];\n        }));\n    }\n    /**\n     * Go through all extensions, create extension storages & setup marks\n     * & bind editor event listener.\n     */ setupExtensions() {\n        this.extensions.forEach((extension)=>{\n            var _a;\n            // store extension storage in editor\n            this.editor.extensionStorage[extension.name] = extension.storage;\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor: this.editor,\n                type: getSchemaTypeByName(extension.name, this.schema)\n            };\n            if (extension.type === \"mark\") {\n                const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, \"keepOnSplit\", context))) !== null && _a !== void 0 ? _a : true;\n                if (keepOnSplit) {\n                    this.splittableMarks.push(extension.name);\n                }\n            }\n            const onBeforeCreate = getExtensionField(extension, \"onBeforeCreate\", context);\n            const onCreate = getExtensionField(extension, \"onCreate\", context);\n            const onUpdate = getExtensionField(extension, \"onUpdate\", context);\n            const onSelectionUpdate = getExtensionField(extension, \"onSelectionUpdate\", context);\n            const onTransaction = getExtensionField(extension, \"onTransaction\", context);\n            const onFocus = getExtensionField(extension, \"onFocus\", context);\n            const onBlur = getExtensionField(extension, \"onBlur\", context);\n            const onDestroy = getExtensionField(extension, \"onDestroy\", context);\n            if (onBeforeCreate) {\n                this.editor.on(\"beforeCreate\", onBeforeCreate);\n            }\n            if (onCreate) {\n                this.editor.on(\"create\", onCreate);\n            }\n            if (onUpdate) {\n                this.editor.on(\"update\", onUpdate);\n            }\n            if (onSelectionUpdate) {\n                this.editor.on(\"selectionUpdate\", onSelectionUpdate);\n            }\n            if (onTransaction) {\n                this.editor.on(\"transaction\", onTransaction);\n            }\n            if (onFocus) {\n                this.editor.on(\"focus\", onFocus);\n            }\n            if (onBlur) {\n                this.editor.on(\"blur\", onBlur);\n            }\n            if (onDestroy) {\n                this.editor.on(\"destroy\", onDestroy);\n            }\n        });\n    }\n}\n/**\n * The Extension class is the base class for all extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */ class Extension {\n    constructor(config = {}){\n        this.type = \"extension\";\n        this.name = \"extension\";\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {}\n        };\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, \"addOptions\", {\n                name: this.name\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, \"addStorage\", {\n            name: this.name,\n            options: this.options\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Extension(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend({\n            ...this.config,\n            addOptions: ()=>{\n                return mergeDeep(this.options, options);\n            }\n        });\n        // Always preserve the current name\n        extension.name = this.name;\n        // Set the parent to be our parent\n        extension.parent = this.parent;\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Extension({\n            ...this.config,\n            ...extendedConfig\n        });\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, \"addOptions\", {\n            name: extension.name\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n            name: extension.name,\n            options: extension.options\n        }));\n        return extension;\n    }\n}\n/**\n * Gets the text between two positions in a Prosemirror node\n * and serializes it using the given text serializers and block separator (see getText)\n * @param startNode The Prosemirror node to start from\n * @param range The range of the text to get\n * @param options Options for the text serializer & block separator\n * @returns The text between the two positions\n */ function getTextBetween(startNode, range, options) {\n    const { from, to } = range;\n    const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n    let text = \"\";\n    startNode.nodesBetween(from, to, (node, pos, parent, index)=>{\n        var _a;\n        if (node.isBlock && pos > from) {\n            text += blockSeparator;\n        }\n        const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\n        if (textSerializer) {\n            if (parent) {\n                text += textSerializer({\n                    node,\n                    pos,\n                    parent,\n                    index,\n                    range\n                });\n            }\n            // do not descend into child nodes when there exists a serializer\n            return false;\n        }\n        if (node.isText) {\n            text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos); // eslint-disable-line\n        }\n    });\n    return text;\n}\n/**\n * Find text serializers `toText` in a Prosemirror schema\n * @param schema The Prosemirror schema to search in\n * @returns A record of text serializers by node name\n */ function getTextSerializersFromSchema(schema) {\n    return Object.fromEntries(Object.entries(schema.nodes).filter(([, node])=>node.spec.toText).map(([name, node])=>[\n            name,\n            node.spec.toText\n        ]));\n}\nconst ClipboardTextSerializer = Extension.create({\n    name: \"clipboardTextSerializer\",\n    addOptions () {\n        return {\n            blockSeparator: undefined\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"clipboardTextSerializer\"),\n                props: {\n                    clipboardTextSerializer: ()=>{\n                        const { editor } = this;\n                        const { state, schema } = editor;\n                        const { doc, selection } = state;\n                        const { ranges } = selection;\n                        const from = Math.min(...ranges.map((range)=>range.$from.pos));\n                        const to = Math.max(...ranges.map((range)=>range.$to.pos));\n                        const textSerializers = getTextSerializersFromSchema(schema);\n                        const range = {\n                            from,\n                            to\n                        };\n                        return getTextBetween(doc, range, {\n                            ...this.options.blockSeparator !== undefined ? {\n                                blockSeparator: this.options.blockSeparator\n                            } : {},\n                            textSerializers\n                        });\n                    }\n                }\n            })\n        ];\n    }\n});\nconst blur = ()=>({ editor, view })=>{\n        requestAnimationFrame(()=>{\n            var _a;\n            if (!editor.isDestroyed) {\n                view.dom.blur();\n                // Browsers should remove the caret on blur but safari does not.\n                // See: https://github.com/ueberdosis/tiptap/issues/2405\n                (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n            }\n        });\n        return true;\n    };\nconst clearContent = (emitUpdate = false)=>({ commands })=>{\n        return commands.setContent(\"\", emitUpdate);\n    };\nconst clearNodes = ()=>({ state, tr, dispatch })=>{\n        const { selection } = tr;\n        const { ranges } = selection;\n        if (!dispatch) {\n            return true;\n        }\n        ranges.forEach(({ $from, $to })=>{\n            state.doc.nodesBetween($from.pos, $to.pos, (node, pos)=>{\n                if (node.type.isText) {\n                    return;\n                }\n                const { doc, mapping } = tr;\n                const $mappedFrom = doc.resolve(mapping.map(pos));\n                const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n                const nodeRange = $mappedFrom.blockRange($mappedTo);\n                if (!nodeRange) {\n                    return;\n                }\n                const targetLiftDepth = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.liftTarget)(nodeRange);\n                if (node.type.isTextblock) {\n                    const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n                    tr.setNodeMarkup(nodeRange.start, defaultType);\n                }\n                if (targetLiftDepth || targetLiftDepth === 0) {\n                    tr.lift(nodeRange, targetLiftDepth);\n                }\n            });\n        });\n        return true;\n    };\nconst command = (fn)=>(props)=>{\n        return fn(props);\n    };\nconst createParagraphNear = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.createParagraphNear)(state, dispatch);\n    };\nconst cut = (originRange, targetPos)=>({ editor, tr })=>{\n        const { state } = editor;\n        const contentSlice = state.doc.slice(originRange.from, originRange.to);\n        tr.deleteRange(originRange.from, originRange.to);\n        const newPos = tr.mapping.map(targetPos);\n        tr.insert(newPos, contentSlice.content);\n        tr.setSelection(new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(tr.doc.resolve(newPos - 1)));\n        return true;\n    };\nconst deleteCurrentNode = ()=>({ tr, dispatch })=>{\n        const { selection } = tr;\n        const currentNode = selection.$anchor.node();\n        // if there is content inside the current node, break out of this command\n        if (currentNode.content.size > 0) {\n            return false;\n        }\n        const $pos = tr.selection.$anchor;\n        for(let depth = $pos.depth; depth > 0; depth -= 1){\n            const node = $pos.node(depth);\n            if (node.type === currentNode.type) {\n                if (dispatch) {\n                    const from = $pos.before(depth);\n                    const to = $pos.after(depth);\n                    tr.delete(from, to).scrollIntoView();\n                }\n                return true;\n            }\n        }\n        return false;\n    };\nconst deleteNode = (typeOrName)=>({ tr, state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const $pos = tr.selection.$anchor;\n        for(let depth = $pos.depth; depth > 0; depth -= 1){\n            const node = $pos.node(depth);\n            if (node.type === type) {\n                if (dispatch) {\n                    const from = $pos.before(depth);\n                    const to = $pos.after(depth);\n                    tr.delete(from, to).scrollIntoView();\n                }\n                return true;\n            }\n        }\n        return false;\n    };\nconst deleteRange = (range)=>({ tr, dispatch })=>{\n        const { from, to } = range;\n        if (dispatch) {\n            tr.delete(from, to);\n        }\n        return true;\n    };\nconst deleteSelection = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.deleteSelection)(state, dispatch);\n    };\nconst enter = ()=>({ commands })=>{\n        return commands.keyboardShortcut(\"Enter\");\n    };\nconst exitCode = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.exitCode)(state, dispatch);\n    };\n/**\n * Check if object1 includes object2\n * @param object1 Object\n * @param object2 Object\n */ function objectIncludes(object1, object2, options = {\n    strict: true\n}) {\n    const keys = Object.keys(object2);\n    if (!keys.length) {\n        return true;\n    }\n    return keys.every((key)=>{\n        if (options.strict) {\n            return object2[key] === object1[key];\n        }\n        if (isRegExp(object2[key])) {\n            return object2[key].test(object1[key]);\n        }\n        return object2[key] === object1[key];\n    });\n}\nfunction findMarkInSet(marks, type, attributes = {}) {\n    return marks.find((item)=>{\n        return item.type === type && objectIncludes(// Only check equality for the attributes that are provided\n        Object.fromEntries(Object.keys(attributes).map((k)=>[\n                k,\n                item.attrs[k]\n            ])), attributes);\n    });\n}\nfunction isMarkInSet(marks, type, attributes = {}) {\n    return !!findMarkInSet(marks, type, attributes);\n}\n/**\n * Get the range of a mark at a resolved position.\n */ function getMarkRange(/**\n * The position to get the mark range for.\n */ $pos, /**\n * The mark type to get the range for.\n */ type, /**\n * The attributes to match against.\n * If not provided, only the first mark at the position will be matched.\n */ attributes) {\n    var _a;\n    if (!$pos || !type) {\n        return;\n    }\n    let start = $pos.parent.childAfter($pos.parentOffset);\n    // If the cursor is at the start of a text node that does not have the mark, look backward\n    if (!start.node || !start.node.marks.some((mark)=>mark.type === type)) {\n        start = $pos.parent.childBefore($pos.parentOffset);\n    }\n    // If there is no text node with the mark even backward, return undefined\n    if (!start.node || !start.node.marks.some((mark)=>mark.type === type)) {\n        return;\n    }\n    // Default to only matching against the first mark's attributes\n    attributes = attributes || ((_a = start.node.marks[0]) === null || _a === void 0 ? void 0 : _a.attrs);\n    // We now know that the cursor is either at the start, middle or end of a text node with the specified mark\n    // so we can look it up on the targeted mark\n    const mark = findMarkInSet([\n        ...start.node.marks\n    ], type, attributes);\n    if (!mark) {\n        return;\n    }\n    let startIndex = start.index;\n    let startPos = $pos.start() + start.offset;\n    let endIndex = startIndex + 1;\n    let endPos = startPos + start.node.nodeSize;\n    while(startIndex > 0 && isMarkInSet([\n        ...$pos.parent.child(startIndex - 1).marks\n    ], type, attributes)){\n        startIndex -= 1;\n        startPos -= $pos.parent.child(startIndex).nodeSize;\n    }\n    while(endIndex < $pos.parent.childCount && isMarkInSet([\n        ...$pos.parent.child(endIndex).marks\n    ], type, attributes)){\n        endPos += $pos.parent.child(endIndex).nodeSize;\n        endIndex += 1;\n    }\n    return {\n        from: startPos,\n        to: endPos\n    };\n}\nfunction getMarkType(nameOrType, schema) {\n    if (typeof nameOrType === \"string\") {\n        if (!schema.marks[nameOrType]) {\n            throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n        }\n        return schema.marks[nameOrType];\n    }\n    return nameOrType;\n}\nconst extendMarkRange = (typeOrName, attributes = {})=>({ tr, state, dispatch })=>{\n        const type = getMarkType(typeOrName, state.schema);\n        const { doc, selection } = tr;\n        const { $from, from, to } = selection;\n        if (dispatch) {\n            const range = getMarkRange($from, type, attributes);\n            if (range && range.from <= from && range.to >= to) {\n                const newSelection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, range.from, range.to);\n                tr.setSelection(newSelection);\n            }\n        }\n        return true;\n    };\nconst first = (commands)=>(props)=>{\n        const items = typeof commands === \"function\" ? commands(props) : commands;\n        for(let i = 0; i < items.length; i += 1){\n            if (items[i](props)) {\n                return true;\n            }\n        }\n        return false;\n    };\nfunction isTextSelection(value) {\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection;\n}\nfunction minMax(value = 0, min = 0, max = 0) {\n    return Math.min(Math.max(value, min), max);\n}\nfunction resolveFocusPosition(doc, position = null) {\n    if (!position) {\n        return null;\n    }\n    const selectionAtStart = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc);\n    const selectionAtEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(doc);\n    if (position === \"start\" || position === true) {\n        return selectionAtStart;\n    }\n    if (position === \"end\") {\n        return selectionAtEnd;\n    }\n    const minPos = selectionAtStart.from;\n    const maxPos = selectionAtEnd.to;\n    if (position === \"all\") {\n        return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n    }\n    return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\nfunction isAndroid() {\n    return navigator.platform === \"Android\" || /android/i.test(navigator.userAgent);\n}\nfunction isiOS() {\n    return [\n        \"iPad Simulator\",\n        \"iPhone Simulator\",\n        \"iPod Simulator\",\n        \"iPad\",\n        \"iPhone\",\n        \"iPod\"\n    ].includes(navigator.platform) || navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document;\n}\nconst focus = (position = null, options = {})=>({ editor, view, tr, dispatch })=>{\n        options = {\n            scrollIntoView: true,\n            ...options\n        };\n        const delayedFocus = ()=>{\n            // focus within `requestAnimationFrame` breaks focus on iOS and Android\n            // so we have to call this\n            if (isiOS() || isAndroid()) {\n                view.dom.focus();\n            }\n            // For React we have to focus asynchronously. Otherwise wild things happen.\n            // see: https://github.com/ueberdosis/tiptap/issues/1520\n            requestAnimationFrame(()=>{\n                if (!editor.isDestroyed) {\n                    view.focus();\n                    if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\n                        editor.commands.scrollIntoView();\n                    }\n                }\n            });\n        };\n        if (view.hasFocus() && position === null || position === false) {\n            return true;\n        }\n        // we don’t try to resolve a NodeSelection or CellSelection\n        if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n            delayedFocus();\n            return true;\n        }\n        // pass through tr.doc instead of editor.state.doc\n        // since transactions could change the editors state before this command has been run\n        const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n        const isSameSelection = editor.state.selection.eq(selection);\n        if (dispatch) {\n            if (!isSameSelection) {\n                tr.setSelection(selection);\n            }\n            // `tr.setSelection` resets the stored marks\n            // so we’ll restore them if the selection is the same as before\n            if (isSameSelection && tr.storedMarks) {\n                tr.setStoredMarks(tr.storedMarks);\n            }\n            delayedFocus();\n        }\n        return true;\n    };\nconst forEach = (items, fn)=>(props)=>{\n        return items.every((item, index)=>fn(item, {\n                ...props,\n                index\n            }));\n    };\nconst insertContent = (value, options)=>({ tr, commands })=>{\n        return commands.insertContentAt({\n            from: tr.selection.from,\n            to: tr.selection.to\n        }, value, options);\n    };\nconst removeWhitespaces = (node)=>{\n    const children = node.childNodes;\n    for(let i = children.length - 1; i >= 0; i -= 1){\n        const child = children[i];\n        if (child.nodeType === 3 && child.nodeValue && /^(\\n\\s\\s|\\n)$/.test(child.nodeValue)) {\n            node.removeChild(child);\n        } else if (child.nodeType === 1) {\n            removeWhitespaces(child);\n        }\n    }\n    return node;\n};\nfunction elementFromString(value) {\n    // add a wrapper to preserve leading and trailing whitespace\n    const wrappedValue = `<body>${value}</body>`;\n    const html = new window.DOMParser().parseFromString(wrappedValue, \"text/html\").body;\n    return removeWhitespaces(html);\n}\n/**\n * Takes a JSON or HTML content and creates a Prosemirror node or fragment from it.\n * @param content The JSON or HTML content to create the node from\n * @param schema The Prosemirror schema to use for the node\n * @param options Options for the parser\n * @returns The created Prosemirror node or fragment\n */ function createNodeFromContent(content, schema, options) {\n    if (content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node || content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n        return content;\n    }\n    options = {\n        slice: true,\n        parseOptions: {},\n        ...options\n    };\n    const isJSONContent = typeof content === \"object\" && content !== null;\n    const isTextContent = typeof content === \"string\";\n    if (isJSONContent) {\n        try {\n            const isArrayContent = Array.isArray(content) && content.length > 0;\n            // if the JSON Content is an array of nodes, create a fragment for each node\n            if (isArrayContent) {\n                return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.fromArray(content.map((item)=>schema.nodeFromJSON(item)));\n            }\n            const node = schema.nodeFromJSON(content);\n            if (options.errorOnInvalidContent) {\n                node.check();\n            }\n            return node;\n        } catch (error) {\n            if (options.errorOnInvalidContent) {\n                throw new Error(\"[tiptap error]: Invalid JSON content\", {\n                    cause: error\n                });\n            }\n            console.warn(\"[tiptap warn]: Invalid content.\", \"Passed value:\", content, \"Error:\", error);\n            return createNodeFromContent(\"\", schema, options);\n        }\n    }\n    if (isTextContent) {\n        // Check for invalid content\n        if (options.errorOnInvalidContent) {\n            let hasInvalidContent = false;\n            let invalidContent = \"\";\n            // A copy of the current schema with a catch-all node at the end\n            const contentCheckSchema = new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n                topNode: schema.spec.topNode,\n                marks: schema.spec.marks,\n                // Prosemirror's schemas are executed such that: the last to execute, matches last\n                // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle\n                nodes: schema.spec.nodes.append({\n                    __tiptap__private__unknown__catch__all__node: {\n                        content: \"inline*\",\n                        group: \"block\",\n                        parseDOM: [\n                            {\n                                tag: \"*\",\n                                getAttrs: (e)=>{\n                                    // If this is ever called, we know that the content has something that we don't know how to handle in the schema\n                                    hasInvalidContent = true;\n                                    // Try to stringify the element for a more helpful error message\n                                    invalidContent = typeof e === \"string\" ? e : e.outerHTML;\n                                    return null;\n                                }\n                            }\n                        ]\n                    }\n                })\n            });\n            if (options.slice) {\n                _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);\n            } else {\n                _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);\n            }\n            if (options.errorOnInvalidContent && hasInvalidContent) {\n                throw new Error(\"[tiptap error]: Invalid HTML content\", {\n                    cause: new Error(`Invalid element found: ${invalidContent}`)\n                });\n            }\n        }\n        const parser = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema);\n        if (options.slice) {\n            return parser.parseSlice(elementFromString(content), options.parseOptions).content;\n        }\n        return parser.parse(elementFromString(content), options.parseOptions);\n    }\n    return createNodeFromContent(\"\", schema, options);\n}\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n    const last = tr.steps.length - 1;\n    if (last < startLen) {\n        return;\n    }\n    const step = tr.steps[last];\n    if (!(step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceStep || step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceAroundStep)) {\n        return;\n    }\n    const map = tr.mapping.maps[last];\n    let end = 0;\n    map.forEach((_from, _to, _newFrom, newTo)=>{\n        if (end === 0) {\n            end = newTo;\n        }\n    });\n    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve(end), bias));\n}\nconst isFragment = (nodeOrFragment)=>{\n    return !(\"type\" in nodeOrFragment);\n};\nconst insertContentAt = (position, value, options)=>({ tr, dispatch, editor })=>{\n        var _a;\n        if (dispatch) {\n            options = {\n                parseOptions: editor.options.parseOptions,\n                updateSelection: true,\n                applyInputRules: false,\n                applyPasteRules: false,\n                ...options\n            };\n            let content;\n            try {\n                content = createNodeFromContent(value, editor.schema, {\n                    parseOptions: {\n                        preserveWhitespace: \"full\",\n                        ...options.parseOptions\n                    },\n                    errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck\n                });\n            } catch (e) {\n                editor.emit(\"contentError\", {\n                    editor,\n                    error: e,\n                    disableCollaboration: ()=>{\n                        if (editor.storage.collaboration) {\n                            editor.storage.collaboration.isDisabled = true;\n                        }\n                    }\n                });\n                return false;\n            }\n            let { from, to } = typeof position === \"number\" ? {\n                from: position,\n                to: position\n            } : {\n                from: position.from,\n                to: position.to\n            };\n            let isOnlyTextContent = true;\n            let isOnlyBlockContent = true;\n            const nodes = isFragment(content) ? content : [\n                content\n            ];\n            nodes.forEach((node)=>{\n                // check if added node is valid\n                node.check();\n                isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n                isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n            });\n            // check if we can replace the wrapping node by\n            // the newly inserted content\n            // example:\n            // replace an empty paragraph by an inserted image\n            // instead of inserting the image below the paragraph\n            if (from === to && isOnlyBlockContent) {\n                const { parent } = tr.doc.resolve(from);\n                const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n                if (isEmptyTextBlock) {\n                    from -= 1;\n                    to += 1;\n                }\n            }\n            let newContent;\n            // if there is only plain text we have to use `insertText`\n            // because this will keep the current marks\n            if (isOnlyTextContent) {\n                // if value is string, we can use it directly\n                // otherwise if it is an array, we have to join it\n                if (Array.isArray(value)) {\n                    newContent = value.map((v)=>v.text || \"\").join(\"\");\n                } else if (value instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n                    let text = \"\";\n                    value.forEach((node)=>{\n                        if (node.text) {\n                            text += node.text;\n                        }\n                    });\n                    newContent = text;\n                } else if (typeof value === \"object\" && !!value && !!value.text) {\n                    newContent = value.text;\n                } else {\n                    newContent = value;\n                }\n                tr.insertText(newContent, from, to);\n            } else {\n                newContent = content;\n                tr.replaceWith(from, to, newContent);\n            }\n            // set cursor at end of inserted content\n            if (options.updateSelection) {\n                selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n            }\n            if (options.applyInputRules) {\n                tr.setMeta(\"applyInputRules\", {\n                    from,\n                    text: newContent\n                });\n            }\n            if (options.applyPasteRules) {\n                tr.setMeta(\"applyPasteRules\", {\n                    from,\n                    text: newContent\n                });\n            }\n        }\n        return true;\n    };\nconst joinUp = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinUp)(state, dispatch);\n    };\nconst joinDown = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinDown)(state, dispatch);\n    };\nconst joinBackward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinBackward)(state, dispatch);\n    };\nconst joinForward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinForward)(state, dispatch);\n    };\nconst joinItemBackward = ()=>({ state, dispatch, tr })=>{\n        try {\n            const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, -1);\n            if (point === null || point === undefined) {\n                return false;\n            }\n            tr.join(point, 2);\n            if (dispatch) {\n                dispatch(tr);\n            }\n            return true;\n        } catch  {\n            return false;\n        }\n    };\nconst joinItemForward = ()=>({ state, dispatch, tr })=>{\n        try {\n            const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, +1);\n            if (point === null || point === undefined) {\n                return false;\n            }\n            tr.join(point, 2);\n            if (dispatch) {\n                dispatch(tr);\n            }\n            return true;\n        } catch  {\n            return false;\n        }\n    };\nconst joinTextblockBackward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinTextblockBackward)(state, dispatch);\n    };\nconst joinTextblockForward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinTextblockForward)(state, dispatch);\n    };\nfunction isMacOS() {\n    return typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\n}\nfunction normalizeKeyName(name) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result === \"Space\") {\n        result = \" \";\n    }\n    let alt;\n    let ctrl;\n    let shift;\n    let meta;\n    for(let i = 0; i < parts.length - 1; i += 1){\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod)) {\n            meta = true;\n        } else if (/^a(lt)?$/i.test(mod)) {\n            alt = true;\n        } else if (/^(c|ctrl|control)$/i.test(mod)) {\n            ctrl = true;\n        } else if (/^s(hift)?$/i.test(mod)) {\n            shift = true;\n        } else if (/^mod$/i.test(mod)) {\n            if (isiOS() || isMacOS()) {\n                meta = true;\n            } else {\n                ctrl = true;\n            }\n        } else {\n            throw new Error(`Unrecognized modifier name: ${mod}`);\n        }\n    }\n    if (alt) {\n        result = `Alt-${result}`;\n    }\n    if (ctrl) {\n        result = `Ctrl-${result}`;\n    }\n    if (meta) {\n        result = `Meta-${result}`;\n    }\n    if (shift) {\n        result = `Shift-${result}`;\n    }\n    return result;\n}\nconst keyboardShortcut = (name)=>({ editor, view, tr, dispatch })=>{\n        const keys = normalizeKeyName(name).split(/-(?!$)/);\n        const key = keys.find((item)=>![\n                \"Alt\",\n                \"Ctrl\",\n                \"Meta\",\n                \"Shift\"\n            ].includes(item));\n        const event = new KeyboardEvent(\"keydown\", {\n            key: key === \"Space\" ? \" \" : key,\n            altKey: keys.includes(\"Alt\"),\n            ctrlKey: keys.includes(\"Ctrl\"),\n            metaKey: keys.includes(\"Meta\"),\n            shiftKey: keys.includes(\"Shift\"),\n            bubbles: true,\n            cancelable: true\n        });\n        const capturedTransaction = editor.captureTransaction(()=>{\n            view.someProp(\"handleKeyDown\", (f)=>f(view, event));\n        });\n        capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step)=>{\n            const newStep = step.map(tr.mapping);\n            if (newStep && dispatch) {\n                tr.maybeStep(newStep);\n            }\n        });\n        return true;\n    };\nfunction isNodeActive(state, typeOrName, attributes = {}) {\n    const { from, to, empty } = state.selection;\n    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n    const nodeRanges = [];\n    state.doc.nodesBetween(from, to, (node, pos)=>{\n        if (node.isText) {\n            return;\n        }\n        const relativeFrom = Math.max(from, pos);\n        const relativeTo = Math.min(to, pos + node.nodeSize);\n        nodeRanges.push({\n            node,\n            from: relativeFrom,\n            to: relativeTo\n        });\n    });\n    const selectionRange = to - from;\n    const matchedNodeRanges = nodeRanges.filter((nodeRange)=>{\n        if (!type) {\n            return true;\n        }\n        return type.name === nodeRange.node.type.name;\n    }).filter((nodeRange)=>objectIncludes(nodeRange.node.attrs, attributes, {\n            strict: false\n        }));\n    if (empty) {\n        return !!matchedNodeRanges.length;\n    }\n    const range = matchedNodeRanges.reduce((sum, nodeRange)=>sum + nodeRange.to - nodeRange.from, 0);\n    return range >= selectionRange;\n}\nconst lift = (typeOrName, attributes = {})=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const isActive = isNodeActive(state, type, attributes);\n        if (!isActive) {\n            return false;\n        }\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.lift)(state, dispatch);\n    };\nconst liftEmptyBlock = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.liftEmptyBlock)(state, dispatch);\n    };\nconst liftListItem = (typeOrName)=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.liftListItem)(type)(state, dispatch);\n    };\nconst newlineInCode = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.newlineInCode)(state, dispatch);\n    };\n/**\n * Get the type of a schema item by its name.\n * @param name The name of the schema item\n * @param schema The Prosemiror schema to search in\n * @returns The type of the schema item (`node` or `mark`), or null if it doesn't exist\n */ function getSchemaTypeNameByName(name, schema) {\n    if (schema.nodes[name]) {\n        return \"node\";\n    }\n    if (schema.marks[name]) {\n        return \"mark\";\n    }\n    return null;\n}\n/**\n * Remove a property or an array of properties from an object\n * @param obj Object\n * @param key Key to remove\n */ function deleteProps(obj, propOrProps) {\n    const props = typeof propOrProps === \"string\" ? [\n        propOrProps\n    ] : propOrProps;\n    return Object.keys(obj).reduce((newObj, prop)=>{\n        if (!props.includes(prop)) {\n            newObj[prop] = obj[prop];\n        }\n        return newObj;\n    }, {});\n}\nconst resetAttributes = (typeOrName, attributes)=>({ tr, state, dispatch })=>{\n        let nodeType = null;\n        let markType = null;\n        const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n        if (!schemaType) {\n            return false;\n        }\n        if (schemaType === \"node\") {\n            nodeType = getNodeType(typeOrName, state.schema);\n        }\n        if (schemaType === \"mark\") {\n            markType = getMarkType(typeOrName, state.schema);\n        }\n        if (dispatch) {\n            tr.selection.ranges.forEach((range)=>{\n                state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos)=>{\n                    if (nodeType && nodeType === node.type) {\n                        tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n                    }\n                    if (markType && node.marks.length) {\n                        node.marks.forEach((mark)=>{\n                            if (markType === mark.type) {\n                                tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n                            }\n                        });\n                    }\n                });\n            });\n        }\n        return true;\n    };\nconst scrollIntoView = ()=>({ tr, dispatch })=>{\n        if (dispatch) {\n            tr.scrollIntoView();\n        }\n        return true;\n    };\nconst selectAll = ()=>({ tr, dispatch })=>{\n        if (dispatch) {\n            const selection = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection(tr.doc);\n            tr.setSelection(selection);\n        }\n        return true;\n    };\nconst selectNodeBackward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeBackward)(state, dispatch);\n    };\nconst selectNodeForward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeForward)(state, dispatch);\n    };\nconst selectParentNode = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectParentNode)(state, dispatch);\n    };\n// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nconst selectTextblockEnd = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockEnd)(state, dispatch);\n    };\n// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nconst selectTextblockStart = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockStart)(state, dispatch);\n    };\n/**\n * Create a new Prosemirror document node from content.\n * @param content The JSON or HTML content to create the document from\n * @param schema The Prosemirror schema to use for the document\n * @param parseOptions Options for the parser\n * @returns The created Prosemirror document node\n */ function createDocument(content, schema, parseOptions = {}, options = {}) {\n    return createNodeFromContent(content, schema, {\n        slice: false,\n        parseOptions,\n        errorOnInvalidContent: options.errorOnInvalidContent\n    });\n}\nconst setContent = (content, emitUpdate = false, parseOptions = {}, options = {})=>({ editor, tr, dispatch, commands })=>{\n        var _a, _b;\n        const { doc } = tr;\n        // This is to keep backward compatibility with the previous behavior\n        // TODO remove this in the next major version\n        if (parseOptions.preserveWhitespace !== \"full\") {\n            const document1 = createDocument(content, editor.schema, parseOptions, {\n                errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck\n            });\n            if (dispatch) {\n                tr.replaceWith(0, doc.content.size, document1).setMeta(\"preventUpdate\", !emitUpdate);\n            }\n            return true;\n        }\n        if (dispatch) {\n            tr.setMeta(\"preventUpdate\", !emitUpdate);\n        }\n        return commands.insertContentAt({\n            from: 0,\n            to: doc.content.size\n        }, content, {\n            parseOptions,\n            errorOnInvalidContent: (_b = options.errorOnInvalidContent) !== null && _b !== void 0 ? _b : editor.options.enableContentCheck\n        });\n    };\nfunction getMarkAttributes(state, typeOrName) {\n    const type = getMarkType(typeOrName, state.schema);\n    const { from, to, empty } = state.selection;\n    const marks = [];\n    if (empty) {\n        if (state.storedMarks) {\n            marks.push(...state.storedMarks);\n        }\n        marks.push(...state.selection.$head.marks());\n    } else {\n        state.doc.nodesBetween(from, to, (node)=>{\n            marks.push(...node.marks);\n        });\n    }\n    const mark = marks.find((markItem)=>markItem.type.name === type.name);\n    if (!mark) {\n        return {};\n    }\n    return {\n        ...mark.attrs\n    };\n}\n/**\n * Returns a new `Transform` based on all steps of the passed transactions.\n * @param oldDoc The Prosemirror node to start from\n * @param transactions The transactions to combine\n * @returns A new `Transform` with all steps of the passed transactions\n */ function combineTransactionSteps(oldDoc, transactions) {\n    const transform = new _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.Transform(oldDoc);\n    transactions.forEach((transaction)=>{\n        transaction.steps.forEach((step)=>{\n            transform.step(step);\n        });\n    });\n    return transform;\n}\n/**\n * Gets the default block type at a given match\n * @param match The content match to get the default block type from\n * @returns The default block type or null\n */ function defaultBlockAt(match) {\n    for(let i = 0; i < match.edgeCount; i += 1){\n        const { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs()) {\n            return type;\n        }\n    }\n    return null;\n}\n/**\n * Find children inside a Prosemirror node that match a predicate.\n * @param node The Prosemirror node to search in\n * @param predicate The predicate to match\n * @returns An array of nodes with their positions\n */ function findChildren(node, predicate) {\n    const nodesWithPos = [];\n    node.descendants((child, pos)=>{\n        if (predicate(child)) {\n            nodesWithPos.push({\n                node: child,\n                pos\n            });\n        }\n    });\n    return nodesWithPos;\n}\n/**\n * Same as `findChildren` but searches only within a `range`.\n * @param node The Prosemirror node to search in\n * @param range The range to search in\n * @param predicate The predicate to match\n * @returns An array of nodes with their positions\n */ function findChildrenInRange(node, range, predicate) {\n    const nodesWithPos = [];\n    // if (range.from === range.to) {\n    //   const nodeAt = node.nodeAt(range.from)\n    //   if (nodeAt) {\n    //     nodesWithPos.push({\n    //       node: nodeAt,\n    //       pos: range.from,\n    //     })\n    //   }\n    // }\n    node.nodesBetween(range.from, range.to, (child, pos)=>{\n        if (predicate(child)) {\n            nodesWithPos.push({\n                node: child,\n                pos\n            });\n        }\n    });\n    return nodesWithPos;\n}\n/**\n * Finds the closest parent node to a resolved position that matches a predicate.\n * @param $pos The resolved position to search from\n * @param predicate The predicate to match\n * @returns The closest parent node to the resolved position that matches the predicate\n * @example ```js\n * findParentNodeClosestToPos($from, node => node.type.name === 'paragraph')\n * ```\n */ function findParentNodeClosestToPos($pos, predicate) {\n    for(let i = $pos.depth; i > 0; i -= 1){\n        const node = $pos.node(i);\n        if (predicate(node)) {\n            return {\n                pos: i > 0 ? $pos.before(i) : 0,\n                start: $pos.start(i),\n                depth: i,\n                node\n            };\n        }\n    }\n}\n/**\n * Finds the closest parent node to the current selection that matches a predicate.\n * @param predicate The predicate to match\n * @returns A command that finds the closest parent node to the current selection that matches the predicate\n * @example ```js\n * findParentNode(node => node.type.name === 'paragraph')\n * ```\n */ function findParentNode(predicate) {\n    return (selection)=>findParentNodeClosestToPos(selection.$from, predicate);\n}\nfunction getSchema(extensions, editor) {\n    const resolvedExtensions = ExtensionManager.resolve(extensions);\n    return getSchemaByResolvedExtensions(resolvedExtensions, editor);\n}\n/**\n * Generate HTML from a JSONContent\n * @param doc The JSONContent to generate HTML from\n * @param extensions The extensions to use for the schema\n * @returns The generated HTML\n */ function generateHTML(doc, extensions) {\n    const schema = getSchema(extensions);\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n    return getHTMLFromFragment(contentNode.content, schema);\n}\n/**\n * Generate JSONContent from HTML\n * @param html The HTML to generate JSONContent from\n * @param extensions The extensions to use for the schema\n * @returns The generated JSONContent\n */ function generateJSON(html, extensions) {\n    const schema = getSchema(extensions);\n    const dom = elementFromString(html);\n    return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\n/**\n * Gets the text of a Prosemirror node\n * @param node The Prosemirror node\n * @param options Options for the text serializer & block separator\n * @returns The text of the node\n * @example ```js\n * const text = getText(node, { blockSeparator: '\\n' })\n * ```\n */ function getText(node, options) {\n    const range = {\n        from: 0,\n        to: node.content.size\n    };\n    return getTextBetween(node, range, options);\n}\n/**\n * Generate raw text from a JSONContent\n * @param doc The JSONContent to generate text from\n * @param extensions The extensions to use for the schema\n * @param options Options for the text generation f.e. blockSeparator or textSerializers\n * @returns The generated text\n */ function generateText(doc, extensions, options) {\n    const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n    const schema = getSchema(extensions);\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n    return getText(contentNode, {\n        blockSeparator,\n        textSerializers: {\n            ...getTextSerializersFromSchema(schema),\n            ...textSerializers\n        }\n    });\n}\nfunction getNodeAttributes(state, typeOrName) {\n    const type = getNodeType(typeOrName, state.schema);\n    const { from, to } = state.selection;\n    const nodes = [];\n    state.doc.nodesBetween(from, to, (node)=>{\n        nodes.push(node);\n    });\n    const node = nodes.reverse().find((nodeItem)=>nodeItem.type.name === type.name);\n    if (!node) {\n        return {};\n    }\n    return {\n        ...node.attrs\n    };\n}\n/**\n * Get node or mark attributes by type or name on the current editor state\n * @param state The current editor state\n * @param typeOrName The node or mark type or name\n * @returns The attributes of the node or mark or an empty object\n */ function getAttributes(state, typeOrName) {\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n    if (schemaType === \"node\") {\n        return getNodeAttributes(state, typeOrName);\n    }\n    if (schemaType === \"mark\") {\n        return getMarkAttributes(state, typeOrName);\n    }\n    return {};\n}\n/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */ function removeDuplicates(array, by = JSON.stringify) {\n    const seen = {};\n    return array.filter((item)=>{\n        const key = by(item);\n        return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n    });\n}\n/**\n * Removes duplicated ranges and ranges that are\n * fully captured by other ranges.\n */ function simplifyChangedRanges(changes) {\n    const uniqueChanges = removeDuplicates(changes);\n    return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index)=>{\n        const rest = uniqueChanges.filter((_, i)=>i !== index);\n        return !rest.some((otherChange)=>{\n            return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n        });\n    });\n}\n/**\n * Returns a list of changed ranges\n * based on the first and last state of all steps.\n */ function getChangedRanges(transform) {\n    const { mapping, steps } = transform;\n    const changes = [];\n    mapping.maps.forEach((stepMap, index)=>{\n        const ranges = [];\n        // This accounts for step changes where no range was actually altered\n        // e.g. when setting a mark, node attribute, etc.\n        // @ts-ignore\n        if (!stepMap.ranges.length) {\n            const { from, to } = steps[index];\n            if (from === undefined || to === undefined) {\n                return;\n            }\n            ranges.push({\n                from,\n                to\n            });\n        } else {\n            stepMap.forEach((from, to)=>{\n                ranges.push({\n                    from,\n                    to\n                });\n            });\n        }\n        ranges.forEach(({ from, to })=>{\n            const newStart = mapping.slice(index).map(from, -1);\n            const newEnd = mapping.slice(index).map(to);\n            const oldStart = mapping.invert().map(newStart, -1);\n            const oldEnd = mapping.invert().map(newEnd);\n            changes.push({\n                oldRange: {\n                    from: oldStart,\n                    to: oldEnd\n                },\n                newRange: {\n                    from: newStart,\n                    to: newEnd\n                }\n            });\n        });\n    });\n    return simplifyChangedRanges(changes);\n}\nfunction getDebugJSON(node, startOffset = 0) {\n    const isTopNode = node.type === node.type.schema.topNodeType;\n    const increment = isTopNode ? 0 : 1;\n    const from = startOffset;\n    const to = from + node.nodeSize;\n    const marks = node.marks.map((mark)=>{\n        const output = {\n            type: mark.type.name\n        };\n        if (Object.keys(mark.attrs).length) {\n            output.attrs = {\n                ...mark.attrs\n            };\n        }\n        return output;\n    });\n    const attrs = {\n        ...node.attrs\n    };\n    const output = {\n        type: node.type.name,\n        from,\n        to\n    };\n    if (Object.keys(attrs).length) {\n        output.attrs = attrs;\n    }\n    if (marks.length) {\n        output.marks = marks;\n    }\n    if (node.content.childCount) {\n        output.content = [];\n        node.forEach((child, offset)=>{\n            var _a;\n            (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n        });\n    }\n    if (node.text) {\n        output.text = node.text;\n    }\n    return output;\n}\nfunction getMarksBetween(from, to, doc) {\n    const marks = [];\n    // get all inclusive marks on empty selection\n    if (from === to) {\n        doc.resolve(from).marks().forEach((mark)=>{\n            const $pos = doc.resolve(from);\n            const range = getMarkRange($pos, mark.type);\n            if (!range) {\n                return;\n            }\n            marks.push({\n                mark,\n                ...range\n            });\n        });\n    } else {\n        doc.nodesBetween(from, to, (node, pos)=>{\n            if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === undefined) {\n                return;\n            }\n            marks.push(...node.marks.map((mark)=>({\n                    from: pos,\n                    to: pos + node.nodeSize,\n                    mark\n                })));\n        });\n    }\n    return marks;\n}\n/**\n * Finds the first node of a given type or name in the current selection.\n * @param state The editor state.\n * @param typeOrName The node type or name.\n * @param pos The position to start searching from.\n * @param maxDepth The maximum depth to search.\n * @returns The node and the depth as an array.\n */ const getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20)=>{\n    const $pos = state.doc.resolve(pos);\n    let currentDepth = maxDepth;\n    let node = null;\n    while(currentDepth > 0 && node === null){\n        const currentNode = $pos.node(currentDepth);\n        if ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type.name) === typeOrName) {\n            node = currentNode;\n        } else {\n            currentDepth -= 1;\n        }\n    }\n    return [\n        node,\n        currentDepth\n    ];\n};\n/**\n * Return attributes of an extension that should be splitted by keepOnSplit flag\n * @param extensionAttributes Array of extension attributes\n * @param typeName The type of the extension\n * @param attributes The attributes of the extension\n * @returns The splitted attributes\n */ function getSplittedAttributes(extensionAttributes, typeName, attributes) {\n    return Object.fromEntries(Object.entries(attributes).filter(([name])=>{\n        const extensionAttribute = extensionAttributes.find((item)=>{\n            return item.type === typeName && item.name === name;\n        });\n        if (!extensionAttribute) {\n            return false;\n        }\n        return extensionAttribute.attribute.keepOnSplit;\n    }));\n}\nfunction isMarkActive(state, typeOrName, attributes = {}) {\n    const { empty, ranges } = state.selection;\n    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n    if (empty) {\n        return !!(state.storedMarks || state.selection.$from.marks()).filter((mark)=>{\n            if (!type) {\n                return true;\n            }\n            return type.name === mark.type.name;\n        }).find((mark)=>objectIncludes(mark.attrs, attributes, {\n                strict: false\n            }));\n    }\n    let selectionRange = 0;\n    const markRanges = [];\n    ranges.forEach(({ $from, $to })=>{\n        const from = $from.pos;\n        const to = $to.pos;\n        state.doc.nodesBetween(from, to, (node, pos)=>{\n            if (!node.isText && !node.marks.length) {\n                return;\n            }\n            const relativeFrom = Math.max(from, pos);\n            const relativeTo = Math.min(to, pos + node.nodeSize);\n            const range = relativeTo - relativeFrom;\n            selectionRange += range;\n            markRanges.push(...node.marks.map((mark)=>({\n                    mark,\n                    from: relativeFrom,\n                    to: relativeTo\n                })));\n        });\n    });\n    if (selectionRange === 0) {\n        return false;\n    }\n    // calculate range of matched mark\n    const matchedRange = markRanges.filter((markRange)=>{\n        if (!type) {\n            return true;\n        }\n        return type.name === markRange.mark.type.name;\n    }).filter((markRange)=>objectIncludes(markRange.mark.attrs, attributes, {\n            strict: false\n        })).reduce((sum, markRange)=>sum + markRange.to - markRange.from, 0);\n    // calculate range of marks that excludes the searched mark\n    // for example `code` doesn’t allow any other marks\n    const excludedRange = markRanges.filter((markRange)=>{\n        if (!type) {\n            return true;\n        }\n        return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n    }).reduce((sum, markRange)=>sum + markRange.to - markRange.from, 0);\n    // we only include the result of `excludedRange`\n    // if there is a match at all\n    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n    return range >= selectionRange;\n}\nfunction isActive(state, name, attributes = {}) {\n    if (!name) {\n        return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n    }\n    const schemaType = getSchemaTypeNameByName(name, state.schema);\n    if (schemaType === \"node\") {\n        return isNodeActive(state, name, attributes);\n    }\n    if (schemaType === \"mark\") {\n        return isMarkActive(state, name, attributes);\n    }\n    return false;\n}\nconst isAtEndOfNode = (state, nodeType)=>{\n    const { $from, $to, $anchor } = state.selection;\n    if (nodeType) {\n        const parentNode = findParentNode((node)=>node.type.name === nodeType)(state.selection);\n        if (!parentNode) {\n            return false;\n        }\n        const $parentPos = state.doc.resolve(parentNode.pos + 1);\n        if ($anchor.pos + 1 === $parentPos.end()) {\n            return true;\n        }\n        return false;\n    }\n    if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n        return false;\n    }\n    return true;\n};\nconst isAtStartOfNode = (state)=>{\n    const { $from, $to } = state.selection;\n    if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n        return false;\n    }\n    return true;\n};\nfunction isList(name, extensions) {\n    const { nodeExtensions } = splitExtensions(extensions);\n    const extension = nodeExtensions.find((item)=>item.name === name);\n    if (!extension) {\n        return false;\n    }\n    const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage\n    };\n    const group = callOrReturn(getExtensionField(extension, \"group\", context));\n    if (typeof group !== \"string\") {\n        return false;\n    }\n    return group.split(\" \").includes(\"list\");\n}\n/**\n * Returns true if the given prosemirror node is empty.\n */ function isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false } = {}) {\n    var _a;\n    if (ignoreWhitespace) {\n        if (node.type.name === \"hardBreak\") {\n            // Hard breaks are considered empty\n            return true;\n        }\n        if (node.isText) {\n            return /^\\s*$/m.test((_a = node.text) !== null && _a !== void 0 ? _a : \"\");\n        }\n    }\n    if (node.isText) {\n        return !node.text;\n    }\n    if (node.isAtom || node.isLeaf) {\n        return false;\n    }\n    if (node.content.childCount === 0) {\n        return true;\n    }\n    if (checkChildren) {\n        let isContentEmpty = true;\n        node.content.forEach((childNode)=>{\n            if (isContentEmpty === false) {\n                // Exit early for perf\n                return;\n            }\n            if (!isNodeEmpty(childNode, {\n                ignoreWhitespace,\n                checkChildren\n            })) {\n                isContentEmpty = false;\n            }\n        });\n        return isContentEmpty;\n    }\n    return false;\n}\nfunction isNodeSelection(value) {\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection;\n}\nfunction posToDOMRect(view, from, to) {\n    const minPos = 0;\n    const maxPos = view.state.doc.content.size;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const start = view.coordsAtPos(resolvedFrom);\n    const end = view.coordsAtPos(resolvedEnd, -1);\n    const top = Math.min(start.top, end.top);\n    const bottom = Math.max(start.bottom, end.bottom);\n    const left = Math.min(start.left, end.left);\n    const right = Math.max(start.right, end.right);\n    const width = right - left;\n    const height = bottom - top;\n    const x = left;\n    const y = top;\n    const data = {\n        top,\n        bottom,\n        left,\n        right,\n        width,\n        height,\n        x,\n        y\n    };\n    return {\n        ...data,\n        toJSON: ()=>data\n    };\n}\n/**\n * The actual implementation of the rewriteUnknownContent function\n */ function rewriteUnknownContentInner({ json, validMarks, validNodes, options, rewrittenContent = [] }) {\n    if (json.marks && Array.isArray(json.marks)) {\n        json.marks = json.marks.filter((mark)=>{\n            const name = typeof mark === \"string\" ? mark : mark.type;\n            if (validMarks.has(name)) {\n                return true;\n            }\n            rewrittenContent.push({\n                original: JSON.parse(JSON.stringify(mark)),\n                unsupported: name\n            });\n            // Just ignore any unknown marks\n            return false;\n        });\n    }\n    if (json.content && Array.isArray(json.content)) {\n        json.content = json.content.map((value)=>rewriteUnknownContentInner({\n                json: value,\n                validMarks,\n                validNodes,\n                options,\n                rewrittenContent\n            }).json).filter((a)=>a !== null && a !== undefined);\n    }\n    if (json.type && !validNodes.has(json.type)) {\n        rewrittenContent.push({\n            original: JSON.parse(JSON.stringify(json)),\n            unsupported: json.type\n        });\n        if (json.content && Array.isArray(json.content) && (options === null || options === void 0 ? void 0 : options.fallbackToParagraph) !== false) {\n            // Just treat it like a paragraph and hope for the best\n            json.type = \"paragraph\";\n            return {\n                json,\n                rewrittenContent\n            };\n        }\n        // or just omit it entirely\n        return {\n            json: null,\n            rewrittenContent\n        };\n    }\n    return {\n        json,\n        rewrittenContent\n    };\n}\n/**\n * Rewrite unknown nodes and marks within JSON content\n * Allowing for user within the editor\n */ function rewriteUnknownContent(/**\n * The JSON content to clean of unknown nodes and marks\n */ json, /**\n * The schema to use for validation\n */ schema, /**\n * Options for the cleaning process\n */ options) {\n    return rewriteUnknownContentInner({\n        json,\n        validNodes: new Set(Object.keys(schema.nodes)),\n        validMarks: new Set(Object.keys(schema.marks)),\n        options\n    });\n}\nfunction canSetMark(state, tr, newMarkType) {\n    var _a;\n    const { selection } = tr;\n    let cursor = null;\n    if (isTextSelection(selection)) {\n        cursor = selection.$cursor;\n    }\n    if (cursor) {\n        const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();\n        // There can be no current marks that exclude the new mark\n        return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark)=>mark.type.excludes(newMarkType));\n    }\n    const { ranges } = selection;\n    return ranges.some(({ $from, $to })=>{\n        let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;\n        state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent)=>{\n            // If we already found a mark that we can enable, return false to bypass the remaining search\n            if (someNodeSupportsMark) {\n                return false;\n            }\n            if (node.isInline) {\n                const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n                const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark)=>otherMark.type.excludes(newMarkType));\n                someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n            }\n            return !someNodeSupportsMark;\n        });\n        return someNodeSupportsMark;\n    });\n}\nconst setMark = (typeOrName, attributes = {})=>({ tr, state, dispatch })=>{\n        const { selection } = tr;\n        const { empty, ranges } = selection;\n        const type = getMarkType(typeOrName, state.schema);\n        if (dispatch) {\n            if (empty) {\n                const oldAttributes = getMarkAttributes(state, type);\n                tr.addStoredMark(type.create({\n                    ...oldAttributes,\n                    ...attributes\n                }));\n            } else {\n                ranges.forEach((range)=>{\n                    const from = range.$from.pos;\n                    const to = range.$to.pos;\n                    state.doc.nodesBetween(from, to, (node, pos)=>{\n                        const trimmedFrom = Math.max(pos, from);\n                        const trimmedTo = Math.min(pos + node.nodeSize, to);\n                        const someHasMark = node.marks.find((mark)=>mark.type === type);\n                        // if there is already a mark of this type\n                        // we know that we have to merge its attributes\n                        // otherwise we add a fresh new mark\n                        if (someHasMark) {\n                            node.marks.forEach((mark)=>{\n                                if (type === mark.type) {\n                                    tr.addMark(trimmedFrom, trimmedTo, type.create({\n                                        ...mark.attrs,\n                                        ...attributes\n                                    }));\n                                }\n                            });\n                        } else {\n                            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n                        }\n                    });\n                });\n            }\n        }\n        return canSetMark(state, tr, type);\n    };\nconst setMeta = (key, value)=>({ tr })=>{\n        tr.setMeta(key, value);\n        return true;\n    };\nconst setNode = (typeOrName, attributes = {})=>({ state, dispatch, chain })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        let attributesToCopy;\n        if (state.selection.$anchor.sameParent(state.selection.$head)) {\n            // only copy attributes if the selection is pointing to a node of the same type\n            attributesToCopy = state.selection.$anchor.parent.attrs;\n        }\n        // TODO: use a fallback like insertContent?\n        if (!type.isTextblock) {\n            console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n            return false;\n        }\n        return chain()// try to convert node to default node if needed\n        .command(({ commands })=>{\n            const canSetBlock = (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, {\n                ...attributesToCopy,\n                ...attributes\n            })(state);\n            if (canSetBlock) {\n                return true;\n            }\n            return commands.clearNodes();\n        }).command(({ state: updatedState })=>{\n            return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, {\n                ...attributesToCopy,\n                ...attributes\n            })(updatedState, dispatch);\n        }).run();\n    };\nconst setNodeSelection = (position)=>({ tr, dispatch })=>{\n        if (dispatch) {\n            const { doc } = tr;\n            const from = minMax(position, 0, doc.content.size);\n            const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(doc, from);\n            tr.setSelection(selection);\n        }\n        return true;\n    };\nconst setTextSelection = (position)=>({ tr, dispatch })=>{\n        if (dispatch) {\n            const { doc } = tr;\n            const { from, to } = typeof position === \"number\" ? {\n                from: position,\n                to: position\n            } : position;\n            const minPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atStart(doc).from;\n            const maxPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atEnd(doc).to;\n            const resolvedFrom = minMax(from, minPos, maxPos);\n            const resolvedEnd = minMax(to, minPos, maxPos);\n            const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, resolvedFrom, resolvedEnd);\n            tr.setSelection(selection);\n        }\n        return true;\n    };\nconst sinkListItem = (typeOrName)=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.sinkListItem)(type)(state, dispatch);\n    };\nfunction ensureMarks(state, splittableMarks) {\n    const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n    if (marks) {\n        const filteredMarks = marks.filter((mark)=>splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\n        state.tr.ensureMarks(filteredMarks);\n    }\n}\nconst splitBlock = ({ keepMarks = true } = {})=>({ tr, state, dispatch, editor })=>{\n        const { selection, doc } = tr;\n        const { $from, $to } = selection;\n        const extensionAttributes = editor.extensionManager.attributes;\n        const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n        if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && selection.node.isBlock) {\n            if (!$from.parentOffset || !(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(doc, $from.pos)) {\n                return false;\n            }\n            if (dispatch) {\n                if (keepMarks) {\n                    ensureMarks(state, editor.extensionManager.splittableMarks);\n                }\n                tr.split($from.pos).scrollIntoView();\n            }\n            return true;\n        }\n        if (!$from.parent.isBlock) {\n            return false;\n        }\n        const atEnd = $to.parentOffset === $to.parent.content.size;\n        const deflt = $from.depth === 0 ? undefined : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n        let types = atEnd && deflt ? [\n            {\n                type: deflt,\n                attrs: newAttributes\n            }\n        ] : undefined;\n        let can = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n        if (!types && !can && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [\n            {\n                type: deflt\n            }\n        ] : undefined)) {\n            can = true;\n            types = deflt ? [\n                {\n                    type: deflt,\n                    attrs: newAttributes\n                }\n            ] : undefined;\n        }\n        if (dispatch) {\n            if (can) {\n                if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n                    tr.deleteSelection();\n                }\n                tr.split(tr.mapping.map($from.pos), 1, types);\n                if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n                    const first = tr.mapping.map($from.before());\n                    const $first = tr.doc.resolve(first);\n                    if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n                        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n                    }\n                }\n            }\n            if (keepMarks) {\n                ensureMarks(state, editor.extensionManager.splittableMarks);\n            }\n            tr.scrollIntoView();\n        }\n        return can;\n    };\nconst splitListItem = (typeOrName, overrideAttrs = {})=>({ tr, state, dispatch, editor })=>{\n        var _a;\n        const type = getNodeType(typeOrName, state.schema);\n        const { $from, $to } = state.selection;\n        // @ts-ignore\n        // eslint-disable-next-line\n        const node = state.selection.node;\n        if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n            return false;\n        }\n        const grandParent = $from.node(-1);\n        if (grandParent.type !== type) {\n            return false;\n        }\n        const extensionAttributes = editor.extensionManager.attributes;\n        if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n                return false;\n            }\n            if (dispatch) {\n                let wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.empty;\n                // eslint-disable-next-line\n                const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for(let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1){\n                    wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from($from.node(d).copy(wrap));\n                }\n                // eslint-disable-next-line\n                const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                const newNextTypeAttributes = {\n                    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n                    ...overrideAttrs\n                };\n                const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\n                wrap = wrap.append(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(type.createAndFill(null, nextType) || undefined));\n                const start = $from.before($from.depth - (depthBefore - 1));\n                tr.replace(start, $from.after(-depthAfter), new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos)=>{\n                    if (sel > -1) {\n                        return false;\n                    }\n                    if (n.isTextblock && n.content.size === 0) {\n                        sel = pos + 1;\n                    }\n                });\n                if (sel > -1) {\n                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(sel)));\n                }\n                tr.scrollIntoView();\n            }\n            return true;\n        }\n        const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        const newTypeAttributes = {\n            ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),\n            ...overrideAttrs\n        };\n        const newNextTypeAttributes = {\n            ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n            ...overrideAttrs\n        };\n        tr.delete($from.pos, $to.pos);\n        const types = nextType ? [\n            {\n                type,\n                attrs: newTypeAttributes\n            },\n            {\n                type: nextType,\n                attrs: newNextTypeAttributes\n            }\n        ] : [\n            {\n                type,\n                attrs: newTypeAttributes\n            }\n        ];\n        if (!(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, $from.pos, 2)) {\n            return false;\n        }\n        if (dispatch) {\n            const { selection, storedMarks } = state;\n            const { splittableMarks } = editor.extensionManager;\n            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n            tr.split($from.pos, 2, types).scrollIntoView();\n            if (!marks || !dispatch) {\n                return true;\n            }\n            const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n            tr.ensureMarks(filteredMarks);\n        }\n        return true;\n    };\nconst joinListBackwards = (tr, listType)=>{\n    const list = findParentNode((node)=>node.type === listType)(tr.selection);\n    if (!list) {\n        return true;\n    }\n    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n    if (before === undefined) {\n        return true;\n    }\n    const nodeBefore = tr.doc.nodeAt(before);\n    const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, list.pos);\n    if (!canJoinBackwards) {\n        return true;\n    }\n    tr.join(list.pos);\n    return true;\n};\nconst joinListForwards = (tr, listType)=>{\n    const list = findParentNode((node)=>node.type === listType)(tr.selection);\n    if (!list) {\n        return true;\n    }\n    const after = tr.doc.resolve(list.start).after(list.depth);\n    if (after === undefined) {\n        return true;\n    }\n    const nodeAfter = tr.doc.nodeAt(after);\n    const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, after);\n    if (!canJoinForwards) {\n        return true;\n    }\n    tr.join(after);\n    return true;\n};\nconst toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {})=>({ editor, tr, state, dispatch, chain, commands, can })=>{\n        const { extensions, splittableMarks } = editor.extensionManager;\n        const listType = getNodeType(listTypeOrName, state.schema);\n        const itemType = getNodeType(itemTypeOrName, state.schema);\n        const { selection, storedMarks } = state;\n        const { $from, $to } = selection;\n        const range = $from.blockRange($to);\n        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n        if (!range) {\n            return false;\n        }\n        const parentList = findParentNode((node)=>isList(node.type.name, extensions))(selection);\n        if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n            // remove list\n            if (parentList.node.type === listType) {\n                return commands.liftListItem(itemType);\n            }\n            // change list type\n            if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n                return chain().command(()=>{\n                    tr.setNodeMarkup(parentList.pos, listType);\n                    return true;\n                }).command(()=>joinListBackwards(tr, listType)).command(()=>joinListForwards(tr, listType)).run();\n            }\n        }\n        if (!keepMarks || !marks || !dispatch) {\n            return chain()// try to convert node to default node if needed\n            .command(()=>{\n                const canWrapInList = can().wrapInList(listType, attributes);\n                if (canWrapInList) {\n                    return true;\n                }\n                return commands.clearNodes();\n            }).wrapInList(listType, attributes).command(()=>joinListBackwards(tr, listType)).command(()=>joinListForwards(tr, listType)).run();\n        }\n        return chain()// try to convert node to default node if needed\n        .command(()=>{\n            const canWrapInList = can().wrapInList(listType, attributes);\n            const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n            tr.ensureMarks(filteredMarks);\n            if (canWrapInList) {\n                return true;\n            }\n            return commands.clearNodes();\n        }).wrapInList(listType, attributes).command(()=>joinListBackwards(tr, listType)).command(()=>joinListForwards(tr, listType)).run();\n    };\nconst toggleMark = (typeOrName, attributes = {}, options = {})=>({ state, commands })=>{\n        const { extendEmptyMarkRange = false } = options;\n        const type = getMarkType(typeOrName, state.schema);\n        const isActive = isMarkActive(state, type, attributes);\n        if (isActive) {\n            return commands.unsetMark(type, {\n                extendEmptyMarkRange\n            });\n        }\n        return commands.setMark(type, attributes);\n    };\nconst toggleNode = (typeOrName, toggleTypeOrName, attributes = {})=>({ state, commands })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const toggleType = getNodeType(toggleTypeOrName, state.schema);\n        const isActive = isNodeActive(state, type, attributes);\n        let attributesToCopy;\n        if (state.selection.$anchor.sameParent(state.selection.$head)) {\n            // only copy attributes if the selection is pointing to a node of the same type\n            attributesToCopy = state.selection.$anchor.parent.attrs;\n        }\n        if (isActive) {\n            return commands.setNode(toggleType, attributesToCopy);\n        }\n        // If the node is not active, we want to set the new node type with the given attributes\n        // Copying over the attributes from the current node if the selection is pointing to a node of the same type\n        return commands.setNode(type, {\n            ...attributesToCopy,\n            ...attributes\n        });\n    };\nconst toggleWrap = (typeOrName, attributes = {})=>({ state, commands })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const isActive = isNodeActive(state, type, attributes);\n        if (isActive) {\n            return commands.lift(type);\n        }\n        return commands.wrapIn(type, attributes);\n    };\nconst undoInputRule = ()=>({ state, dispatch })=>{\n        const plugins = state.plugins;\n        for(let i = 0; i < plugins.length; i += 1){\n            const plugin = plugins[i];\n            let undoable;\n            // @ts-ignore\n            // eslint-disable-next-line\n            if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n                if (dispatch) {\n                    const tr = state.tr;\n                    const toUndo = undoable.transform;\n                    for(let j = toUndo.steps.length - 1; j >= 0; j -= 1){\n                        tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                    }\n                    if (undoable.text) {\n                        const marks = tr.doc.resolve(undoable.from).marks();\n                        tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                    } else {\n                        tr.delete(undoable.from, undoable.to);\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    };\nconst unsetAllMarks = ()=>({ tr, dispatch })=>{\n        const { selection } = tr;\n        const { empty, ranges } = selection;\n        if (empty) {\n            return true;\n        }\n        if (dispatch) {\n            ranges.forEach((range)=>{\n                tr.removeMark(range.$from.pos, range.$to.pos);\n            });\n        }\n        return true;\n    };\nconst unsetMark = (typeOrName, options = {})=>({ tr, state, dispatch })=>{\n        var _a;\n        const { extendEmptyMarkRange = false } = options;\n        const { selection } = tr;\n        const type = getMarkType(typeOrName, state.schema);\n        const { $from, empty, ranges } = selection;\n        if (!dispatch) {\n            return true;\n        }\n        if (empty && extendEmptyMarkRange) {\n            let { from, to } = selection;\n            const attrs = (_a = $from.marks().find((mark)=>mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\n            const range = getMarkRange($from, type, attrs);\n            if (range) {\n                from = range.from;\n                to = range.to;\n            }\n            tr.removeMark(from, to, type);\n        } else {\n            ranges.forEach((range)=>{\n                tr.removeMark(range.$from.pos, range.$to.pos, type);\n            });\n        }\n        tr.removeStoredMark(type);\n        return true;\n    };\nconst updateAttributes = (typeOrName, attributes = {})=>({ tr, state, dispatch })=>{\n        let nodeType = null;\n        let markType = null;\n        const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n        if (!schemaType) {\n            return false;\n        }\n        if (schemaType === \"node\") {\n            nodeType = getNodeType(typeOrName, state.schema);\n        }\n        if (schemaType === \"mark\") {\n            markType = getMarkType(typeOrName, state.schema);\n        }\n        if (dispatch) {\n            tr.selection.ranges.forEach((range)=>{\n                const from = range.$from.pos;\n                const to = range.$to.pos;\n                let lastPos;\n                let lastNode;\n                let trimmedFrom;\n                let trimmedTo;\n                if (tr.selection.empty) {\n                    state.doc.nodesBetween(from, to, (node, pos)=>{\n                        if (nodeType && nodeType === node.type) {\n                            trimmedFrom = Math.max(pos, from);\n                            trimmedTo = Math.min(pos + node.nodeSize, to);\n                            lastPos = pos;\n                            lastNode = node;\n                        }\n                    });\n                } else {\n                    state.doc.nodesBetween(from, to, (node, pos)=>{\n                        if (pos < from && nodeType && nodeType === node.type) {\n                            trimmedFrom = Math.max(pos, from);\n                            trimmedTo = Math.min(pos + node.nodeSize, to);\n                            lastPos = pos;\n                            lastNode = node;\n                        }\n                        if (pos >= from && pos <= to) {\n                            if (nodeType && nodeType === node.type) {\n                                tr.setNodeMarkup(pos, undefined, {\n                                    ...node.attrs,\n                                    ...attributes\n                                });\n                            }\n                            if (markType && node.marks.length) {\n                                node.marks.forEach((mark)=>{\n                                    if (markType === mark.type) {\n                                        const trimmedFrom2 = Math.max(pos, from);\n                                        const trimmedTo2 = Math.min(pos + node.nodeSize, to);\n                                        tr.addMark(trimmedFrom2, trimmedTo2, markType.create({\n                                            ...mark.attrs,\n                                            ...attributes\n                                        }));\n                                    }\n                                });\n                            }\n                        }\n                    });\n                }\n                if (lastNode) {\n                    if (lastPos !== undefined) {\n                        tr.setNodeMarkup(lastPos, undefined, {\n                            ...lastNode.attrs,\n                            ...attributes\n                        });\n                    }\n                    if (markType && lastNode.marks.length) {\n                        lastNode.marks.forEach((mark)=>{\n                            if (markType === mark.type) {\n                                tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                                    ...mark.attrs,\n                                    ...attributes\n                                }));\n                            }\n                        });\n                    }\n                }\n            });\n        }\n        return true;\n    };\nconst wrapIn = (typeOrName, attributes = {})=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.wrapIn)(type, attributes)(state, dispatch);\n    };\nconst wrapInList = (typeOrName, attributes = {})=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.wrapInList)(type, attributes)(state, dispatch);\n    };\nvar commands = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    blur: blur,\n    clearContent: clearContent,\n    clearNodes: clearNodes,\n    command: command,\n    createParagraphNear: createParagraphNear,\n    cut: cut,\n    deleteCurrentNode: deleteCurrentNode,\n    deleteNode: deleteNode,\n    deleteRange: deleteRange,\n    deleteSelection: deleteSelection,\n    enter: enter,\n    exitCode: exitCode,\n    extendMarkRange: extendMarkRange,\n    first: first,\n    focus: focus,\n    forEach: forEach,\n    insertContent: insertContent,\n    insertContentAt: insertContentAt,\n    joinBackward: joinBackward,\n    joinDown: joinDown,\n    joinForward: joinForward,\n    joinItemBackward: joinItemBackward,\n    joinItemForward: joinItemForward,\n    joinTextblockBackward: joinTextblockBackward,\n    joinTextblockForward: joinTextblockForward,\n    joinUp: joinUp,\n    keyboardShortcut: keyboardShortcut,\n    lift: lift,\n    liftEmptyBlock: liftEmptyBlock,\n    liftListItem: liftListItem,\n    newlineInCode: newlineInCode,\n    resetAttributes: resetAttributes,\n    scrollIntoView: scrollIntoView,\n    selectAll: selectAll,\n    selectNodeBackward: selectNodeBackward,\n    selectNodeForward: selectNodeForward,\n    selectParentNode: selectParentNode,\n    selectTextblockEnd: selectTextblockEnd,\n    selectTextblockStart: selectTextblockStart,\n    setContent: setContent,\n    setMark: setMark,\n    setMeta: setMeta,\n    setNode: setNode,\n    setNodeSelection: setNodeSelection,\n    setTextSelection: setTextSelection,\n    sinkListItem: sinkListItem,\n    splitBlock: splitBlock,\n    splitListItem: splitListItem,\n    toggleList: toggleList,\n    toggleMark: toggleMark,\n    toggleNode: toggleNode,\n    toggleWrap: toggleWrap,\n    undoInputRule: undoInputRule,\n    unsetAllMarks: unsetAllMarks,\n    unsetMark: unsetMark,\n    updateAttributes: updateAttributes,\n    wrapIn: wrapIn,\n    wrapInList: wrapInList\n});\nconst Commands = Extension.create({\n    name: \"commands\",\n    addCommands () {\n        return {\n            ...commands\n        };\n    }\n});\nconst Drop = Extension.create({\n    name: \"drop\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"tiptapDrop\"),\n                props: {\n                    handleDrop: (_, e, slice, moved)=>{\n                        this.editor.emit(\"drop\", {\n                            editor: this.editor,\n                            event: e,\n                            slice,\n                            moved\n                        });\n                    }\n                }\n            })\n        ];\n    }\n});\nconst Editable = Extension.create({\n    name: \"editable\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"editable\"),\n                props: {\n                    editable: ()=>this.editor.options.editable\n                }\n            })\n        ];\n    }\n});\nconst focusEventsPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"focusEvents\");\nconst FocusEvents = Extension.create({\n    name: \"focusEvents\",\n    addProseMirrorPlugins () {\n        const { editor } = this;\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: focusEventsPluginKey,\n                props: {\n                    handleDOMEvents: {\n                        focus: (view, event)=>{\n                            editor.isFocused = true;\n                            const transaction = editor.state.tr.setMeta(\"focus\", {\n                                event\n                            }).setMeta(\"addToHistory\", false);\n                            view.dispatch(transaction);\n                            return false;\n                        },\n                        blur: (view, event)=>{\n                            editor.isFocused = false;\n                            const transaction = editor.state.tr.setMeta(\"blur\", {\n                                event\n                            }).setMeta(\"addToHistory\", false);\n                            view.dispatch(transaction);\n                            return false;\n                        }\n                    }\n                }\n            })\n        ];\n    }\n});\nconst Keymap = Extension.create({\n    name: \"keymap\",\n    addKeyboardShortcuts () {\n        const handleBackspace = ()=>this.editor.commands.first(({ commands })=>[\n                    ()=>commands.undoInputRule(),\n                    // maybe convert first text block node to default node\n                    ()=>commands.command(({ tr })=>{\n                            const { selection, doc } = tr;\n                            const { empty, $anchor } = selection;\n                            const { pos, parent } = $anchor;\n                            const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;\n                            const parentIsIsolating = $parentPos.parent.type.spec.isolating;\n                            const parentPos = $anchor.pos - $anchor.parentOffset;\n                            const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc).from === pos;\n                            if (!empty || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === \"paragraph\" // prevent clearNodes when no nodes to clear, otherwise history stack is appended\n                            ) {\n                                return false;\n                            }\n                            return commands.clearNodes();\n                        }),\n                    ()=>commands.deleteSelection(),\n                    ()=>commands.joinBackward(),\n                    ()=>commands.selectNodeBackward()\n                ]);\n        const handleDelete = ()=>this.editor.commands.first(({ commands })=>[\n                    ()=>commands.deleteSelection(),\n                    ()=>commands.deleteCurrentNode(),\n                    ()=>commands.joinForward(),\n                    ()=>commands.selectNodeForward()\n                ]);\n        const handleEnter = ()=>this.editor.commands.first(({ commands })=>[\n                    ()=>commands.newlineInCode(),\n                    ()=>commands.createParagraphNear(),\n                    ()=>commands.liftEmptyBlock(),\n                    ()=>commands.splitBlock()\n                ]);\n        const baseKeymap = {\n            Enter: handleEnter,\n            \"Mod-Enter\": ()=>this.editor.commands.exitCode(),\n            Backspace: handleBackspace,\n            \"Mod-Backspace\": handleBackspace,\n            \"Shift-Backspace\": handleBackspace,\n            Delete: handleDelete,\n            \"Mod-Delete\": handleDelete,\n            \"Mod-a\": ()=>this.editor.commands.selectAll()\n        };\n        const pcKeymap = {\n            ...baseKeymap\n        };\n        const macKeymap = {\n            ...baseKeymap,\n            \"Ctrl-h\": handleBackspace,\n            \"Alt-Backspace\": handleBackspace,\n            \"Ctrl-d\": handleDelete,\n            \"Ctrl-Alt-Backspace\": handleDelete,\n            \"Alt-Delete\": handleDelete,\n            \"Alt-d\": handleDelete,\n            \"Ctrl-a\": ()=>this.editor.commands.selectTextblockStart(),\n            \"Ctrl-e\": ()=>this.editor.commands.selectTextblockEnd()\n        };\n        if (isiOS() || isMacOS()) {\n            return macKeymap;\n        }\n        return pcKeymap;\n    },\n    addProseMirrorPlugins () {\n        return [\n            // With this plugin we check if the whole document was selected and deleted.\n            // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n            // to a paragraph if necessary.\n            // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n            // with many other commands.\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"clearDocument\"),\n                appendTransaction: (transactions, oldState, newState)=>{\n                    if (transactions.some((tr)=>tr.getMeta(\"composition\"))) {\n                        return;\n                    }\n                    const docChanges = transactions.some((transaction)=>transaction.docChanged) && !oldState.doc.eq(newState.doc);\n                    const ignoreTr = transactions.some((transaction)=>transaction.getMeta(\"preventClearDocument\"));\n                    if (!docChanges || ignoreTr) {\n                        return;\n                    }\n                    const { empty, from, to } = oldState.selection;\n                    const allFrom = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(oldState.doc).from;\n                    const allEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(oldState.doc).to;\n                    const allWasSelected = from === allFrom && to === allEnd;\n                    if (empty || !allWasSelected) {\n                        return;\n                    }\n                    const isEmpty = isNodeEmpty(newState.doc);\n                    if (!isEmpty) {\n                        return;\n                    }\n                    const tr = newState.tr;\n                    const state = createChainableState({\n                        state: newState,\n                        transaction: tr\n                    });\n                    const { commands } = new CommandManager({\n                        editor: this.editor,\n                        state\n                    });\n                    commands.clearNodes();\n                    if (!tr.steps.length) {\n                        return;\n                    }\n                    return tr;\n                }\n            })\n        ];\n    }\n});\nconst Paste = Extension.create({\n    name: \"paste\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"tiptapPaste\"),\n                props: {\n                    handlePaste: (_view, e, slice)=>{\n                        this.editor.emit(\"paste\", {\n                            editor: this.editor,\n                            event: e,\n                            slice\n                        });\n                    }\n                }\n            })\n        ];\n    }\n});\nconst Tabindex = Extension.create({\n    name: \"tabindex\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"tabindex\"),\n                props: {\n                    attributes: ()=>this.editor.isEditable ? {\n                            tabindex: \"0\"\n                        } : {}\n                }\n            })\n        ];\n    }\n});\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ClipboardTextSerializer: ClipboardTextSerializer,\n    Commands: Commands,\n    Drop: Drop,\n    Editable: Editable,\n    FocusEvents: FocusEvents,\n    Keymap: Keymap,\n    Paste: Paste,\n    Tabindex: Tabindex,\n    focusEventsPluginKey: focusEventsPluginKey\n});\nclass NodePos {\n    get name() {\n        return this.node.type.name;\n    }\n    constructor(pos, editor, isBlock = false, node = null){\n        this.currentNode = null;\n        this.actualDepth = null;\n        this.isBlock = isBlock;\n        this.resolvedPos = pos;\n        this.editor = editor;\n        this.currentNode = node;\n    }\n    get node() {\n        return this.currentNode || this.resolvedPos.node();\n    }\n    get element() {\n        return this.editor.view.domAtPos(this.pos).node;\n    }\n    get depth() {\n        var _a;\n        return (_a = this.actualDepth) !== null && _a !== void 0 ? _a : this.resolvedPos.depth;\n    }\n    get pos() {\n        return this.resolvedPos.pos;\n    }\n    get content() {\n        return this.node.content;\n    }\n    set content(content) {\n        let from = this.from;\n        let to = this.to;\n        if (this.isBlock) {\n            if (this.content.size === 0) {\n                console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);\n                return;\n            }\n            from = this.from + 1;\n            to = this.to - 1;\n        }\n        this.editor.commands.insertContentAt({\n            from,\n            to\n        }, content);\n    }\n    get attributes() {\n        return this.node.attrs;\n    }\n    get textContent() {\n        return this.node.textContent;\n    }\n    get size() {\n        return this.node.nodeSize;\n    }\n    get from() {\n        if (this.isBlock) {\n            return this.pos;\n        }\n        return this.resolvedPos.start(this.resolvedPos.depth);\n    }\n    get range() {\n        return {\n            from: this.from,\n            to: this.to\n        };\n    }\n    get to() {\n        if (this.isBlock) {\n            return this.pos + this.size;\n        }\n        return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);\n    }\n    get parent() {\n        if (this.depth === 0) {\n            return null;\n        }\n        const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);\n        const $pos = this.resolvedPos.doc.resolve(parentPos);\n        return new NodePos($pos, this.editor);\n    }\n    get before() {\n        let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));\n        if ($pos.depth !== this.depth) {\n            $pos = this.resolvedPos.doc.resolve(this.from - 3);\n        }\n        return new NodePos($pos, this.editor);\n    }\n    get after() {\n        let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));\n        if ($pos.depth !== this.depth) {\n            $pos = this.resolvedPos.doc.resolve(this.to + 3);\n        }\n        return new NodePos($pos, this.editor);\n    }\n    get children() {\n        const children = [];\n        this.node.content.forEach((node, offset)=>{\n            const isBlock = node.isBlock && !node.isTextblock;\n            const isNonTextAtom = node.isAtom && !node.isText;\n            const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);\n            const $pos = this.resolvedPos.doc.resolve(targetPos);\n            if (!isBlock && $pos.depth <= this.depth) {\n                return;\n            }\n            const childNodePos = new NodePos($pos, this.editor, isBlock, isBlock ? node : null);\n            if (isBlock) {\n                childNodePos.actualDepth = this.depth + 1;\n            }\n            children.push(new NodePos($pos, this.editor, isBlock, isBlock ? node : null));\n        });\n        return children;\n    }\n    get firstChild() {\n        return this.children[0] || null;\n    }\n    get lastChild() {\n        const children = this.children;\n        return children[children.length - 1] || null;\n    }\n    closest(selector, attributes = {}) {\n        let node = null;\n        let currentNode = this.parent;\n        while(currentNode && !node){\n            if (currentNode.node.type.name === selector) {\n                if (Object.keys(attributes).length > 0) {\n                    const nodeAttributes = currentNode.node.attrs;\n                    const attrKeys = Object.keys(attributes);\n                    for(let index = 0; index < attrKeys.length; index += 1){\n                        const key = attrKeys[index];\n                        if (nodeAttributes[key] !== attributes[key]) {\n                            break;\n                        }\n                    }\n                } else {\n                    node = currentNode;\n                }\n            }\n            currentNode = currentNode.parent;\n        }\n        return node;\n    }\n    querySelector(selector, attributes = {}) {\n        return this.querySelectorAll(selector, attributes, true)[0] || null;\n    }\n    querySelectorAll(selector, attributes = {}, firstItemOnly = false) {\n        let nodes = [];\n        if (!this.children || this.children.length === 0) {\n            return nodes;\n        }\n        const attrKeys = Object.keys(attributes);\n        /**\n         * Finds all children recursively that match the selector and attributes\n         * If firstItemOnly is true, it will return the first item found\n         */ this.children.forEach((childPos)=>{\n            // If we already found a node and we only want the first item, we dont need to keep going\n            if (firstItemOnly && nodes.length > 0) {\n                return;\n            }\n            if (childPos.node.type.name === selector) {\n                const doesAllAttributesMatch = attrKeys.every((key)=>attributes[key] === childPos.node.attrs[key]);\n                if (doesAllAttributesMatch) {\n                    nodes.push(childPos);\n                }\n            }\n            // If we already found a node and we only want the first item, we can stop here and skip the recursion\n            if (firstItemOnly && nodes.length > 0) {\n                return;\n            }\n            nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));\n        });\n        return nodes;\n    }\n    setAttribute(attributes) {\n        const { tr } = this.editor.state;\n        tr.setNodeMarkup(this.from, undefined, {\n            ...this.node.attrs,\n            ...attributes\n        });\n        this.editor.view.dispatch(tr);\n    }\n}\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\nfunction createStyleTag(style, nonce, suffix) {\n    const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : \"\"}]`);\n    if (tiptapStyleTag !== null) {\n        return tiptapStyleTag;\n    }\n    const styleNode = document.createElement(\"style\");\n    if (nonce) {\n        styleNode.setAttribute(\"nonce\", nonce);\n    }\n    styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : \"\"}`, \"\");\n    styleNode.innerHTML = style;\n    document.getElementsByTagName(\"head\")[0].appendChild(styleNode);\n    return styleNode;\n}\nclass Editor extends EventEmitter {\n    constructor(options = {}){\n        super();\n        this.isFocused = false;\n        /**\n         * The editor is considered initialized after the `create` event has been emitted.\n         */ this.isInitialized = false;\n        this.extensionStorage = {};\n        this.options = {\n            element: document.createElement(\"div\"),\n            content: \"\",\n            injectCSS: true,\n            injectNonce: undefined,\n            extensions: [],\n            autofocus: false,\n            editable: true,\n            editorProps: {},\n            parseOptions: {},\n            coreExtensionOptions: {},\n            enableInputRules: true,\n            enablePasteRules: true,\n            enableCoreExtensions: true,\n            enableContentCheck: false,\n            onBeforeCreate: ()=>null,\n            onCreate: ()=>null,\n            onUpdate: ()=>null,\n            onSelectionUpdate: ()=>null,\n            onTransaction: ()=>null,\n            onFocus: ()=>null,\n            onBlur: ()=>null,\n            onDestroy: ()=>null,\n            onContentError: ({ error })=>{\n                throw error;\n            },\n            onPaste: ()=>null,\n            onDrop: ()=>null\n        };\n        this.isCapturingTransaction = false;\n        this.capturedTransaction = null;\n        this.setOptions(options);\n        this.createExtensionManager();\n        this.createCommandManager();\n        this.createSchema();\n        this.on(\"beforeCreate\", this.options.onBeforeCreate);\n        this.emit(\"beforeCreate\", {\n            editor: this\n        });\n        this.on(\"contentError\", this.options.onContentError);\n        this.createView();\n        this.injectCSS();\n        this.on(\"create\", this.options.onCreate);\n        this.on(\"update\", this.options.onUpdate);\n        this.on(\"selectionUpdate\", this.options.onSelectionUpdate);\n        this.on(\"transaction\", this.options.onTransaction);\n        this.on(\"focus\", this.options.onFocus);\n        this.on(\"blur\", this.options.onBlur);\n        this.on(\"destroy\", this.options.onDestroy);\n        this.on(\"drop\", ({ event, slice, moved })=>this.options.onDrop(event, slice, moved));\n        this.on(\"paste\", ({ event, slice })=>this.options.onPaste(event, slice));\n        window.setTimeout(()=>{\n            if (this.isDestroyed) {\n                return;\n            }\n            this.commands.focus(this.options.autofocus);\n            this.emit(\"create\", {\n                editor: this\n            });\n            this.isInitialized = true;\n        }, 0);\n    }\n    /**\n     * Returns the editor storage.\n     */ get storage() {\n        return this.extensionStorage;\n    }\n    /**\n     * An object of all registered commands.\n     */ get commands() {\n        return this.commandManager.commands;\n    }\n    /**\n     * Create a command chain to call multiple commands at once.\n     */ chain() {\n        return this.commandManager.chain();\n    }\n    /**\n     * Check if a command or a command chain can be executed. Without executing it.\n     */ can() {\n        return this.commandManager.can();\n    }\n    /**\n     * Inject CSS styles.\n     */ injectCSS() {\n        if (this.options.injectCSS && document) {\n            this.css = createStyleTag(style, this.options.injectNonce);\n        }\n    }\n    /**\n     * Update editor options.\n     *\n     * @param options A list of options\n     */ setOptions(options = {}) {\n        this.options = {\n            ...this.options,\n            ...options\n        };\n        if (!this.view || !this.state || this.isDestroyed) {\n            return;\n        }\n        if (this.options.editorProps) {\n            this.view.setProps(this.options.editorProps);\n        }\n        this.view.updateState(this.state);\n    }\n    /**\n     * Update editable state of the editor.\n     */ setEditable(editable, emitUpdate = true) {\n        this.setOptions({\n            editable\n        });\n        if (emitUpdate) {\n            this.emit(\"update\", {\n                editor: this,\n                transaction: this.state.tr\n            });\n        }\n    }\n    /**\n     * Returns whether the editor is editable.\n     */ get isEditable() {\n        // since plugins are applied after creating the view\n        // `editable` is always `true` for one tick.\n        // that’s why we also have to check for `options.editable`\n        return this.options.editable && this.view && this.view.editable;\n    }\n    /**\n     * Returns the editor state.\n     */ get state() {\n        return this.view.state;\n    }\n    /**\n     * Register a ProseMirror plugin.\n     *\n     * @param plugin A ProseMirror plugin\n     * @param handlePlugins Control how to merge the plugin into the existing plugins.\n     * @returns The new editor state\n     */ registerPlugin(plugin, handlePlugins) {\n        const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [\n            ...this.state.plugins\n        ]) : [\n            ...this.state.plugins,\n            plugin\n        ];\n        const state = this.state.reconfigure({\n            plugins\n        });\n        this.view.updateState(state);\n        return state;\n    }\n    /**\n     * Unregister a ProseMirror plugin.\n     *\n     * @param nameOrPluginKeyToRemove The plugins name\n     * @returns The new editor state or undefined if the editor is destroyed\n     */ unregisterPlugin(nameOrPluginKeyToRemove) {\n        if (this.isDestroyed) {\n            return undefined;\n        }\n        const prevPlugins = this.state.plugins;\n        let plugins = prevPlugins;\n        [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey)=>{\n            // @ts-ignore\n            const name = typeof nameOrPluginKey === \"string\" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n            // @ts-ignore\n            plugins = prevPlugins.filter((plugin)=>!plugin.key.startsWith(name));\n        });\n        if (prevPlugins.length === plugins.length) {\n            // No plugin was removed, so we don’t need to update the state\n            return undefined;\n        }\n        const state = this.state.reconfigure({\n            plugins\n        });\n        this.view.updateState(state);\n        return state;\n    }\n    /**\n     * Creates an extension manager.\n     */ createExtensionManager() {\n        var _a, _b;\n        const coreExtensions = this.options.enableCoreExtensions ? [\n            Editable,\n            ClipboardTextSerializer.configure({\n                blockSeparator: (_b = (_a = this.options.coreExtensionOptions) === null || _a === void 0 ? void 0 : _a.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator\n            }),\n            Commands,\n            FocusEvents,\n            Keymap,\n            Tabindex,\n            Drop,\n            Paste\n        ].filter((ext)=>{\n            if (typeof this.options.enableCoreExtensions === \"object\") {\n                return this.options.enableCoreExtensions[ext.name] !== false;\n            }\n            return true;\n        }) : [];\n        const allExtensions = [\n            ...coreExtensions,\n            ...this.options.extensions\n        ].filter((extension)=>{\n            return [\n                \"extension\",\n                \"node\",\n                \"mark\"\n            ].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n        });\n        this.extensionManager = new ExtensionManager(allExtensions, this);\n    }\n    /**\n     * Creates an command manager.\n     */ createCommandManager() {\n        this.commandManager = new CommandManager({\n            editor: this\n        });\n    }\n    /**\n     * Creates a ProseMirror schema.\n     */ createSchema() {\n        this.schema = this.extensionManager.schema;\n    }\n    /**\n     * Creates a ProseMirror view.\n     */ createView() {\n        var _a;\n        let doc;\n        try {\n            doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n                errorOnInvalidContent: this.options.enableContentCheck\n            });\n        } catch (e) {\n            if (!(e instanceof Error) || ![\n                \"[tiptap error]: Invalid JSON content\",\n                \"[tiptap error]: Invalid HTML content\"\n            ].includes(e.message)) {\n                // Not the content error we were expecting\n                throw e;\n            }\n            this.emit(\"contentError\", {\n                editor: this,\n                error: e,\n                disableCollaboration: ()=>{\n                    if (this.storage.collaboration) {\n                        this.storage.collaboration.isDisabled = true;\n                    }\n                    // To avoid syncing back invalid content, reinitialize the extensions without the collaboration extension\n                    this.options.extensions = this.options.extensions.filter((extension)=>extension.name !== \"collaboration\");\n                    // Restart the initialization process by recreating the extension manager with the new set of extensions\n                    this.createExtensionManager();\n                }\n            });\n            // Content is invalid, but attempt to create it anyway, stripping out the invalid parts\n            doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n                errorOnInvalidContent: false\n            });\n        }\n        const selection = resolveFocusPosition(doc, this.options.autofocus);\n        this.view = new _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.EditorView(this.options.element, {\n            ...this.options.editorProps,\n            attributes: {\n                // add `role=\"textbox\"` to the editor element\n                role: \"textbox\",\n                ...(_a = this.options.editorProps) === null || _a === void 0 ? void 0 : _a.attributes\n            },\n            dispatchTransaction: this.dispatchTransaction.bind(this),\n            state: _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n                doc,\n                selection: selection || undefined\n            })\n        });\n        // `editor.view` is not yet available at this time.\n        // Therefore we will add all plugins and node views directly afterwards.\n        const newState = this.state.reconfigure({\n            plugins: this.extensionManager.plugins\n        });\n        this.view.updateState(newState);\n        this.createNodeViews();\n        this.prependClass();\n        // Let’s store the editor instance in the DOM element.\n        // So we’ll have access to it for tests.\n        // @ts-ignore\n        const dom = this.view.dom;\n        dom.editor = this;\n    }\n    /**\n     * Creates all node views.\n     */ createNodeViews() {\n        if (this.view.isDestroyed) {\n            return;\n        }\n        this.view.setProps({\n            nodeViews: this.extensionManager.nodeViews\n        });\n    }\n    /**\n     * Prepend class name to element.\n     */ prependClass() {\n        this.view.dom.className = `tiptap ${this.view.dom.className}`;\n    }\n    captureTransaction(fn) {\n        this.isCapturingTransaction = true;\n        fn();\n        this.isCapturingTransaction = false;\n        const tr = this.capturedTransaction;\n        this.capturedTransaction = null;\n        return tr;\n    }\n    /**\n     * The callback over which to send transactions (state updates) produced by the view.\n     *\n     * @param transaction An editor state transaction\n     */ dispatchTransaction(transaction) {\n        // if the editor / the view of the editor was destroyed\n        // the transaction should not be dispatched as there is no view anymore.\n        if (this.view.isDestroyed) {\n            return;\n        }\n        if (this.isCapturingTransaction) {\n            if (!this.capturedTransaction) {\n                this.capturedTransaction = transaction;\n                return;\n            }\n            transaction.steps.forEach((step)=>{\n                var _a;\n                return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);\n            });\n            return;\n        }\n        const state = this.state.apply(transaction);\n        const selectionHasChanged = !this.state.selection.eq(state.selection);\n        this.emit(\"beforeTransaction\", {\n            editor: this,\n            transaction,\n            nextState: state\n        });\n        this.view.updateState(state);\n        this.emit(\"transaction\", {\n            editor: this,\n            transaction\n        });\n        if (selectionHasChanged) {\n            this.emit(\"selectionUpdate\", {\n                editor: this,\n                transaction\n            });\n        }\n        const focus = transaction.getMeta(\"focus\");\n        const blur = transaction.getMeta(\"blur\");\n        if (focus) {\n            this.emit(\"focus\", {\n                editor: this,\n                event: focus.event,\n                transaction\n            });\n        }\n        if (blur) {\n            this.emit(\"blur\", {\n                editor: this,\n                event: blur.event,\n                transaction\n            });\n        }\n        if (!transaction.docChanged || transaction.getMeta(\"preventUpdate\")) {\n            return;\n        }\n        this.emit(\"update\", {\n            editor: this,\n            transaction\n        });\n    }\n    /**\n     * Get attributes of the currently selected node or mark.\n     */ getAttributes(nameOrType) {\n        return getAttributes(this.state, nameOrType);\n    }\n    isActive(nameOrAttributes, attributesOrUndefined) {\n        const name = typeof nameOrAttributes === \"string\" ? nameOrAttributes : null;\n        const attributes = typeof nameOrAttributes === \"string\" ? attributesOrUndefined : nameOrAttributes;\n        return isActive(this.state, name, attributes);\n    }\n    /**\n     * Get the document as JSON.\n     */ getJSON() {\n        return this.state.doc.toJSON();\n    }\n    /**\n     * Get the document as HTML.\n     */ getHTML() {\n        return getHTMLFromFragment(this.state.doc.content, this.schema);\n    }\n    /**\n     * Get the document as text.\n     */ getText(options) {\n        const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n        return getText(this.state.doc, {\n            blockSeparator,\n            textSerializers: {\n                ...getTextSerializersFromSchema(this.schema),\n                ...textSerializers\n            }\n        });\n    }\n    /**\n     * Check if there is no content.\n     */ get isEmpty() {\n        return isNodeEmpty(this.state.doc);\n    }\n    /**\n     * Get the number of characters for the current document.\n     *\n     * @deprecated\n     */ getCharacterCount() {\n        console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\n        return this.state.doc.content.size - 2;\n    }\n    /**\n     * Destroy the editor.\n     */ destroy() {\n        this.emit(\"destroy\");\n        if (this.view) {\n            // Cleanup our reference to prevent circular references which caused memory leaks\n            // @ts-ignore\n            const dom = this.view.dom;\n            if (dom && dom.editor) {\n                delete dom.editor;\n            }\n            this.view.destroy();\n        }\n        this.removeAllListeners();\n    }\n    /**\n     * Check if the editor is already destroyed.\n     */ get isDestroyed() {\n        var _a;\n        // @ts-ignore\n        return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n    }\n    $node(selector, attributes) {\n        var _a;\n        return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelector(selector, attributes)) || null;\n    }\n    $nodes(selector, attributes) {\n        var _a;\n        return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector, attributes)) || null;\n    }\n    $pos(pos) {\n        const $pos = this.state.doc.resolve(pos);\n        return new NodePos($pos, this);\n    }\n    get $doc() {\n        return this.$pos(0);\n    }\n}\n/**\n * Build an input rule that adds a mark when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */ function markInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            const attributes = callOrReturn(config.getAttributes, undefined, match);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const { tr } = state;\n            const captureGroup = match[match.length - 1];\n            const fullMatch = match[0];\n            if (captureGroup) {\n                const startSpaces = fullMatch.search(/\\S/);\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\n                const textEnd = textStart + captureGroup.length;\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item)=>{\n                    // @ts-ignore\n                    const excluded = item.mark.type.excluded;\n                    return excluded.find((type)=>type === config.type && type !== item.mark.type);\n                }).filter((item)=>item.to > textStart);\n                if (excludedMarks.length) {\n                    return null;\n                }\n                if (textEnd < range.to) {\n                    tr.delete(textEnd, range.to);\n                }\n                if (textStart > range.from) {\n                    tr.delete(range.from + startSpaces, textStart);\n                }\n                const markEnd = range.from + startSpaces + captureGroup.length;\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n                tr.removeStoredMark(config.type);\n            }\n        }\n    });\n}\n/**\n * Build an input rule that adds a node when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */ function nodeInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            const { tr } = state;\n            const start = range.from;\n            let end = range.to;\n            const newNode = config.type.create(attributes);\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                let matchStart = start + offset;\n                if (matchStart > end) {\n                    matchStart = end;\n                } else {\n                    end = matchStart + match[1].length;\n                }\n                // insert last typed character\n                const lastChar = match[0][match[0].length - 1];\n                tr.insertText(lastChar, start + match[0].length - 1);\n                // insert node from input rule\n                tr.replaceWith(matchStart, end, newNode);\n            } else if (match[0]) {\n                const insertionStart = config.type.isInline ? start : start - 1;\n                tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));\n            }\n            tr.scrollIntoView();\n        }\n    });\n}\n/**\n * Build an input rule that changes the type of a textblock when the\n * matched text is typed into it. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */ function textblockTypeInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            const $start = state.doc.resolve(range.from);\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n                return null;\n            }\n            state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n        }\n    });\n}\n/**\n * Build an input rule that replaces text when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */ function textInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            let insert = config.replace;\n            let start = range.from;\n            const end = range.to;\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                insert += match[0].slice(offset + match[1].length);\n                start += offset;\n                const cutOff = start - end;\n                if (cutOff > 0) {\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\n                    start = end;\n                }\n            }\n            state.tr.insertText(insert, start, end);\n        }\n    });\n}\n/**\n * Build an input rule for automatically wrapping a textblock when a\n * given string is typed. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n *\n * `type` is the type of node to wrap in.\n *\n * By default, if there’s a node with the same type above the newly\n * wrapped node, the rule will try to join those\n * two nodes. You can pass a join predicate, which takes a regular\n * expression match and the node before the wrapped node, and can\n * return a boolean to indicate whether a join should happen.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */ function wrappingInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match, chain })=>{\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            const tr = state.tr.delete(range.from, range.to);\n            const $start = tr.doc.resolve(range.from);\n            const blockRange = $start.blockRange();\n            const wrapping = blockRange && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.findWrapping)(blockRange, config.type, attributes);\n            if (!wrapping) {\n                return null;\n            }\n            tr.wrap(blockRange, wrapping);\n            if (config.keepMarks && config.editor) {\n                const { selection, storedMarks } = state;\n                const { splittableMarks } = config.editor.extensionManager;\n                const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n                if (marks) {\n                    const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n                    tr.ensureMarks(filteredMarks);\n                }\n            }\n            if (config.keepAttributes) {\n                /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */ const nodeType = config.type.name === \"bulletList\" || config.type.name === \"orderedList\" ? \"listItem\" : \"taskList\";\n                chain().updateAttributes(nodeType, attributes).run();\n            }\n            const before = tr.doc.resolve(range.from - 1).nodeBefore;\n            if (before && before.type === config.type && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n                tr.join(range.from - 1);\n            }\n        }\n    });\n}\n/**\n * The Node class is used to create custom node extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */ class Node {\n    constructor(config = {}){\n        this.type = \"node\";\n        this.name = \"node\";\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {}\n        };\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, \"addOptions\", {\n                name: this.name\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, \"addStorage\", {\n            name: this.name,\n            options: this.options\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Node(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend({\n            ...this.config,\n            addOptions: ()=>{\n                return mergeDeep(this.options, options);\n            }\n        });\n        // Always preserve the current name\n        extension.name = this.name;\n        // Set the parent to be our parent\n        extension.parent = this.parent;\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Node(extendedConfig);\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, \"addOptions\", {\n            name: extension.name\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n            name: extension.name,\n            options: extension.options\n        }));\n        return extension;\n    }\n}\n/**\n * Node views are used to customize the rendered DOM structure of a node.\n * @see https://tiptap.dev/guide/node-views\n */ class NodeView {\n    constructor(component, props, options){\n        this.isDragging = false;\n        this.component = component;\n        this.editor = props.editor;\n        this.options = {\n            stopEvent: null,\n            ignoreMutation: null,\n            ...options\n        };\n        this.extension = props.extension;\n        this.node = props.node;\n        this.decorations = props.decorations;\n        this.innerDecorations = props.innerDecorations;\n        this.view = props.view;\n        this.HTMLAttributes = props.HTMLAttributes;\n        this.getPos = props.getPos;\n        this.mount();\n    }\n    mount() {\n        // eslint-disable-next-line\n        return;\n    }\n    get dom() {\n        return this.editor.view.dom;\n    }\n    get contentDOM() {\n        return null;\n    }\n    onDragStart(event) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const { view } = this.editor;\n        const target = event.target;\n        // get the drag handle element\n        // `closest` is not available for text nodes so we may have to use its parent\n        const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest(\"[data-drag-handle]\") : target.closest(\"[data-drag-handle]\");\n        if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n            return;\n        }\n        let x = 0;\n        let y = 0;\n        // calculate offset for drag element if we use a different drag handle element\n        if (this.dom !== dragHandle) {\n            const domBox = this.dom.getBoundingClientRect();\n            const handleBox = dragHandle.getBoundingClientRect();\n            // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n            const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;\n            const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;\n            x = handleBox.x - domBox.x + offsetX;\n            y = handleBox.y - domBox.y + offsetY;\n        }\n        const clonedNode = this.dom.cloneNode(true);\n        (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(clonedNode, x, y);\n        const pos = this.getPos();\n        if (typeof pos !== \"number\") {\n            return;\n        }\n        // we need to tell ProseMirror that we want to move the whole node\n        // so we create a NodeSelection\n        const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, pos);\n        const transaction = view.state.tr.setSelection(selection);\n        view.dispatch(transaction);\n    }\n    stopEvent(event) {\n        var _a;\n        if (!this.dom) {\n            return false;\n        }\n        if (typeof this.options.stopEvent === \"function\") {\n            return this.options.stopEvent({\n                event\n            });\n        }\n        const target = event.target;\n        const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\n        // any event from child nodes should be handled by ProseMirror\n        if (!isInElement) {\n            return false;\n        }\n        const isDragEvent = event.type.startsWith(\"drag\");\n        const isDropEvent = event.type === \"drop\";\n        const isInput = [\n            \"INPUT\",\n            \"BUTTON\",\n            \"SELECT\",\n            \"TEXTAREA\"\n        ].includes(target.tagName) || target.isContentEditable;\n        // any input event within node views should be ignored by ProseMirror\n        if (isInput && !isDropEvent && !isDragEvent) {\n            return true;\n        }\n        const { isEditable } = this.editor;\n        const { isDragging } = this;\n        const isDraggable = !!this.node.type.spec.draggable;\n        const isSelectable = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(this.node);\n        const isCopyEvent = event.type === \"copy\";\n        const isPasteEvent = event.type === \"paste\";\n        const isCutEvent = event.type === \"cut\";\n        const isClickEvent = event.type === \"mousedown\";\n        // ProseMirror tries to drag selectable nodes\n        // even if `draggable` is set to `false`\n        // this fix prevents that\n        if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {\n            event.preventDefault();\n        }\n        if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {\n            event.preventDefault();\n            return false;\n        }\n        // we have to store that dragging started\n        if (isDraggable && isEditable && !isDragging && isClickEvent) {\n            const dragHandle = target.closest(\"[data-drag-handle]\");\n            const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n            if (isValidDragHandle) {\n                this.isDragging = true;\n                document.addEventListener(\"dragend\", ()=>{\n                    this.isDragging = false;\n                }, {\n                    once: true\n                });\n                document.addEventListener(\"drop\", ()=>{\n                    this.isDragging = false;\n                }, {\n                    once: true\n                });\n                document.addEventListener(\"mouseup\", ()=>{\n                    this.isDragging = false;\n                }, {\n                    once: true\n                });\n            }\n        }\n        // these events are handled by prosemirror\n        if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.\n     * @return `false` if the editor should re-read the selection or re-parse the range around the mutation\n     * @return `true` if it can safely be ignored.\n     */ ignoreMutation(mutation) {\n        if (!this.dom || !this.contentDOM) {\n            return true;\n        }\n        if (typeof this.options.ignoreMutation === \"function\") {\n            return this.options.ignoreMutation({\n                mutation\n            });\n        }\n        // a leaf/atom node is like a black box for ProseMirror\n        // and should be fully handled by the node view\n        if (this.node.isLeaf || this.node.isAtom) {\n            return true;\n        }\n        // ProseMirror should handle any selections\n        if (mutation.type === \"selection\") {\n            return false;\n        }\n        // try to prevent a bug on iOS and Android that will break node views on enter\n        // this is because ProseMirror can’t preventDispatch on enter\n        // this will lead to a re-render of the node view on enter\n        // see: https://github.com/ueberdosis/tiptap/issues/1214\n        // see: https://github.com/ueberdosis/tiptap/issues/2534\n        if (this.dom.contains(mutation.target) && mutation.type === \"childList\" && (isiOS() || isAndroid()) && this.editor.isFocused) {\n            const changedNodes = [\n                ...Array.from(mutation.addedNodes),\n                ...Array.from(mutation.removedNodes)\n            ];\n            // we’ll check if every changed node is contentEditable\n            // to make sure it’s probably mutated by ProseMirror\n            if (changedNodes.every((node)=>node.isContentEditable)) {\n                return false;\n            }\n        }\n        // we will allow mutation contentDOM with attributes\n        // so we can for example adding classes within our node view\n        if (this.contentDOM === mutation.target && mutation.type === \"attributes\") {\n            return true;\n        }\n        // ProseMirror should handle any changes within contentDOM\n        if (this.contentDOM.contains(mutation.target)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Update the attributes of the prosemirror node.\n     */ updateAttributes(attributes) {\n        this.editor.commands.command(({ tr })=>{\n            const pos = this.getPos();\n            if (typeof pos !== \"number\") {\n                return false;\n            }\n            tr.setNodeMarkup(pos, undefined, {\n                ...this.node.attrs,\n                ...attributes\n            });\n            return true;\n        });\n    }\n    /**\n     * Delete the node.\n     */ deleteNode() {\n        const from = this.getPos();\n        if (typeof from !== \"number\") {\n            return;\n        }\n        const to = from + this.node.nodeSize;\n        this.editor.commands.deleteRange({\n            from,\n            to\n        });\n    }\n}\n/**\n * Build an paste rule that adds a mark when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */ function markPasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler: ({ state, range, match, pasteEvent })=>{\n            const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const { tr } = state;\n            const captureGroup = match[match.length - 1];\n            const fullMatch = match[0];\n            let markEnd = range.to;\n            if (captureGroup) {\n                const startSpaces = fullMatch.search(/\\S/);\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\n                const textEnd = textStart + captureGroup.length;\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item)=>{\n                    // @ts-ignore\n                    const excluded = item.mark.type.excluded;\n                    return excluded.find((type)=>type === config.type && type !== item.mark.type);\n                }).filter((item)=>item.to > textStart);\n                if (excludedMarks.length) {\n                    return null;\n                }\n                if (textEnd < range.to) {\n                    tr.delete(textEnd, range.to);\n                }\n                if (textStart > range.from) {\n                    tr.delete(range.from + startSpaces, textStart);\n                }\n                markEnd = range.from + startSpaces + captureGroup.length;\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n                tr.removeStoredMark(config.type);\n            }\n        }\n    });\n}\n// source: https://stackoverflow.com/a/6969486\nfunction escapeForRegEx(string) {\n    return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nfunction isString(value) {\n    return typeof value === \"string\";\n}\n/**\n * Build an paste rule that adds a node when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */ function nodePasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler ({ match, chain, range, pasteEvent }) {\n            const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n            const content = callOrReturn(config.getContent, undefined, attributes);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const node = {\n                type: config.type.name,\n                attrs: attributes\n            };\n            if (content) {\n                node.content = content;\n            }\n            if (match.input) {\n                chain().deleteRange(range).insertContentAt(range.from, node);\n            }\n        }\n    });\n}\n/**\n * Build an paste rule that replaces text when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */ function textPasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            let insert = config.replace;\n            let start = range.from;\n            const end = range.to;\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                insert += match[0].slice(offset + match[1].length);\n                start += offset;\n                const cutOff = start - end;\n                if (cutOff > 0) {\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\n                    start = end;\n                }\n            }\n            state.tr.insertText(insert, start, end);\n        }\n    });\n}\nclass Tracker {\n    constructor(transaction){\n        this.transaction = transaction;\n        this.currentStep = this.transaction.steps.length;\n    }\n    map(position) {\n        let deleted = false;\n        const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step)=>{\n            const mapResult = step.getMap().mapResult(newPosition);\n            if (mapResult.deleted) {\n                deleted = true;\n            }\n            return mapResult.pos;\n        }, position);\n        return {\n            position: mappedPosition,\n            deleted\n        };\n    }\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlIO0FBQzVFO0FBQ0Y7QUFDMEQ7QUFDb0M7QUFDc2lCO0FBQzNpQjtBQUVwSTs7OztDQUlDLEdBQ0QsU0FBU21FLHFCQUFxQkMsTUFBTTtJQUNoQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsV0FBVyxFQUFFLEdBQUdGO0lBQy9CLElBQUksRUFBRUcsU0FBUyxFQUFFLEdBQUdEO0lBQ3BCLElBQUksRUFBRUUsR0FBRyxFQUFFLEdBQUdGO0lBQ2QsSUFBSSxFQUFFRyxXQUFXLEVBQUUsR0FBR0g7SUFDdEIsT0FBTztRQUNILEdBQUdELEtBQUs7UUFDUkssT0FBT0wsTUFBTUssS0FBSyxDQUFDQyxJQUFJLENBQUNOO1FBQ3hCTyxrQkFBa0JQLE1BQU1PLGdCQUFnQixDQUFDRCxJQUFJLENBQUNOO1FBQzlDUSxTQUFTUixNQUFNUSxPQUFPO1FBQ3RCQyxRQUFRVCxNQUFNUyxNQUFNO1FBQ3BCQyxhQUFhVixNQUFNVSxXQUFXLENBQUNKLElBQUksQ0FBQ047UUFDcENXLFFBQVFYLE1BQU1XLE1BQU0sQ0FBQ0wsSUFBSSxDQUFDTjtRQUMxQixJQUFJSSxlQUFjO1lBQ2QsT0FBT0E7UUFDWDtRQUNBLElBQUlGLGFBQVk7WUFDWixPQUFPQTtRQUNYO1FBQ0EsSUFBSUMsT0FBTTtZQUNOLE9BQU9BO1FBQ1g7UUFDQSxJQUFJUyxNQUFLO1lBQ0xWLFlBQVlELFlBQVlDLFNBQVM7WUFDakNDLE1BQU1GLFlBQVlFLEdBQUc7WUFDckJDLGNBQWNILFlBQVlHLFdBQVc7WUFDckMsT0FBT0g7UUFDWDtJQUNKO0FBQ0o7QUFFQSxNQUFNWTtJQUNGQyxZQUFZQyxLQUFLLENBQUU7UUFDZixJ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QUFDQSxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ3k3QixXQUFXLEdBQUcsSUFBSSxDQUFDejdCLFdBQVcsQ0FBQ2dQLEtBQUssQ0FBQzdHLE1BQU07SUFDcEQ7SUFDQXpHLElBQUl5YixRQUFRLEVBQUU7UUFDVixJQUFJdWUsVUFBVTtRQUNkLE1BQU1DLGlCQUFpQixJQUFJLENBQUMzN0IsV0FBVyxDQUFDZ1AsS0FBSyxDQUN4QzFCLEtBQUssQ0FBQyxJQUFJLENBQUNtdUIsV0FBVyxFQUN0QnYxQixNQUFNLENBQUMsQ0FBQzAxQixhQUFhbGI7WUFDdEIsTUFBTW1iLFlBQVluYixLQUFLb2IsTUFBTSxHQUFHRCxTQUFTLENBQUNEO1lBQzFDLElBQUlDLFVBQVVILE9BQU8sRUFBRTtnQkFDbkJBLFVBQVU7WUFDZDtZQUNBLE9BQU9HLFVBQVVodkIsR0FBRztRQUN4QixHQUFHc1E7UUFDSCxPQUFPO1lBQ0hBLFVBQVV3ZTtZQUNWRDtRQUNKO0lBQ0o7QUFDSjtBQUU2K0MsQ0FDNytDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvaW5kZXguanM/ZTU0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSwgVGV4dFNlbGVjdGlvbiwgU2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24sIEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3JztcbmltcG9ydCB7IGtleW1hcCB9IGZyb20gJ0B0aXB0YXAvcG0va2V5bWFwJztcbmltcG9ydCB7IFNjaGVtYSwgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIE5vZGUgYXMgTm9kZSQxLCBET01QYXJzZXIsIFNsaWNlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCc7XG5pbXBvcnQgeyBsaWZ0VGFyZ2V0LCBSZXBsYWNlU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIGpvaW5Qb2ludCwgVHJhbnNmb3JtLCBjYW5TcGxpdCwgY2FuSm9pbiwgZmluZFdyYXBwaW5nIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nO1xuaW1wb3J0IHsgY3JlYXRlUGFyYWdyYXBoTmVhciBhcyBjcmVhdGVQYXJhZ3JhcGhOZWFyJDEsIGRlbGV0ZVNlbGVjdGlvbiBhcyBkZWxldGVTZWxlY3Rpb24kMSwgZXhpdENvZGUgYXMgZXhpdENvZGUkMSwgam9pblVwIGFzIGpvaW5VcCQxLCBqb2luRG93biBhcyBqb2luRG93biQxLCBqb2luQmFja3dhcmQgYXMgam9pbkJhY2t3YXJkJDEsIGpvaW5Gb3J3YXJkIGFzIGpvaW5Gb3J3YXJkJDEsIGpvaW5UZXh0YmxvY2tCYWNrd2FyZCBhcyBqb2luVGV4dGJsb2NrQmFja3dhcmQkMSwgam9pblRleHRibG9ja0ZvcndhcmQgYXMgam9pblRleHRibG9ja0ZvcndhcmQkMSwgbGlmdCBhcyBsaWZ0JDEsIGxpZnRFbXB0eUJsb2NrIGFzIGxpZnRFbXB0eUJsb2NrJDEsIG5ld2xpbmVJbkNvZGUgYXMgbmV3bGluZUluQ29kZSQxLCBzZWxlY3ROb2RlQmFja3dhcmQgYXMgc2VsZWN0Tm9kZUJhY2t3YXJkJDEsIHNlbGVjdE5vZGVGb3J3YXJkIGFzIHNlbGVjdE5vZGVGb3J3YXJkJDEsIHNlbGVjdFBhcmVudE5vZGUgYXMgc2VsZWN0UGFyZW50Tm9kZSQxLCBzZWxlY3RUZXh0YmxvY2tFbmQgYXMgc2VsZWN0VGV4dGJsb2NrRW5kJDEsIHNlbGVjdFRleHRibG9ja1N0YXJ0IGFzIHNlbGVjdFRleHRibG9ja1N0YXJ0JDEsIHNldEJsb2NrVHlwZSwgd3JhcEluIGFzIHdyYXBJbiQxIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcyc7XG5pbXBvcnQgeyBsaWZ0TGlzdEl0ZW0gYXMgbGlmdExpc3RJdGVtJDEsIHNpbmtMaXN0SXRlbSBhcyBzaW5rTGlzdEl0ZW0kMSwgd3JhcEluTGlzdCBhcyB3cmFwSW5MaXN0JDEgfSBmcm9tICdAdGlwdGFwL3BtL3NjaGVtYS1saXN0JztcblxuLyoqXG4gKiBUYWtlcyBhIFRyYW5zYWN0aW9uICYgRWRpdG9yIFN0YXRlIGFuZCB0dXJucyBpdCBpbnRvIGEgY2hhaW5hYmxlIHN0YXRlIG9iamVjdFxuICogQHBhcmFtIGNvbmZpZyBUaGUgdHJhbnNhY3Rpb24gYW5kIHN0YXRlIHRvIGNyZWF0ZSB0aGUgY2hhaW5hYmxlIHN0YXRlIGZyb21cbiAqIEByZXR1cm5zIEEgY2hhaW5hYmxlIEVkaXRvciBzdGF0ZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoY29uZmlnKSB7XG4gICAgY29uc3QgeyBzdGF0ZSwgdHJhbnNhY3Rpb24gfSA9IGNvbmZpZztcbiAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHRyYW5zYWN0aW9uO1xuICAgIGxldCB7IGRvYyB9ID0gdHJhbnNhY3Rpb247XG4gICAgbGV0IHsgc3RvcmVkTWFya3MgfSA9IHRyYW5zYWN0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBhcHBseTogc3RhdGUuYXBwbHkuYmluZChzdGF0ZSksXG4gICAgICAgIGFwcGx5VHJhbnNhY3Rpb246IHN0YXRlLmFwcGx5VHJhbnNhY3Rpb24uYmluZChzdGF0ZSksXG4gICAgICAgIHBsdWdpbnM6IHN0YXRlLnBsdWdpbnMsXG4gICAgICAgIHNjaGVtYTogc3RhdGUuc2NoZW1hLFxuICAgICAgICByZWNvbmZpZ3VyZTogc3RhdGUucmVjb25maWd1cmUuYmluZChzdGF0ZSksXG4gICAgICAgIHRvSlNPTjogc3RhdGUudG9KU09OLmJpbmQoc3RhdGUpLFxuICAgICAgICBnZXQgc3RvcmVkTWFya3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVkTWFya3M7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzZWxlY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZG9jKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHRyKCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gdHJhbnNhY3Rpb24uc2VsZWN0aW9uO1xuICAgICAgICAgICAgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICAgICAgICAgICAgc3RvcmVkTWFya3MgPSB0cmFuc2FjdGlvbi5zdG9yZWRNYXJrcztcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5jbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3I7XG4gICAgICAgIHRoaXMucmF3Q29tbWFuZHMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmNvbW1hbmRzO1xuICAgICAgICB0aGlzLmN1c3RvbVN0YXRlID0gcHJvcHMuc3RhdGU7XG4gICAgfVxuICAgIGdldCBoYXNDdXN0b21TdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jdXN0b21TdGF0ZTtcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21TdGF0ZSB8fCB0aGlzLmVkaXRvci5zdGF0ZTtcbiAgICB9XG4gICAgZ2V0IGNvbW1hbmRzKCkge1xuICAgICAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyLmdldE1ldGEoJ3ByZXZlbnREaXNwYXRjaCcpICYmICF0aGlzLmhhc0N1c3RvbVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCBtZXRob2RdO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldCBjaGFpbigpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4oKTtcbiAgICB9XG4gICAgZ2V0IGNhbigpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2FuKCk7XG4gICAgfVxuICAgIGNyZWF0ZUNoYWluKHN0YXJ0VHIsIHNob3VsZERpc3BhdGNoID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gW107XG4gICAgICAgIGNvbnN0IGhhc1N0YXJ0VHJhbnNhY3Rpb24gPSAhIXN0YXJ0VHI7XG4gICAgICAgIGNvbnN0IHRyID0gc3RhcnRUciB8fCBzdGF0ZS50cjtcbiAgICAgICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYXNTdGFydFRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgJiYgc2hvdWxkRGlzcGF0Y2hcbiAgICAgICAgICAgICAgICAmJiAhdHIuZ2V0TWV0YSgncHJldmVudERpc3BhdGNoJylcbiAgICAgICAgICAgICAgICAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrcy5ldmVyeShjYWxsYmFjayA9PiBjYWxsYmFjayA9PT0gdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoYWluID0ge1xuICAgICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluZWRDb21tYW5kID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIsIHNob3VsZERpc3BhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW25hbWUsIGNoYWluZWRDb21tYW5kXTtcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIHJ1bixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgIH1cbiAgICBjcmVhdGVDYW4oc3RhcnRUcikge1xuICAgICAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZGlzcGF0Y2ggPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgZGlzcGF0Y2gpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRDb21tYW5kcyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbbmFtZSwgKC4uLmFyZ3MpID0+IGNvbW1hbmQoLi4uYXJncykoeyAuLi5wcm9wcywgZGlzcGF0Y2g6IHVuZGVmaW5lZCB9KV07XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmZvcm1hdHRlZENvbW1hbmRzLFxuICAgICAgICAgICAgY2hhaW46ICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4odHIsIGRpc3BhdGNoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRQcm9wcyh0ciwgc2hvdWxkRGlzcGF0Y2ggPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAgIHRyLFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgIHN0YXRlOiBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkaXNwYXRjaDogc2hvdWxkRGlzcGF0Y2ggPyAoKSA9PiB1bmRlZmluZWQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGFpbjogKCkgPT4gdGhpcy5jcmVhdGVDaGFpbih0ciwgc2hvdWxkRGlzcGF0Y2gpLFxuICAgICAgICAgICAgY2FuOiAoKSA9PiB0aGlzLmNyZWF0ZUNhbih0ciksXG4gICAgICAgICAgICBnZXQgY29tbWFuZHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCAoLi4uYXJncykgPT4gY29tbWFuZCguLi5hcmdzKShwcm9wcyldO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG59XG5cbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gICAgfVxuICAgIG9uKGV2ZW50LCBmbikge1xuICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50XSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdLnB1c2goZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb2ZmKGV2ZW50LCBmbikge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrcy5maWx0ZXIoY2FsbGJhY2sgPT4gY2FsbGJhY2sgIT09IGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uY2UoZXZlbnQsIGZuKSB7XG4gICAgICAgIGNvbnN0IG9uY2VGbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9mZihldmVudCwgb25jZUZuKTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5vbihldmVudCwgb25jZUZuKTtcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZmllbGQgZnJvbSBhbiBleHRlbnNpb25cbiAqIEBwYXJhbSBleHRlbnNpb24gVGhlIFRpcHRhcCBleHRlbnNpb25cbiAqIEBwYXJhbSBmaWVsZCBUaGUgZmllbGQsIGZvciBleGFtcGxlIGByZW5kZXJIVE1MYCBvciBgcHJpb3JpdHlgXG4gKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCBvYmplY3QgdGhhdCBzaG91bGQgYmUgcGFzc2VkIGFzIGB0aGlzYCBpbnRvIHRoZSBmdW5jdGlvblxuICogQHJldHVybnMgVGhlIGZpZWxkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgZmllbGQsIGNvbnRleHQpIHtcbiAgICBpZiAoZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09IHVuZGVmaW5lZCAmJiBleHRlbnNpb24ucGFyZW50KSB7XG4gICAgICAgIHJldHVybiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uY29uZmlnW2ZpZWxkXS5iaW5kKHtcbiAgICAgICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgICAgICBwYXJlbnQ6IGV4dGVuc2lvbi5wYXJlbnRcbiAgICAgICAgICAgICAgICA/IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbi5wYXJlbnQsIGZpZWxkLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvbi5jb25maWdbZmllbGRdO1xufVxuXG5mdW5jdGlvbiBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IGJhc2VFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi50eXBlID09PSAnZXh0ZW5zaW9uJyk7XG4gICAgY29uc3Qgbm9kZUV4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdub2RlJyk7XG4gICAgY29uc3QgbWFya0V4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdtYXJrJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZUV4dGVuc2lvbnMsXG4gICAgICAgIG5vZGVFeHRlbnNpb25zLFxuICAgICAgICBtYXJrRXh0ZW5zaW9ucyxcbiAgICB9O1xufVxuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgYWxsIGV4dGVuc2lvbiBhdHRyaWJ1dGVzIGRlZmluZWQgaW4gYGFkZEF0dHJpYnV0ZWAgYW5kIGBhZGRHbG9iYWxBdHRyaWJ1dGVgLlxuICogQHBhcmFtIGV4dGVuc2lvbnMgTGlzdCBvZiBleHRlbnNpb25zXG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IFtdO1xuICAgIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMsIG1hcmtFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XG4gICAgY29uc3Qgbm9kZUFuZE1hcmtFeHRlbnNpb25zID0gWy4uLm5vZGVFeHRlbnNpb25zLCAuLi5tYXJrRXh0ZW5zaW9uc107XG4gICAgY29uc3QgZGVmYXVsdEF0dHJpYnV0ZSA9IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgcmVuZGVyZWQ6IHRydWUsXG4gICAgICAgIHJlbmRlckhUTUw6IG51bGwsXG4gICAgICAgIHBhcnNlSFRNTDogbnVsbCxcbiAgICAgICAga2VlcE9uU3BsaXQ6IHRydWUsXG4gICAgICAgIGlzUmVxdWlyZWQ6IGZhbHNlLFxuICAgIH07XG4gICAgZXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICBleHRlbnNpb25zOiBub2RlQW5kTWFya0V4dGVuc2lvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZEdsb2JhbEF0dHJpYnV0ZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRHbG9iYWxBdHRyaWJ1dGVzJywgY29udGV4dCk7XG4gICAgICAgIGlmICghYWRkR2xvYmFsQXR0cmlidXRlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdsb2JhbEF0dHJpYnV0ZXMgPSBhZGRHbG9iYWxBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGdsb2JhbEF0dHJpYnV0ZXMuZm9yRWFjaChnbG9iYWxBdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgICAgZ2xvYmFsQXR0cmlidXRlLnR5cGVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC5lbnRyaWVzKGdsb2JhbEF0dHJpYnV0ZS5hdHRyaWJ1dGVzKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBub2RlQW5kTWFya0V4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhZGRBdHRyaWJ1dGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkQXR0cmlidXRlcycsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIWFkZEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYGFzIEF0dHJpYnV0ZXNgXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhZGRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIE9iamVjdFxuICAgICAgICAgICAgLmVudHJpZXMoYXR0cmlidXRlcylcbiAgICAgICAgICAgIC5mb3JFYWNoKChbbmFtZSwgYXR0cmlidXRlXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkQXR0ciA9IHtcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlLFxuICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIChtZXJnZWRBdHRyID09PSBudWxsIHx8IG1lcmdlZEF0dHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lcmdlZEF0dHIuZGVmYXVsdCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRBdHRyLmRlZmF1bHQgPSBtZXJnZWRBdHRyLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobWVyZ2VkQXR0ciA9PT0gbnVsbCB8fCBtZXJnZWRBdHRyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXJnZWRBdHRyLmlzUmVxdWlyZWQpICYmIChtZXJnZWRBdHRyID09PSBudWxsIHx8IG1lcmdlZEF0dHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lcmdlZEF0dHIuZGVmYXVsdCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXJnZWRBdHRyLmRlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiBtZXJnZWRBdHRyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGVzO1xufVxuXG5mdW5jdGlvbiBnZXROb2RlVHlwZShuYW1lT3JUeXBlLCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghc2NoZW1hLm5vZGVzW25hbWVPclR5cGVdKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVGhlcmUgaXMgbm8gbm9kZSB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hLm5vZGVzW25hbWVPclR5cGVdO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZU9yVHlwZTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVzKC4uLm9iamVjdHMpIHtcbiAgICByZXR1cm4gb2JqZWN0c1xuICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gISFpdGVtKVxuICAgICAgICAucmVkdWNlKChpdGVtcywgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGVzID0geyAuLi5pdGVtcyB9O1xuICAgICAgICBPYmplY3QuZW50cmllcyhpdGVtKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0cyA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlQ2xhc3NlcyA9IHZhbHVlID8gU3RyaW5nKHZhbHVlKS5zcGxpdCgnICcpIDogW107XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdDbGFzc2VzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldID8gbWVyZ2VkQXR0cmlidXRlc1trZXldLnNwbGl0KCcgJykgOiBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRDbGFzc2VzID0gdmFsdWVDbGFzc2VzLmZpbHRlcih2YWx1ZUNsYXNzID0+ICFleGlzdGluZ0NsYXNzZXMuaW5jbHVkZXModmFsdWVDbGFzcykpO1xuICAgICAgICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IFsuLi5leGlzdGluZ0NsYXNzZXMsIC4uLmluc2VydENsYXNzZXNdLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0eWxlcyA9IHZhbHVlID8gdmFsdWUuc3BsaXQoJzsnKS5tYXAoKHN0eWxlKSA9PiBzdHlsZS50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU3R5bGVzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldID8gbWVyZ2VkQXR0cmlidXRlc1trZXldLnNwbGl0KCc7JykubWFwKChzdHlsZSkgPT4gc3R5bGUudHJpbSgpKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1N0eWxlcy5mb3JFYWNoKHN0eWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3Byb3BlcnR5LCB2YWxdID0gc3R5bGUuc3BsaXQoJzonKS5tYXAocGFydCA9PiBwYXJ0LnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlTWFwLnNldChwcm9wZXJ0eSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZXdTdHlsZXMuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eSwgdmFsXSA9IHN0eWxlLnNwbGl0KCc6JykubWFwKHBhcnQgPT4gcGFydC50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZU1hcC5zZXQocHJvcGVydHksIHZhbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gQXJyYXkuZnJvbShzdHlsZU1hcC5lbnRyaWVzKCkpLm1hcCgoW3Byb3BlcnR5LCB2YWxdKSA9PiBgJHtwcm9wZXJ0eX06ICR7dmFsfWApLmpvaW4oJzsgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXJnZWRBdHRyaWJ1dGVzO1xuICAgIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGVPck1hcmssIGV4dGVuc2lvbkF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlc1xuICAgICAgICAuZmlsdGVyKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gbm9kZU9yTWFyay50eXBlLm5hbWUpXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJlZClcbiAgICAgICAgLm1hcChpdGVtID0+IHtcbiAgICAgICAgaWYgKCFpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFtpdGVtLm5hbWVdOiBub2RlT3JNYXJrLmF0dHJzW2l0ZW0ubmFtZV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKG5vZGVPck1hcmsuYXR0cnMpIHx8IHt9O1xuICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSkgPT4gbWVyZ2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSksIHt9KTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZnVuY3Rpb24tdHlwZVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogT3B0aW9uYWxseSBjYWxscyBgdmFsdWVgIGFzIGEgZnVuY3Rpb24uXG4gKiBPdGhlcndpc2UgaXQgaXMgcmV0dXJuZWQgZGlyZWN0bHkuXG4gKiBAcGFyYW0gdmFsdWUgRnVuY3Rpb24gb3IgYW55IHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQgT3B0aW9uYWwgY29udGV4dCB0byBiaW5kIHRvIGZ1bmN0aW9uLlxuICogQHBhcmFtIHByb3BzIE9wdGlvbmFsIHByb3BzIHRvIHBhc3MgdG8gZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhbGxPclJldHVybih2YWx1ZSwgY29udGV4dCA9IHVuZGVmaW5lZCwgLi4ucHJvcHMpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5iaW5kKGNvbnRleHQpKC4uLnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUoLi4ucHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3QodmFsdWUgPSB7fSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5tYXRjaCgvXlsrLV0/KD86XFxkKlxcLik/XFxkKyQvKSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG1lcmdlcyBleHRlbnNpb24gYXR0cmlidXRlcyBpbnRvIHBhcnNlcnVsZSBhdHRyaWJ1dGVzIChgYXR0cnNgIG9yIGBnZXRBdHRyc2ApLlxuICogQ2FuY2VscyB3aGVuIGBnZXRBdHRyc2AgcmV0dXJuZWQgYGZhbHNlYC5cbiAqIEBwYXJhbSBwYXJzZVJ1bGUgUHJvc2VNaXJyb3IgUGFyc2VSdWxlXG4gKiBAcGFyYW0gZXh0ZW5zaW9uQXR0cmlidXRlcyBMaXN0IG9mIGF0dHJpYnV0ZXMgdG8gaW5qZWN0XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShwYXJzZVJ1bGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoJ3N0eWxlJyBpbiBwYXJzZVJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUnVsZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucGFyc2VSdWxlLFxuICAgICAgICBnZXRBdHRyczogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBwYXJzZVJ1bGUuZ2V0QXR0cnMgPyBwYXJzZVJ1bGUuZ2V0QXR0cnMobm9kZSkgOiBwYXJzZVJ1bGUuYXR0cnM7XG4gICAgICAgICAgICBpZiAob2xkQXR0cmlidXRlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gZXh0ZW5zaW9uQXR0cmlidXRlcy5yZWR1Y2UoKGl0ZW1zLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUxcbiAgICAgICAgICAgICAgICAgICAgPyBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUwobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgOiBmcm9tU3RyaW5nKChub2RlKS5nZXRBdHRyaWJ1dGUoaXRlbS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5pdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgW2l0ZW0ubmFtZV06IHZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5vbGRBdHRyaWJ1dGVzLCAuLi5uZXdBdHRyaWJ1dGVzIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY2xlYW5VcFNjaGVtYUl0ZW0oZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIE9iamVjdC5lbnRyaWVzKGRhdGEpLmZpbHRlcigoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmIChrZXkgPT09ICdhdHRycycgJiYgaXNFbXB0eU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICB9KSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUHJvc2VtaXJyb3Igc2NoZW1hIGJhc2VkIG9uIHRoZSBnaXZlbiBleHRlbnNpb25zLlxuICogQHBhcmFtIGV4dGVuc2lvbnMgQW4gYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnNcbiAqIEBwYXJhbSBlZGl0b3IgVGhlIGVkaXRvciBpbnN0YW5jZVxuICogQHJldHVybnMgQSBQcm9zZW1pcnJvciBzY2hlbWFcbiAqL1xuZnVuY3Rpb24gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFsbEF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XG4gICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBjb25zdCB0b3BOb2RlID0gKF9hID0gbm9kZUV4dGVuc2lvbnMuZmluZChleHRlbnNpb24gPT4gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAndG9wTm9kZScpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWU7XG4gICAgY29uc3Qgbm9kZXMgPSBPYmplY3QuZnJvbUVudHJpZXMobm9kZUV4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcihhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXh0cmFOb2RlRmllbGRzID0gZXh0ZW5zaW9ucy5yZWR1Y2UoKGZpZWxkcywgZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5kTm9kZVNjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkKGUsICdleHRlbmROb2RlU2NoZW1hJywgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICAuLi4oZXh0ZW5kTm9kZVNjaGVtYSA/IGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xuICAgICAgICAgICAgLi4uZXh0cmFOb2RlRmllbGRzLFxuICAgICAgICAgICAgY29udGVudDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2NvbnRlbnQnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBtYXJrczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ21hcmtzJywgY29udGV4dCkpLFxuICAgICAgICAgICAgZ3JvdXA6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGlubGluZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2lubGluZScsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGF0b206IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhdG9tJywgY29udGV4dCkpLFxuICAgICAgICAgICAgc2VsZWN0YWJsZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3NlbGVjdGFibGUnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdkcmFnZ2FibGUnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnY29kZScsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIHdoaXRlc3BhY2U6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICd3aGl0ZXNwYWNlJywgY29udGV4dCkpLFxuICAgICAgICAgICAgbGluZWJyZWFrUmVwbGFjZW1lbnQ6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdsaW5lYnJlYWtSZXBsYWNlbWVudCcsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGRlZmluaW5nOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnZGVmaW5pbmcnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBpc29sYXRpbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdpc29sYXRpbmcnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKGV4dGVuc2lvbkF0dHJpYnV0ZSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsIHsgZGVmYXVsdDogKF9hID0gZXh0ZW5zaW9uQXR0cmlidXRlID09PSBudWxsIHx8IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlZmF1bHQgfV07XG4gICAgICAgICAgICB9KSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJzZUhUTUwgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAncGFyc2VIVE1MJywgY29udGV4dCkpO1xuICAgICAgICBpZiAocGFyc2VIVE1MKSB7XG4gICAgICAgICAgICBzY2hlbWEucGFyc2VET00gPSBwYXJzZUhUTUwubWFwKHBhcnNlUnVsZSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3JlbmRlckhUTUwnLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgICAgIHNjaGVtYS50b0RPTSA9IG5vZGUgPT4gcmVuZGVySFRNTCh7XG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBIVE1MQXR0cmlidXRlczogZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVyVGV4dCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3JlbmRlclRleHQnLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlbmRlclRleHQpIHtcbiAgICAgICAgICAgIHNjaGVtYS50b1RleHQgPSByZW5kZXJUZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV07XG4gICAgfSkpO1xuICAgIGNvbnN0IG1hcmtzID0gT2JqZWN0LmZyb21FbnRyaWVzKG1hcmtFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gYWxsQXR0cmlidXRlcy5maWx0ZXIoYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGV4dHJhTWFya0ZpZWxkcyA9IGV4dGVuc2lvbnMucmVkdWNlKChmaWVsZHMsIGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuZE1hcmtTY2hlbWEgPSBnZXRFeHRlbnNpb25GaWVsZChlLCAnZXh0ZW5kTWFya1NjaGVtYScsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgLi4uKGV4dGVuZE1hcmtTY2hlbWEgPyBleHRlbmRNYXJrU2NoZW1hKGV4dGVuc2lvbikgOiB7fSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IGNsZWFuVXBTY2hlbWFJdGVtKHtcbiAgICAgICAgICAgIC4uLmV4dHJhTWFya0ZpZWxkcyxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2luY2x1c2l2ZScsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGV4Y2x1ZGVzOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnZXhjbHVkZXMnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBncm91cDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpLFxuICAgICAgICAgICAgc3Bhbm5pbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdzcGFubmluZycsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGNvZGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdjb2RlJywgY29udGV4dCkpLFxuICAgICAgICAgICAgYXR0cnM6IE9iamVjdC5mcm9tRW50cmllcyhleHRlbnNpb25BdHRyaWJ1dGVzLm1hcChleHRlbnNpb25BdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbkF0dHJpYnV0ZS5uYW1lLCB7IGRlZmF1bHQ6IChfYSA9IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PT0gbnVsbCB8fCBleHRlbnNpb25BdHRyaWJ1dGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0IH1dO1xuICAgICAgICAgICAgfSkpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyc2VIVE1MID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3BhcnNlSFRNTCcsIGNvbnRleHQpKTtcbiAgICAgICAgaWYgKHBhcnNlSFRNTCkge1xuICAgICAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChwYXJzZVJ1bGUgPT4gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbmRlckhUTUwgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdyZW5kZXJIVE1MJywgY29udGV4dCk7XG4gICAgICAgIGlmIChyZW5kZXJIVE1MKSB7XG4gICAgICAgICAgICBzY2hlbWEudG9ET00gPSBtYXJrID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgICAgICAgIG1hcmssXG4gICAgICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhtYXJrLCBleHRlbnNpb25BdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV07XG4gICAgfSkpO1xuICAgIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICAgICAgdG9wTm9kZSxcbiAgICAgICAgbm9kZXMsXG4gICAgICAgIG1hcmtzLFxuICAgIH0pO1xufVxuXG4vKipcbiAqIFRyaWVzIHRvIGdldCBhIG5vZGUgb3IgbWFyayB0eXBlIGJ5IGl0cyBuYW1lLlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIG5vZGUgb3IgbWFyayB0eXBlXG4gKiBAcGFyYW0gc2NoZW1hIFRoZSBQcm9zZW1pcm9yIHNjaGVtYSB0byBzZWFyY2ggaW5cbiAqIEByZXR1cm5zIFRoZSBub2RlIG9yIG1hcmsgdHlwZSwgb3IgbnVsbCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gKi9cbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVCeU5hbWUobmFtZSwgc2NoZW1hKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5ub2Rlc1tuYW1lXSB8fCBzY2hlbWEubWFya3NbbmFtZV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlbmFibGVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZW5hYmxlZCkpIHtcbiAgICAgICAgcmV0dXJuIGVuYWJsZWQuc29tZShlbmFibGVkRXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgZW5hYmxlZEV4dGVuc2lvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IGVuYWJsZWRFeHRlbnNpb25cbiAgICAgICAgICAgICAgICA6IGVuYWJsZWRFeHRlbnNpb24ubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBleHRlbnNpb24ubmFtZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlbmFibGVkO1xufVxuXG5mdW5jdGlvbiBnZXRIVE1MRnJvbUZyYWdtZW50KGZyYWdtZW50LCBzY2hlbWEpIHtcbiAgICBjb25zdCBkb2N1bWVudEZyYWdtZW50ID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSkuc2VyaWFsaXplRnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgIGNvbnN0IHRlbXBvcmFyeURvY3VtZW50ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGVtcG9yYXJ5RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50RnJhZ21lbnQpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHRleHQgY29udGVudCBvZiBhIHJlc29sdmVkIHByb3NlbWlycm9yIHBvc2l0aW9uXG4gKiBAcGFyYW0gJGZyb20gVGhlIHJlc29sdmVkIHBvc2l0aW9uIHRvIGdldCB0aGUgdGV4dCBjb250ZW50IGZyb21cbiAqIEBwYXJhbSBtYXhNYXRjaCBUaGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBtYXRjaFxuICogQHJldHVybnMgVGhlIHRleHQgY29udGVudFxuICovXG5jb25zdCBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyA9ICgkZnJvbSwgbWF4TWF0Y2ggPSA1MDApID0+IHtcbiAgICBsZXQgdGV4dEJlZm9yZSA9ICcnO1xuICAgIGNvbnN0IHNsaWNlRW5kUG9zID0gJGZyb20ucGFyZW50T2Zmc2V0O1xuICAgICRmcm9tLnBhcmVudC5ub2Rlc0JldHdlZW4oTWF0aC5tYXgoMCwgc2xpY2VFbmRQb3MgLSBtYXhNYXRjaCksIHNsaWNlRW5kUG9zLCAobm9kZSwgcG9zLCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNodW5rID0gKChfYiA9IChfYSA9IG5vZGUudHlwZS5zcGVjKS50b1RleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgIH0pKVxuICAgICAgICAgICAgfHwgbm9kZS50ZXh0Q29udGVudFxuICAgICAgICAgICAgfHwgJyVsZWFmJSc7XG4gICAgICAgIHRleHRCZWZvcmUgKz0gbm9kZS5pc0F0b20gJiYgIW5vZGUuaXNUZXh0ID8gY2h1bmsgOiBjaHVuay5zbGljZSgwLCBNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIHBvcykpO1xuICAgIH0pO1xuICAgIHJldHVybiB0ZXh0QmVmb3JlO1xufTtcblxuZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmNsYXNzIElucHV0UnVsZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlcjtcbiAgICB9XG59XG5jb25zdCBpbnB1dFJ1bGVNYXRjaGVySGFuZGxlciA9ICh0ZXh0LCBmaW5kKSA9PiB7XG4gICAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XG4gICAgICAgIHJldHVybiBmaW5kLmV4ZWModGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0UnVsZU1hdGNoID0gZmluZCh0ZXh0KTtcbiAgICBpZiAoIWlucHV0UnVsZU1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbaW5wdXRSdWxlTWF0Y2gudGV4dF07XG4gICAgcmVzdWx0LmluZGV4ID0gaW5wdXRSdWxlTWF0Y2guaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gdGV4dDtcbiAgICByZXN1bHQuZGF0YSA9IGlucHV0UnVsZU1hdGNoLmRhdGE7XG4gICAgaWYgKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XG4gICAgICAgIGlmICghaW5wdXRSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogXCJpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aFwiIG11c3QgYmUgcGFydCBvZiBcImlucHV0UnVsZU1hdGNoLnRleHRcIi4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZnVuY3Rpb24gcnVuJDEoY29uZmlnKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZWRpdG9yLCBmcm9tLCB0bywgdGV4dCwgcnVsZXMsIHBsdWdpbiwgfSA9IGNvbmZpZztcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCAkZnJvbSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgaWYgKFxuICAgIC8vIGNoZWNrIGZvciBjb2RlIG5vZGVcbiAgICAkZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGVcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNvZGUgbWFya1xuICAgICAgICB8fCAhISgoX2EgPSAoJGZyb20ubm9kZUJlZm9yZSB8fCAkZnJvbS5ub2RlQWZ0ZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya3MuZmluZChtYXJrID0+IG1hcmsudHlwZS5zcGVjLmNvZGUpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBtYXRjaGVkID0gZmFsc2U7XG4gICAgY29uc3QgdGV4dEJlZm9yZSA9IGdldFRleHRDb250ZW50RnJvbU5vZGVzKCRmcm9tKSArIHRleHQ7XG4gICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaCA9IGlucHV0UnVsZU1hdGNoZXJIYW5kbGVyKHRleHRCZWZvcmUsIHJ1bGUuZmluZCk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgc3RhdGU6IHZpZXcuc3RhdGUsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgICAgIGZyb206IGZyb20gLSAobWF0Y2hbMF0ubGVuZ3RoIC0gdGV4dC5sZW5ndGgpLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICByYW5nZSxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgY29tbWFuZHMsXG4gICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgIGNhbixcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHN0b3AgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXNcbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IG51bGwgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3JlIHRyYW5zZm9ybSBhcyBtZXRhIGRhdGFcbiAgICAgICAgLy8gc28gd2UgY2FuIHVuZG8gaW5wdXQgcnVsZXMgd2l0aGluIHRoZSBgdW5kb0lucHV0UnVsZXNgIGNvbW1hbmRcbiAgICAgICAgdHIuc2V0TWV0YShwbHVnaW4sIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHIsXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICB9KTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXRjaGVkO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gaW5wdXQgcnVsZXMgcGx1Z2luLiBXaGVuIGVuYWJsZWQsIGl0IHdpbGwgY2F1c2UgdGV4dFxuICogaW5wdXQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZeKAmXNcbiAqIGFjdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5wdXRSdWxlc1BsdWdpbihwcm9wcykge1xuICAgIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih7XG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGx5KHRyLCBwcmV2LCBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZCA9IHRyLmdldE1ldGEocGx1Z2luKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIElucHV0UnVsZSBpcyB0cmlnZ2VyZWQgYnkgaW5zZXJ0Q29udGVudCgpXG4gICAgICAgICAgICAgICAgY29uc3Qgc2ltdWxhdGVkSW5wdXRNZXRhID0gdHIuZ2V0TWV0YSgnYXBwbHlJbnB1dFJ1bGVzJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTaW11bGF0ZWRJbnB1dCA9ICEhc2ltdWxhdGVkSW5wdXRNZXRhO1xuICAgICAgICAgICAgICAgIGlmIChpc1NpbXVsYXRlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHsgdGV4dCB9ID0gc2ltdWxhdGVkSW5wdXRNZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGdldEhUTUxGcm9tRnJhZ21lbnQoRnJhZ21lbnQuZnJvbSh0ZXh0KSwgc3RhdGUuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZnJvbSB9ID0gc2ltdWxhdGVkSW5wdXRNZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW4kMSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0ci5zZWxlY3Rpb25TZXQgfHwgdHIuZG9jQ2hhbmdlZCA/IG51bGwgOiBwcmV2O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGhhbmRsZVRleHRJbnB1dCh2aWV3LCBmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBydW4kMSh7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRpb25lbmQ6IHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1biQxKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGFkZCBzdXBwb3J0IGZvciBpbnB1dCBydWxlcyB0byB0cmlnZ2VyIG9uIGVudGVyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgZXhhbXBsZSBmb3IgY29kZSBibG9ja3NcbiAgICAgICAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSAnRW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuJDEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnXFxuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpc0lucHV0UnVsZXM6IHRydWUsXG4gICAgfSk7XG4gICAgcmV0dXJuIHBsdWdpbjtcbn1cblxuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWVzcXVlZWIvaXMtd2hhdC9ibG9iLzg4ZDZlNGNhOTJmYjJiYWFiNjAwM2M1NGUwMmVlZGY0ZTcyOWU1YWIvc3JjL2luZGV4LnRzXG5mdW5jdGlvbiBnZXRUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ09iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7IC4uLnRhcmdldCB9O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pICYmIGlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIFRoZSBNYXJrIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGN1c3RvbSBtYXJrIGV4dGVuc2lvbnMuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucyNjcmVhdGUtYS1uZXctZXh0ZW5zaW9uXG4gKi9cbmNsYXNzIE1hcmsge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdtYXJrJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ21hcmsnO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25maWcubmFtZTtcbiAgICAgICAgaWYgKGNvbmZpZy5kZWZhdWx0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhjb25maWcuZGVmYXVsdE9wdGlvbnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGBhZGRPcHRpb25zYCBmYWxsYmFja1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0T3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmFkZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZCh0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRTdG9yYWdlJywge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICB9KSkgfHwge307XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrKGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXG4gICAgICAgIC8vIHdpdGggZGlmZmVyZW50IGNhbGxzIG9mIGBjb25maWd1cmVgXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5kKHtcbiAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAgICAgYWRkT3B0aW9uczogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZURlZXAodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBbHdheXMgcHJlc2VydmUgdGhlIGN1cnJlbnQgbmFtZVxuICAgICAgICBleHRlbnNpb24ubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgLy8gU2V0IHRoZSBwYXJlbnQgdG8gYmUgb3VyIHBhcmVudFxuICAgICAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxuICAgIGV4dGVuZChleHRlbmRlZENvbmZpZyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBNYXJrKGV4dGVuZGVkQ29uZmlnKTtcbiAgICAgICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb247XG4gICAgICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWU7XG4gICAgICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgfSkpO1xuICAgICAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgIH1cbiAgICBzdGF0aWMgaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyayB9KSB7XG4gICAgICAgIGNvbnN0IHsgdHIgfSA9IGVkaXRvci5zdGF0ZTtcbiAgICAgICAgY29uc3QgY3VycmVudFBvcyA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gICAgICAgIGNvbnN0IGlzQXRFbmQgPSBjdXJyZW50UG9zLnBvcyA9PT0gY3VycmVudFBvcy5lbmQoKTtcbiAgICAgICAgaWYgKGlzQXRFbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrcyA9IGN1cnJlbnRQb3MubWFya3MoKTtcbiAgICAgICAgICAgIGNvbnN0IGlzSW5NYXJrID0gISFjdXJyZW50TWFya3MuZmluZChtID0+IChtID09PSBudWxsIHx8IG0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG0udHlwZS5uYW1lKSA9PT0gbWFyay5uYW1lKTtcbiAgICAgICAgICAgIGlmICghaXNJbk1hcmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZW1vdmVNYXJrID0gY3VycmVudE1hcmtzLmZpbmQobSA9PiAobSA9PT0gbnVsbCB8fCBtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtLnR5cGUubmFtZSkgPT09IG1hcmsubmFtZSk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlTWFyaykge1xuICAgICAgICAgICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsocmVtb3ZlTWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5pbnNlcnRUZXh0KCcgJywgY3VycmVudFBvcy5wb3MpO1xuICAgICAgICAgICAgZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBQYXN0ZSBydWxlcyBhcmUgdXNlZCB0byByZWFjdCB0byBwYXN0ZWQgY29udGVudC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI3Bhc3RlLXJ1bGVzXG4gKi9cbmNsYXNzIFBhc3RlUnVsZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlcjtcbiAgICB9XG59XG5jb25zdCBwYXN0ZVJ1bGVNYXRjaGVySGFuZGxlciA9ICh0ZXh0LCBmaW5kLCBldmVudCkgPT4ge1xuICAgIGlmIChpc1JlZ0V4cChmaW5kKSkge1xuICAgICAgICByZXR1cm4gWy4uLnRleHQubWF0Y2hBbGwoZmluZCldO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVzID0gZmluZCh0ZXh0LCBldmVudCk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXMubWFwKHBhc3RlUnVsZU1hdGNoID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW3Bhc3RlUnVsZU1hdGNoLnRleHRdO1xuICAgICAgICByZXN1bHQuaW5kZXggPSBwYXN0ZVJ1bGVNYXRjaC5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gdGV4dDtcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBwYXN0ZVJ1bGVNYXRjaC5kYXRhO1xuICAgICAgICBpZiAocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpIHtcbiAgICAgICAgICAgIGlmICghcGFzdGVSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IFwicGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGhcIiBtdXN0IGJlIHBhcnQgb2YgXCJwYXN0ZVJ1bGVNYXRjaC50ZXh0XCIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBydW4oY29uZmlnKSB7XG4gICAgY29uc3QgeyBlZGl0b3IsIHN0YXRlLCBmcm9tLCB0bywgcnVsZSwgcGFzdGVFdmVudCwgZHJvcEV2ZW50LCB9ID0gY29uZmlnO1xuICAgIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgc3RhdGUsXG4gICAgfSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLnR5cGUuc3BlYy5jb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLmNvbnRlbnQuc2l6ZSk7XG4gICAgICAgIGNvbnN0IHRleHRUb01hdGNoID0gbm9kZS50ZXh0QmV0d2VlbihyZXNvbHZlZEZyb20gLSBwb3MsIHJlc29sdmVkVG8gLSBwb3MsIHVuZGVmaW5lZCwgJ1xcdWZmZmMnKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyKHRleHRUb01hdGNoLCBydWxlLmZpbmQsIHBhc3RlRXZlbnQpO1xuICAgICAgICBtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHJlc29sdmVkRnJvbSArIG1hdGNoLmluZGV4ICsgMTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgZnJvbTogc3RhdGUudHIubWFwcGluZy5tYXAoc3RhcnQpLFxuICAgICAgICAgICAgICAgIHRvOiBzdGF0ZS50ci5tYXBwaW5nLm1hcChlbmQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgICAgIGNvbW1hbmRzLFxuICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgIGNhbixcbiAgICAgICAgICAgICAgICBwYXN0ZUV2ZW50LFxuICAgICAgICAgICAgICAgIGRyb3BFdmVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc3VjY2VzcyA9IGhhbmRsZXJzLmV2ZXJ5KGhhbmRsZXIgPT4gaGFuZGxlciAhPT0gbnVsbCk7XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG59XG4vLyBXaGVuIGRyYWdnaW5nIGFjcm9zcyBlZGl0b3JzLCBtdXN0IGdldCBhbm90aGVyIGVkaXRvciBpbnN0YW5jZSB0byBkZWxldGUgc2VsZWN0aW9uIGNvbnRlbnQuXG5sZXQgdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvciA9IG51bGw7XG5jb25zdCBjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50ID0gKHRleHQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgfSk7XG4gICAgKF9hID0gZXZlbnQuY2xpcGJvYXJkRGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldERhdGEoJ3RleHQvaHRtbCcsIHRleHQpO1xuICAgIHJldHVybiBldmVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbiBwYXN0ZSBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSBwYXN0ZWRcbiAqIHRleHQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZeKAmXNcbiAqIGFjdGlvbi5cbiAqL1xuZnVuY3Rpb24gcGFzdGVSdWxlc1BsdWdpbihwcm9wcykge1xuICAgIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHM7XG4gICAgbGV0IGRyYWdTb3VyY2VFbGVtZW50ID0gbnVsbDtcbiAgICBsZXQgaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3IgPSBmYWxzZTtcbiAgICBsZXQgaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yID0gZmFsc2U7XG4gICAgbGV0IHBhc3RlRXZlbnQgPSB0eXBlb2YgQ2xpcGJvYXJkRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScpIDogbnVsbDtcbiAgICBsZXQgZHJvcEV2ZW50O1xuICAgIHRyeSB7XG4gICAgICAgIGRyb3BFdmVudCA9IHR5cGVvZiBEcmFnRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IERyYWdFdmVudCgnZHJvcCcpIDogbnVsbDtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICBkcm9wRXZlbnQgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwcm9jZXNzRXZlbnQgPSAoeyBzdGF0ZSwgZnJvbSwgdG8sIHJ1bGUsIHBhc3RlRXZ0LCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gICAgICAgIGNvbnN0IGNoYWluYWJsZVN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gcnVuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHN0YXRlOiBjaGFpbmFibGVTdGF0ZSxcbiAgICAgICAgICAgIGZyb206IE1hdGgubWF4KGZyb20gLSAxLCAwKSxcbiAgICAgICAgICAgIHRvOiB0by5iIC0gMSxcbiAgICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgICBwYXN0ZUV2ZW50OiBwYXN0ZUV2dCxcbiAgICAgICAgICAgIGRyb3BFdmVudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaGFuZGxlciB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRyb3BFdmVudCA9IHR5cGVvZiBEcmFnRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IERyYWdFdmVudCgnZHJvcCcpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICBkcm9wRXZlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHBhc3RlRXZlbnQgPSB0eXBlb2YgQ2xpcGJvYXJkRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScpIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHRyO1xuICAgIH07XG4gICAgY29uc3QgcGx1Z2lucyA9IHJ1bGVzLm1hcChydWxlID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgLy8gd2UgcmVnaXN0ZXIgYSBnbG9iYWwgZHJhZyBoYW5kbGVyIHRvIHRyYWNrIHRoZSBjdXJyZW50IGRyYWcgc291cmNlIGVsZW1lbnRcbiAgICAgICAgICAgIHZpZXcodmlldykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZURyYWdzdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdTb3VyY2VFbGVtZW50ID0gKChfYSA9IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2aWV3LmRvbS5wYXJlbnRFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnU291cmNlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlRHJhZ2VuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ3N0YXJ0KTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIGhhbmRsZURyYWdlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ3N0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgaGFuZGxlRHJhZ2VuZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgICAgICBkcm9wOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvciA9IGRyYWdTb3VyY2VFbGVtZW50ID09PSB2aWV3LmRvbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRyYWdGcm9tT3RoZXJFZGl0b3IgPSB0aXB0YXBEcmFnRnJvbU90aGVyRWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkcmFnRnJvbU90aGVyRWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldFRpbWVvdXQgdG8gYXZvaWQgdGhlIHdyb25nIGNvbnRlbnQgYWZ0ZXIgZHJvcCwgdGltZW91dCBhcmcgY2FuJ3QgYmUgZW1wdHkgb3IgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRyYWdGcm9tT3RoZXJFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdGcm9tT3RoZXJFZGl0b3IuY29tbWFuZHMuZGVsZXRlUmFuZ2UoeyBmcm9tOiBzZWxlY3Rpb24uZnJvbSwgdG86IHNlbGVjdGlvbi50byB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFzdGU6IChfdmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAoX2EgPSBldmVudC5jbGlwYm9hcmREYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXN0ZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9ICEhKGh0bWwgPT09IG51bGwgfHwgaHRtbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHRtbC5pbmNsdWRlcygnZGF0YS1wbS1zbGljZScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Bhc3RlID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgndWlFdmVudCcpID09PSAncGFzdGUnICYmICFpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0Ryb3AgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCd1aUV2ZW50JykgPT09ICdkcm9wJyAmJiAhaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yO1xuICAgICAgICAgICAgICAgIC8vIGlmIFBhc3RlUnVsZSBpcyB0cmlnZ2VyZWQgYnkgaW5zZXJ0Q29udGVudCgpXG4gICAgICAgICAgICAgICAgY29uc3Qgc2ltdWxhdGVkUGFzdGVNZXRhID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgnYXBwbHlQYXN0ZVJ1bGVzJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTaW11bGF0ZWRQYXN0ZSA9ICEhc2ltdWxhdGVkUGFzdGVNZXRhO1xuICAgICAgICAgICAgICAgIGlmICghaXNQYXN0ZSAmJiAhaXNEcm9wICYmICFpc1NpbXVsYXRlZFBhc3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHNpbXVsYXRlZCBwYXN0ZVxuICAgICAgICAgICAgICAgIGlmIChpc1NpbXVsYXRlZFBhc3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHRleHQgfSA9IHNpbXVsYXRlZFBhc3RlTWV0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZ2V0SFRNTEZyb21GcmFnbWVudChGcmFnbWVudC5mcm9tKHRleHQpLCBzdGF0ZS5zY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZnJvbSB9ID0gc2ltdWxhdGVkUGFzdGVNZXRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFzdGVFdnQgPSBjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50KHRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0V2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogeyBiOiB0byB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzdGVFdnQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgYWN0dWFsIHBhc3RlL2Ryb3BcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZTdGFydChzdGF0ZS5kb2MuY29udGVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG8gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZkVuZChzdGF0ZS5kb2MuY29udGVudCk7XG4gICAgICAgICAgICAgICAgLy8gc3RvcCBpZiB0aGVyZSBpcyBubyBjaGFuZ2VkIHJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihmcm9tKSB8fCAhdG8gfHwgZnJvbSA9PT0gdG8uYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlRXZ0OiBwYXN0ZUV2ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBsdWdpbnM7XG59XG5cbmZ1bmN0aW9uIGZpbmREdXBsaWNhdGVzKGl0ZW1zKSB7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBpdGVtcy5maWx0ZXIoKGVsLCBpbmRleCkgPT4gaXRlbXMuaW5kZXhPZihlbCkgIT09IGluZGV4KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGZpbHRlcmVkKSk7XG59XG5cbmNsYXNzIEV4dGVuc2lvbk1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGV4dGVuc2lvbnMsIGVkaXRvcikge1xuICAgICAgICB0aGlzLnNwbGl0dGFibGVNYXJrcyA9IFtdO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5yZXNvbHZlKGV4dGVuc2lvbnMpO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucywgZWRpdG9yKTtcbiAgICAgICAgdGhpcy5zZXR1cEV4dGVuc2lvbnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZsYXR0ZW5lZCBhbmQgc29ydGVkIGV4dGVuc2lvbiBsaXN0IHdoaWxlXG4gICAgICogYWxzbyBjaGVja2luZyBmb3IgZHVwbGljYXRlZCBleHRlbnNpb25zIGFuZCB3YXJucyB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBBbiBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICAgICAqIEByZXR1cm5zIEFuIGZsYXR0ZW5lZCBhbmQgc29ydGVkIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zXG4gICAgICovXG4gICAgc3RhdGljIHJlc29sdmUoZXh0ZW5zaW9ucykge1xuICAgICAgICBjb25zdCByZXNvbHZlZEV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnNvcnQoRXh0ZW5zaW9uTWFuYWdlci5mbGF0dGVuKGV4dGVuc2lvbnMpKTtcbiAgICAgICAgY29uc3QgZHVwbGljYXRlZE5hbWVzID0gZmluZER1cGxpY2F0ZXMocmVzb2x2ZWRFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4gZXh0ZW5zaW9uLm5hbWUpKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZWROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3RpcHRhcCB3YXJuXTogRHVwbGljYXRlIGV4dGVuc2lvbiBuYW1lcyBmb3VuZDogWyR7ZHVwbGljYXRlZE5hbWVzXG4gICAgICAgICAgICAgICAgLm1hcChpdGVtID0+IGAnJHtpdGVtfSdgKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfV0uIFRoaXMgY2FuIGxlYWQgdG8gaXNzdWVzLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZEV4dGVuc2lvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZsYXR0ZW5lZCBhcnJheSBvZiBleHRlbnNpb25zIGJ5IHRyYXZlcnNpbmcgdGhlIGBhZGRFeHRlbnNpb25zYCBmaWVsZC5cbiAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBBbiBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICAgICAqIEByZXR1cm5zIEEgZmxhdHRlbmVkIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zXG4gICAgICovXG4gICAgc3RhdGljIGZsYXR0ZW4oZXh0ZW5zaW9ucykge1xuICAgICAgICByZXR1cm4gKGV4dGVuc2lvbnNcbiAgICAgICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWRkRXh0ZW5zaW9ucyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZEV4dGVuc2lvbnMnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChhZGRFeHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtleHRlbnNpb24sIC4uLnRoaXMuZmxhdHRlbihhZGRFeHRlbnNpb25zKCkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgICAgIH0pXG4gICAgICAgICAgICAvLyBgSW5maW5pdHlgIHdpbGwgYnJlYWsgVHlwZVNjcmlwdCBzbyB3ZSBzZXQgYSBudW1iZXIgdGhhdCBpcyBwcm9iYWJseSBoaWdoIGVub3VnaFxuICAgICAgICAgICAgLmZsYXQoMTApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU29ydCBleHRlbnNpb25zIGJ5IHByaW9yaXR5LlxuICAgICAqIEBwYXJhbSBleHRlbnNpb25zIEFuIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zXG4gICAgICogQHJldHVybnMgQSBzb3J0ZWQgYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnMgYnkgcHJpb3JpdHlcbiAgICAgKi9cbiAgICBzdGF0aWMgc29ydChleHRlbnNpb25zKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcmlvcml0eSA9IDEwMDtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlBID0gZ2V0RXh0ZW5zaW9uRmllbGQoYSwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5O1xuICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlCID0gZ2V0RXh0ZW5zaW9uRmllbGQoYiwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5O1xuICAgICAgICAgICAgaWYgKHByaW9yaXR5QSA+IHByaW9yaXR5Qikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmlvcml0eUEgPCBwcmlvcml0eUIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBjb21tYW5kcyBmcm9tIHRoZSBleHRlbnNpb25zLlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGFsbCBjb21tYW5kcyB3aGVyZSB0aGUga2V5IGlzIHRoZSBjb21tYW5kIG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgY29tbWFuZCBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldCBjb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5yZWR1Y2UoKGNvbW1hbmRzLCBleHRlbnNpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWRkQ29tbWFuZHMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRDb21tYW5kcycsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKCFhZGRDb21tYW5kcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY29tbWFuZHMsXG4gICAgICAgICAgICAgICAgLi4uYWRkQ29tbWFuZHMoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCByZWdpc3RlcmVkIFByb3NlbWlycm9yIHBsdWdpbnMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBQcm9zZW1pcnJvciBwbHVnaW5zXG4gICAgICovXG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xuICAgICAgICAvLyBXaXRoIFByb3NlTWlycm9yLCBmaXJzdCBwbHVnaW5zIHdpdGhpbiBhbiBhcnJheSBhcmUgZXhlY3V0ZWQgZmlyc3QuXG4gICAgICAgIC8vIEluIFRpcHRhcCwgd2UgcHJvdmlkZSB0aGUgYWJpbGl0eSB0byBvdmVycmlkZSBwbHVnaW5zLFxuICAgICAgICAvLyBzbyBpdCBmZWVscyBtb3JlIG5hdHVyYWwgdG8gcnVuIHBsdWdpbnMgYXQgdGhlIGVuZCBvZiBhbiBhcnJheSBmaXJzdC5cbiAgICAgICAgLy8gVGhhdOKAmXMgd2h5IHdlIGhhdmUgdG8gcmV2ZXJzZSB0aGUgYGV4dGVuc2lvbnNgIGFycmF5IGFuZCBzb3J0IGFnYWluXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBgcHJpb3JpdHlgIG9wdGlvbi5cbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIuc29ydChbLi4udGhpcy5leHRlbnNpb25zXS5yZXZlcnNlKCkpO1xuICAgICAgICBjb25zdCBpbnB1dFJ1bGVzID0gW107XG4gICAgICAgIGNvbnN0IHBhc3RlUnVsZXMgPSBbXTtcbiAgICAgICAgY29uc3QgYWxsUGx1Z2lucyA9IGV4dGVuc2lvbnNcbiAgICAgICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5zID0gW107XG4gICAgICAgICAgICBjb25zdCBhZGRLZXlib2FyZFNob3J0Y3V0cyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZEtleWJvYXJkU2hvcnRjdXRzJywgY29udGV4dCk7XG4gICAgICAgICAgICBsZXQgZGVmYXVsdEJpbmRpbmdzID0ge307XG4gICAgICAgICAgICAvLyBiaW5kIGV4aXQgaGFuZGxpbmdcbiAgICAgICAgICAgIGlmIChleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnICYmIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2V4aXRhYmxlJywgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QmluZGluZ3MuQXJyb3dSaWdodCA9ICgpID0+IE1hcmsuaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyazogZXh0ZW5zaW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZEtleWJvYXJkU2hvcnRjdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmluZGluZ3MgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSkubWFwKChbc2hvcnRjdXQsIG1ldGhvZF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzaG9ydGN1dCwgKCkgPT4gbWV0aG9kKHsgZWRpdG9yIH0pXTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEJpbmRpbmdzID0geyAuLi5kZWZhdWx0QmluZGluZ3MsIC4uLmJpbmRpbmdzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXlNYXBQbHVnaW4gPSBrZXltYXAoZGVmYXVsdEJpbmRpbmdzKTtcbiAgICAgICAgICAgIHBsdWdpbnMucHVzaChrZXlNYXBQbHVnaW4pO1xuICAgICAgICAgICAgY29uc3QgYWRkSW5wdXRSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZElucHV0UnVsZXMnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVkaXRvci5vcHRpb25zLmVuYWJsZUlucHV0UnVsZXMpICYmIGFkZElucHV0UnVsZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dFJ1bGVzLnB1c2goLi4uYWRkSW5wdXRSdWxlcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZFBhc3RlUnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRQYXN0ZVJ1bGVzJywgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlZGl0b3Iub3B0aW9ucy5lbmFibGVQYXN0ZVJ1bGVzKSAmJiBhZGRQYXN0ZVJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgcGFzdGVSdWxlcy5wdXNoKC4uLmFkZFBhc3RlUnVsZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRQcm9zZU1pcnJvclBsdWdpbnMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRQcm9zZU1pcnJvclBsdWdpbnMnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChhZGRQcm9zZU1pcnJvclBsdWdpbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9zZU1pcnJvclBsdWdpbnMgPSBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKTtcbiAgICAgICAgICAgICAgICBwbHVnaW5zLnB1c2goLi4ucHJvc2VNaXJyb3JQbHVnaW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwbHVnaW5zO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZsYXQoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGlucHV0UnVsZXNQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBydWxlczogaW5wdXRSdWxlcyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLi4ucGFzdGVSdWxlc1BsdWdpbih7XG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIHJ1bGVzOiBwYXN0ZVJ1bGVzLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAuLi5hbGxQbHVnaW5zLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGF0dHJpYnV0ZXMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBub2RlIHZpZXdzIGZyb20gdGhlIGV4dGVuc2lvbnMuXG4gICAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYWxsIG5vZGUgdmlld3Mgd2hlcmUgdGhlIGtleSBpcyB0aGUgbm9kZSBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgdGhlIG5vZGUgdmlldyBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldCBub2RlVmlld3MoKSB7XG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhub2RlRXh0ZW5zaW9uc1xuICAgICAgICAgICAgLmZpbHRlcihleHRlbnNpb24gPT4gISFnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGROb2RlVmlldycpKVxuICAgICAgICAgICAgLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcy5maWx0ZXIoYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXROb2RlVHlwZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFkZE5vZGVWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkTm9kZVZpZXcnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmICghYWRkTm9kZVZpZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RldmlldyA9IChub2RlLCB2aWV3LCBnZXRQb3MsIGRlY29yYXRpb25zLCBpbm5lckRlY29yYXRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVWaWV3KCkoe1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXNzLXRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0UG9zOiBnZXRQb3MsXG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICBpbm5lckRlY29yYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aXB0YXAtc3BlY2lmaWNcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIG5vZGV2aWV3XTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHbyB0aHJvdWdoIGFsbCBleHRlbnNpb25zLCBjcmVhdGUgZXh0ZW5zaW9uIHN0b3JhZ2VzICYgc2V0dXAgbWFya3NcbiAgICAgKiAmIGJpbmQgZWRpdG9yIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIHNldHVwRXh0ZW5zaW9ucygpIHtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIHN0b3JlIGV4dGVuc2lvbiBzdG9yYWdlIGluIGVkaXRvclxuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZVtleHRlbnNpb24ubmFtZV0gPSBleHRlbnNpb24uc3RvcmFnZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZWVwT25TcGxpdCA9IChfYSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdrZWVwT25TcGxpdCcsIGNvbnRleHQpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2VlcE9uU3BsaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdHRhYmxlTWFya3MucHVzaChleHRlbnNpb24ubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb25CZWZvcmVDcmVhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkJlZm9yZUNyZWF0ZScsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb25DcmVhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkNyZWF0ZScsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvblVwZGF0ZScsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb25TZWxlY3Rpb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvblNlbGVjdGlvblVwZGF0ZScsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb25UcmFuc2FjdGlvbiA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ29uVHJhbnNhY3Rpb24nLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG9uRm9jdXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkZvY3VzJywgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBvbkJsdXIgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkJsdXInLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG9uRGVzdHJveSA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ29uRGVzdHJveScsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG9uQmVmb3JlQ3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JlZm9yZUNyZWF0ZScsIG9uQmVmb3JlQ3JlYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdjcmVhdGUnLCBvbkNyZWF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vbigndXBkYXRlJywgb25VcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uU2VsZWN0aW9uVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3NlbGVjdGlvblVwZGF0ZScsIG9uU2VsZWN0aW9uVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3RyYW5zYWN0aW9uJywgb25UcmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Gb2N1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdmb2N1cycsIG9uRm9jdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uQmx1cikge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdibHVyJywgb25CbHVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vbignZGVzdHJveScsIG9uRGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgRXh0ZW5zaW9uIGNsYXNzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgZXh0ZW5zaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zI2NyZWF0ZS1hLW5ldy1leHRlbnNpb25cbiAqL1xuY2xhc3MgRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZXh0ZW5zaW9uJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ2V4dGVuc2lvbic7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lO1xuICAgICAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRPcHRpb25zJywge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQodGhpcywgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgIH0pKSB8fCB7fTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEV4dGVuc2lvbihjb25maWcpO1xuICAgIH1cbiAgICBjb25maWd1cmUob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIHJldHVybiBhIG5ldyBpbnN0YW5jZSBzbyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGV4dGVuc2lvblxuICAgICAgICAvLyB3aXRoIGRpZmZlcmVudCBjYWxscyBvZiBgY29uZmlndXJlYFxuICAgICAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCh7XG4gICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIGFkZE9wdGlvbnM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWx3YXlzIHByZXNlcnZlIHRoZSBjdXJyZW50IG5hbWVcbiAgICAgICAgZXh0ZW5zaW9uLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIC8vIFNldCB0aGUgcGFyZW50IHRvIGJlIG91ciBwYXJlbnRcbiAgICAgICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgIH1cbiAgICBleHRlbmQoZXh0ZW5kZWRDb25maWcgPSB7fSkge1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgRXh0ZW5zaW9uKHsgLi4udGhpcy5jb25maWcsIC4uLmV4dGVuZGVkQ29uZmlnIH0pO1xuICAgICAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvbjtcbiAgICAgICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZTtcbiAgICAgICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICB9KSk7XG4gICAgICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHRleHQgYmV0d2VlbiB0d28gcG9zaXRpb25zIGluIGEgUHJvc2VtaXJyb3Igbm9kZVxuICogYW5kIHNlcmlhbGl6ZXMgaXQgdXNpbmcgdGhlIGdpdmVuIHRleHQgc2VyaWFsaXplcnMgYW5kIGJsb2NrIHNlcGFyYXRvciAoc2VlIGdldFRleHQpXG4gKiBAcGFyYW0gc3RhcnROb2RlIFRoZSBQcm9zZW1pcnJvciBub2RlIHRvIHN0YXJ0IGZyb21cbiAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIHRleHQgdG8gZ2V0XG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgdGV4dCBzZXJpYWxpemVyICYgYmxvY2sgc2VwYXJhdG9yXG4gKiBAcmV0dXJucyBUaGUgdGV4dCBiZXR3ZWVuIHRoZSB0d28gcG9zaXRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRCZXR3ZWVuKHN0YXJ0Tm9kZSwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgc3RhcnROb2RlLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50LCBpbmRleCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChub2RlLmlzQmxvY2sgJiYgcG9zID4gZnJvbSkge1xuICAgICAgICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0U2VyaWFsaXplciA9IHRleHRTZXJpYWxpemVycyA9PT0gbnVsbCB8fCB0ZXh0U2VyaWFsaXplcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHRTZXJpYWxpemVyc1tub2RlLnR5cGUubmFtZV07XG4gICAgICAgIGlmICh0ZXh0U2VyaWFsaXplcikge1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gdGV4dFNlcmlhbGl6ZXIoe1xuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG8gbm90IGRlc2NlbmQgaW50byBjaGlsZCBub2RlcyB3aGVuIHRoZXJlIGV4aXN0cyBhIHNlcmlhbGl6ZXJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgIHRleHQgKz0gKF9hID0gbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0ZXh0O1xufVxuXG4vKipcbiAqIEZpbmQgdGV4dCBzZXJpYWxpemVycyBgdG9UZXh0YCBpbiBhIFByb3NlbWlycm9yIHNjaGVtYVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJyb3Igc2NoZW1hIHRvIHNlYXJjaCBpblxuICogQHJldHVybnMgQSByZWNvcmQgb2YgdGV4dCBzZXJpYWxpemVycyBieSBub2RlIG5hbWVcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNjaGVtYS5ub2RlcylcbiAgICAgICAgLmZpbHRlcigoWywgbm9kZV0pID0+IG5vZGUuc3BlYy50b1RleHQpXG4gICAgICAgIC5tYXAoKFtuYW1lLCBub2RlXSkgPT4gW25hbWUsIG5vZGUuc3BlYy50b1RleHRdKSk7XG59XG5cbmNvbnN0IENsaXBib2FyZFRleHRTZXJpYWxpemVyID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2NsaXBib2FyZFRleHRTZXJpYWxpemVyJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmxvY2tTZXBhcmF0b3I6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXInKSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBjbGlwYm9hcmRUZXh0U2VyaWFsaXplcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHN0YXRlLCBzY2hlbWEgfSA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBNYXRoLm1pbiguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiRmcm9tLnBvcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiR0by5wb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRTZXJpYWxpemVycyA9IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0geyBmcm9tLCB0byB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKGRvYywgcmFuZ2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4odGhpcy5vcHRpb25zLmJsb2NrU2VwYXJhdG9yICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGJsb2NrU2VwYXJhdG9yOiB0aGlzLm9wdGlvbnMuYmxvY2tTZXBhcmF0b3IgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0U2VyaWFsaXplcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5jb25zdCBibHVyID0gKCkgPT4gKHsgZWRpdG9yLCB2aWV3IH0pID0+IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgICAgICAgICAvLyBCcm93c2VycyBzaG91bGQgcmVtb3ZlIHRoZSBjYXJldCBvbiBibHVyIGJ1dCBzYWZhcmkgZG9lcyBub3QuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMjQwNVxuICAgICAgICAgICAgKF9hID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmdldFNlbGVjdGlvbigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGNsZWFyQ29udGVudCA9IChlbWl0VXBkYXRlID0gZmFsc2UpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICByZXR1cm4gY29tbWFuZHMuc2V0Q29udGVudCgnJywgZW1pdFVwZGF0ZSk7XG59O1xuXG5jb25zdCBjbGVhck5vZGVzID0gKCkgPT4gKHsgc3RhdGUsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgaWYgKCFkaXNwYXRjaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZG9jLCBtYXBwaW5nIH0gPSB0cjtcbiAgICAgICAgICAgIGNvbnN0ICRtYXBwZWRGcm9tID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zKSk7XG4gICAgICAgICAgICBjb25zdCAkbWFwcGVkVG8gPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplKSk7XG4gICAgICAgICAgICBjb25zdCBub2RlUmFuZ2UgPSAkbWFwcGVkRnJvbS5ibG9ja1JhbmdlKCRtYXBwZWRUbyk7XG4gICAgICAgICAgICBpZiAoIW5vZGVSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldExpZnREZXB0aCA9IGxpZnRUYXJnZXQobm9kZVJhbmdlKTtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlZmF1bHRUeXBlIH0gPSAkbWFwcGVkRnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJG1hcHBlZEZyb20uaW5kZXgoKSk7XG4gICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChub2RlUmFuZ2Uuc3RhcnQsIGRlZmF1bHRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRMaWZ0RGVwdGggfHwgdGFyZ2V0TGlmdERlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdHIubGlmdChub2RlUmFuZ2UsIHRhcmdldExpZnREZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgY29tbWFuZCA9IGZuID0+IHByb3BzID0+IHtcbiAgICByZXR1cm4gZm4ocHJvcHMpO1xufTtcblxuY29uc3QgY3JlYXRlUGFyYWdyYXBoTmVhciA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcmFncmFwaE5lYXIkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3QgY3V0ID0gKG9yaWdpblJhbmdlLCB0YXJnZXRQb3MpID0+ICh7IGVkaXRvciwgdHIgfSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgICBjb25zdCBjb250ZW50U2xpY2UgPSBzdGF0ZS5kb2Muc2xpY2Uob3JpZ2luUmFuZ2UuZnJvbSwgb3JpZ2luUmFuZ2UudG8pO1xuICAgIHRyLmRlbGV0ZVJhbmdlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKTtcbiAgICBjb25zdCBuZXdQb3MgPSB0ci5tYXBwaW5nLm1hcCh0YXJnZXRQb3MpO1xuICAgIHRyLmluc2VydChuZXdQb3MsIGNvbnRlbnRTbGljZS5jb250ZW50KTtcbiAgICB0ci5zZXRTZWxlY3Rpb24obmV3IFRleHRTZWxlY3Rpb24odHIuZG9jLnJlc29sdmUobmV3UG9zIC0gMSkpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGRlbGV0ZUN1cnJlbnROb2RlID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gICAgY29uc3QgY3VycmVudE5vZGUgPSBzZWxlY3Rpb24uJGFuY2hvci5ub2RlKCk7XG4gICAgLy8gaWYgdGhlcmUgaXMgY29udGVudCBpbnNpZGUgdGhlIGN1cnJlbnQgbm9kZSwgYnJlYWsgb3V0IG9mIHRoaXMgY29tbWFuZFxuICAgIGlmIChjdXJyZW50Tm9kZS5jb250ZW50LnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yO1xuICAgIGZvciAobGV0IGRlcHRoID0gJHBvcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aCAtPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZGVwdGgpO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBjdXJyZW50Tm9kZS50eXBlKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gJHBvcy5iZWZvcmUoZGVwdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gJHBvcy5hZnRlcihkZXB0aCk7XG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgZGVsZXRlTm9kZSA9IHR5cGVPck5hbWUgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yO1xuICAgIGZvciAobGV0IGRlcHRoID0gJHBvcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aCAtPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZGVwdGgpO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gJHBvcy5iZWZvcmUoZGVwdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gJHBvcy5hZnRlcihkZXB0aCk7XG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgZGVsZXRlUmFuZ2UgPSByYW5nZSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHJhbmdlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGRlbGV0ZVNlbGVjdGlvbiA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGRlbGV0ZVNlbGVjdGlvbiQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5jb25zdCBlbnRlciA9ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICByZXR1cm4gY29tbWFuZHMua2V5Ym9hcmRTaG9ydGN1dCgnRW50ZXInKTtcbn07XG5cbmNvbnN0IGV4aXRDb2RlID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gZXhpdENvZGUkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBvYmplY3QxIGluY2x1ZGVzIG9iamVjdDJcbiAqIEBwYXJhbSBvYmplY3QxIE9iamVjdFxuICogQHBhcmFtIG9iamVjdDIgT2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG9iamVjdEluY2x1ZGVzKG9iamVjdDEsIG9iamVjdDIsIG9wdGlvbnMgPSB7IHN0cmljdDogdHJ1ZSB9KSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdDIpO1xuICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBrZXlzLmV2ZXJ5KGtleSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDJba2V5XSA9PT0gb2JqZWN0MVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JlZ0V4cChvYmplY3QyW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0MltrZXldLnRlc3Qob2JqZWN0MVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRNYXJrSW5TZXQobWFya3MsIHR5cGUsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIHJldHVybiBtYXJrcy5maW5kKGl0ZW0gPT4ge1xuICAgICAgICByZXR1cm4gKGl0ZW0udHlwZSA9PT0gdHlwZVxuICAgICAgICAgICAgJiYgb2JqZWN0SW5jbHVkZXMoXG4gICAgICAgICAgICAvLyBPbmx5IGNoZWNrIGVxdWFsaXR5IGZvciB0aGUgYXR0cmlidXRlcyB0aGF0IGFyZSBwcm92aWRlZFxuICAgICAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcChrID0+IFtrLCBpdGVtLmF0dHJzW2tdXSkpLCBhdHRyaWJ1dGVzKSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc01hcmtJblNldChtYXJrcywgdHlwZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgcmV0dXJuICEhZmluZE1hcmtJblNldChtYXJrcywgdHlwZSwgYXR0cmlidXRlcyk7XG59XG4vKipcbiAqIEdldCB0aGUgcmFuZ2Ugb2YgYSBtYXJrIGF0IGEgcmVzb2x2ZWQgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdldE1hcmtSYW5nZShcbi8qKlxuICogVGhlIHBvc2l0aW9uIHRvIGdldCB0aGUgbWFyayByYW5nZSBmb3IuXG4gKi9cbiRwb3MsIFxuLyoqXG4gKiBUaGUgbWFyayB0eXBlIHRvIGdldCB0aGUgcmFuZ2UgZm9yLlxuICovXG50eXBlLCBcbi8qKlxuICogVGhlIGF0dHJpYnV0ZXMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAqIElmIG5vdCBwcm92aWRlZCwgb25seSB0aGUgZmlyc3QgbWFyayBhdCB0aGUgcG9zaXRpb24gd2lsbCBiZSBtYXRjaGVkLlxuICovXG5hdHRyaWJ1dGVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghJHBvcyB8fCAhdHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzdGFydCA9ICRwb3MucGFyZW50LmNoaWxkQWZ0ZXIoJHBvcy5wYXJlbnRPZmZzZXQpO1xuICAgIC8vIElmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlIHRoYXQgZG9lcyBub3QgaGF2ZSB0aGUgbWFyaywgbG9vayBiYWNrd2FyZFxuICAgIGlmICghc3RhcnQubm9kZSB8fCAhc3RhcnQubm9kZS5tYXJrcy5zb21lKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKSkge1xuICAgICAgICBzdGFydCA9ICRwb3MucGFyZW50LmNoaWxkQmVmb3JlKCRwb3MucGFyZW50T2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gdGV4dCBub2RlIHdpdGggdGhlIG1hcmsgZXZlbiBiYWNrd2FyZCwgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmICghc3RhcnQubm9kZSB8fCAhc3RhcnQubm9kZS5tYXJrcy5zb21lKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlZmF1bHQgdG8gb25seSBtYXRjaGluZyBhZ2FpbnN0IHRoZSBmaXJzdCBtYXJrJ3MgYXR0cmlidXRlc1xuICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8ICgoX2EgPSBzdGFydC5ub2RlLm1hcmtzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cnMpO1xuICAgIC8vIFdlIG5vdyBrbm93IHRoYXQgdGhlIGN1cnNvciBpcyBlaXRoZXIgYXQgdGhlIHN0YXJ0LCBtaWRkbGUgb3IgZW5kIG9mIGEgdGV4dCBub2RlIHdpdGggdGhlIHNwZWNpZmllZCBtYXJrXG4gICAgLy8gc28gd2UgY2FuIGxvb2sgaXQgdXAgb24gdGhlIHRhcmdldGVkIG1hcmtcbiAgICBjb25zdCBtYXJrID0gZmluZE1hcmtJblNldChbLi4uc3RhcnQubm9kZS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgIGlmICghbWFyaykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaW5kZXg7XG4gICAgbGV0IHN0YXJ0UG9zID0gJHBvcy5zdGFydCgpICsgc3RhcnQub2Zmc2V0O1xuICAgIGxldCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyAxO1xuICAgIGxldCBlbmRQb3MgPSBzdGFydFBvcyArIHN0YXJ0Lm5vZGUubm9kZVNpemU7XG4gICAgd2hpbGUgKHN0YXJ0SW5kZXggPiAwXG4gICAgICAgICYmIGlzTWFya0luU2V0KFsuLi4kcG9zLnBhcmVudC5jaGlsZChzdGFydEluZGV4IC0gMSkubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKSkge1xuICAgICAgICBzdGFydEluZGV4IC09IDE7XG4gICAgICAgIHN0YXJ0UG9zIC09ICRwb3MucGFyZW50LmNoaWxkKHN0YXJ0SW5kZXgpLm5vZGVTaXplO1xuICAgIH1cbiAgICB3aGlsZSAoZW5kSW5kZXggPCAkcG9zLnBhcmVudC5jaGlsZENvdW50XG4gICAgICAgICYmIGlzTWFya0luU2V0KFsuLi4kcG9zLnBhcmVudC5jaGlsZChlbmRJbmRleCkubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKSkge1xuICAgICAgICBlbmRQb3MgKz0gJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm5vZGVTaXplO1xuICAgICAgICBlbmRJbmRleCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBzdGFydFBvcyxcbiAgICAgICAgdG86IGVuZFBvcyxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRNYXJrVHlwZShuYW1lT3JUeXBlLCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghc2NoZW1hLm1hcmtzW25hbWVPclR5cGVdKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVGhlcmUgaXMgbm8gbWFyayB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hLm1hcmtzW25hbWVPclR5cGVdO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZU9yVHlwZTtcbn1cblxuY29uc3QgZXh0ZW5kTWFya1JhbmdlID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gdHI7XG4gICAgY29uc3QgeyAkZnJvbSwgZnJvbSwgdG8gfSA9IHNlbGVjdGlvbjtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJGZyb20sIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAocmFuZ2UgJiYgcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgZmlyc3QgPSBjb21tYW5kcyA9PiBwcm9wcyA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSB0eXBlb2YgY29tbWFuZHMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjb21tYW5kcyhwcm9wcylcbiAgICAgICAgOiBjb21tYW5kcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChpdGVtc1tpXShwcm9wcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dFNlbGVjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIG1pbk1heCh2YWx1ZSA9IDAsIG1pbiA9IDAsIG1heCA9IDApIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGb2N1c1Bvc2l0aW9uKGRvYywgcG9zaXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uQXRTdGFydCA9IFNlbGVjdGlvbi5hdFN0YXJ0KGRvYyk7XG4gICAgY29uc3Qgc2VsZWN0aW9uQXRFbmQgPSBTZWxlY3Rpb24uYXRFbmQoZG9jKTtcbiAgICBpZiAocG9zaXRpb24gPT09ICdzdGFydCcgfHwgcG9zaXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkF0U3RhcnQ7XG4gICAgfVxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkF0RW5kO1xuICAgIH1cbiAgICBjb25zdCBtaW5Qb3MgPSBzZWxlY3Rpb25BdFN0YXJ0LmZyb207XG4gICAgY29uc3QgbWF4UG9zID0gc2VsZWN0aW9uQXRFbmQudG87XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYWxsJykge1xuICAgICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBtaW5NYXgoMCwgbWluUG9zLCBtYXhQb3MpLCBtaW5NYXgoZG9jLmNvbnRlbnQuc2l6ZSwgbWluUG9zLCBtYXhQb3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcyksIG1pbk1heChwb3NpdGlvbiwgbWluUG9zLCBtYXhQb3MpKTtcbn1cblxuZnVuY3Rpb24gaXNBbmRyb2lkKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdBbmRyb2lkJyB8fCAvYW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5cbmZ1bmN0aW9uIGlzaU9TKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgICdpUGFkIFNpbXVsYXRvcicsXG4gICAgICAgICdpUGhvbmUgU2ltdWxhdG9yJyxcbiAgICAgICAgJ2lQb2QgU2ltdWxhdG9yJyxcbiAgICAgICAgJ2lQYWQnLFxuICAgICAgICAnaVBob25lJyxcbiAgICAgICAgJ2lQb2QnLFxuICAgIF0uaW5jbHVkZXMobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAgICAgICAvLyBpUGFkIG9uIGlPUyAxMyBkZXRlY3Rpb25cbiAgICAgICAgfHwgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ01hYycpICYmICdvbnRvdWNoZW5kJyBpbiBkb2N1bWVudCk7XG59XG5cbmNvbnN0IGZvY3VzID0gKHBvc2l0aW9uID0gbnVsbCwgb3B0aW9ucyA9IHt9KSA9PiAoeyBlZGl0b3IsIHZpZXcsIHRyLCBkaXNwYXRjaCwgfSkgPT4ge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgY29uc3QgZGVsYXllZEZvY3VzID0gKCkgPT4ge1xuICAgICAgICAvLyBmb2N1cyB3aXRoaW4gYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYnJlYWtzIGZvY3VzIG9uIGlPUyBhbmQgQW5kcm9pZFxuICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIGNhbGwgdGhpc1xuICAgICAgICBpZiAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSkge1xuICAgICAgICAgICAgdmlldy5kb20uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgUmVhY3Qgd2UgaGF2ZSB0byBmb2N1cyBhc3luY2hyb25vdXNseS4gT3RoZXJ3aXNlIHdpbGQgdGhpbmdzIGhhcHBlbi5cbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzE1MjBcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNvbW1hbmRzLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlmICgodmlldy5oYXNGb2N1cygpICYmIHBvc2l0aW9uID09PSBudWxsKSB8fCBwb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIHdlIGRvbuKAmXQgdHJ5IHRvIHJlc29sdmUgYSBOb2RlU2VsZWN0aW9uIG9yIENlbGxTZWxlY3Rpb25cbiAgICBpZiAoZGlzcGF0Y2ggJiYgcG9zaXRpb24gPT09IG51bGwgJiYgIWlzVGV4dFNlbGVjdGlvbihlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICBkZWxheWVkRm9jdXMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIHBhc3MgdGhyb3VnaCB0ci5kb2MgaW5zdGVhZCBvZiBlZGl0b3Iuc3RhdGUuZG9jXG4gICAgLy8gc2luY2UgdHJhbnNhY3Rpb25zIGNvdWxkIGNoYW5nZSB0aGUgZWRpdG9ycyBzdGF0ZSBiZWZvcmUgdGhpcyBjb21tYW5kIGhhcyBiZWVuIHJ1blxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHJlc29sdmVGb2N1c1Bvc2l0aW9uKHRyLmRvYywgcG9zaXRpb24pIHx8IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgY29uc3QgaXNTYW1lU2VsZWN0aW9uID0gZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5lcShzZWxlY3Rpb24pO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBpZiAoIWlzU2FtZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYHRyLnNldFNlbGVjdGlvbmAgcmVzZXRzIHRoZSBzdG9yZWQgbWFya3NcbiAgICAgICAgLy8gc28gd2XigJlsbCByZXN0b3JlIHRoZW0gaWYgdGhlIHNlbGVjdGlvbiBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcbiAgICAgICAgaWYgKGlzU2FtZVNlbGVjdGlvbiAmJiB0ci5zdG9yZWRNYXJrcykge1xuICAgICAgICAgICAgdHIuc2V0U3RvcmVkTWFya3ModHIuc3RvcmVkTWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGF5ZWRGb2N1cygpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGZvckVhY2ggPSAoaXRlbXMsIGZuKSA9PiBwcm9wcyA9PiB7XG4gICAgcmV0dXJuIGl0ZW1zLmV2ZXJ5KChpdGVtLCBpbmRleCkgPT4gZm4oaXRlbSwgeyAuLi5wcm9wcywgaW5kZXggfSkpO1xufTtcblxuY29uc3QgaW5zZXJ0Q29udGVudCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4gKHsgdHIsIGNvbW1hbmRzIH0pID0+IHtcbiAgICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbTogdHIuc2VsZWN0aW9uLmZyb20sIHRvOiB0ci5zZWxlY3Rpb24udG8gfSwgdmFsdWUsIG9wdGlvbnMpO1xufTtcblxuY29uc3QgcmVtb3ZlV2hpdGVzcGFjZXMgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDMgJiYgY2hpbGQubm9kZVZhbHVlICYmIC9eKFxcblxcc1xcc3xcXG4pJC8udGVzdChjaGlsZC5ub2RlVmFsdWUpKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgcmVtb3ZlV2hpdGVzcGFjZXMoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcbmZ1bmN0aW9uIGVsZW1lbnRGcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgLy8gYWRkIGEgd3JhcHBlciB0byBwcmVzZXJ2ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgY29uc3Qgd3JhcHBlZFZhbHVlID0gYDxib2R5PiR7dmFsdWV9PC9ib2R5PmA7XG4gICAgY29uc3QgaHRtbCA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHdyYXBwZWRWYWx1ZSwgJ3RleHQvaHRtbCcpLmJvZHk7XG4gICAgcmV0dXJuIHJlbW92ZVdoaXRlc3BhY2VzKGh0bWwpO1xufVxuXG4vKipcbiAqIFRha2VzIGEgSlNPTiBvciBIVE1MIGNvbnRlbnQgYW5kIGNyZWF0ZXMgYSBQcm9zZW1pcnJvciBub2RlIG9yIGZyYWdtZW50IGZyb20gaXQuXG4gKiBAcGFyYW0gY29udGVudCBUaGUgSlNPTiBvciBIVE1MIGNvbnRlbnQgdG8gY3JlYXRlIHRoZSBub2RlIGZyb21cbiAqIEBwYXJhbSBzY2hlbWEgVGhlIFByb3NlbWlycm9yIHNjaGVtYSB0byB1c2UgZm9yIHRoZSBub2RlXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgcGFyc2VyXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBQcm9zZW1pcnJvciBub2RlIG9yIGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVGcm9tQ29udGVudChjb250ZW50LCBzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIE5vZGUkMSB8fCBjb250ZW50IGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHNsaWNlOiB0cnVlLFxuICAgICAgICBwYXJzZU9wdGlvbnM6IHt9LFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgY29uc3QgaXNKU09OQ29udGVudCA9IHR5cGVvZiBjb250ZW50ID09PSAnb2JqZWN0JyAmJiBjb250ZW50ICE9PSBudWxsO1xuICAgIGNvbnN0IGlzVGV4dENvbnRlbnQgPSB0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZyc7XG4gICAgaWYgKGlzSlNPTkNvbnRlbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQXJyYXlDb250ZW50ID0gQXJyYXkuaXNBcnJheShjb250ZW50KSAmJiBjb250ZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAvLyBpZiB0aGUgSlNPTiBDb250ZW50IGlzIGFuIGFycmF5IG9mIG5vZGVzLCBjcmVhdGUgYSBmcmFnbWVudCBmb3IgZWFjaCBub2RlXG4gICAgICAgICAgICBpZiAoaXNBcnJheUNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbUFycmF5KGNvbnRlbnQubWFwKGl0ZW0gPT4gc2NoZW1hLm5vZGVGcm9tSlNPTihpdGVtKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHNjaGVtYS5ub2RlRnJvbUpTT04oY29udGVudCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBub2RlLmNoZWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSlNPTiBjb250ZW50JywgeyBjYXVzZTogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IEludmFsaWQgY29udGVudC4nLCAnUGFzc2VkIHZhbHVlOicsIGNvbnRlbnQsICdFcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KCcnLCBzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc1RleHRDb250ZW50KSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBpbnZhbGlkIGNvbnRlbnRcbiAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgaGFzSW52YWxpZENvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpbnZhbGlkQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgLy8gQSBjb3B5IG9mIHRoZSBjdXJyZW50IHNjaGVtYSB3aXRoIGEgY2F0Y2gtYWxsIG5vZGUgYXQgdGhlIGVuZFxuICAgICAgICAgICAgY29uc3QgY29udGVudENoZWNrU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgICAgICAgICAgICAgdG9wTm9kZTogc2NoZW1hLnNwZWMudG9wTm9kZSxcbiAgICAgICAgICAgICAgICBtYXJrczogc2NoZW1hLnNwZWMubWFya3MsXG4gICAgICAgICAgICAgICAgLy8gUHJvc2VtaXJyb3IncyBzY2hlbWFzIGFyZSBleGVjdXRlZCBzdWNoIHRoYXQ6IHRoZSBsYXN0IHRvIGV4ZWN1dGUsIG1hdGNoZXMgbGFzdFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB3ZSBjYW4gYWRkIGEgY2F0Y2gtYWxsIG5vZGUgYXQgdGhlIGVuZCBvZiB0aGUgc2NoZW1hIHRvIGNhdGNoIGFueSBjb250ZW50IHRoYXQgd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlXG4gICAgICAgICAgICAgICAgbm9kZXM6IHNjaGVtYS5zcGVjLm5vZGVzLmFwcGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIF9fdGlwdGFwX19wcml2YXRlX191bmtub3duX19jYXRjaF9fYWxsX19ub2RlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnaW5saW5lKicsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICcqJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBldmVyIGNhbGxlZCwgd2Uga25vdyB0aGF0IHRoZSBjb250ZW50IGhhcyBzb21ldGhpbmcgdGhhdCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGUgaW4gdGhlIHNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzSW52YWxpZENvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHN0cmluZ2lmeSB0aGUgZWxlbWVudCBmb3IgYSBtb3JlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZENvbnRlbnQgPSB0eXBlb2YgZSA9PT0gJ3N0cmluZycgPyBlIDogZS5vdXRlckhUTUw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2xpY2UpIHtcbiAgICAgICAgICAgICAgICBET01QYXJzZXIuZnJvbVNjaGVtYShjb250ZW50Q2hlY2tTY2hlbWEpLnBhcnNlU2xpY2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIERPTVBhcnNlci5mcm9tU2NoZW1hKGNvbnRlbnRDaGVja1NjaGVtYSkucGFyc2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCAmJiBoYXNJbnZhbGlkQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSFRNTCBjb250ZW50JywgeyBjYXVzZTogbmV3IEVycm9yKGBJbnZhbGlkIGVsZW1lbnQgZm91bmQ6ICR7aW52YWxpZENvbnRlbnR9YCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VyID0gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2xpY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VTbGljZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KCcnLCBzY2hlbWEsIG9wdGlvbnMpO1xufVxuXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci1zdGF0ZS9ibG9iL21hc3Rlci9zcmMvc2VsZWN0aW9uLmpzI0w0NjZcbmZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBzdGFydExlbiwgYmlhcykge1xuICAgIGNvbnN0IGxhc3QgPSB0ci5zdGVwcy5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0IDwgc3RhcnRMZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGVwID0gdHIuc3RlcHNbbGFzdF07XG4gICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwIHx8IHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlQXJvdW5kU3RlcCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbbGFzdF07XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgbWFwLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4ge1xuICAgICAgICBpZiAoZW5kID09PSAwKSB7XG4gICAgICAgICAgICBlbmQgPSBuZXdUbztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSk7XG59XG5cbmNvbnN0IGlzRnJhZ21lbnQgPSAobm9kZU9yRnJhZ21lbnQpID0+IHtcbiAgICByZXR1cm4gISgndHlwZScgaW4gbm9kZU9yRnJhZ21lbnQpO1xufTtcbmNvbnN0IGluc2VydENvbnRlbnRBdCA9IChwb3NpdGlvbiwgdmFsdWUsIG9wdGlvbnMpID0+ICh7IHRyLCBkaXNwYXRjaCwgZWRpdG9yIH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwYXJzZU9wdGlvbnM6IGVkaXRvci5vcHRpb25zLnBhcnNlT3B0aW9ucyxcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGFwcGx5SW5wdXRSdWxlczogZmFsc2UsXG4gICAgICAgICAgICBhcHBseVBhc3RlUnVsZXM6IGZhbHNlLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250ZW50ID0gY3JlYXRlTm9kZUZyb21Db250ZW50KHZhbHVlLCBlZGl0b3Iuc2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJ2Z1bGwnLFxuICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLnBhcnNlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogKF9hID0gb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlZGl0b3IuZW1pdCgnY29udGVudEVycm9yJywge1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlQ29sbGFib3JhdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdG9yLnN0b3JhZ2UuY29sbGFib3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnN0b3JhZ2UuY29sbGFib3JhdGlvbi5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdHlwZW9mIHBvc2l0aW9uID09PSAnbnVtYmVyJyA/IHsgZnJvbTogcG9zaXRpb24sIHRvOiBwb3NpdGlvbiB9IDogeyBmcm9tOiBwb3NpdGlvbi5mcm9tLCB0bzogcG9zaXRpb24udG8gfTtcbiAgICAgICAgbGV0IGlzT25seVRleHRDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzT25seUJsb2NrQ29udGVudCA9IHRydWU7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gaXNGcmFnbWVudChjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF07XG4gICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBhZGRlZCBub2RlIGlzIHZhbGlkXG4gICAgICAgICAgICBub2RlLmNoZWNrKCk7XG4gICAgICAgICAgICBpc09ubHlUZXh0Q29udGVudCA9IGlzT25seVRleHRDb250ZW50ID8gbm9kZS5pc1RleHQgJiYgbm9kZS5tYXJrcy5sZW5ndGggPT09IDAgOiBmYWxzZTtcbiAgICAgICAgICAgIGlzT25seUJsb2NrQ29udGVudCA9IGlzT25seUJsb2NrQ29udGVudCA/IG5vZGUuaXNCbG9jayA6IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlcGxhY2UgdGhlIHdyYXBwaW5nIG5vZGUgYnlcbiAgICAgICAgLy8gdGhlIG5ld2x5IGluc2VydGVkIGNvbnRlbnRcbiAgICAgICAgLy8gZXhhbXBsZTpcbiAgICAgICAgLy8gcmVwbGFjZSBhbiBlbXB0eSBwYXJhZ3JhcGggYnkgYW4gaW5zZXJ0ZWQgaW1hZ2VcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBpbnNlcnRpbmcgdGhlIGltYWdlIGJlbG93IHRoZSBwYXJhZ3JhcGhcbiAgICAgICAgaWYgKGZyb20gPT09IHRvICYmIGlzT25seUJsb2NrQ29udGVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBwYXJlbnQgfSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pO1xuICAgICAgICAgICAgY29uc3QgaXNFbXB0eVRleHRCbG9jayA9IHBhcmVudC5pc1RleHRibG9jayAmJiAhcGFyZW50LnR5cGUuc3BlYy5jb2RlICYmICFwYXJlbnQuY2hpbGRDb3VudDtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5VGV4dEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgZnJvbSAtPSAxO1xuICAgICAgICAgICAgICAgIHRvICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0NvbnRlbnQ7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgcGxhaW4gdGV4dCB3ZSBoYXZlIHRvIHVzZSBgaW5zZXJ0VGV4dGBcbiAgICAgICAgLy8gYmVjYXVzZSB0aGlzIHdpbGwga2VlcCB0aGUgY3VycmVudCBtYXJrc1xuICAgICAgICBpZiAoaXNPbmx5VGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIGlmIHZhbHVlIGlzIHN0cmluZywgd2UgY2FuIHVzZSBpdCBkaXJlY3RseVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIGl0IGlzIGFuIGFycmF5LCB3ZSBoYXZlIHRvIGpvaW4gaXRcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZS5tYXAodiA9PiB2LnRleHQgfHwgJycpLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBub2RlLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZXdDb250ZW50ID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgISF2YWx1ZSAmJiAhIXZhbHVlLnRleHQpIHtcbiAgICAgICAgICAgICAgICBuZXdDb250ZW50ID0gdmFsdWUudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLmluc2VydFRleHQobmV3Q29udGVudCwgZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB0ci5yZXBsYWNlV2l0aChmcm9tLCB0bywgbmV3Q29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGN1cnNvciBhdCBlbmQgb2YgaW5zZXJ0ZWQgY29udGVudFxuICAgICAgICBpZiAob3B0aW9ucy51cGRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCB0ci5zdGVwcy5sZW5ndGggLSAxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwbHlJbnB1dFJ1bGVzKSB7XG4gICAgICAgICAgICB0ci5zZXRNZXRhKCdhcHBseUlucHV0UnVsZXMnLCB7IGZyb20sIHRleHQ6IG5ld0NvbnRlbnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwbHlQYXN0ZVJ1bGVzKSB7XG4gICAgICAgICAgICB0ci5zZXRNZXRhKCdhcHBseVBhc3RlUnVsZXMnLCB7IGZyb20sIHRleHQ6IG5ld0NvbnRlbnQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBqb2luVXAgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBqb2luVXAkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcbmNvbnN0IGpvaW5Eb3duID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gam9pbkRvd24kMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcbmNvbnN0IGpvaW5CYWNrd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGpvaW5CYWNrd2FyZCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuY29uc3Qgam9pbkZvcndhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBqb2luRm9yd2FyZCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5jb25zdCBqb2luSXRlbUJhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCB0ciwgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgLTEpO1xuICAgICAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyLmpvaW4ocG9pbnQsIDIpO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuY29uc3Qgam9pbkl0ZW1Gb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCB0ciwgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgKzEpO1xuICAgICAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyLmpvaW4ocG9pbnQsIDIpO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuY29uc3Qgam9pblRleHRibG9ja0JhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gam9pblRleHRibG9ja0JhY2t3YXJkJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmNvbnN0IGpvaW5UZXh0YmxvY2tGb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gam9pblRleHRibG9ja0ZvcndhcmQkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuZnVuY3Rpb24gaXNNYWNPUygpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgICAgICAgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdCA9PT0gJ1NwYWNlJykge1xuICAgICAgICByZXN1bHQgPSAnICc7XG4gICAgfVxuICAgIGxldCBhbHQ7XG4gICAgbGV0IGN0cmw7XG4gICAgbGV0IHNoaWZ0O1xuICAgIGxldCBtZXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKSB7XG4gICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGlmIChpc2lPUygpIHx8IGlzTWFjT1MoKSkge1xuICAgICAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiAke21vZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IGBBbHQtJHtyZXN1bHR9YDtcbiAgICB9XG4gICAgaWYgKGN0cmwpIHtcbiAgICAgICAgcmVzdWx0ID0gYEN0cmwtJHtyZXN1bHR9YDtcbiAgICB9XG4gICAgaWYgKG1ldGEpIHtcbiAgICAgICAgcmVzdWx0ID0gYE1ldGEtJHtyZXN1bHR9YDtcbiAgICB9XG4gICAgaWYgKHNoaWZ0KSB7XG4gICAgICAgIHJlc3VsdCA9IGBTaGlmdC0ke3Jlc3VsdH1gO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qga2V5Ym9hcmRTaG9ydGN1dCA9IG5hbWUgPT4gKHsgZWRpdG9yLCB2aWV3LCB0ciwgZGlzcGF0Y2gsIH0pID0+IHtcbiAgICBjb25zdCBrZXlzID0gbm9ybWFsaXplS2V5TmFtZShuYW1lKS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgY29uc3Qga2V5ID0ga2V5cy5maW5kKGl0ZW0gPT4gIVsnQWx0JywgJ0N0cmwnLCAnTWV0YScsICdTaGlmdCddLmluY2x1ZGVzKGl0ZW0pKTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBLZXlib2FyZEV2ZW50KCdrZXlkb3duJywge1xuICAgICAgICBrZXk6IGtleSA9PT0gJ1NwYWNlJ1xuICAgICAgICAgICAgPyAnICdcbiAgICAgICAgICAgIDoga2V5LFxuICAgICAgICBhbHRLZXk6IGtleXMuaW5jbHVkZXMoJ0FsdCcpLFxuICAgICAgICBjdHJsS2V5OiBrZXlzLmluY2x1ZGVzKCdDdHJsJyksXG4gICAgICAgIG1ldGFLZXk6IGtleXMuaW5jbHVkZXMoJ01ldGEnKSxcbiAgICAgICAgc2hpZnRLZXk6IGtleXMuaW5jbHVkZXMoJ1NoaWZ0JyksXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgfSk7XG4gICAgY29uc3QgY2FwdHVyZWRUcmFuc2FjdGlvbiA9IGVkaXRvci5jYXB0dXJlVHJhbnNhY3Rpb24oKCkgPT4ge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKCdoYW5kbGVLZXlEb3duJywgZiA9PiBmKHZpZXcsIGV2ZW50KSk7XG4gICAgfSk7XG4gICAgY2FwdHVyZWRUcmFuc2FjdGlvbiA9PT0gbnVsbCB8fCBjYXB0dXJlZFRyYW5zYWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXB0dXJlZFRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goc3RlcCA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1N0ZXAgPSBzdGVwLm1hcCh0ci5tYXBwaW5nKTtcbiAgICAgICAgaWYgKG5ld1N0ZXAgJiYgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHRyLm1heWJlU3RlcChuZXdTdGVwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGw7XG4gICAgY29uc3Qgbm9kZVJhbmdlcyA9IFtdO1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVsYXRpdmVGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLm5vZGVTaXplKTtcbiAgICAgICAgbm9kZVJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXG4gICAgICAgICAgICB0bzogcmVsYXRpdmVUbyxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uUmFuZ2UgPSB0byAtIGZyb207XG4gICAgY29uc3QgbWF0Y2hlZE5vZGVSYW5nZXMgPSBub2RlUmFuZ2VzXG4gICAgICAgIC5maWx0ZXIobm9kZVJhbmdlID0+IHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBub2RlUmFuZ2Uubm9kZS50eXBlLm5hbWU7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihub2RlUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobm9kZVJhbmdlLm5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSk7XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIHJldHVybiAhIW1hdGNoZWROb2RlUmFuZ2VzLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2UgPSBtYXRjaGVkTm9kZVJhbmdlcy5yZWR1Y2UoKHN1bSwgbm9kZVJhbmdlKSA9PiBzdW0gKyBub2RlUmFuZ2UudG8gLSBub2RlUmFuZ2UuZnJvbSwgMCk7XG4gICAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlO1xufVxuXG5jb25zdCBsaWZ0ID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBsaWZ0JDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmNvbnN0IGxpZnRFbXB0eUJsb2NrID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gbGlmdEVtcHR5QmxvY2skMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3QgbGlmdExpc3RJdGVtID0gdHlwZU9yTmFtZSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIHJldHVybiBsaWZ0TGlzdEl0ZW0kMSh0eXBlKShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3QgbmV3bGluZUluQ29kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIG5ld2xpbmVJbkNvZGUkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgYSBzY2hlbWEgaXRlbSBieSBpdHMgbmFtZS5cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzY2hlbWEgaXRlbVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJvciBzY2hlbWEgdG8gc2VhcmNoIGluXG4gKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgc2NoZW1hIGl0ZW0gKGBub2RlYCBvciBgbWFya2ApLCBvciBudWxsIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAqL1xuZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUobmFtZSwgc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYS5ub2Rlc1tuYW1lXSkge1xuICAgICAgICByZXR1cm4gJ25vZGUnO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLm1hcmtzW25hbWVdKSB7XG4gICAgICAgIHJldHVybiAnbWFyayc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIHByb3BlcnR5IG9yIGFuIGFycmF5IG9mIHByb3BlcnRpZXMgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSBvYmogT2JqZWN0XG4gKiBAcGFyYW0ga2V5IEtleSB0byByZW1vdmVcbiAqL1xuZnVuY3Rpb24gZGVsZXRlUHJvcHMob2JqLCBwcm9wT3JQcm9wcykge1xuICAgIGNvbnN0IHByb3BzID0gdHlwZW9mIHByb3BPclByb3BzID09PSAnc3RyaW5nJ1xuICAgICAgICA/IFtwcm9wT3JQcm9wc11cbiAgICAgICAgOiBwcm9wT3JQcm9wcztcbiAgICByZXR1cm4gT2JqZWN0XG4gICAgICAgIC5rZXlzKG9iailcbiAgICAgICAgLnJlZHVjZSgobmV3T2JqLCBwcm9wKSA9PiB7XG4gICAgICAgIGlmICghcHJvcHMuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgICAgIG5ld09ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH0sIHt9KTtcbn1cblxuY29uc3QgcmVzZXRBdHRyaWJ1dGVzID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMpID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBub2RlVHlwZSA9IG51bGw7XG4gICAgbGV0IG1hcmtUeXBlID0gbnVsbDtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUodHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgIG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xuICAgICAgICBtYXJrVHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB0ci5zZWxlY3Rpb24ucmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbihyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCBkZWxldGVQcm9wcyhub2RlLmF0dHJzLCBhdHRyaWJ1dGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSAmJiBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBtYXJrVHlwZS5jcmVhdGUoZGVsZXRlUHJvcHMobWFyay5hdHRycywgYXR0cmlidXRlcykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNjcm9sbEludG9WaWV3ID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzZWxlY3RBbGwgPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBuZXcgQWxsU2VsZWN0aW9uKHRyLmRvYyk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNlbGVjdE5vZGVCYWNrd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdE5vZGVCYWNrd2FyZCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5jb25zdCBzZWxlY3ROb2RlRm9yd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdE5vZGVGb3J3YXJkJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmNvbnN0IHNlbGVjdFBhcmVudE5vZGUgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBzZWxlY3RQYXJlbnROb2RlJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIEB0cy1pZ25vcmVcbi8vIFRPRE86IGFkZCB0eXBlcyB0byBAdHlwZXMvcHJvc2VtaXJyb3ItY29tbWFuZHNcbmNvbnN0IHNlbGVjdFRleHRibG9ja0VuZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdFRleHRibG9ja0VuZCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBAdHMtaWdub3JlXG4vLyBUT0RPOiBhZGQgdHlwZXMgdG8gQHR5cGVzL3Byb3NlbWlycm9yLWNvbW1hbmRzXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tTdGFydCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdFRleHRibG9ja1N0YXJ0JDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFByb3NlbWlycm9yIGRvY3VtZW50IG5vZGUgZnJvbSBjb250ZW50LlxuICogQHBhcmFtIGNvbnRlbnQgVGhlIEpTT04gb3IgSFRNTCBjb250ZW50IHRvIGNyZWF0ZSB0aGUgZG9jdW1lbnQgZnJvbVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJyb3Igc2NoZW1hIHRvIHVzZSBmb3IgdGhlIGRvY3VtZW50XG4gKiBAcGFyYW0gcGFyc2VPcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBwYXJzZXJcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIFByb3NlbWlycm9yIGRvY3VtZW50IG5vZGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnQoY29udGVudCwgc2NoZW1hLCBwYXJzZU9wdGlvbnMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudChjb250ZW50LCBzY2hlbWEsIHtcbiAgICAgICAgc2xpY2U6IGZhbHNlLFxuICAgICAgICBwYXJzZU9wdGlvbnMsXG4gICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQsXG4gICAgfSk7XG59XG5cbmNvbnN0IHNldENvbnRlbnQgPSAoY29udGVudCwgZW1pdFVwZGF0ZSA9IGZhbHNlLCBwYXJzZU9wdGlvbnMgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiAoeyBlZGl0b3IsIHRyLCBkaXNwYXRjaCwgY29tbWFuZHMsIH0pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgZG9jIH0gPSB0cjtcbiAgICAvLyBUaGlzIGlzIHRvIGtlZXAgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBwcmV2aW91cyBiZWhhdmlvclxuICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvblxuICAgIGlmIChwYXJzZU9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSAnZnVsbCcpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBjcmVhdGVEb2N1bWVudChjb250ZW50LCBlZGl0b3Iuc2NoZW1hLCBwYXJzZU9wdGlvbnMsIHtcbiAgICAgICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogKF9hID0gb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgoMCwgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jdW1lbnQpLnNldE1ldGEoJ3ByZXZlbnRVcGRhdGUnLCAhZW1pdFVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB0ci5zZXRNZXRhKCdwcmV2ZW50VXBkYXRlJywgIWVtaXRVcGRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbTogMCwgdG86IGRvYy5jb250ZW50LnNpemUgfSwgY29udGVudCwge1xuICAgICAgICBwYXJzZU9wdGlvbnMsXG4gICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogKF9iID0gb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayxcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKSB7XG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgeyBmcm9tLCB0bywgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBjb25zdCBtYXJrcyA9IFtdO1xuICAgIGlmIChlbXB0eSkge1xuICAgICAgICBpZiAoc3RhdGUuc3RvcmVkTWFya3MpIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc3RvcmVkTWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKC4uLm5vZGUubWFya3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWFyayA9IG1hcmtzLmZpbmQobWFya0l0ZW0gPT4gbWFya0l0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpO1xuICAgIGlmICghbWFyaykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7IC4uLm1hcmsuYXR0cnMgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGBUcmFuc2Zvcm1gIGJhc2VkIG9uIGFsbCBzdGVwcyBvZiB0aGUgcGFzc2VkIHRyYW5zYWN0aW9ucy5cbiAqIEBwYXJhbSBvbGREb2MgVGhlIFByb3NlbWlycm9yIG5vZGUgdG8gc3RhcnQgZnJvbVxuICogQHBhcmFtIHRyYW5zYWN0aW9ucyBUaGUgdHJhbnNhY3Rpb25zIHRvIGNvbWJpbmVcbiAqIEByZXR1cm5zIEEgbmV3IGBUcmFuc2Zvcm1gIHdpdGggYWxsIHN0ZXBzIG9mIHRoZSBwYXNzZWQgdHJhbnNhY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKG9sZERvYywgdHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybShvbGREb2MpO1xuICAgIHRyYW5zYWN0aW9ucy5mb3JFYWNoKHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5zdGVwKHN0ZXApO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRlZmF1bHQgYmxvY2sgdHlwZSBhdCBhIGdpdmVuIG1hdGNoXG4gKiBAcGFyYW0gbWF0Y2ggVGhlIGNvbnRlbnQgbWF0Y2ggdG8gZ2V0IHRoZSBkZWZhdWx0IGJsb2NrIHR5cGUgZnJvbVxuICogQHJldHVybnMgVGhlIGRlZmF1bHQgYmxvY2sgdHlwZSBvciBudWxsXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRCbG9ja0F0KG1hdGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRmluZCBjaGlsZHJlbiBpbnNpZGUgYSBQcm9zZW1pcnJvciBub2RlIHRoYXQgbWF0Y2ggYSBwcmVkaWNhdGUuXG4gKiBAcGFyYW0gbm9kZSBUaGUgUHJvc2VtaXJyb3Igbm9kZSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBtYXRjaFxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgd2l0aCB0aGVpciBwb3NpdGlvbnNcbiAqL1xuZnVuY3Rpb24gZmluZENoaWxkcmVuKG5vZGUsIHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IG5vZGVzV2l0aFBvcyA9IFtdO1xuICAgIG5vZGUuZGVzY2VuZGFudHMoKGNoaWxkLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgICAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlc1dpdGhQb3M7XG59XG5cbi8qKlxuICogU2FtZSBhcyBgZmluZENoaWxkcmVuYCBidXQgc2VhcmNoZXMgb25seSB3aXRoaW4gYSBgcmFuZ2VgLlxuICogQHBhcmFtIG5vZGUgVGhlIFByb3NlbWlycm9yIG5vZGUgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyB3aXRoIHRoZWlyIHBvc2l0aW9uc1xuICovXG5mdW5jdGlvbiBmaW5kQ2hpbGRyZW5JblJhbmdlKG5vZGUsIHJhbmdlLCBwcmVkaWNhdGUpIHtcbiAgICBjb25zdCBub2Rlc1dpdGhQb3MgPSBbXTtcbiAgICAvLyBpZiAocmFuZ2UuZnJvbSA9PT0gcmFuZ2UudG8pIHtcbiAgICAvLyAgIGNvbnN0IG5vZGVBdCA9IG5vZGUubm9kZUF0KHJhbmdlLmZyb20pXG4gICAgLy8gICBpZiAobm9kZUF0KSB7XG4gICAgLy8gICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAvLyAgICAgICBub2RlOiBub2RlQXQsXG4gICAgLy8gICAgICAgcG9zOiByYW5nZS5mcm9tLFxuICAgIC8vICAgICB9KVxuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICBub2RlLm5vZGVzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgKGNoaWxkLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgICAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlc1dpdGhQb3M7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgdG8gYSByZXNvbHZlZCBwb3NpdGlvbiB0aGF0IG1hdGNoZXMgYSBwcmVkaWNhdGUuXG4gKiBAcGFyYW0gJHBvcyBUaGUgcmVzb2x2ZWQgcG9zaXRpb24gdG8gc2VhcmNoIGZyb21cbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBtYXRjaFxuICogQHJldHVybnMgVGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgdG8gdGhlIHJlc29sdmVkIHBvc2l0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgcHJlZGljYXRlXG4gKiBAZXhhbXBsZSBgYGBqc1xuICogZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MoJGZyb20sIG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zKCRwb3MsIHByZWRpY2F0ZSkge1xuICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoaSk7XG4gICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9zOiBpID4gMCA/ICRwb3MuYmVmb3JlKGkpIDogMCxcbiAgICAgICAgICAgICAgICBzdGFydDogJHBvcy5zdGFydChpKSxcbiAgICAgICAgICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gdGhhdCBtYXRjaGVzIGEgcHJlZGljYXRlLlxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBBIGNvbW1hbmQgdGhhdCBmaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gdGhhdCBtYXRjaGVzIHRoZSBwcmVkaWNhdGVcbiAqIEBleGFtcGxlIGBgYGpzXG4gKiBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZS5uYW1lID09PSAncGFyYWdyYXBoJylcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBmaW5kUGFyZW50Tm9kZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gKHNlbGVjdGlvbikgPT4gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3Moc2VsZWN0aW9uLiRmcm9tLCBwcmVkaWNhdGUpO1xufVxuXG5mdW5jdGlvbiBnZXRTY2hlbWEoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5yZXNvbHZlKGV4dGVuc2lvbnMpO1xuICAgIHJldHVybiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhyZXNvbHZlZEV4dGVuc2lvbnMsIGVkaXRvcik7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgSFRNTCBmcm9tIGEgSlNPTkNvbnRlbnRcbiAqIEBwYXJhbSBkb2MgVGhlIEpTT05Db250ZW50IHRvIGdlbmVyYXRlIEhUTUwgZnJvbVxuICogQHBhcmFtIGV4dGVuc2lvbnMgVGhlIGV4dGVuc2lvbnMgdG8gdXNlIGZvciB0aGUgc2NoZW1hXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIEhUTUxcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVIVE1MKGRvYywgZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcbiAgICBjb25zdCBjb250ZW50Tm9kZSA9IE5vZGUkMS5mcm9tSlNPTihzY2hlbWEsIGRvYyk7XG4gICAgcmV0dXJuIGdldEhUTUxGcm9tRnJhZ21lbnQoY29udGVudE5vZGUuY29udGVudCwgc2NoZW1hKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBKU09OQ29udGVudCBmcm9tIEhUTUxcbiAqIEBwYXJhbSBodG1sIFRoZSBIVE1MIHRvIGdlbmVyYXRlIEpTT05Db250ZW50IGZyb21cbiAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBleHRlbnNpb25zIHRvIHVzZSBmb3IgdGhlIHNjaGVtYVxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBKU09OQ29udGVudFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUpTT04oaHRtbCwgZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcbiAgICBjb25zdCBkb20gPSBlbGVtZW50RnJvbVN0cmluZyhodG1sKTtcbiAgICByZXR1cm4gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKS5wYXJzZShkb20pLnRvSlNPTigpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHRleHQgb2YgYSBQcm9zZW1pcnJvciBub2RlXG4gKiBAcGFyYW0gbm9kZSBUaGUgUHJvc2VtaXJyb3Igbm9kZVxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHRleHQgc2VyaWFsaXplciAmIGJsb2NrIHNlcGFyYXRvclxuICogQHJldHVybnMgVGhlIHRleHQgb2YgdGhlIG5vZGVcbiAqIEBleGFtcGxlIGBgYGpzXG4gKiBjb25zdCB0ZXh0ID0gZ2V0VGV4dChub2RlLCB7IGJsb2NrU2VwYXJhdG9yOiAnXFxuJyB9KVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldFRleHQobm9kZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICBmcm9tOiAwLFxuICAgICAgICB0bzogbm9kZS5jb250ZW50LnNpemUsXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0VGV4dEJldHdlZW4obm9kZSwgcmFuZ2UsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHJhdyB0ZXh0IGZyb20gYSBKU09OQ29udGVudFxuICogQHBhcmFtIGRvYyBUaGUgSlNPTkNvbnRlbnQgdG8gZ2VuZXJhdGUgdGV4dCBmcm9tXG4gKiBAcGFyYW0gZXh0ZW5zaW9ucyBUaGUgZXh0ZW5zaW9ucyB0byB1c2UgZm9yIHRoZSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSB0ZXh0IGdlbmVyYXRpb24gZi5lLiBibG9ja1NlcGFyYXRvciBvciB0ZXh0U2VyaWFsaXplcnNcbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgdGV4dFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRleHQoZG9jLCBleHRlbnNpb25zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzY2hlbWEgPSBnZXRTY2hlbWEoZXh0ZW5zaW9ucyk7XG4gICAgY29uc3QgY29udGVudE5vZGUgPSBOb2RlJDEuZnJvbUpTT04oc2NoZW1hLCBkb2MpO1xuICAgIHJldHVybiBnZXRUZXh0KGNvbnRlbnROb2RlLCB7XG4gICAgICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgICAgICB0ZXh0U2VyaWFsaXplcnM6IHtcbiAgICAgICAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKSxcbiAgICAgICAgICAgIC4uLnRleHRTZXJpYWxpemVycyxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZUF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBub2RlID0+IHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICB9KTtcbiAgICBjb25zdCBub2RlID0gbm9kZXMucmV2ZXJzZSgpLmZpbmQobm9kZUl0ZW0gPT4gbm9kZUl0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7IC4uLm5vZGUuYXR0cnMgfTtcbn1cblxuLyoqXG4gKiBHZXQgbm9kZSBvciBtYXJrIGF0dHJpYnV0ZXMgYnkgdHlwZSBvciBuYW1lIG9uIHRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZVxuICogQHBhcmFtIHN0YXRlIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZVxuICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIG5vZGUgb3IgbWFyayB0eXBlIG9yIG5hbWVcbiAqIEByZXR1cm5zIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBub2RlIG9yIG1hcmsgb3IgYW4gZW1wdHkgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpIHtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUodHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgIHJldHVybiBnZXROb2RlQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgcmV0dXJuIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZHVwbGljYXRlZCB2YWx1ZXMgd2l0aGluIGFuIGFycmF5LlxuICogU3VwcG9ydHMgbnVtYmVycywgc3RyaW5ncyBhbmQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlcyhhcnJheSwgYnkgPSBKU09OLnN0cmluZ2lmeSkge1xuICAgIGNvbnN0IHNlZW4gPSB7fTtcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBieShpdGVtKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWVuLCBrZXkpXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IChzZWVuW2tleV0gPSB0cnVlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZWQgcmFuZ2VzIGFuZCByYW5nZXMgdGhhdCBhcmVcbiAqIGZ1bGx5IGNhcHR1cmVkIGJ5IG90aGVyIHJhbmdlcy5cbiAqL1xuZnVuY3Rpb24gc2ltcGxpZnlDaGFuZ2VkUmFuZ2VzKGNoYW5nZXMpIHtcbiAgICBjb25zdCB1bmlxdWVDaGFuZ2VzID0gcmVtb3ZlRHVwbGljYXRlcyhjaGFuZ2VzKTtcbiAgICByZXR1cm4gdW5pcXVlQ2hhbmdlcy5sZW5ndGggPT09IDFcbiAgICAgICAgPyB1bmlxdWVDaGFuZ2VzXG4gICAgICAgIDogdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKGNoYW5nZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSB1bmlxdWVDaGFuZ2VzLmZpbHRlcigoXywgaSkgPT4gaSAhPT0gaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuICFyZXN0LnNvbWUob3RoZXJDaGFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2Uub2xkUmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5vbGRSYW5nZS5mcm9tXG4gICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZS5vbGRSYW5nZS50byA8PSBvdGhlckNoYW5nZS5vbGRSYW5nZS50b1xuICAgICAgICAgICAgICAgICAgICAmJiBjaGFuZ2UubmV3UmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5uZXdSYW5nZS5mcm9tXG4gICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZS5uZXdSYW5nZS50byA8PSBvdGhlckNoYW5nZS5uZXdSYW5nZS50bztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgY2hhbmdlZCByYW5nZXNcbiAqIGJhc2VkIG9uIHRoZSBmaXJzdCBhbmQgbGFzdCBzdGF0ZSBvZiBhbGwgc3RlcHMuXG4gKi9cbmZ1bmN0aW9uIGdldENoYW5nZWRSYW5nZXModHJhbnNmb3JtKSB7XG4gICAgY29uc3QgeyBtYXBwaW5nLCBzdGVwcyB9ID0gdHJhbnNmb3JtO1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBtYXBwaW5nLm1hcHMuZm9yRWFjaCgoc3RlcE1hcCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcmFuZ2VzID0gW107XG4gICAgICAgIC8vIFRoaXMgYWNjb3VudHMgZm9yIHN0ZXAgY2hhbmdlcyB3aGVyZSBubyByYW5nZSB3YXMgYWN0dWFsbHkgYWx0ZXJlZFxuICAgICAgICAvLyBlLmcuIHdoZW4gc2V0dGluZyBhIG1hcmssIG5vZGUgYXR0cmlidXRlLCBldGMuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCFzdGVwTWFwLnJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0ZXBzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQgfHwgdG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGVwTWFwLmZvckVhY2goKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlcy5mb3JFYWNoKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKGZyb20sIC0xKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuZCA9IG1hcHBpbmcuc2xpY2UoaW5kZXgpLm1hcCh0byk7XG4gICAgICAgICAgICBjb25zdCBvbGRTdGFydCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld1N0YXJ0LCAtMSk7XG4gICAgICAgICAgICBjb25zdCBvbGRFbmQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdFbmQpO1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvbGRSYW5nZToge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBvbGRTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgdG86IG9sZEVuZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5ld1JhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IG5ld1N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICB0bzogbmV3RW5kLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVidWdKU09OKG5vZGUsIHN0YXJ0T2Zmc2V0ID0gMCkge1xuICAgIGNvbnN0IGlzVG9wTm9kZSA9IG5vZGUudHlwZSA9PT0gbm9kZS50eXBlLnNjaGVtYS50b3BOb2RlVHlwZTtcbiAgICBjb25zdCBpbmNyZW1lbnQgPSBpc1RvcE5vZGUgPyAwIDogMTtcbiAgICBjb25zdCBmcm9tID0gc3RhcnRPZmZzZXQ7XG4gICAgY29uc3QgdG8gPSBmcm9tICsgbm9kZS5ub2RlU2l6ZTtcbiAgICBjb25zdCBtYXJrcyA9IG5vZGUubWFya3MubWFwKG1hcmsgPT4ge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICB0eXBlOiBtYXJrLnR5cGUubmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1hcmsuYXR0cnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0cHV0LmF0dHJzID0geyAuLi5tYXJrLmF0dHJzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcbiAgICBjb25zdCBhdHRycyA9IHsgLi4ubm9kZS5hdHRycyB9O1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLm5hbWUsXG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgIH07XG4gICAgaWYgKE9iamVjdC5rZXlzKGF0dHJzKS5sZW5ndGgpIHtcbiAgICAgICAgb3V0cHV0LmF0dHJzID0gYXR0cnM7XG4gICAgfVxuICAgIGlmIChtYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgb3V0cHV0Lm1hcmtzID0gbWFya3M7XG4gICAgfVxuICAgIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICBvdXRwdXQuY29udGVudCA9IFtdO1xuICAgICAgICBub2RlLmZvckVhY2goKGNoaWxkLCBvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IG91dHB1dC5jb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVzaChnZXREZWJ1Z0pTT04oY2hpbGQsIHN0YXJ0T2Zmc2V0ICsgb2Zmc2V0ICsgaW5jcmVtZW50KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobm9kZS50ZXh0KSB7XG4gICAgICAgIG91dHB1dC50ZXh0ID0gbm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBnZXRNYXJrc0JldHdlZW4oZnJvbSwgdG8sIGRvYykge1xuICAgIGNvbnN0IG1hcmtzID0gW107XG4gICAgLy8gZ2V0IGFsbCBpbmNsdXNpdmUgbWFya3Mgb24gZW1wdHkgc2VsZWN0aW9uXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgIGRvY1xuICAgICAgICAgICAgLnJlc29sdmUoZnJvbSlcbiAgICAgICAgICAgIC5tYXJrcygpXG4gICAgICAgICAgICAuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgICAgIGNvbnN0ICRwb3MgPSBkb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0TWFya1JhbmdlKCRwb3MsIG1hcmsudHlwZSk7XG4gICAgICAgICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbWFyayxcbiAgICAgICAgICAgICAgICAuLi5yYW5nZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLm5vZGVTaXplKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFya3MucHVzaCguLi5ub2RlLm1hcmtzLm1hcChtYXJrID0+ICh7XG4gICAgICAgICAgICAgICAgZnJvbTogcG9zLFxuICAgICAgICAgICAgICAgIHRvOiBwb3MgKyBub2RlLm5vZGVTaXplLFxuICAgICAgICAgICAgICAgIG1hcmssXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtzO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBub2RlIG9mIGEgZ2l2ZW4gdHlwZSBvciBuYW1lIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBzdGF0ZSBUaGUgZWRpdG9yIHN0YXRlLlxuICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIG5vZGUgdHlwZSBvciBuYW1lLlxuICogQHBhcmFtIHBvcyBUaGUgcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoaW5nIGZyb20uXG4gKiBAcGFyYW0gbWF4RGVwdGggVGhlIG1heGltdW0gZGVwdGggdG8gc2VhcmNoLlxuICogQHJldHVybnMgVGhlIG5vZGUgYW5kIHRoZSBkZXB0aCBhcyBhbiBhcnJheS5cbiAqL1xuY29uc3QgZ2V0Tm9kZUF0UG9zaXRpb24gPSAoc3RhdGUsIHR5cGVPck5hbWUsIHBvcywgbWF4RGVwdGggPSAyMCkgPT4ge1xuICAgIGNvbnN0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGxldCBjdXJyZW50RGVwdGggPSBtYXhEZXB0aDtcbiAgICBsZXQgbm9kZSA9IG51bGw7XG4gICAgd2hpbGUgKGN1cnJlbnREZXB0aCA+IDAgJiYgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9ICRwb3Mubm9kZShjdXJyZW50RGVwdGgpO1xuICAgICAgICBpZiAoKGN1cnJlbnROb2RlID09PSBudWxsIHx8IGN1cnJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS50eXBlLm5hbWUpID09PSB0eXBlT3JOYW1lKSB7XG4gICAgICAgICAgICBub2RlID0gY3VycmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50RGVwdGggLT0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW25vZGUsIGN1cnJlbnREZXB0aF07XG59O1xuXG4vKipcbiAqIFJldHVybiBhdHRyaWJ1dGVzIG9mIGFuIGV4dGVuc2lvbiB0aGF0IHNob3VsZCBiZSBzcGxpdHRlZCBieSBrZWVwT25TcGxpdCBmbGFnXG4gKiBAcGFyYW0gZXh0ZW5zaW9uQXR0cmlidXRlcyBBcnJheSBvZiBleHRlbnNpb24gYXR0cmlidXRlc1xuICogQHBhcmFtIHR5cGVOYW1lIFRoZSB0eXBlIG9mIHRoZSBleHRlbnNpb25cbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBleHRlbnNpb25cbiAqIEByZXR1cm5zIFRoZSBzcGxpdHRlZCBhdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCB0eXBlTmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0XG4gICAgICAgIC5lbnRyaWVzKGF0dHJpYnV0ZXMpXG4gICAgICAgIC5maWx0ZXIoKFtuYW1lXSkgPT4ge1xuICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGUgPSBleHRlbnNpb25BdHRyaWJ1dGVzLmZpbmQoaXRlbSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS50eXBlID09PSB0eXBlTmFtZSAmJiBpdGVtLm5hbWUgPT09IG5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWV4dGVuc2lvbkF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlLmtlZXBPblNwbGl0O1xuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gaXNNYXJrQWN0aXZlKHN0YXRlLCB0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsO1xuICAgIGlmIChlbXB0eSkge1xuICAgICAgICByZXR1cm4gISEoc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG4gICAgICAgICAgICAuZmlsdGVyKG1hcmsgPT4ge1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrLnR5cGUubmFtZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maW5kKG1hcmsgPT4gb2JqZWN0SW5jbHVkZXMobWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKTtcbiAgICB9XG4gICAgbGV0IHNlbGVjdGlvblJhbmdlID0gMDtcbiAgICBjb25zdCBtYXJrUmFuZ2VzID0gW107XG4gICAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZyb20gPSAkZnJvbS5wb3M7XG4gICAgICAgIGNvbnN0IHRvID0gJHRvLnBvcztcbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzVGV4dCAmJiAhbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpO1xuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLm5vZGVTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcmVsYXRpdmVUbyAtIHJlbGF0aXZlRnJvbTtcbiAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlICs9IHJhbmdlO1xuICAgICAgICAgICAgbWFya1Jhbmdlcy5wdXNoKC4uLm5vZGUubWFya3MubWFwKG1hcmsgPT4gKHtcbiAgICAgICAgICAgICAgICBtYXJrLFxuICAgICAgICAgICAgICAgIGZyb206IHJlbGF0aXZlRnJvbSxcbiAgICAgICAgICAgICAgICB0bzogcmVsYXRpdmVUbyxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb25SYW5nZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSByYW5nZSBvZiBtYXRjaGVkIG1hcmtcbiAgICBjb25zdCBtYXRjaGVkUmFuZ2UgPSBtYXJrUmFuZ2VzXG4gICAgICAgIC5maWx0ZXIobWFya1JhbmdlID0+IHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrUmFuZ2UubWFyay50eXBlLm5hbWU7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobWFya1JhbmdlLm1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcbiAgICAgICAgLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKTtcbiAgICAvLyBjYWxjdWxhdGUgcmFuZ2Ugb2YgbWFya3MgdGhhdCBleGNsdWRlcyB0aGUgc2VhcmNoZWQgbWFya1xuICAgIC8vIGZvciBleGFtcGxlIGBjb2RlYCBkb2VzbuKAmXQgYWxsb3cgYW55IG90aGVyIG1hcmtzXG4gICAgY29uc3QgZXhjbHVkZWRSYW5nZSA9IG1hcmtSYW5nZXNcbiAgICAgICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrUmFuZ2UubWFyay50eXBlICE9PSB0eXBlICYmIG1hcmtSYW5nZS5tYXJrLnR5cGUuZXhjbHVkZXModHlwZSk7XG4gICAgfSlcbiAgICAgICAgLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKTtcbiAgICAvLyB3ZSBvbmx5IGluY2x1ZGUgdGhlIHJlc3VsdCBvZiBgZXhjbHVkZWRSYW5nZWBcbiAgICAvLyBpZiB0aGVyZSBpcyBhIG1hdGNoIGF0IGFsbFxuICAgIGNvbnN0IHJhbmdlID0gbWF0Y2hlZFJhbmdlID4gMCA/IG1hdGNoZWRSYW5nZSArIGV4Y2x1ZGVkUmFuZ2UgOiBtYXRjaGVkUmFuZ2U7XG4gICAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlO1xufVxuXG5mdW5jdGlvbiBpc0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG51bGwsIGF0dHJpYnV0ZXMpIHx8IGlzTWFya0FjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgcmV0dXJuIGlzTm9kZUFjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgcmV0dXJuIGlzTWFya0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgaXNBdEVuZE9mTm9kZSA9IChzdGF0ZSwgbm9kZVR5cGUpID0+IHtcbiAgICBjb25zdCB7ICRmcm9tLCAkdG8sICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAobm9kZVR5cGUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09IG5vZGVUeXBlKShzdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCAkcGFyZW50UG9zID0gc3RhdGUuZG9jLnJlc29sdmUocGFyZW50Tm9kZS5wb3MgKyAxKTtcbiAgICAgICAgaWYgKCRhbmNob3IucG9zICsgMSA9PT0gJHBhcmVudFBvcy5lbmQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJHRvLnBhcmVudE9mZnNldCA8ICR0by5wYXJlbnQubm9kZVNpemUgLSAyIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgaXNBdFN0YXJ0T2ZOb2RlID0gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCRmcm9tLnBhcmVudE9mZnNldCA+IDAgfHwgJGZyb20ucG9zICE9PSAkdG8ucG9zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBpc0xpc3QobmFtZSwgZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBub2RlRXh0ZW5zaW9ucy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSBuYW1lKTtcbiAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgfTtcbiAgICBjb25zdCBncm91cCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKTtcbiAgICBpZiAodHlwZW9mIGdyb3VwICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBncm91cC5zcGxpdCgnICcpLmluY2x1ZGVzKCdsaXN0Jyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwcm9zZW1pcnJvciBub2RlIGlzIGVtcHR5LlxuICovXG5mdW5jdGlvbiBpc05vZGVFbXB0eShub2RlLCB7IGNoZWNrQ2hpbGRyZW4gPSB0cnVlLCBpZ25vcmVXaGl0ZXNwYWNlID0gZmFsc2UsIH0gPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoaWdub3JlV2hpdGVzcGFjZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlLm5hbWUgPT09ICdoYXJkQnJlYWsnKSB7XG4gICAgICAgICAgICAvLyBIYXJkIGJyZWFrcyBhcmUgY29uc2lkZXJlZCBlbXB0eVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gL15cXHMqJC9tLnRlc3QoKF9hID0gbm9kZS50ZXh0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgIHJldHVybiAhbm9kZS50ZXh0O1xuICAgIH1cbiAgICBpZiAobm9kZS5pc0F0b20gfHwgbm9kZS5pc0xlYWYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jb250ZW50LmNoaWxkQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjaGVja0NoaWxkcmVuKSB7XG4gICAgICAgIGxldCBpc0NvbnRlbnRFbXB0eSA9IHRydWU7XG4gICAgICAgIG5vZGUuY29udGVudC5mb3JFYWNoKGNoaWxkTm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNDb250ZW50RW1wdHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBmb3IgcGVyZlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOb2RlRW1wdHkoY2hpbGROb2RlLCB7IGlnbm9yZVdoaXRlc3BhY2UsIGNoZWNrQ2hpbGRyZW4gfSkpIHtcbiAgICAgICAgICAgICAgICBpc0NvbnRlbnRFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlzQ29udGVudEVtcHR5O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZVNlbGVjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHBvc1RvRE9NUmVjdCh2aWV3LCBmcm9tLCB0bykge1xuICAgIGNvbnN0IG1pblBvcyA9IDA7XG4gICAgY29uc3QgbWF4UG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplO1xuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcyk7XG4gICAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKTtcbiAgICBjb25zdCBzdGFydCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRGcm9tKTtcbiAgICBjb25zdCBlbmQgPSB2aWV3LmNvb3Jkc0F0UG9zKHJlc29sdmVkRW5kLCAtMSk7XG4gICAgY29uc3QgdG9wID0gTWF0aC5taW4oc3RhcnQudG9wLCBlbmQudG9wKTtcbiAgICBjb25zdCBib3R0b20gPSBNYXRoLm1heChzdGFydC5ib3R0b20sIGVuZC5ib3R0b20pO1xuICAgIGNvbnN0IGxlZnQgPSBNYXRoLm1pbihzdGFydC5sZWZ0LCBlbmQubGVmdCk7XG4gICAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChzdGFydC5yaWdodCwgZW5kLnJpZ2h0KTtcbiAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgY29uc3QgeCA9IGxlZnQ7XG4gICAgY29uc3QgeSA9IHRvcDtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICB0b3AsXG4gICAgICAgIGJvdHRvbSxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICB0b0pTT046ICgpID0+IGRhdGEsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSByZXdyaXRlVW5rbm93bkNvbnRlbnQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gcmV3cml0ZVVua25vd25Db250ZW50SW5uZXIoeyBqc29uLCB2YWxpZE1hcmtzLCB2YWxpZE5vZGVzLCBvcHRpb25zLCByZXdyaXR0ZW5Db250ZW50ID0gW10sIH0pIHtcbiAgICBpZiAoanNvbi5tYXJrcyAmJiBBcnJheS5pc0FycmF5KGpzb24ubWFya3MpKSB7XG4gICAgICAgIGpzb24ubWFya3MgPSBqc29uLm1hcmtzLmZpbHRlcihtYXJrID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbWFyayA9PT0gJ3N0cmluZycgPyBtYXJrIDogbWFyay50eXBlO1xuICAgICAgICAgICAgaWYgKHZhbGlkTWFya3MuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXdyaXR0ZW5Db250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1hcmspKSxcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZDogbmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSnVzdCBpZ25vcmUgYW55IHVua25vd24gbWFya3NcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChqc29uLmNvbnRlbnQgJiYgQXJyYXkuaXNBcnJheShqc29uLmNvbnRlbnQpKSB7XG4gICAgICAgIGpzb24uY29udGVudCA9IGpzb24uY29udGVudFxuICAgICAgICAgICAgLm1hcCh2YWx1ZSA9PiByZXdyaXRlVW5rbm93bkNvbnRlbnRJbm5lcih7XG4gICAgICAgICAgICBqc29uOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbGlkTWFya3MsXG4gICAgICAgICAgICB2YWxpZE5vZGVzLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIHJld3JpdHRlbkNvbnRlbnQsXG4gICAgICAgIH0pLmpzb24pXG4gICAgICAgICAgICAuZmlsdGVyKGEgPT4gYSAhPT0gbnVsbCAmJiBhICE9PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBpZiAoanNvbi50eXBlICYmICF2YWxpZE5vZGVzLmhhcyhqc29uLnR5cGUpKSB7XG4gICAgICAgIHJld3JpdHRlbkNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW5hbDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShqc29uKSksXG4gICAgICAgICAgICB1bnN1cHBvcnRlZDoganNvbi50eXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGpzb24uY29udGVudCAmJiBBcnJheS5pc0FycmF5KGpzb24uY29udGVudCkgJiYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFsbGJhY2tUb1BhcmFncmFwaCkgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgLy8gSnVzdCB0cmVhdCBpdCBsaWtlIGEgcGFyYWdyYXBoIGFuZCBob3BlIGZvciB0aGUgYmVzdFxuICAgICAgICAgICAganNvbi50eXBlID0gJ3BhcmFncmFwaCc7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGpzb24sXG4gICAgICAgICAgICAgICAgcmV3cml0dGVuQ29udGVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3IganVzdCBvbWl0IGl0IGVudGlyZWx5XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBqc29uOiBudWxsLFxuICAgICAgICAgICAgcmV3cml0dGVuQ29udGVudCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsganNvbiwgcmV3cml0dGVuQ29udGVudCB9O1xufVxuLyoqXG4gKiBSZXdyaXRlIHVua25vd24gbm9kZXMgYW5kIG1hcmtzIHdpdGhpbiBKU09OIGNvbnRlbnRcbiAqIEFsbG93aW5nIGZvciB1c2VyIHdpdGhpbiB0aGUgZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHJld3JpdGVVbmtub3duQ29udGVudChcbi8qKlxuICogVGhlIEpTT04gY29udGVudCB0byBjbGVhbiBvZiB1bmtub3duIG5vZGVzIGFuZCBtYXJrc1xuICovXG5qc29uLCBcbi8qKlxuICogVGhlIHNjaGVtYSB0byB1c2UgZm9yIHZhbGlkYXRpb25cbiAqL1xuc2NoZW1hLCBcbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIGNsZWFuaW5nIHByb2Nlc3NcbiAqL1xub3B0aW9ucykge1xuICAgIHJldHVybiByZXdyaXRlVW5rbm93bkNvbnRlbnRJbm5lcih7XG4gICAgICAgIGpzb24sXG4gICAgICAgIHZhbGlkTm9kZXM6IG5ldyBTZXQoT2JqZWN0LmtleXMoc2NoZW1hLm5vZGVzKSksXG4gICAgICAgIHZhbGlkTWFya3M6IG5ldyBTZXQoT2JqZWN0LmtleXMoc2NoZW1hLm1hcmtzKSksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhblNldE1hcmsoc3RhdGUsIHRyLCBuZXdNYXJrVHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gICAgbGV0IGN1cnNvciA9IG51bGw7XG4gICAgaWYgKGlzVGV4dFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIGN1cnNvciA9IHNlbGVjdGlvbi4kY3Vyc29yO1xuICAgIH1cbiAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrcyA9IChfYSA9IHN0YXRlLnN0b3JlZE1hcmtzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXJzb3IubWFya3MoKTtcbiAgICAgICAgLy8gVGhlcmUgY2FuIGJlIG5vIGN1cnJlbnQgbWFya3MgdGhhdCBleGNsdWRlIHRoZSBuZXcgbWFya1xuICAgICAgICByZXR1cm4gKCEhbmV3TWFya1R5cGUuaXNJblNldChjdXJyZW50TWFya3MpXG4gICAgICAgICAgICB8fCAhY3VycmVudE1hcmtzLnNvbWUobWFyayA9PiBtYXJrLnR5cGUuZXhjbHVkZXMobmV3TWFya1R5cGUpKSk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgcmV0dXJuIHJhbmdlcy5zb21lKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgICAgICBsZXQgc29tZU5vZGVTdXBwb3J0c01hcmsgPSAkZnJvbS5kZXB0aCA9PT0gMFxuICAgICAgICAgICAgPyBzdGF0ZS5kb2MuaW5saW5lQ29udGVudCAmJiBzdGF0ZS5kb2MudHlwZS5hbGxvd3NNYXJrVHlwZShuZXdNYXJrVHlwZSlcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgX3BvcywgcGFyZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGZvdW5kIGEgbWFyayB0aGF0IHdlIGNhbiBlbmFibGUsIHJldHVybiBmYWxzZSB0byBieXBhc3MgdGhlIHJlbWFpbmluZyBzZWFyY2hcbiAgICAgICAgICAgIGlmIChzb21lTm9kZVN1cHBvcnRzTWFyaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmlzSW5saW5lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50QWxsb3dzTWFya1R5cGUgPSAhcGFyZW50IHx8IHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlID0gISFuZXdNYXJrVHlwZS5pc0luU2V0KG5vZGUubWFya3MpXG4gICAgICAgICAgICAgICAgICAgIHx8ICFub2RlLm1hcmtzLnNvbWUob3RoZXJNYXJrID0+IG90aGVyTWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSk7XG4gICAgICAgICAgICAgICAgc29tZU5vZGVTdXBwb3J0c01hcmsgPSBwYXJlbnRBbGxvd3NNYXJrVHlwZSAmJiBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFzb21lTm9kZVN1cHBvcnRzTWFyaztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzb21lTm9kZVN1cHBvcnRzTWFyaztcbiAgICB9KTtcbn1cbmNvbnN0IHNldE1hcmsgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gICAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlKTtcbiAgICAgICAgICAgIHRyLmFkZFN0b3JlZE1hcmsodHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIC4uLm9sZEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gcmFuZ2UuJHRvLnBvcztcbiAgICAgICAgICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb21lSGFzTWFyayA9IG5vZGUubWFya3MuZmluZChtYXJrID0+IG1hcmsudHlwZSA9PT0gdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBtYXJrIG9mIHRoaXMgdHlwZVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IHRoYXQgd2UgaGF2ZSB0byBtZXJnZSBpdHMgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgYWRkIGEgZnJlc2ggbmV3IG1hcmtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbWVIYXNNYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKHRyaW1tZWRGcm9tLCB0cmltbWVkVG8sIHR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKHRyaW1tZWRGcm9tLCB0cmltbWVkVG8sIHR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhblNldE1hcmsoc3RhdGUsIHRyLCB0eXBlKTtcbn07XG5cbmNvbnN0IHNldE1ldGEgPSAoa2V5LCB2YWx1ZSkgPT4gKHsgdHIgfSkgPT4ge1xuICAgIHRyLnNldE1ldGEoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzZXROb2RlID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCBjaGFpbiB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgbGV0IGF0dHJpYnV0ZXNUb0NvcHk7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnNhbWVQYXJlbnQoc3RhdGUuc2VsZWN0aW9uLiRoZWFkKSkge1xuICAgICAgICAvLyBvbmx5IGNvcHkgYXR0cmlidXRlcyBpZiB0aGUgc2VsZWN0aW9uIGlzIHBvaW50aW5nIHRvIGEgbm9kZSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgIGF0dHJpYnV0ZXNUb0NvcHkgPSBzdGF0ZS5zZWxlY3Rpb24uJGFuY2hvci5wYXJlbnQuYXR0cnM7XG4gICAgfVxuICAgIC8vIFRPRE86IHVzZSBhIGZhbGxiYWNrIGxpa2UgaW5zZXJ0Q29udGVudD9cbiAgICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBDdXJyZW50bHkgXCJzZXROb2RlKClcIiBvbmx5IHN1cHBvcnRzIHRleHQgYmxvY2sgbm9kZXMuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChjaGFpbigpXG4gICAgICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgICAuY29tbWFuZCgoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhblNldEJsb2NrID0gc2V0QmxvY2tUeXBlKHR5cGUsIHsgLi4uYXR0cmlidXRlc1RvQ29weSwgLi4uYXR0cmlidXRlcyB9KShzdGF0ZSk7XG4gICAgICAgIGlmIChjYW5TZXRCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICB9KVxuICAgICAgICAuY29tbWFuZCgoeyBzdGF0ZTogdXBkYXRlZFN0YXRlIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHNldEJsb2NrVHlwZSh0eXBlLCB7IC4uLmF0dHJpYnV0ZXNUb0NvcHksIC4uLmF0dHJpYnV0ZXMgfSkodXBkYXRlZFN0YXRlLCBkaXNwYXRjaCk7XG4gICAgfSlcbiAgICAgICAgLnJ1bigpKTtcbn07XG5cbmNvbnN0IHNldE5vZGVTZWxlY3Rpb24gPSBwb3NpdGlvbiA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCB7IGRvYyB9ID0gdHI7XG4gICAgICAgIGNvbnN0IGZyb20gPSBtaW5NYXgocG9zaXRpb24sIDAsIGRvYy5jb250ZW50LnNpemUpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIGZyb20pO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzZXRUZXh0U2VsZWN0aW9uID0gcG9zaXRpb24gPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgeyBkb2MgfSA9IHRyO1xuICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiBwb3NpdGlvbjtcbiAgICAgICAgY29uc3QgbWluUG9zID0gVGV4dFNlbGVjdGlvbi5hdFN0YXJ0KGRvYykuZnJvbTtcbiAgICAgICAgY29uc3QgbWF4UG9zID0gVGV4dFNlbGVjdGlvbi5hdEVuZChkb2MpLnRvO1xuICAgICAgICBjb25zdCByZXNvbHZlZEZyb20gPSBtaW5NYXgoZnJvbSwgbWluUG9zLCBtYXhQb3MpO1xuICAgICAgICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJlc29sdmVkRnJvbSwgcmVzb2x2ZWRFbmQpO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzaW5rTGlzdEl0ZW0gPSB0eXBlT3JOYW1lID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgcmV0dXJuIHNpbmtMaXN0SXRlbSQxKHR5cGUpKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5mdW5jdGlvbiBlbnN1cmVNYXJrcyhzdGF0ZSwgc3BsaXR0YWJsZU1hcmtzKSB7XG4gICAgY29uc3QgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCAoc3RhdGUuc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpO1xuICAgIGlmIChtYXJrcykge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzID09PSBudWxsIHx8IHNwbGl0dGFibGVNYXJrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgICAgIHN0YXRlLnRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xuICAgIH1cbn1cbmNvbnN0IHNwbGl0QmxvY2sgPSAoeyBrZWVwTWFya3MgPSB0cnVlIH0gPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCwgZWRpdG9yLCB9KSA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHI7XG4gICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpO1xuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgaWYgKCEkZnJvbS5wYXJlbnRPZmZzZXQgfHwgIWNhblNwbGl0KGRvYywgJGZyb20ucG9zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgICAgICAgICAgIGVuc3VyZU1hcmtzKHN0YXRlLCBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5zcGxpdHRhYmxlTWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoISRmcm9tLnBhcmVudC5pc0Jsb2NrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYXRFbmQgPSAkdG8ucGFyZW50T2Zmc2V0ID09PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICBjb25zdCBkZWZsdCA9ICRmcm9tLmRlcHRoID09PSAwXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZSgtMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcigtMSkpKTtcbiAgICBsZXQgdHlwZXMgPSBhdEVuZCAmJiBkZWZsdFxuICAgICAgICA/IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBkZWZsdCxcbiAgICAgICAgICAgICAgICBhdHRyczogbmV3QXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuICAgIGlmICghdHlwZXNcbiAgICAgICAgJiYgIWNhblxuICAgICAgICAmJiBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQpKSB7XG4gICAgICAgIGNhbiA9IHRydWU7XG4gICAgICAgIHR5cGVzID0gZGVmbHRcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZGVmbHQsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiBuZXdBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGlmIChjYW4pIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICAgICAgICBpZiAoZGVmbHQgJiYgIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT09IGRlZmx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QpO1xuICAgICAgICAgICAgICAgIGlmICgkZnJvbS5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksIGRlZmx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbjtcbn07XG5cbmNvbnN0IHNwbGl0TGlzdEl0ZW0gPSAodHlwZU9yTmFtZSwgb3ZlcnJpZGVBdHRycyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IsIH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGNvbnN0IG5vZGUgPSBzdGF0ZS5zZWxlY3Rpb24ubm9kZTtcbiAgICBpZiAoKG5vZGUgJiYgbm9kZS5pc0Jsb2NrKSB8fCAkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGdyYW5kUGFyZW50ID0gJGZyb20ubm9kZSgtMSk7XG4gICAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlcztcbiAgICBpZiAoJGZyb20ucGFyZW50LmNvbnRlbnQuc2l6ZSA9PT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAgICAgLy8gbGlzdCBpdGVtIHNob3VsZCBiZSBzcGxpdC4gT3RoZXJ3aXNlLCBiYWlsIG91dCBhbmQgbGV0IG5leHRcbiAgICAgICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICAgICAgaWYgKCRmcm9tLmRlcHRoID09PSAyXG4gICAgICAgICAgICB8fCAkZnJvbS5ub2RlKC0zKS50eXBlICE9PSB0eXBlXG4gICAgICAgICAgICB8fCAkZnJvbS5pbmRleCgtMikgIT09ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBjb25zdCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcbiAgICAgICAgICAgIC8vIEJ1aWxkIGEgZnJhZ21lbnQgY29udGFpbmluZyBlbXB0eSB2ZXJzaW9ucyBvZiB0aGUgc3RydWN0dXJlXG4gICAgICAgICAgICAvLyBmcm9tIHRoZSBvdXRlciBsaXN0IGl0ZW0gdG8gdGhlIHBhcmVudCBub2RlIG9mIHRoZSBjdXJzb3JcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCAtIGRlcHRoQmVmb3JlOyBkID49ICRmcm9tLmRlcHRoIC0gMzsgZCAtPSAxKSB7XG4gICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgY29uc3QgZGVwdGhBZnRlciA9ICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDEgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogMztcbiAgICAgICAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgICAgICAgIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5nZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgJGZyb20ubm9kZSgpLnR5cGUubmFtZSwgJGZyb20ubm9kZSgpLmF0dHJzKSxcbiAgICAgICAgICAgICAgICAuLi5vdmVycmlkZUF0dHJzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUeXBlID0gKChfYSA9IHR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3JlYXRlQW5kRmlsbChuZXdOZXh0VHlwZUF0dHJpYnV0ZXMpKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3cmFwID0gd3JhcC5hcHBlbmQoRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZUFuZEZpbGwobnVsbCwgbmV4dFR5cGUpIHx8IHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSk7XG4gICAgICAgICAgICB0ci5yZXBsYWNlKHN0YXJ0LCAkZnJvbS5hZnRlcigtZGVwdGhBZnRlciksIG5ldyBTbGljZSh3cmFwLCA0IC0gZGVwdGhCZWZvcmUsIDApKTtcbiAgICAgICAgICAgIGxldCBzZWwgPSAtMTtcbiAgICAgICAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIHRyLmRvYy5jb250ZW50LnNpemUsIChuLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobi5pc1RleHRibG9jayAmJiBuLmNvbnRlbnQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWwgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNlbCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShzZWwpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBuZXh0VHlwZSA9ICR0by5wb3MgPT09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xuICAgIGNvbnN0IG5ld1R5cGVBdHRyaWJ1dGVzID0ge1xuICAgICAgICAuLi5nZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgZ3JhbmRQYXJlbnQudHlwZS5uYW1lLCBncmFuZFBhcmVudC5hdHRycyksXG4gICAgICAgIC4uLm92ZXJyaWRlQXR0cnMsXG4gICAgfTtcbiAgICBjb25zdCBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIC4uLmdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpLFxuICAgICAgICAuLi5vdmVycmlkZUF0dHJzLFxuICAgIH07XG4gICAgdHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gICAgY29uc3QgdHlwZXMgPSBuZXh0VHlwZVxuICAgICAgICA/IFtcbiAgICAgICAgICAgIHsgdHlwZSwgYXR0cnM6IG5ld1R5cGVBdHRyaWJ1dGVzIH0sXG4gICAgICAgICAgICB7IHR5cGU6IG5leHRUeXBlLCBhdHRyczogbmV3TmV4dFR5cGVBdHRyaWJ1dGVzIH0sXG4gICAgICAgIF1cbiAgICAgICAgOiBbeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfV07XG4gICAgaWYgKCFjYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgICAgIHRyLnNwbGl0KCRmcm9tLnBvcywgMiwgdHlwZXMpLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIGlmICghbWFya3MgfHwgIWRpc3BhdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGpvaW5MaXN0QmFja3dhcmRzID0gKHRyLCBsaXN0VHlwZSkgPT4ge1xuICAgIGNvbnN0IGxpc3QgPSBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZSA9PT0gbGlzdFR5cGUpKHRyLnNlbGVjdGlvbik7XG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCBsaXN0LnBvcyAtIDEpKS5iZWZvcmUobGlzdC5kZXB0aCk7XG4gICAgaWYgKGJlZm9yZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBub2RlQmVmb3JlID0gdHIuZG9jLm5vZGVBdChiZWZvcmUpO1xuICAgIGNvbnN0IGNhbkpvaW5CYWNrd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gKG5vZGVCZWZvcmUgPT09IG51bGwgfHwgbm9kZUJlZm9yZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZUJlZm9yZS50eXBlKSAmJiBjYW5Kb2luKHRyLmRvYywgbGlzdC5wb3MpO1xuICAgIGlmICghY2FuSm9pbkJhY2t3YXJkcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHIuam9pbihsaXN0LnBvcyk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3Qgam9pbkxpc3RGb3J3YXJkcyA9ICh0ciwgbGlzdFR5cGUpID0+IHtcbiAgICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pO1xuICAgIGlmICghbGlzdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYWZ0ZXIgPSB0ci5kb2MucmVzb2x2ZShsaXN0LnN0YXJ0KS5hZnRlcihsaXN0LmRlcHRoKTtcbiAgICBpZiAoYWZ0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZUFmdGVyID0gdHIuZG9jLm5vZGVBdChhZnRlcik7XG4gICAgY29uc3QgY2FuSm9pbkZvcndhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IChub2RlQWZ0ZXIgPT09IG51bGwgfHwgbm9kZUFmdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlQWZ0ZXIudHlwZSkgJiYgY2FuSm9pbih0ci5kb2MsIGFmdGVyKTtcbiAgICBpZiAoIWNhbkpvaW5Gb3J3YXJkcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHIuam9pbihhZnRlcik7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgdG9nZ2xlTGlzdCA9IChsaXN0VHlwZU9yTmFtZSwgaXRlbVR5cGVPck5hbWUsIGtlZXBNYXJrcywgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBlZGl0b3IsIHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGNoYWluLCBjb21tYW5kcywgY2FuLCB9KSA9PiB7XG4gICAgY29uc3QgeyBleHRlbnNpb25zLCBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgIGNvbnN0IGxpc3RUeXBlID0gZ2V0Tm9kZVR5cGUobGlzdFR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgaXRlbVR5cGUgPSBnZXROb2RlVHlwZShpdGVtVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlO1xuICAgIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50TGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gaXNMaXN0KG5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKSkoc2VsZWN0aW9uKTtcbiAgICBpZiAocmFuZ2UuZGVwdGggPj0gMSAmJiBwYXJlbnRMaXN0ICYmIHJhbmdlLmRlcHRoIC0gcGFyZW50TGlzdC5kZXB0aCA8PSAxKSB7XG4gICAgICAgIC8vIHJlbW92ZSBsaXN0XG4gICAgICAgIGlmIChwYXJlbnRMaXN0Lm5vZGUudHlwZSA9PT0gbGlzdFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0TGlzdEl0ZW0oaXRlbVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoYW5nZSBsaXN0IHR5cGVcbiAgICAgICAgaWYgKGlzTGlzdChwYXJlbnRMaXN0Lm5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKVxuICAgICAgICAgICAgJiYgbGlzdFR5cGUudmFsaWRDb250ZW50KHBhcmVudExpc3Qubm9kZS5jb250ZW50KVxuICAgICAgICAgICAgJiYgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocGFyZW50TGlzdC5wb3MsIGxpc3RUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgICAgICAgICAgLnJ1bigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgha2VlcE1hcmtzIHx8ICFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluKClcbiAgICAgICAgICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FuV3JhcEluTGlzdCA9IGNhbigpLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcbiAgICAgICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgICAgICAucnVuKCk7XG4gICAgfVxuICAgIHJldHVybiAoY2hhaW4oKVxuICAgICAgICAvLyB0cnkgdG8gY29udmVydCBub2RlIHRvIGRlZmF1bHQgbm9kZSBpZiBuZWVkZWRcbiAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYW5XcmFwSW5MaXN0ID0gY2FuKCkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcyk7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gICAgICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpO1xuICAgIH0pXG4gICAgICAgIC53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgIC5ydW4oKSk7XG59O1xuXG5jb25zdCB0b2dnbGVNYXJrID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICAgIGNvbnN0IHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGlzTWFya0FjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodHlwZSwgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodHlwZSwgYXR0cmlidXRlcyk7XG59O1xuXG5jb25zdCB0b2dnbGVOb2RlID0gKHR5cGVPck5hbWUsIHRvZ2dsZVR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB0b2dnbGVUeXBlID0gZ2V0Tm9kZVR5cGUodG9nZ2xlVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gICAgbGV0IGF0dHJpYnV0ZXNUb0NvcHk7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnNhbWVQYXJlbnQoc3RhdGUuc2VsZWN0aW9uLiRoZWFkKSkge1xuICAgICAgICAvLyBvbmx5IGNvcHkgYXR0cmlidXRlcyBpZiB0aGUgc2VsZWN0aW9uIGlzIHBvaW50aW5nIHRvIGEgbm9kZSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgIGF0dHJpYnV0ZXNUb0NvcHkgPSBzdGF0ZS5zZWxlY3Rpb24uJGFuY2hvci5wYXJlbnQuYXR0cnM7XG4gICAgfVxuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0b2dnbGVUeXBlLCBhdHRyaWJ1dGVzVG9Db3B5KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIG5vZGUgaXMgbm90IGFjdGl2ZSwgd2Ugd2FudCB0byBzZXQgdGhlIG5ldyBub2RlIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlc1xuICAgIC8vIENvcHlpbmcgb3ZlciB0aGUgYXR0cmlidXRlcyBmcm9tIHRoZSBjdXJyZW50IG5vZGUgaWYgdGhlIHNlbGVjdGlvbiBpcyBwb2ludGluZyB0byBhIG5vZGUgb2YgdGhlIHNhbWUgdHlwZVxuICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHR5cGUsIHsgLi4uYXR0cmlidXRlc1RvQ29weSwgLi4uYXR0cmlidXRlcyB9KTtcbn07XG5cbmNvbnN0IHRvZ2dsZVdyYXAgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmxpZnQodHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBjb21tYW5kcy53cmFwSW4odHlwZSwgYXR0cmlidXRlcyk7XG59O1xuXG5jb25zdCB1bmRvSW5wdXRSdWxlID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCBwbHVnaW5zID0gc3RhdGUucGx1Z2lucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgICAgbGV0IHVuZG9hYmxlO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBpZiAocGx1Z2luLnNwZWMuaXNJbnB1dFJ1bGVzICYmICh1bmRvYWJsZSA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSkpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvVW5kbyA9IHVuZG9hYmxlLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gdG9VbmRvLnN0ZXBzLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLnN0ZXAodG9VbmRvLnN0ZXBzW2pdLmludmVydCh0b1VuZG8uZG9jc1tqXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodW5kb2FibGUudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrcyA9IHRyLmRvYy5yZXNvbHZlKHVuZG9hYmxlLmZyb20pLm1hcmtzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvLCBzdGF0ZS5zY2hlbWEudGV4dCh1bmRvYWJsZS50ZXh0LCBtYXJrcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCB1bnNldEFsbE1hcmtzID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gICAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCB1bnNldE1hcmsgPSAodHlwZU9yTmFtZSwgb3B0aW9ucyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgaWYgKCFkaXNwYXRjaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVtcHR5ICYmIGV4dGVuZEVtcHR5TWFya1JhbmdlKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IGF0dHJzID0gKF9hID0gJGZyb20ubWFya3MoKS5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzO1xuICAgICAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cnMpO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGZyb20gPSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgdG8gPSByYW5nZS50bztcbiAgICAgICAgfVxuICAgICAgICB0ci5yZW1vdmVNYXJrKGZyb20sIHRvLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCB0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsodHlwZSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCB1cGRhdGVBdHRyaWJ1dGVzID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IG5vZGVUeXBlID0gbnVsbDtcbiAgICBsZXQgbWFya1R5cGUgPSBudWxsO1xuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSh0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGlmICghc2NoZW1hVHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHRyLnNlbGVjdGlvbi5yYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSByYW5nZS4kZnJvbS5wb3M7XG4gICAgICAgICAgICBjb25zdCB0byA9IHJhbmdlLiR0by5wb3M7XG4gICAgICAgICAgICBsZXQgbGFzdFBvcztcbiAgICAgICAgICAgIGxldCBsYXN0Tm9kZTtcbiAgICAgICAgICAgIGxldCB0cmltbWVkRnJvbTtcbiAgICAgICAgICAgIGxldCB0cmltbWVkVG87XG4gICAgICAgICAgICBpZiAodHIuc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBvcyA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zIDwgZnJvbSAmJiBub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UG9zID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKChtYXJrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkRnJvbTIgPSBNYXRoLm1heChwb3MsIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRvMiA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsodHJpbW1lZEZyb20yLCB0cmltbWVkVG8yLCBtYXJrVHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAobGFzdFBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5sYXN0Tm9kZS5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUgJiYgbGFzdE5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3ROb2RlLm1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayh0cmltbWVkRnJvbSwgdHJpbW1lZFRvLCBtYXJrVHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5tYXJrLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCB3cmFwSW4gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIHJldHVybiB3cmFwSW4kMSh0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3Qgd3JhcEluTGlzdCA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgcmV0dXJuIHdyYXBJbkxpc3QkMSh0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxudmFyIGNvbW1hbmRzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJsdXI6IGJsdXIsXG4gIGNsZWFyQ29udGVudDogY2xlYXJDb250ZW50LFxuICBjbGVhck5vZGVzOiBjbGVhck5vZGVzLFxuICBjb21tYW5kOiBjb21tYW5kLFxuICBjcmVhdGVQYXJhZ3JhcGhOZWFyOiBjcmVhdGVQYXJhZ3JhcGhOZWFyLFxuICBjdXQ6IGN1dCxcbiAgZGVsZXRlQ3VycmVudE5vZGU6IGRlbGV0ZUN1cnJlbnROb2RlLFxuICBkZWxldGVOb2RlOiBkZWxldGVOb2RlLFxuICBkZWxldGVSYW5nZTogZGVsZXRlUmFuZ2UsXG4gIGRlbGV0ZVNlbGVjdGlvbjogZGVsZXRlU2VsZWN0aW9uLFxuICBlbnRlcjogZW50ZXIsXG4gIGV4aXRDb2RlOiBleGl0Q29kZSxcbiAgZXh0ZW5kTWFya1JhbmdlOiBleHRlbmRNYXJrUmFuZ2UsXG4gIGZpcnN0OiBmaXJzdCxcbiAgZm9jdXM6IGZvY3VzLFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBpbnNlcnRDb250ZW50OiBpbnNlcnRDb250ZW50LFxuICBpbnNlcnRDb250ZW50QXQ6IGluc2VydENvbnRlbnRBdCxcbiAgam9pbkJhY2t3YXJkOiBqb2luQmFja3dhcmQsXG4gIGpvaW5Eb3duOiBqb2luRG93bixcbiAgam9pbkZvcndhcmQ6IGpvaW5Gb3J3YXJkLFxuICBqb2luSXRlbUJhY2t3YXJkOiBqb2luSXRlbUJhY2t3YXJkLFxuICBqb2luSXRlbUZvcndhcmQ6IGpvaW5JdGVtRm9yd2FyZCxcbiAgam9pblRleHRibG9ja0JhY2t3YXJkOiBqb2luVGV4dGJsb2NrQmFja3dhcmQsXG4gIGpvaW5UZXh0YmxvY2tGb3J3YXJkOiBqb2luVGV4dGJsb2NrRm9yd2FyZCxcbiAgam9pblVwOiBqb2luVXAsXG4gIGtleWJvYXJkU2hvcnRjdXQ6IGtleWJvYXJkU2hvcnRjdXQsXG4gIGxpZnQ6IGxpZnQsXG4gIGxpZnRFbXB0eUJsb2NrOiBsaWZ0RW1wdHlCbG9jayxcbiAgbGlmdExpc3RJdGVtOiBsaWZ0TGlzdEl0ZW0sXG4gIG5ld2xpbmVJbkNvZGU6IG5ld2xpbmVJbkNvZGUsXG4gIHJlc2V0QXR0cmlidXRlczogcmVzZXRBdHRyaWJ1dGVzLFxuICBzY3JvbGxJbnRvVmlldzogc2Nyb2xsSW50b1ZpZXcsXG4gIHNlbGVjdEFsbDogc2VsZWN0QWxsLFxuICBzZWxlY3ROb2RlQmFja3dhcmQ6IHNlbGVjdE5vZGVCYWNrd2FyZCxcbiAgc2VsZWN0Tm9kZUZvcndhcmQ6IHNlbGVjdE5vZGVGb3J3YXJkLFxuICBzZWxlY3RQYXJlbnROb2RlOiBzZWxlY3RQYXJlbnROb2RlLFxuICBzZWxlY3RUZXh0YmxvY2tFbmQ6IHNlbGVjdFRleHRibG9ja0VuZCxcbiAgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6IHNlbGVjdFRleHRibG9ja1N0YXJ0LFxuICBzZXRDb250ZW50OiBzZXRDb250ZW50LFxuICBzZXRNYXJrOiBzZXRNYXJrLFxuICBzZXRNZXRhOiBzZXRNZXRhLFxuICBzZXROb2RlOiBzZXROb2RlLFxuICBzZXROb2RlU2VsZWN0aW9uOiBzZXROb2RlU2VsZWN0aW9uLFxuICBzZXRUZXh0U2VsZWN0aW9uOiBzZXRUZXh0U2VsZWN0aW9uLFxuICBzaW5rTGlzdEl0ZW06IHNpbmtMaXN0SXRlbSxcbiAgc3BsaXRCbG9jazogc3BsaXRCbG9jayxcbiAgc3BsaXRMaXN0SXRlbTogc3BsaXRMaXN0SXRlbSxcbiAgdG9nZ2xlTGlzdDogdG9nZ2xlTGlzdCxcbiAgdG9nZ2xlTWFyazogdG9nZ2xlTWFyayxcbiAgdG9nZ2xlTm9kZTogdG9nZ2xlTm9kZSxcbiAgdG9nZ2xlV3JhcDogdG9nZ2xlV3JhcCxcbiAgdW5kb0lucHV0UnVsZTogdW5kb0lucHV0UnVsZSxcbiAgdW5zZXRBbGxNYXJrczogdW5zZXRBbGxNYXJrcyxcbiAgdW5zZXRNYXJrOiB1bnNldE1hcmssXG4gIHVwZGF0ZUF0dHJpYnV0ZXM6IHVwZGF0ZUF0dHJpYnV0ZXMsXG4gIHdyYXBJbjogd3JhcEluLFxuICB3cmFwSW5MaXN0OiB3cmFwSW5MaXN0XG59KTtcblxuY29uc3QgQ29tbWFuZHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnY29tbWFuZHMnLFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbWFuZHMsXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5jb25zdCBEcm9wID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2Ryb3AnLFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgndGlwdGFwRHJvcCcpLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZURyb3A6IChfLCBlLCBzbGljZSwgbW92ZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVtaXQoJ2Ryb3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmNvbnN0IEVkaXRhYmxlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2VkaXRhYmxlJyxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2VkaXRhYmxlJyksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6ICgpID0+IHRoaXMuZWRpdG9yLm9wdGlvbnMuZWRpdGFibGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuY29uc3QgZm9jdXNFdmVudHNQbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCdmb2N1c0V2ZW50cycpO1xuY29uc3QgRm9jdXNFdmVudHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnZm9jdXNFdmVudHMnLFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBrZXk6IGZvY3VzRXZlbnRzUGx1Z2luS2V5LFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM6ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdmb2N1cycsIHsgZXZlbnQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldE1ldGEoJ2FkZFRvSGlzdG9yeScsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYmx1cjogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdibHVyJywgeyBldmVudCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuY29uc3QgS2V5bWFwID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2tleW1hcCcsXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUJhY2tzcGFjZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLnVuZG9JbnB1dFJ1bGUoKSxcbiAgICAgICAgICAgIC8vIG1heWJlIGNvbnZlcnQgZmlyc3QgdGV4dCBibG9jayBub2RlIHRvIGRlZmF1bHQgbm9kZVxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHI7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgJGFuY2hvciB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zLCBwYXJlbnQgfSA9ICRhbmNob3I7XG4gICAgICAgICAgICAgICAgY29uc3QgJHBhcmVudFBvcyA9ICRhbmNob3IucGFyZW50LmlzVGV4dGJsb2NrICYmIHBvcyA+IDAgPyB0ci5kb2MucmVzb2x2ZShwb3MgLSAxKSA6ICRhbmNob3I7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50SXNJc29sYXRpbmcgPSAkcGFyZW50UG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFBvcyA9ICRhbmNob3IucG9zIC0gJGFuY2hvci5wYXJlbnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gKHBhcmVudElzSXNvbGF0aW5nICYmICRwYXJlbnRQb3MucGFyZW50LmNoaWxkQ291bnQgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgID8gcGFyZW50UG9zID09PSAkYW5jaG9yLnBvc1xuICAgICAgICAgICAgICAgICAgICA6IFNlbGVjdGlvbi5hdFN0YXJ0KGRvYykuZnJvbSA9PT0gcG9zO1xuICAgICAgICAgICAgICAgIGlmICghZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgfHwgIXBhcmVudC50eXBlLmlzVGV4dGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIHx8IHBhcmVudC50ZXh0Q29udGVudC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlzQXRTdGFydFxuICAgICAgICAgICAgICAgICAgICB8fCAoaXNBdFN0YXJ0ICYmICRhbmNob3IucGFyZW50LnR5cGUubmFtZSA9PT0gJ3BhcmFncmFwaCcpIC8vIHByZXZlbnQgY2xlYXJOb2RlcyB3aGVuIG5vIG5vZGVzIHRvIGNsZWFyLCBvdGhlcndpc2UgaGlzdG9yeSBzdGFjayBpcyBhcHBlbmRlZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkJhY2t3YXJkKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlQmFja3dhcmQoKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZURlbGV0ZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlQ3VycmVudE5vZGUoKSxcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmpvaW5Gb3J3YXJkKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlRm9yd2FyZCgpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRW50ZXIgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5uZXdsaW5lSW5Db2RlKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5jcmVhdGVQYXJhZ3JhcGhOZWFyKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5saWZ0RW1wdHlCbG9jaygpLFxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuc3BsaXRCbG9jaygpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgYmFzZUtleW1hcCA9IHtcbiAgICAgICAgICAgIEVudGVyOiBoYW5kbGVFbnRlcixcbiAgICAgICAgICAgICdNb2QtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5leGl0Q29kZSgpLFxuICAgICAgICAgICAgQmFja3NwYWNlOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAgICAgICAnTW9kLUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICAgICAgICdTaGlmdC1CYWNrc3BhY2UnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAgICAgICBEZWxldGU6IGhhbmRsZURlbGV0ZSxcbiAgICAgICAgICAgICdNb2QtRGVsZXRlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgICAgICAgJ01vZC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0QWxsKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBjS2V5bWFwID0ge1xuICAgICAgICAgICAgLi4uYmFzZUtleW1hcCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWFjS2V5bWFwID0ge1xuICAgICAgICAgICAgLi4uYmFzZUtleW1hcCxcbiAgICAgICAgICAgICdDdHJsLWgnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAgICAgICAnQWx0LUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICAgICAgICdDdHJsLWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAgICAgICAnQ3RybC1BbHQtQmFja3NwYWNlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgICAgICAgJ0FsdC1EZWxldGUnOiBoYW5kbGVEZWxldGUsXG4gICAgICAgICAgICAnQWx0LWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAgICAgICAnQ3RybC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrU3RhcnQoKSxcbiAgICAgICAgICAgICdDdHJsLWUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RUZXh0YmxvY2tFbmQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzaU9TKCkgfHwgaXNNYWNPUygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFjS2V5bWFwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwY0tleW1hcDtcbiAgICB9LFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIFdpdGggdGhpcyBwbHVnaW4gd2UgY2hlY2sgaWYgdGhlIHdob2xlIGRvY3VtZW50IHdhcyBzZWxlY3RlZCBhbmQgZGVsZXRlZC5cbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSB3aWxsIGFkZGl0aW9uYWxseSBjYWxsIGBjbGVhck5vZGVzKClgIHRvIGNvbnZlcnQgZS5nLiBhIGhlYWRpbmdcbiAgICAgICAgICAgIC8vIHRvIGEgcGFyYWdyYXBoIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gUHJvc2VNaXJyb3IncyBgQWxsU2VsZWN0aW9uYCwgd2hpY2ggZG9lc27igJl0IHdvcmsgd2VsbFxuICAgICAgICAgICAgLy8gd2l0aCBtYW55IG90aGVyIGNvbW1hbmRzLlxuICAgICAgICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgICAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdjbGVhckRvY3VtZW50JyksXG4gICAgICAgICAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuZ2V0TWV0YSgnY29tcG9zaXRpb24nKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdHJhbnNhY3Rpb25zLnNvbWUodHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICFvbGRTdGF0ZS5kb2MuZXEobmV3U3RhdGUuZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWdub3JlVHIgPSB0cmFuc2FjdGlvbnMuc29tZSh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5nZXRNZXRhKCdwcmV2ZW50Q2xlYXJEb2N1bWVudCcpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb2NDaGFuZ2VzIHx8IGlnbm9yZVRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgZnJvbSwgdG8gfSA9IG9sZFN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsRnJvbSA9IFNlbGVjdGlvbi5hdFN0YXJ0KG9sZFN0YXRlLmRvYykuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsRW5kID0gU2VsZWN0aW9uLmF0RW5kKG9sZFN0YXRlLmRvYykudG87XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbFdhc1NlbGVjdGVkID0gZnJvbSA9PT0gYWxsRnJvbSAmJiB0byA9PT0gYWxsRW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW1wdHkgfHwgIWFsbFdhc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNFbXB0eSA9IGlzTm9kZUVtcHR5KG5ld1N0YXRlLmRvYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gbmV3U3RhdGUudHI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjb21tYW5kcyB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuY29uc3QgUGFzdGUgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAncGFzdGUnLFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgndGlwdGFwUGFzdGUnKSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVQYXN0ZTogKF92aWV3LCBlLCBzbGljZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdCgncGFzdGUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmNvbnN0IFRhYmluZGV4ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3RhYmluZGV4JyxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ3RhYmluZGV4JyksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogKCkgPT4gKHRoaXMuZWRpdG9yLmlzRWRpdGFibGUgPyB7IHRhYmluZGV4OiAnMCcgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXI6IENsaXBib2FyZFRleHRTZXJpYWxpemVyLFxuICBDb21tYW5kczogQ29tbWFuZHMsXG4gIERyb3A6IERyb3AsXG4gIEVkaXRhYmxlOiBFZGl0YWJsZSxcbiAgRm9jdXNFdmVudHM6IEZvY3VzRXZlbnRzLFxuICBLZXltYXA6IEtleW1hcCxcbiAgUGFzdGU6IFBhc3RlLFxuICBUYWJpbmRleDogVGFiaW5kZXgsXG4gIGZvY3VzRXZlbnRzUGx1Z2luS2V5OiBmb2N1c0V2ZW50c1BsdWdpbktleVxufSk7XG5cbmNsYXNzIE5vZGVQb3Mge1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnR5cGUubmFtZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocG9zLCBlZGl0b3IsIGlzQmxvY2sgPSBmYWxzZSwgbm9kZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0dWFsRGVwdGggPSBudWxsO1xuICAgICAgICB0aGlzLmlzQmxvY2sgPSBpc0Jsb2NrO1xuICAgICAgICB0aGlzLnJlc29sdmVkUG9zID0gcG9zO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIGdldCBub2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50Tm9kZSB8fCB0aGlzLnJlc29sdmVkUG9zLm5vZGUoKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvci52aWV3LmRvbUF0UG9zKHRoaXMucG9zKS5ub2RlO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuYWN0dWFsRGVwdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMucmVzb2x2ZWRQb3MuZGVwdGg7XG4gICAgfVxuICAgIGdldCBwb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLnBvcztcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuY29udGVudDtcbiAgICB9XG4gICAgc2V0IGNvbnRlbnQoY29udGVudCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICAgICAgbGV0IHRvID0gdGhpcy50bztcbiAgICAgICAgaWYgKHRoaXMuaXNCbG9jaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWW91IGNhbuKAmXQgc2V0IGNvbnRlbnQgb24gYSBibG9jayBub2RlLiBUcmllZCB0byBzZXQgY29udGVudCBvbiAke3RoaXMubmFtZX0gYXQgJHt0aGlzLnBvc31gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tID0gdGhpcy5mcm9tICsgMTtcbiAgICAgICAgICAgIHRvID0gdGhpcy50byAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbSwgdG8gfSwgY29udGVudCk7XG4gICAgfVxuICAgIGdldCBhdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmF0dHJzO1xuICAgIH1cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLm5vZGVTaXplO1xuICAgIH1cbiAgICBnZXQgZnJvbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLnN0YXJ0KHRoaXMucmVzb2x2ZWRQb3MuZGVwdGgpO1xuICAgIH1cbiAgICBnZXQgcmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHRvKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3MgKyB0aGlzLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3MuZW5kKHRoaXMucmVzb2x2ZWRQb3MuZGVwdGgpICsgKHRoaXMubm9kZS5pc1RleHQgPyAwIDogMSk7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRQb3MgPSB0aGlzLnJlc29sdmVkUG9zLnN0YXJ0KHRoaXMucmVzb2x2ZWRQb3MuZGVwdGggLSAxKTtcbiAgICAgICAgY29uc3QgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUocGFyZW50UG9zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yKTtcbiAgICB9XG4gICAgZ2V0IGJlZm9yZSgpIHtcbiAgICAgICAgbGV0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMuZnJvbSAtICh0aGlzLmlzQmxvY2sgPyAxIDogMikpO1xuICAgICAgICBpZiAoJHBvcy5kZXB0aCAhPT0gdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy5mcm9tIC0gMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yKTtcbiAgICB9XG4gICAgZ2V0IGFmdGVyKCkge1xuICAgICAgICBsZXQgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy50byArICh0aGlzLmlzQmxvY2sgPyAyIDogMSkpO1xuICAgICAgICBpZiAoJHBvcy5kZXB0aCAhPT0gdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy50byArIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcik7XG4gICAgfVxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5ub2RlLmNvbnRlbnQuZm9yRWFjaCgobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0Jsb2NrID0gbm9kZS5pc0Jsb2NrICYmICFub2RlLmlzVGV4dGJsb2NrO1xuICAgICAgICAgICAgY29uc3QgaXNOb25UZXh0QXRvbSA9IG5vZGUuaXNBdG9tICYmICFub2RlLmlzVGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBvcyA9IHRoaXMucG9zICsgb2Zmc2V0ICsgKGlzTm9uVGV4dEF0b20gPyAwIDogMSk7XG4gICAgICAgICAgICBjb25zdCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0YXJnZXRQb3MpO1xuICAgICAgICAgICAgaWYgKCFpc0Jsb2NrICYmICRwb3MuZGVwdGggPD0gdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZVBvcyA9IG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yLCBpc0Jsb2NrLCBpc0Jsb2NrID8gbm9kZSA6IG51bGwpO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVQb3MuYWN0dWFsRGVwdGggPSB0aGlzLmRlcHRoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IsIGlzQmxvY2ssIGlzQmxvY2sgPyBub2RlIDogbnVsbCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF0gfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG4gICAgY2xvc2VzdChzZWxlY3RvciwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgICAgIGxldCBub2RlID0gbnVsbDtcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSAmJiAhbm9kZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLm5vZGUudHlwZS5uYW1lID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVBdHRyaWJ1dGVzID0gY3VycmVudE5vZGUubm9kZS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cktleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGF0dHJLZXlzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXR0cktleXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVBdHRyaWJ1dGVzW2tleV0gIT09IGF0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzLCB0cnVlKVswXSB8fCBudWxsO1xuICAgIH1cbiAgICBxdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzID0ge30sIGZpcnN0SXRlbU9ubHkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cktleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmRzIGFsbCBjaGlsZHJlbiByZWN1cnNpdmVseSB0aGF0IG1hdGNoIHRoZSBzZWxlY3RvciBhbmQgYXR0cmlidXRlc1xuICAgICAgICAgKiBJZiBmaXJzdEl0ZW1Pbmx5IGlzIHRydWUsIGl0IHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBpdGVtIGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGRQb3MgPT4ge1xuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBmb3VuZCBhIG5vZGUgYW5kIHdlIG9ubHkgd2FudCB0aGUgZmlyc3QgaXRlbSwgd2UgZG9udCBuZWVkIHRvIGtlZXAgZ29pbmdcbiAgICAgICAgICAgIGlmIChmaXJzdEl0ZW1Pbmx5ICYmIG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRQb3Mubm9kZS50eXBlLm5hbWUgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9lc0FsbEF0dHJpYnV0ZXNNYXRjaCA9IGF0dHJLZXlzLmV2ZXJ5KGtleSA9PiBhdHRyaWJ1dGVzW2tleV0gPT09IGNoaWxkUG9zLm5vZGUuYXR0cnNba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvZXNBbGxBdHRyaWJ1dGVzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChjaGlsZFBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBmb3VuZCBhIG5vZGUgYW5kIHdlIG9ubHkgd2FudCB0aGUgZmlyc3QgaXRlbSwgd2UgY2FuIHN0b3AgaGVyZSBhbmQgc2tpcCB0aGUgcmVjdXJzaW9uXG4gICAgICAgICAgICBpZiAoZmlyc3RJdGVtT25seSAmJiBub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQoY2hpbGRQb3MucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcywgZmlyc3RJdGVtT25seSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGUoYXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCB7IHRyIH0gPSB0aGlzLmVkaXRvci5zdGF0ZTtcbiAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0aGlzLmZyb20sIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgLi4udGhpcy5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICAgIH1cbn1cblxuY29uc3Qgc3R5bGUgPSBgLlByb3NlTWlycm9yIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uUHJvc2VNaXJyb3Ige1xuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd2hpdGUtc3BhY2U6IGJyZWFrLXNwYWNlcztcbiAgLXdlYmtpdC1mb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IFwibGlnYVwiIDA7IC8qIHRoZSBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBFZGdlICovXG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0ge1xuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xufVxuXG4uUHJvc2VNaXJyb3IgW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdIFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG4uUHJvc2VNaXJyb3IgcHJlIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG5pbWcuUHJvc2VNaXJyb3Itc2VwYXJhdG9yIHtcbiAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7XG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xuICBtYXJnaW46IDAgIWltcG9ydGFudDtcbiAgd2lkdGg6IDAgIWltcG9ydGFudDtcbiAgaGVpZ2h0OiAwICFpbXBvcnRhbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBub25lO1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBtYXJnaW46IDA7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3I6YWZ0ZXIge1xuICBjb250ZW50OiBcIlwiO1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IC0ycHg7XG4gIHdpZHRoOiAyMHB4O1xuICBib3JkZXItdG9wOiAxcHggc29saWQgYmxhY2s7XG4gIGFuaW1hdGlvbjogUHJvc2VNaXJyb3ItY3Vyc29yLWJsaW5rIDEuMXMgc3RlcHMoMiwgc3RhcnQpIGluZmluaXRlO1xufVxuXG5Aa2V5ZnJhbWVzIFByb3NlTWlycm9yLWN1cnNvci1ibGluayB7XG4gIHRvIHtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKjo6c2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICo6Oi1tb3otc2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICoge1xuICBjYXJldC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1mb2N1c2VkIC5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBibG9jaztcbn1cblxuLnRpcHB5LWJveFtkYXRhLWFuaW1hdGlvbj1mYWRlXVtkYXRhLXN0YXRlPWhpZGRlbl0ge1xuICBvcGFjaXR5OiAwXG59YDtcblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVUYWcoc3R5bGUsIG5vbmNlLCBzdWZmaXgpIHtcbiAgICBjb25zdCB0aXB0YXBTdHlsZVRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHN0eWxlW2RhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiAnJ31dYCk7XG4gICAgaWYgKHRpcHRhcFN0eWxlVGFnICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aXB0YXBTdHlsZVRhZztcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gICAgfVxuICAgIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoYGRhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiAnJ31gLCAnJyk7XG4gICAgc3R5bGVOb2RlLmlubmVySFRNTCA9IHN0eWxlO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGVOb2RlKTtcbiAgICByZXR1cm4gc3R5bGVOb2RlO1xufVxuXG5jbGFzcyBFZGl0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVkaXRvciBpcyBjb25zaWRlcmVkIGluaXRpYWxpemVkIGFmdGVyIHRoZSBgY3JlYXRlYCBldmVudCBoYXMgYmVlbiBlbWl0dGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uU3RvcmFnZSA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgaW5qZWN0Q1NTOiB0cnVlLFxuICAgICAgICAgICAgaW5qZWN0Tm9uY2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IFtdLFxuICAgICAgICAgICAgYXV0b2ZvY3VzOiBmYWxzZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZWRpdG9yUHJvcHM6IHt9LFxuICAgICAgICAgICAgcGFyc2VPcHRpb25zOiB7fSxcbiAgICAgICAgICAgIGNvcmVFeHRlbnNpb25PcHRpb25zOiB7fSxcbiAgICAgICAgICAgIGVuYWJsZUlucHV0UnVsZXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVQYXN0ZVJ1bGVzOiB0cnVlLFxuICAgICAgICAgICAgZW5hYmxlQ29yZUV4dGVuc2lvbnM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDb250ZW50Q2hlY2s6IGZhbHNlLFxuICAgICAgICAgICAgb25CZWZvcmVDcmVhdGU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkNyZWF0ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25TZWxlY3Rpb25VcGRhdGU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvblRyYW5zYWN0aW9uOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25Gb2N1czogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQmx1cjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uRGVzdHJveTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQ29udGVudEVycm9yOiAoeyBlcnJvciB9KSA9PiB7IHRocm93IGVycm9yOyB9LFxuICAgICAgICAgICAgb25QYXN0ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uRHJvcDogKCkgPT4gbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29tbWFuZE1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVTY2hlbWEoKTtcbiAgICAgICAgdGhpcy5vbignYmVmb3JlQ3JlYXRlJywgdGhpcy5vcHRpb25zLm9uQmVmb3JlQ3JlYXRlKTtcbiAgICAgICAgdGhpcy5lbWl0KCdiZWZvcmVDcmVhdGUnLCB7IGVkaXRvcjogdGhpcyB9KTtcbiAgICAgICAgdGhpcy5vbignY29udGVudEVycm9yJywgdGhpcy5vcHRpb25zLm9uQ29udGVudEVycm9yKTtcbiAgICAgICAgdGhpcy5jcmVhdGVWaWV3KCk7XG4gICAgICAgIHRoaXMuaW5qZWN0Q1NTKCk7XG4gICAgICAgIHRoaXMub24oJ2NyZWF0ZScsIHRoaXMub3B0aW9ucy5vbkNyZWF0ZSk7XG4gICAgICAgIHRoaXMub24oJ3VwZGF0ZScsIHRoaXMub3B0aW9ucy5vblVwZGF0ZSk7XG4gICAgICAgIHRoaXMub24oJ3NlbGVjdGlvblVwZGF0ZScsIHRoaXMub3B0aW9ucy5vblNlbGVjdGlvblVwZGF0ZSk7XG4gICAgICAgIHRoaXMub24oJ3RyYW5zYWN0aW9uJywgdGhpcy5vcHRpb25zLm9uVHJhbnNhY3Rpb24pO1xuICAgICAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMub3B0aW9ucy5vbkZvY3VzKTtcbiAgICAgICAgdGhpcy5vbignYmx1cicsIHRoaXMub3B0aW9ucy5vbkJsdXIpO1xuICAgICAgICB0aGlzLm9uKCdkZXN0cm95JywgdGhpcy5vcHRpb25zLm9uRGVzdHJveSk7XG4gICAgICAgIHRoaXMub24oJ2Ryb3AnLCAoeyBldmVudCwgc2xpY2UsIG1vdmVkIH0pID0+IHRoaXMub3B0aW9ucy5vbkRyb3AoZXZlbnQsIHNsaWNlLCBtb3ZlZCkpO1xuICAgICAgICB0aGlzLm9uKCdwYXN0ZScsICh7IGV2ZW50LCBzbGljZSB9KSA9PiB0aGlzLm9wdGlvbnMub25QYXN0ZShldmVudCwgc2xpY2UpKTtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLmZvY3VzKHRoaXMub3B0aW9ucy5hdXRvZm9jdXMpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjcmVhdGUnLCB7IGVkaXRvcjogdGhpcyB9KTtcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RvcmFnZS5cbiAgICAgKi9cbiAgICBnZXQgc3RvcmFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uU3RvcmFnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IG9mIGFsbCByZWdpc3RlcmVkIGNvbW1hbmRzLlxuICAgICAqL1xuICAgIGdldCBjb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY29tbWFuZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbW1hbmQgY2hhaW4gdG8gY2FsbCBtdWx0aXBsZSBjb21tYW5kcyBhdCBvbmNlLlxuICAgICAqL1xuICAgIGNoYWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jaGFpbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGNvbW1hbmQgb3IgYSBjb21tYW5kIGNoYWluIGNhbiBiZSBleGVjdXRlZC4gV2l0aG91dCBleGVjdXRpbmcgaXQuXG4gICAgICovXG4gICAgY2FuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jYW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5qZWN0IENTUyBzdHlsZXMuXG4gICAgICovXG4gICAgaW5qZWN0Q1NTKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmluamVjdENTUyAmJiBkb2N1bWVudCkge1xuICAgICAgICAgICAgdGhpcy5jc3MgPSBjcmVhdGVTdHlsZVRhZyhzdHlsZSwgdGhpcy5vcHRpb25zLmluamVjdE5vbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZWRpdG9yIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBIGxpc3Qgb2Ygb3B0aW9uc1xuICAgICAqL1xuICAgIHNldE9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy52aWV3IHx8ICF0aGlzLnN0YXRlIHx8IHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkaXRvclByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuc2V0UHJvcHModGhpcy5vcHRpb25zLmVkaXRvclByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBlZGl0YWJsZSBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIHNldEVkaXRhYmxlKGVkaXRhYmxlLCBlbWl0VXBkYXRlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMoeyBlZGl0YWJsZSB9KTtcbiAgICAgICAgaWYgKGVtaXRVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgeyBlZGl0b3I6IHRoaXMsIHRyYW5zYWN0aW9uOiB0aGlzLnN0YXRlLnRyIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLlxuICAgICAqL1xuICAgIGdldCBpc0VkaXRhYmxlKCkge1xuICAgICAgICAvLyBzaW5jZSBwbHVnaW5zIGFyZSBhcHBsaWVkIGFmdGVyIGNyZWF0aW5nIHRoZSB2aWV3XG4gICAgICAgIC8vIGBlZGl0YWJsZWAgaXMgYWx3YXlzIGB0cnVlYCBmb3Igb25lIHRpY2suXG4gICAgICAgIC8vIHRoYXTigJlzIHdoeSB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgZm9yIGBvcHRpb25zLmVkaXRhYmxlYFxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmVkaXRhYmxlICYmIHRoaXMudmlldyAmJiB0aGlzLnZpZXcuZWRpdGFibGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVkaXRvciBzdGF0ZS5cbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBsdWdpbiBBIFByb3NlTWlycm9yIHBsdWdpblxuICAgICAqIEBwYXJhbSBoYW5kbGVQbHVnaW5zIENvbnRyb2wgaG93IHRvIG1lcmdlIHRoZSBwbHVnaW4gaW50byB0aGUgZXhpc3RpbmcgcGx1Z2lucy5cbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IGVkaXRvciBzdGF0ZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbiwgaGFuZGxlUGx1Z2lucykge1xuICAgICAgICBjb25zdCBwbHVnaW5zID0gaXNGdW5jdGlvbihoYW5kbGVQbHVnaW5zKVxuICAgICAgICAgICAgPyBoYW5kbGVQbHVnaW5zKHBsdWdpbiwgWy4uLnRoaXMuc3RhdGUucGx1Z2luc10pXG4gICAgICAgICAgICA6IFsuLi50aGlzLnN0YXRlLnBsdWdpbnMsIHBsdWdpbl07XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7IHBsdWdpbnMgfSk7XG4gICAgICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lT3JQbHVnaW5LZXlUb1JlbW92ZSBUaGUgcGx1Z2lucyBuYW1lXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBlZGl0b3Igc3RhdGUgb3IgdW5kZWZpbmVkIGlmIHRoZSBlZGl0b3IgaXMgZGVzdHJveWVkXG4gICAgICovXG4gICAgdW5yZWdpc3RlclBsdWdpbihuYW1lT3JQbHVnaW5LZXlUb1JlbW92ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2UGx1Z2lucyA9IHRoaXMuc3RhdGUucGx1Z2lucztcbiAgICAgICAgbGV0IHBsdWdpbnMgPSBwcmV2UGx1Z2lucztcbiAgICAgICAgW10uY29uY2F0KG5hbWVPclBsdWdpbktleVRvUmVtb3ZlKS5mb3JFYWNoKG5hbWVPclBsdWdpbktleSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPclBsdWdpbktleSA9PT0gJ3N0cmluZycgPyBgJHtuYW1lT3JQbHVnaW5LZXl9JGAgOiBuYW1lT3JQbHVnaW5LZXkua2V5O1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcGx1Z2lucyA9IHByZXZQbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gIXBsdWdpbi5rZXkuc3RhcnRzV2l0aChuYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJldlBsdWdpbnMubGVuZ3RoID09PSBwbHVnaW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gTm8gcGx1Z2luIHdhcyByZW1vdmVkLCBzbyB3ZSBkb27igJl0IG5lZWQgdG8gdXBkYXRlIHRoZSBzdGF0ZVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoe1xuICAgICAgICAgICAgcGx1Z2lucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBleHRlbnNpb24gbWFuYWdlci5cbiAgICAgKi9cbiAgICBjcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjb3JlRXh0ZW5zaW9ucyA9IHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9ucyA/IFtcbiAgICAgICAgICAgIEVkaXRhYmxlLFxuICAgICAgICAgICAgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIuY29uZmlndXJlKHtcbiAgICAgICAgICAgICAgICBibG9ja1NlcGFyYXRvcjogKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmNvcmVFeHRlbnNpb25PcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ibG9ja1NlcGFyYXRvcixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgQ29tbWFuZHMsXG4gICAgICAgICAgICBGb2N1c0V2ZW50cyxcbiAgICAgICAgICAgIEtleW1hcCxcbiAgICAgICAgICAgIFRhYmluZGV4LFxuICAgICAgICAgICAgRHJvcCxcbiAgICAgICAgICAgIFBhc3RlLFxuICAgICAgICBdLmZpbHRlcihleHQgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZW5hYmxlQ29yZUV4dGVuc2lvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9uc1tleHQubmFtZV0gIT09IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pIDogW107XG4gICAgICAgIGNvbnN0IGFsbEV4dGVuc2lvbnMgPSBbLi4uY29yZUV4dGVuc2lvbnMsIC4uLnRoaXMub3B0aW9ucy5leHRlbnNpb25zXS5maWx0ZXIoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbJ2V4dGVuc2lvbicsICdub2RlJywgJ21hcmsnXS5pbmNsdWRlcyhleHRlbnNpb24gPT09IG51bGwgfHwgZXh0ZW5zaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRlbnNpb24udHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbk1hbmFnZXIgPSBuZXcgRXh0ZW5zaW9uTWFuYWdlcihhbGxFeHRlbnNpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBjb21tYW5kIG1hbmFnZXIuXG4gICAgICovXG4gICAgY3JlYXRlQ29tbWFuZE1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHNjaGVtYS5cbiAgICAgKi9cbiAgICBjcmVhdGVTY2hlbWEoKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gdGhpcy5leHRlbnNpb25NYW5hZ2VyLnNjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHZpZXcuXG4gICAgICovXG4gICAgY3JlYXRlVmlldygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZG9jO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jID0gY3JlYXRlRG9jdW1lbnQodGhpcy5vcHRpb25zLmNvbnRlbnQsIHRoaXMuc2NoZW1hLCB0aGlzLm9wdGlvbnMucGFyc2VPcHRpb25zLCB7IGVycm9yT25JbnZhbGlkQ29udGVudDogdGhpcy5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEVycm9yKSB8fCAhWydbdGlwdGFwIGVycm9yXTogSW52YWxpZCBKU09OIGNvbnRlbnQnLCAnW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSFRNTCBjb250ZW50J10uaW5jbHVkZXMoZS5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCB0aGUgY29udGVudCBlcnJvciB3ZSB3ZXJlIGV4cGVjdGluZ1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NvbnRlbnRFcnJvcicsIHtcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgICAgZGlzYWJsZUNvbGxhYm9yYXRpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5jb2xsYWJvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UuY29sbGFib3JhdGlvbi5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBhdm9pZCBzeW5jaW5nIGJhY2sgaW52YWxpZCBjb250ZW50LCByZWluaXRpYWxpemUgdGhlIGV4dGVuc2lvbnMgd2l0aG91dCB0aGUgY29sbGFib3JhdGlvbiBleHRlbnNpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi5uYW1lICE9PSAnY29sbGFib3JhdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0YXJ0IHRoZSBpbml0aWFsaXphdGlvbiBwcm9jZXNzIGJ5IHJlY3JlYXRpbmcgdGhlIGV4dGVuc2lvbiBtYW5hZ2VyIHdpdGggdGhlIG5ldyBzZXQgb2YgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUV4dGVuc2lvbk1hbmFnZXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDb250ZW50IGlzIGludmFsaWQsIGJ1dCBhdHRlbXB0IHRvIGNyZWF0ZSBpdCBhbnl3YXksIHN0cmlwcGluZyBvdXQgdGhlIGludmFsaWQgcGFydHNcbiAgICAgICAgICAgIGRvYyA9IGNyZWF0ZURvY3VtZW50KHRoaXMub3B0aW9ucy5jb250ZW50LCB0aGlzLnNjaGVtYSwgdGhpcy5vcHRpb25zLnBhcnNlT3B0aW9ucywgeyBlcnJvck9uSW52YWxpZENvbnRlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHJlc29sdmVGb2N1c1Bvc2l0aW9uKGRvYywgdGhpcy5vcHRpb25zLmF1dG9mb2N1cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBFZGl0b3JWaWV3KHRoaXMub3B0aW9ucy5lbGVtZW50LCB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGByb2xlPVwidGV4dGJveFwiYCB0byB0aGUgZWRpdG9yIGVsZW1lbnRcbiAgICAgICAgICAgICAgICByb2xlOiAndGV4dGJveCcsXG4gICAgICAgICAgICAgICAgLi4uKF9hID0gdGhpcy5vcHRpb25zLmVkaXRvclByb3BzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwYXRjaFRyYW5zYWN0aW9uOiB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbiB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGBlZGl0b3Iudmlld2AgaXMgbm90IHlldCBhdmFpbGFibGUgYXQgdGhpcyB0aW1lLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2Ugd2lsbCBhZGQgYWxsIHBsdWdpbnMgYW5kIG5vZGUgdmlld3MgZGlyZWN0bHkgYWZ0ZXJ3YXJkcy5cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcbiAgICAgICAgICAgIHBsdWdpbnM6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5wbHVnaW5zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgdGhpcy5jcmVhdGVOb2RlVmlld3MoKTtcbiAgICAgICAgdGhpcy5wcmVwZW5kQ2xhc3MoKTtcbiAgICAgICAgLy8gTGV04oCZcyBzdG9yZSB0aGUgZWRpdG9yIGluc3RhbmNlIGluIHRoZSBET00gZWxlbWVudC5cbiAgICAgICAgLy8gU28gd2XigJlsbCBoYXZlIGFjY2VzcyB0byBpdCBmb3IgdGVzdHMuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgZG9tID0gdGhpcy52aWV3LmRvbTtcbiAgICAgICAgZG9tLmVkaXRvciA9IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYWxsIG5vZGUgdmlld3MuXG4gICAgICovXG4gICAgY3JlYXRlTm9kZVZpZXdzKCkge1xuICAgICAgICBpZiAodGhpcy52aWV3LmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3LnNldFByb3BzKHtcbiAgICAgICAgICAgIG5vZGVWaWV3czogdGhpcy5leHRlbnNpb25NYW5hZ2VyLm5vZGVWaWV3cyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBlbmQgY2xhc3MgbmFtZSB0byBlbGVtZW50LlxuICAgICAqL1xuICAgIHByZXBlbmRDbGFzcygpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5jbGFzc05hbWUgPSBgdGlwdGFwICR7dGhpcy52aWV3LmRvbS5jbGFzc05hbWV9YDtcbiAgICB9XG4gICAgY2FwdHVyZVRyYW5zYWN0aW9uKGZuKSB7XG4gICAgICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0ciA9IHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbjtcbiAgICAgICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGJhY2sgb3ZlciB3aGljaCB0byBzZW5kIHRyYW5zYWN0aW9ucyAoc3RhdGUgdXBkYXRlcykgcHJvZHVjZWQgYnkgdGhlIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgZGlzcGF0Y2hUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICAvLyBpZiB0aGUgZWRpdG9yIC8gdGhlIHZpZXcgb2YgdGhlIGVkaXRvciB3YXMgZGVzdHJveWVkXG4gICAgICAgIC8vIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgbm90IGJlIGRpc3BhdGNoZWQgYXMgdGhlcmUgaXMgbm8gdmlldyBhbnltb3JlLlxuICAgICAgICBpZiAodGhpcy52aWV3LmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGVwKHN0ZXApOyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuYXBwbHkodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25IYXNDaGFuZ2VkID0gIXRoaXMuc3RhdGUuc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuZW1pdCgnYmVmb3JlVHJhbnNhY3Rpb24nLCB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIG5leHRTdGF0ZTogc3RhdGUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgICAgICB0aGlzLmVtaXQoJ3RyYW5zYWN0aW9uJywge1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2VsZWN0aW9uSGFzQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzZWxlY3Rpb25VcGRhdGUnLCB7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9jdXMgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdmb2N1cycpO1xuICAgICAgICBjb25zdCBibHVyID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgnYmx1cicpO1xuICAgICAgICBpZiAoZm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZm9jdXMnLCB7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBmb2N1cy5ldmVudCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibHVyKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2JsdXInLCB7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBibHVyLmV2ZW50LFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkIHx8IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3ByZXZlbnRVcGRhdGUnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywge1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYXR0cmlidXRlcyBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgb3IgbWFyay5cbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dGVzKG5hbWVPclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGdldEF0dHJpYnV0ZXModGhpcy5zdGF0ZSwgbmFtZU9yVHlwZSk7XG4gICAgfVxuICAgIGlzQWN0aXZlKG5hbWVPckF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNPclVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPckF0dHJpYnV0ZXMgPT09ICdzdHJpbmcnID8gbmFtZU9yQXR0cmlidXRlcyA6IG51bGw7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gJ3N0cmluZycgPyBhdHRyaWJ1dGVzT3JVbmRlZmluZWQgOiBuYW1lT3JBdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gaXNBY3RpdmUodGhpcy5zdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSlNPTi5cbiAgICAgKi9cbiAgICBnZXRKU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MudG9KU09OKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSFRNTC5cbiAgICAgKi9cbiAgICBnZXRIVE1MKCkge1xuICAgICAgICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudCh0aGlzLnN0YXRlLmRvYy5jb250ZW50LCB0aGlzLnNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgdGV4dC5cbiAgICAgKi9cbiAgICBnZXRUZXh0KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIGdldFRleHQodGhpcy5zdGF0ZS5kb2MsIHtcbiAgICAgICAgICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgICAgICAgICAgdGV4dFNlcmlhbGl6ZXJzOiB7XG4gICAgICAgICAgICAgICAgLi4uZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSh0aGlzLnNjaGVtYSksXG4gICAgICAgICAgICAgICAgLi4udGV4dFNlcmlhbGl6ZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIG5vIGNvbnRlbnQuXG4gICAgICovXG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBpc05vZGVFbXB0eSh0aGlzLnN0YXRlLmRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXRDaGFyYWN0ZXJDb3VudCgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBcImVkaXRvci5nZXRDaGFyYWN0ZXJDb3VudCgpXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImVkaXRvci5zdG9yYWdlLmNoYXJhY3RlckNvdW50LmNoYXJhY3RlcnMoKVwiIGluc3RlYWQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRvYy5jb250ZW50LnNpemUgLSAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZXN0cm95Jyk7XG4gICAgICAgIGlmICh0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgIC8vIENsZWFudXAgb3VyIHJlZmVyZW5jZSB0byBwcmV2ZW50IGNpcmN1bGFyIHJlZmVyZW5jZXMgd2hpY2ggY2F1c2VkIG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgZG9tID0gdGhpcy52aWV3LmRvbTtcbiAgICAgICAgICAgIGlmIChkb20gJiYgZG9tLmVkaXRvcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkb20uZWRpdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZWRpdG9yIGlzIGFscmVhZHkgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiAhKChfYSA9IHRoaXMudmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRvY1ZpZXcpO1xuICAgIH1cbiAgICAkbm9kZShzZWxlY3RvciwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy4kZG9jKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucXVlcnlTZWxlY3RvcihzZWxlY3RvciwgYXR0cmlidXRlcykpIHx8IG51bGw7XG4gICAgfVxuICAgICRub2RlcyhzZWxlY3RvciwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy4kZG9jKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcykpIHx8IG51bGw7XG4gICAgfVxuICAgICRwb3MocG9zKSB7XG4gICAgICAgIGNvbnN0ICRwb3MgPSB0aGlzLnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0ICRkb2MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRwb3MoMCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9kb2NzL2VkaXRvci9leHRlbnNpb25zL2N1c3RvbS1leHRlbnNpb25zL2V4dGVuZC1leGlzdGluZyNpbnB1dC1ydWxlc1xuICovXG5mdW5jdGlvbiBtYXJrSW5wdXRSdWxlKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCk7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlR3JvdXAgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmVHcm91cCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dFN0YXJ0ID0gcmFuZ2UuZnJvbSArIGZ1bGxNYXRjaC5pbmRleE9mKGNhcHR1cmVHcm91cCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhjbHVkZWRNYXJrcyA9IGdldE1hcmtzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgc3RhdGUuZG9jKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGNsdWRlZC5maW5kKHR5cGUgPT4gdHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgdHlwZSAhPT0gaXRlbS5tYXJrLnR5cGUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnRvID4gdGV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZWRNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXh0RW5kIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKHRleHRFbmQsIHJhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHRTdGFydCA+IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgdGV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWFya0VuZCA9IHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcyArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSk7XG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhjb25maWcudHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IGFkZHMgYSBub2RlIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI2lucHV0LXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIG5vZGVJbnB1dFJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHJhbmdlLnRvO1xuICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hTdGFydCA9IHN0YXJ0ICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoU3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBtYXRjaFN0YXJ0ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgbGFzdCB0eXBlZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q2hhciA9IG1hdGNoWzBdW21hdGNoWzBdLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHRyLmluc2VydFRleHQobGFzdENoYXIsIHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IG5vZGUgZnJvbSBpbnB1dCBydWxlXG4gICAgICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgobWF0Y2hTdGFydCwgZW5kLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0aW9uU3RhcnQgPSBjb25maWcudHlwZS5pc0lubGluZSA/IHN0YXJ0IDogc3RhcnQgLSAxO1xuICAgICAgICAgICAgICAgIHRyLmluc2VydChpbnNlcnRpb25TdGFydCwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpKS5kZWxldGUodHIubWFwcGluZy5tYXAoc3RhcnQpLCB0ci5tYXBwaW5nLm1hcChlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IGNoYW5nZXMgdGhlIHR5cGUgb2YgYSB0ZXh0YmxvY2sgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LiBXaGVuIHVzaW5nIGEgcmVndWxhciBleHByZXNpb24geW914oCZbGxcbiAqIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZXh0ZW5zaW9ucy9jdXN0b20tZXh0ZW5zaW9ucy9leHRlbmQtZXhpc3RpbmcjaW5wdXQtcnVsZXNcbiAqL1xuZnVuY3Rpb24gdGV4dGJsb2NrVHlwZUlucHV0UnVsZShjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgICAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0ICRzdGFydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pO1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCkgfHwge307XG4gICAgICAgICAgICBpZiAoISRzdGFydC5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkc3RhcnQuaW5kZXgoLTEpLCAkc3RhcnQuaW5kZXhBZnRlcigtMSksIGNvbmZpZy50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudHJcbiAgICAgICAgICAgICAgICAuZGVsZXRlKHJhbmdlLmZyb20sIHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgIC5zZXRCbG9ja1R5cGUocmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCByZXBsYWNlcyB0ZXh0IHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI2lucHV0LXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIHRleHRJbnB1dFJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2U7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG87XG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ICs9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCArIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kO1xuICAgICAgICAgICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydCA9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCAtIGN1dE9mZiwgb2Zmc2V0KSArIGluc2VydDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudHIuaW5zZXJ0VGV4dChpbnNlcnQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgYSB0ZXh0YmxvY2sgd2hlbiBhXG4gKiBnaXZlbiBzdHJpbmcgaXMgdHlwZWQuIFdoZW4gdXNpbmcgYSByZWd1bGFyIGV4cHJlc2lvbiB5b3XigJlsbFxuICogcHJvYmFibHkgd2FudCB0aGUgcmVnZXhwIHRvIHN0YXJ0IHdpdGggYF5gLCBzbyB0aGF0IHRoZSBwYXR0ZXJuIGNhblxuICogb25seSBvY2N1ciBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXG4gKlxuICogYHR5cGVgIGlzIHRoZSB0eXBlIG9mIG5vZGUgdG8gd3JhcCBpbi5cbiAqXG4gKiBCeSBkZWZhdWx0LCBpZiB0aGVyZeKAmXMgYSBub2RlIHdpdGggdGhlIHNhbWUgdHlwZSBhYm92ZSB0aGUgbmV3bHlcbiAqIHdyYXBwZWQgbm9kZSwgdGhlIHJ1bGUgd2lsbCB0cnkgdG8gam9pbiB0aG9zZVxuICogdHdvIG5vZGVzLiBZb3UgY2FuIHBhc3MgYSBqb2luIHByZWRpY2F0ZSwgd2hpY2ggdGFrZXMgYSByZWd1bGFyXG4gKiBleHByZXNzaW9uIG1hdGNoIGFuZCB0aGUgbm9kZSBiZWZvcmUgdGhlIHdyYXBwZWQgbm9kZSwgYW5kIGNhblxuICogcmV0dXJuIGEgYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIGEgam9pbiBzaG91bGQgaGFwcGVuLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZXh0ZW5zaW9ucy9jdXN0b20tZXh0ZW5zaW9ucy9leHRlbmQtZXhpc3RpbmcjaW5wdXQtcnVsZXNcbiAqL1xuZnVuY3Rpb24gd3JhcHBpbmdJbnB1dFJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCwgY2hhaW4sIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50ci5kZWxldGUocmFuZ2UuZnJvbSwgcmFuZ2UudG8pO1xuICAgICAgICAgICAgY29uc3QgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja1JhbmdlID0gJHN0YXJ0LmJsb2NrUmFuZ2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwaW5nID0gYmxvY2tSYW5nZSAmJiBmaW5kV3JhcHBpbmcoYmxvY2tSYW5nZSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgaWYgKCF3cmFwcGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIud3JhcChibG9ja1JhbmdlLCB3cmFwcGluZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmtlZXBNYXJrcyAmJiBjb25maWcuZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gY29uZmlnLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICAgICAgICAgICAgICBpZiAobWFya3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgLyoqIElmIHRoZSBub2RlVHlwZSBpcyBgYnVsbGV0TGlzdGAgb3IgYG9yZGVyZWRMaXN0YCBzZXQgdGhlIGBub2RlVHlwZWAgYXMgYGxpc3RJdGVtYCAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVUeXBlID0gY29uZmlnLnR5cGUubmFtZSA9PT0gJ2J1bGxldExpc3QnIHx8IGNvbmZpZy50eXBlLm5hbWUgPT09ICdvcmRlcmVkTGlzdCcgPyAnbGlzdEl0ZW0nIDogJ3Rhc2tMaXN0JztcbiAgICAgICAgICAgICAgICBjaGFpbigpLnVwZGF0ZUF0dHJpYnV0ZXMobm9kZVR5cGUsIGF0dHJpYnV0ZXMpLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSAtIDEpLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICBpZiAoYmVmb3JlXG4gICAgICAgICAgICAgICAgJiYgYmVmb3JlLnR5cGUgPT09IGNvbmZpZy50eXBlXG4gICAgICAgICAgICAgICAgJiYgY2FuSm9pbih0ci5kb2MsIHJhbmdlLmZyb20gLSAxKVxuICAgICAgICAgICAgICAgICYmICghY29uZmlnLmpvaW5QcmVkaWNhdGUgfHwgY29uZmlnLmpvaW5QcmVkaWNhdGUobWF0Y2gsIGJlZm9yZSkpKSB7XG4gICAgICAgICAgICAgICAgdHIuam9pbihyYW5nZS5mcm9tIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogVGhlIE5vZGUgY2xhc3MgaXMgdXNlZCB0byBjcmVhdGUgY3VzdG9tIG5vZGUgZXh0ZW5zaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zI2NyZWF0ZS1hLW5ldy1leHRlbnNpb25cbiAqL1xuY2xhc3MgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ25vZGUnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnbm9kZSc7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lO1xuICAgICAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRPcHRpb25zJywge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQodGhpcywgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgIH0pKSB8fCB7fTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUoY29uZmlnKTtcbiAgICB9XG4gICAgY29uZmlndXJlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBleHRlbnNpb25cbiAgICAgICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbmQoe1xuICAgICAgICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAgICAgICBhZGRPcHRpb25zOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFsd2F5cyBwcmVzZXJ2ZSB0aGUgY3VycmVudCBuYW1lXG4gICAgICAgIGV4dGVuc2lvbi5uYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAvLyBTZXQgdGhlIHBhcmVudCB0byBiZSBvdXIgcGFyZW50XG4gICAgICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICB9XG4gICAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnID0ge30pIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IE5vZGUoZXh0ZW5kZWRDb25maWcpO1xuICAgICAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvbjtcbiAgICAgICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZTtcbiAgICAgICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICB9KSk7XG4gICAgICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxufVxuXG4vKipcbiAqIE5vZGUgdmlld3MgYXJlIHVzZWQgdG8gY3VzdG9taXplIHRoZSByZW5kZXJlZCBET00gc3RydWN0dXJlIG9mIGEgbm9kZS5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL25vZGUtdmlld3NcbiAqL1xuY2xhc3MgTm9kZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgc3RvcEV2ZW50OiBudWxsLFxuICAgICAgICAgICAgaWdub3JlTXV0YXRpb246IG51bGwsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IHByb3BzLmV4dGVuc2lvbjtcbiAgICAgICAgdGhpcy5ub2RlID0gcHJvcHMubm9kZTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHByb3BzLmRlY29yYXRpb25zO1xuICAgICAgICB0aGlzLmlubmVyRGVjb3JhdGlvbnMgPSBwcm9wcy5pbm5lckRlY29yYXRpb25zO1xuICAgICAgICB0aGlzLnZpZXcgPSBwcm9wcy52aWV3O1xuICAgICAgICB0aGlzLkhUTUxBdHRyaWJ1dGVzID0gcHJvcHMuSFRNTEF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuZ2V0UG9zID0gcHJvcHMuZ2V0UG9zO1xuICAgICAgICB0aGlzLm1vdW50KCk7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBnZXQgZG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3Iudmlldy5kb207XG4gICAgfVxuICAgIGdldCBjb250ZW50RE9NKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IHRoaXMuZWRpdG9yO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIC8vIGdldCB0aGUgZHJhZyBoYW5kbGUgZWxlbWVudFxuICAgICAgICAvLyBgY2xvc2VzdGAgaXMgbm90IGF2YWlsYWJsZSBmb3IgdGV4dCBub2RlcyBzbyB3ZSBtYXkgaGF2ZSB0byB1c2UgaXRzIHBhcmVudFxuICAgICAgICBjb25zdCBkcmFnSGFuZGxlID0gdGFyZ2V0Lm5vZGVUeXBlID09PSAzXG4gICAgICAgICAgICA/IChfYSA9IHRhcmdldC5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJylcbiAgICAgICAgICAgIDogdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpO1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICgoX2IgPSB0aGlzLmNvbnRlbnRET00pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250YWlucyh0YXJnZXQpKSB8fCAhZHJhZ0hhbmRsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGZvciBkcmFnIGVsZW1lbnQgaWYgd2UgdXNlIGEgZGlmZmVyZW50IGRyYWcgaGFuZGxlIGVsZW1lbnRcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9PSBkcmFnSGFuZGxlKSB7XG4gICAgICAgICAgICBjb25zdCBkb21Cb3ggPSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUJveCA9IGRyYWdIYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAvLyBJbiBSZWFjdCwgd2UgaGF2ZSB0byBnbyB0aHJvdWdoIG5hdGl2ZUV2ZW50IHRvIHJlYWNoIG9mZnNldFgvb2Zmc2V0WS5cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFggPSAoX2MgPSBldmVudC5vZmZzZXRYKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2QgPSBldmVudC5uYXRpdmVFdmVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm9mZnNldFg7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRZID0gKF9lID0gZXZlbnQub2Zmc2V0WSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogKF9mID0gZXZlbnQubmF0aXZlRXZlbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5vZmZzZXRZO1xuICAgICAgICAgICAgeCA9IGhhbmRsZUJveC54IC0gZG9tQm94LnggKyBvZmZzZXRYO1xuICAgICAgICAgICAgeSA9IGhhbmRsZUJveC55IC0gZG9tQm94LnkgKyBvZmZzZXRZO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsb25lZE5vZGUgPSB0aGlzLmRvbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIChfZyA9IGV2ZW50LmRhdGFUcmFuc2ZlcikgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnNldERyYWdJbWFnZShjbG9uZWROb2RlLCB4LCB5KTtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXRQb3MoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbmVlZCB0byB0ZWxsIFByb3NlTWlycm9yIHRoYXQgd2Ugd2FudCB0byBtb3ZlIHRoZSB3aG9sZSBub2RlXG4gICAgICAgIC8vIHNvIHdlIGNyZWF0ZSBhIE5vZGVTZWxlY3Rpb25cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHBvcyk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIHN0b3BFdmVudChldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3RvcEV2ZW50KHsgZXZlbnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBjb25zdCBpc0luRWxlbWVudCA9IHRoaXMuZG9tLmNvbnRhaW5zKHRhcmdldCkgJiYgISgoX2EgPSB0aGlzLmNvbnRlbnRET00pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyh0YXJnZXQpKTtcbiAgICAgICAgLy8gYW55IGV2ZW50IGZyb20gY2hpbGQgbm9kZXMgc2hvdWxkIGJlIGhhbmRsZWQgYnkgUHJvc2VNaXJyb3JcbiAgICAgICAgaWYgKCFpc0luRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRHJhZ0V2ZW50ID0gZXZlbnQudHlwZS5zdGFydHNXaXRoKCdkcmFnJyk7XG4gICAgICAgIGNvbnN0IGlzRHJvcEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2Ryb3AnO1xuICAgICAgICBjb25zdCBpc0lucHV0ID0gWydJTlBVVCcsICdCVVRUT04nLCAnU0VMRUNUJywgJ1RFWFRBUkVBJ10uaW5jbHVkZXModGFyZ2V0LnRhZ05hbWUpIHx8IHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgICAgICAgLy8gYW55IGlucHV0IGV2ZW50IHdpdGhpbiBub2RlIHZpZXdzIHNob3VsZCBiZSBpZ25vcmVkIGJ5IFByb3NlTWlycm9yXG4gICAgICAgIGlmIChpc0lucHV0ICYmICFpc0Ryb3BFdmVudCAmJiAhaXNEcmFnRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaXNFZGl0YWJsZSB9ID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIGNvbnN0IHsgaXNEcmFnZ2luZyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlO1xuICAgICAgICBjb25zdCBpc1NlbGVjdGFibGUgPSBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh0aGlzLm5vZGUpO1xuICAgICAgICBjb25zdCBpc0NvcHlFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjb3B5JztcbiAgICAgICAgY29uc3QgaXNQYXN0ZUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ3Bhc3RlJztcbiAgICAgICAgY29uc3QgaXNDdXRFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjdXQnO1xuICAgICAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBldmVudC50eXBlID09PSAnbW91c2Vkb3duJztcbiAgICAgICAgLy8gUHJvc2VNaXJyb3IgdHJpZXMgdG8gZHJhZyBzZWxlY3RhYmxlIG5vZGVzXG4gICAgICAgIC8vIGV2ZW4gaWYgYGRyYWdnYWJsZWAgaXMgc2V0IHRvIGBmYWxzZWBcbiAgICAgICAgLy8gdGhpcyBmaXggcHJldmVudHMgdGhhdFxuICAgICAgICBpZiAoIWlzRHJhZ2dhYmxlICYmIGlzU2VsZWN0YWJsZSAmJiBpc0RyYWdFdmVudCAmJiBldmVudC50YXJnZXQgPT09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RyYWdnYWJsZSAmJiBpc0RyYWdFdmVudCAmJiAhaXNEcmFnZ2luZyAmJiBldmVudC50YXJnZXQgPT09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gc3RvcmUgdGhhdCBkcmFnZ2luZyBzdGFydGVkXG4gICAgICAgIGlmIChpc0RyYWdnYWJsZSAmJiBpc0VkaXRhYmxlICYmICFpc0RyYWdnaW5nICYmIGlzQ2xpY2tFdmVudCkge1xuICAgICAgICAgICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5jbG9zZXN0KCdbZGF0YS1kcmFnLWhhbmRsZV0nKTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWREcmFnSGFuZGxlID0gZHJhZ0hhbmRsZSAmJiAodGhpcy5kb20gPT09IGRyYWdIYW5kbGUgfHwgdGhpcy5kb20uY29udGFpbnMoZHJhZ0hhbmRsZSkpO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREcmFnSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGVzZSBldmVudHMgYXJlIGhhbmRsZWQgYnkgcHJvc2VtaXJyb3JcbiAgICAgICAgaWYgKGlzRHJhZ2dpbmdcbiAgICAgICAgICAgIHx8IGlzRHJvcEV2ZW50XG4gICAgICAgICAgICB8fCBpc0NvcHlFdmVudFxuICAgICAgICAgICAgfHwgaXNQYXN0ZUV2ZW50XG4gICAgICAgICAgICB8fCBpc0N1dEV2ZW50XG4gICAgICAgICAgICB8fCAoaXNDbGlja0V2ZW50ICYmIGlzU2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBET00gW211dGF0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTXV0YXRpb25PYnNlcnZlcikgb3IgYSBzZWxlY3Rpb24gY2hhbmdlIGhhcHBlbnMgd2l0aGluIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm4gYGZhbHNlYCBpZiB0aGUgZWRpdG9yIHNob3VsZCByZS1yZWFkIHRoZSBzZWxlY3Rpb24gb3IgcmUtcGFyc2UgdGhlIHJhbmdlIGFyb3VuZCB0aGUgbXV0YXRpb25cbiAgICAgKiBAcmV0dXJuIGB0cnVlYCBpZiBpdCBjYW4gc2FmZWx5IGJlIGlnbm9yZWQuXG4gICAgICovXG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbih7IG11dGF0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGEgbGVhZi9hdG9tIG5vZGUgaXMgbGlrZSBhIGJsYWNrIGJveCBmb3IgUHJvc2VNaXJyb3JcbiAgICAgICAgLy8gYW5kIHNob3VsZCBiZSBmdWxseSBoYW5kbGVkIGJ5IHRoZSBub2RlIHZpZXdcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pc0xlYWYgfHwgdGhpcy5ub2RlLmlzQXRvbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvc2VNaXJyb3Igc2hvdWxkIGhhbmRsZSBhbnkgc2VsZWN0aW9uc1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ3NlbGVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cnkgdG8gcHJldmVudCBhIGJ1ZyBvbiBpT1MgYW5kIEFuZHJvaWQgdGhhdCB3aWxsIGJyZWFrIG5vZGUgdmlld3Mgb24gZW50ZXJcbiAgICAgICAgLy8gdGhpcyBpcyBiZWNhdXNlIFByb3NlTWlycm9yIGNhbuKAmXQgcHJldmVudERpc3BhdGNoIG9uIGVudGVyXG4gICAgICAgIC8vIHRoaXMgd2lsbCBsZWFkIHRvIGEgcmUtcmVuZGVyIG9mIHRoZSBub2RlIHZpZXcgb24gZW50ZXJcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzEyMTRcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzI1MzRcbiAgICAgICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldClcbiAgICAgICAgICAgICYmIG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnXG4gICAgICAgICAgICAmJiAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSlcbiAgICAgICAgICAgICYmIHRoaXMuZWRpdG9yLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlZE5vZGVzID0gW1xuICAgICAgICAgICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24uYWRkZWROb2RlcyksXG4gICAgICAgICAgICAgICAgLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5yZW1vdmVkTm9kZXMpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8vIHdl4oCZbGwgY2hlY2sgaWYgZXZlcnkgY2hhbmdlZCBub2RlIGlzIGNvbnRlbnRFZGl0YWJsZVxuICAgICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGl04oCZcyBwcm9iYWJseSBtdXRhdGVkIGJ5IFByb3NlTWlycm9yXG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVzLmV2ZXJ5KG5vZGUgPT4gbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2Ugd2lsbCBhbGxvdyBtdXRhdGlvbiBjb250ZW50RE9NIHdpdGggYXR0cmlidXRlc1xuICAgICAgICAvLyBzbyB3ZSBjYW4gZm9yIGV4YW1wbGUgYWRkaW5nIGNsYXNzZXMgd2l0aGluIG91ciBub2RlIHZpZXdcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSA9PT0gbXV0YXRpb24udGFyZ2V0ICYmIG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvc2VNaXJyb3Igc2hvdWxkIGhhbmRsZSBhbnkgY2hhbmdlcyB3aXRoaW4gY29udGVudERPTVxuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBwcm9zZW1pcnJvciBub2RlLlxuICAgICAqL1xuICAgIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoZSBub2RlLlxuICAgICAqL1xuICAgIGRlbGV0ZU5vZGUoKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmdldFBvcygpO1xuICAgICAgICBpZiAodHlwZW9mIGZyb20gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5ub2RlLm5vZGVTaXplO1xuICAgICAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5kZWxldGVSYW5nZSh7IGZyb20sIHRvIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgYWRkcyBhIG1hcmsgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI3Bhc3RlLXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIG1hcmtQYXN0ZVJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCwgcGFzdGVFdmVudCwgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCwgcGFzdGVFdmVudCk7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlR3JvdXAgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgbGV0IG1hcmtFbmQgPSByYW5nZS50bztcbiAgICAgICAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydFNwYWNlcyA9IGZ1bGxNYXRjaC5zZWFyY2goL1xcUy8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRTdGFydCA9IHJhbmdlLmZyb20gKyBmdWxsTWF0Y2guaW5kZXhPZihjYXB0dXJlR3JvdXApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRFbmQgPSB0ZXh0U3RhcnQgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IGl0ZW0ubWFyay50eXBlLmV4Y2x1ZGVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCh0eXBlID0+IHR5cGUgPT09IGNvbmZpZy50eXBlICYmIHR5cGUgIT09IGl0ZW0ubWFyay50eXBlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS50byA+IHRleHRTdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dEVuZCA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcmtFbmQgPSByYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpO1xuICAgICAgICAgICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsoY29uZmlnLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82OTY5NDg2XG5mdW5jdGlvbiBlc2NhcGVGb3JSZWdFeChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgYWRkcyBhIG5vZGUgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI3Bhc3RlLXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIG5vZGVQYXN0ZVJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcih7IG1hdGNoLCBjaGFpbiwgcmFuZ2UsIHBhc3RlRXZlbnQsIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gsIHBhc3RlRXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGNhbGxPclJldHVybihjb25maWcuZ2V0Q29udGVudCwgdW5kZWZpbmVkLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzID09PSBmYWxzZSB8fCBhdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RlID0geyB0eXBlOiBjb25maWcudHlwZS5uYW1lLCBhdHRyczogYXR0cmlidXRlcyB9O1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgY2hhaW4oKS5kZWxldGVSYW5nZShyYW5nZSkuaW5zZXJ0Q29udGVudEF0KHJhbmdlLmZyb20sIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCByZXBsYWNlcyB0ZXh0IHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgcGFzdGVkIGludG8gaXQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9kb2NzL2VkaXRvci9leHRlbnNpb25zL2N1c3RvbS1leHRlbnNpb25zL2V4dGVuZC1leGlzdGluZyNwYXN0ZS1ydWxlc1xuICovXG5mdW5jdGlvbiB0ZXh0UGFzdGVSdWxlKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IGNvbmZpZy5yZXBsYWNlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvO1xuICAgICAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXRPZmYgPSBzdGFydCAtIGVuZDtcbiAgICAgICAgICAgICAgICBpZiAoY3V0T2ZmID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuY2xhc3MgVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwcy5sZW5ndGg7XG4gICAgfVxuICAgIG1hcChwb3NpdGlvbikge1xuICAgICAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBtYXBwZWRQb3NpdGlvbiA9IHRoaXMudHJhbnNhY3Rpb24uc3RlcHNcbiAgICAgICAgICAgIC5zbGljZSh0aGlzLmN1cnJlbnRTdGVwKVxuICAgICAgICAgICAgLnJlZHVjZSgobmV3UG9zaXRpb24sIHN0ZXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcFJlc3VsdCA9IHN0ZXAuZ2V0TWFwKCkubWFwUmVzdWx0KG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChtYXBSZXN1bHQuZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcFJlc3VsdC5wb3M7XG4gICAgICAgIH0sIHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBtYXBwZWRQb3NpdGlvbixcbiAgICAgICAgICAgIGRlbGV0ZWQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgeyBDb21tYW5kTWFuYWdlciwgRWRpdG9yLCBFeHRlbnNpb24sIElucHV0UnVsZSwgTWFyaywgTm9kZSwgTm9kZVBvcywgTm9kZVZpZXcsIFBhc3RlUnVsZSwgVHJhY2tlciwgY2FsbE9yUmV0dXJuLCBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcywgY3JlYXRlQ2hhaW5hYmxlU3RhdGUsIGNyZWF0ZURvY3VtZW50LCBjcmVhdGVOb2RlRnJvbUNvbnRlbnQsIGNyZWF0ZVN0eWxlVGFnLCBkZWZhdWx0QmxvY2tBdCwgZGVsZXRlUHJvcHMsIGVsZW1lbnRGcm9tU3RyaW5nLCBlc2NhcGVGb3JSZWdFeCwgaW5kZXggYXMgZXh0ZW5zaW9ucywgZmluZENoaWxkcmVuLCBmaW5kQ2hpbGRyZW5JblJhbmdlLCBmaW5kRHVwbGljYXRlcywgZmluZFBhcmVudE5vZGUsIGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zLCBmcm9tU3RyaW5nLCBnZW5lcmF0ZUhUTUwsIGdlbmVyYXRlSlNPTiwgZ2VuZXJhdGVUZXh0LCBnZXRBdHRyaWJ1dGVzLCBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMsIGdldENoYW5nZWRSYW5nZXMsIGdldERlYnVnSlNPTiwgZ2V0RXh0ZW5zaW9uRmllbGQsIGdldEhUTUxGcm9tRnJhZ21lbnQsIGdldE1hcmtBdHRyaWJ1dGVzLCBnZXRNYXJrUmFuZ2UsIGdldE1hcmtUeXBlLCBnZXRNYXJrc0JldHdlZW4sIGdldE5vZGVBdFBvc2l0aW9uLCBnZXROb2RlQXR0cmlidXRlcywgZ2V0Tm9kZVR5cGUsIGdldFJlbmRlcmVkQXR0cmlidXRlcywgZ2V0U2NoZW1hLCBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucywgZ2V0U2NoZW1hVHlwZUJ5TmFtZSwgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUsIGdldFNwbGl0dGVkQXR0cmlidXRlcywgZ2V0VGV4dCwgZ2V0VGV4dEJldHdlZW4sIGdldFRleHRDb250ZW50RnJvbU5vZGVzLCBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLCBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUsIGlucHV0UnVsZXNQbHVnaW4sIGlzQWN0aXZlLCBpc0F0RW5kT2ZOb2RlLCBpc0F0U3RhcnRPZk5vZGUsIGlzRW1wdHlPYmplY3QsIGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkLCBpc0Z1bmN0aW9uLCBpc0xpc3QsIGlzTWFjT1MsIGlzTWFya0FjdGl2ZSwgaXNOb2RlQWN0aXZlLCBpc05vZGVFbXB0eSwgaXNOb2RlU2VsZWN0aW9uLCBpc051bWJlciwgaXNQbGFpbk9iamVjdCwgaXNSZWdFeHAsIGlzU3RyaW5nLCBpc1RleHRTZWxlY3Rpb24sIGlzaU9TLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMsIG1lcmdlRGVlcCwgbWluTWF4LCBub2RlSW5wdXRSdWxlLCBub2RlUGFzdGVSdWxlLCBvYmplY3RJbmNsdWRlcywgcGFzdGVSdWxlc1BsdWdpbiwgcG9zVG9ET01SZWN0LCByZW1vdmVEdXBsaWNhdGVzLCByZXNvbHZlRm9jdXNQb3NpdGlvbiwgcmV3cml0ZVVua25vd25Db250ZW50LCBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCwgc3BsaXRFeHRlbnNpb25zLCB0ZXh0SW5wdXRSdWxlLCB0ZXh0UGFzdGVSdWxlLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlLCB3cmFwcGluZ0lucHV0UnVsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiUGx1Z2luIiwiUGx1Z2luS2V5IiwiVGV4dFNlbGVjdGlvbiIsIlNlbGVjdGlvbiIsIkFsbFNlbGVjdGlvbiIsIk5vZGVTZWxlY3Rpb24iLCJFZGl0b3JTdGF0ZSIsIkVkaXRvclZpZXciLCJrZXltYXAiLCJTY2hlbWEiLCJET01TZXJpYWxpemVyIiwiRnJhZ21lbnQiLCJOb2RlIiwiTm9kZSQxIiwiRE9NUGFyc2VyIiwiU2xpY2UiLCJsaWZ0VGFyZ2V0IiwiUmVwbGFjZVN0ZXAiLCJSZXBsYWNlQXJvdW5kU3RlcCIsImpvaW5Qb2ludCIsIlRyYW5zZm9ybSIsImNhblNwbGl0IiwiY2FuSm9pbiIsImZpbmRXcmFwcGluZyIsImNyZWF0ZVBhcmFncmFwaE5lYXIiLCJjcmVhdGVQYXJhZ3JhcGhOZWFyJDEiLCJkZWxldGVTZWxlY3Rpb24iLCJkZWxldGVTZWxlY3Rpb24kMSIsImV4aXRDb2RlIiwiZXhpdENvZGUkMSIsImpvaW5VcCIsImpvaW5VcCQxIiwiam9pbkRvd24iLCJqb2luRG93biQxIiwiam9pbkJhY2t3YXJkIiwiam9pbkJhY2t3YXJkJDEiLCJqb2luRm9yd2FyZCIsImpvaW5Gb3J3YXJkJDEiLCJqb2luVGV4dGJsb2NrQmFja3dhcmQiLCJqb2luVGV4dGJsb2NrQmFja3dhcmQkMSIsImpvaW5UZXh0YmxvY2tGb3J3YXJkIiwiam9pblRleHRibG9ja0ZvcndhcmQkMSIsImxpZnQiLCJsaWZ0JDEiLCJsaWZ0RW1wdHlCbG9jayIsImxpZnRFbXB0eUJsb2NrJDEiLCJuZXdsaW5lSW5Db2RlIiwibmV3bGluZUluQ29kZSQxIiwic2VsZWN0Tm9kZUJhY2t3YXJkIiwic2VsZWN0Tm9kZUJhY2t3YXJkJDEiLCJzZWxlY3ROb2RlRm9yd2FyZCIsInNlbGVjdE5vZGVGb3J3YXJkJDEiLCJzZWxlY3RQYXJlbnROb2RlIiwic2VsZWN0UGFyZW50Tm9kZSQxIiwic2VsZWN0VGV4dGJsb2NrRW5kIiwic2VsZWN0VGV4dGJsb2NrRW5kJDEiLCJzZWxlY3RUZXh0YmxvY2tTdGFydCIsInNlbGVjdFRleHRibG9ja1N0YXJ0JDEiLCJzZXRCbG9ja1R5cGUiLCJ3cmFwSW4iLCJ3cmFwSW4kMSIsImxpZnRMaXN0SXRlbSIsImxpZnRMaXN0SXRlbSQxIiwic2lua0xpc3RJdGVtIiwic2lua0xpc3RJdGVtJDEiLCJ3cmFwSW5MaXN0Iiwid3JhcEluTGlzdCQxIiwiY3JlYXRlQ2hhaW5hYmxlU3RhdGUiLCJjb25maWciLCJzdGF0ZSIsInRyYW5zYWN0aW9uIiwic2VsZWN0aW9uIiwiZG9jIiwic3RvcmVkTWFya3MiLCJhcHBseSIsImJpbmQiLCJhcHBseVRyYW5zYWN0aW9uIiwicGx1Z2lucyIsInNjaGVtYSIsInJlY29uZmlndXJlIiwidG9KU09OIiwidHIiLCJDb21tYW5kTWFuYWdlciIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJlZGl0b3IiLCJyYXdDb21tYW5kcyIsImV4dGVuc2lvbk1hbmFnZXIiLCJjb21tYW5kcyIsImN1c3RvbVN0YXRlIiwiaGFzQ3VzdG9tU3RhdGUiLCJ2aWV3IiwiYnVpbGRQcm9wcyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIm1hcCIsIm5hbWUiLCJjb21tYW5kIiwibWV0aG9kIiwiYXJncyIsImNhbGxiYWNrIiwiZ2V0TWV0YSIsImRpc3BhdGNoIiwiY2hhaW4iLCJjcmVhdGVDaGFpbiIsImNhbiIsImNyZWF0ZUNhbiIsInN0YXJ0VHIiLCJzaG91bGREaXNwYXRjaCIsImNhbGxiYWNrcyIsImhhc1N0YXJ0VHJhbnNhY3Rpb24iLCJydW4iLCJldmVyeSIsImNoYWluZWRDb21tYW5kIiwicHVzaCIsImZvcm1hdHRlZENvbW1hbmRzIiwidW5kZWZpbmVkIiwiRXZlbnRFbWl0dGVyIiwib24iLCJldmVudCIsImZuIiwiZW1pdCIsImZvckVhY2giLCJvZmYiLCJmaWx0ZXIiLCJvbmNlIiwib25jZUZuIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZ2V0RXh0ZW5zaW9uRmllbGQiLCJleHRlbnNpb24iLCJmaWVsZCIsImNvbnRleHQiLCJwYXJlbnQiLCJ2YWx1ZSIsInNwbGl0RXh0ZW5zaW9ucyIsImV4dGVuc2lvbnMiLCJiYXNlRXh0ZW5zaW9ucyIsInR5cGUiLCJub2RlRXh0ZW5zaW9ucyIsIm1hcmtFeHRlbnNpb25zIiwiZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zIiwiZXh0ZW5zaW9uQXR0cmlidXRlcyIsIm5vZGVBbmRNYXJrRXh0ZW5zaW9ucyIsImRlZmF1bHRBdHRyaWJ1dGUiLCJkZWZhdWx0IiwicmVuZGVyZWQiLCJyZW5kZXJIVE1MIiwicGFyc2VIVE1MIiwia2VlcE9uU3BsaXQiLCJpc1JlcXVpcmVkIiwib3B0aW9ucyIsInN0b3JhZ2UiLCJhZGRHbG9iYWxBdHRyaWJ1dGVzIiwiZ2xvYmFsQXR0cmlidXRlcyIsImdsb2JhbEF0dHJpYnV0ZSIsInR5cGVzIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZSIsImFkZEF0dHJpYnV0ZXMiLCJtZXJnZWRBdHRyIiwiZ2V0Tm9kZVR5cGUiLCJuYW1lT3JUeXBlIiwibm9kZXMiLCJFcnJvciIsIm1lcmdlQXR0cmlidXRlcyIsIm9iamVjdHMiLCJpdGVtIiwicmVkdWNlIiwiaXRlbXMiLCJtZXJnZWRBdHRyaWJ1dGVzIiwia2V5IiwiZXhpc3RzIiwidmFsdWVDbGFzc2VzIiwiU3RyaW5nIiwic3BsaXQiLCJleGlzdGluZ0NsYXNzZXMiLCJpbnNlcnRDbGFzc2VzIiwidmFsdWVDbGFzcyIsImluY2x1ZGVzIiwiam9pbiIsIm5ld1N0eWxlcyIsInN0eWxlIiwidHJpbSIsIkJvb2xlYW4iLCJleGlzdGluZ1N0eWxlcyIsInN0eWxlTWFwIiwiTWFwIiwicHJvcGVydHkiLCJ2YWwiLCJwYXJ0Iiwic2V0IiwiQXJyYXkiLCJmcm9tIiwiZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzIiwibm9kZU9yTWFyayIsImF0dHJzIiwiaXNGdW5jdGlvbiIsImNhbGxPclJldHVybiIsImlzRW1wdHlPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiZnJvbVN0cmluZyIsIm1hdGNoIiwiTnVtYmVyIiwiaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlIiwicGFyc2VSdWxlIiwiZ2V0QXR0cnMiLCJub2RlIiwib2xkQXR0cmlidXRlcyIsIm5ld0F0dHJpYnV0ZXMiLCJnZXRBdHRyaWJ1dGUiLCJjbGVhblVwU2NoZW1hSXRlbSIsImRhdGEiLCJnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyIsIl9hIiwiYWxsQXR0cmlidXRlcyIsInRvcE5vZGUiLCJmaW5kIiwiZXh0cmFOb2RlRmllbGRzIiwiZmllbGRzIiwiZSIsImV4dGVuZE5vZGVTY2hlbWEiLCJjb250ZW50IiwibWFya3MiLCJncm91cCIsImlubGluZSIsImF0b20iLCJzZWxlY3RhYmxlIiwiZHJhZ2dhYmxlIiwiY29kZSIsIndoaXRlc3BhY2UiLCJsaW5lYnJlYWtSZXBsYWNlbWVudCIsImRlZmluaW5nIiwiaXNvbGF0aW5nIiwiZXh0ZW5zaW9uQXR0cmlidXRlIiwicGFyc2VET00iLCJ0b0RPTSIsIkhUTUxBdHRyaWJ1dGVzIiwicmVuZGVyVGV4dCIsInRvVGV4dCIsImV4dHJhTWFya0ZpZWxkcyIsImV4dGVuZE1hcmtTY2hlbWEiLCJpbmNsdXNpdmUiLCJleGNsdWRlcyIsInNwYW5uaW5nIiwibWFyayIsImdldFNjaGVtYVR5cGVCeU5hbWUiLCJpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZCIsImVuYWJsZWQiLCJpc0FycmF5Iiwic29tZSIsImVuYWJsZWRFeHRlbnNpb24iLCJnZXRIVE1MRnJvbUZyYWdtZW50IiwiZnJhZ21lbnQiLCJkb2N1bWVudEZyYWdtZW50IiwiZnJvbVNjaGVtYSIsInNlcmlhbGl6ZUZyYWdtZW50IiwidGVtcG9yYXJ5RG9jdW1lbnQiLCJkb2N1bWVudCIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlSFRNTERvY3VtZW50IiwiY29udGFpbmVyIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwiaW5uZXJIVE1MIiwiZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMiLCIkZnJvbSIsIm1heE1hdGNoIiwidGV4dEJlZm9yZSIsInNsaWNlRW5kUG9zIiwicGFyZW50T2Zmc2V0Iiwibm9kZXNCZXR3ZWVuIiwiTWF0aCIsIm1heCIsInBvcyIsImluZGV4IiwiX2IiLCJjaHVuayIsInNwZWMiLCJjYWxsIiwidGV4dENvbnRlbnQiLCJpc0F0b20iLCJpc1RleHQiLCJzbGljZSIsImlzUmVnRXhwIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJJbnB1dFJ1bGUiLCJoYW5kbGVyIiwiaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIiLCJ0ZXh0IiwiZXhlYyIsImlucHV0UnVsZU1hdGNoIiwicmVzdWx0IiwiaW5wdXQiLCJyZXBsYWNlV2l0aCIsImNvbnNvbGUiLCJ3YXJuIiwicnVuJDEiLCJ0byIsInJ1bGVzIiwicGx1Z2luIiwiY29tcG9zaW5nIiwicmVzb2x2ZSIsIm5vZGVCZWZvcmUiLCJub2RlQWZ0ZXIiLCJtYXRjaGVkIiwicnVsZSIsInJhbmdlIiwic3RlcHMiLCJzZXRNZXRhIiwidHJhbnNmb3JtIiwiaW5wdXRSdWxlc1BsdWdpbiIsImluaXQiLCJwcmV2Iiwic3RvcmVkIiwic2ltdWxhdGVkSW5wdXRNZXRhIiwiaXNTaW11bGF0ZWRJbnB1dCIsInNldFRpbWVvdXQiLCJzZWxlY3Rpb25TZXQiLCJkb2NDaGFuZ2VkIiwiaGFuZGxlVGV4dElucHV0IiwiaGFuZGxlRE9NRXZlbnRzIiwiY29tcG9zaXRpb25lbmQiLCIkY3Vyc29yIiwiaGFuZGxlS2V5RG93biIsImlzSW5wdXRSdWxlcyIsImdldFR5cGUiLCJpc1BsYWluT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJtZXJnZURlZXAiLCJ0YXJnZXQiLCJzb3VyY2UiLCJvdXRwdXQiLCJNYXJrIiwiY2hpbGQiLCJkZWZhdWx0T3B0aW9ucyIsImFkZE9wdGlvbnMiLCJjcmVhdGUiLCJjb25maWd1cmUiLCJleHRlbmQiLCJleHRlbmRlZENvbmZpZyIsImhhbmRsZUV4aXQiLCJjdXJyZW50UG9zIiwiaXNBdEVuZCIsImVuZCIsImN1cnJlbnRNYXJrcyIsImlzSW5NYXJrIiwibSIsInJlbW92ZU1hcmsiLCJyZW1vdmVTdG9yZWRNYXJrIiwiaW5zZXJ0VGV4dCIsImlzTnVtYmVyIiwiUGFzdGVSdWxlIiwicGFzdGVSdWxlTWF0Y2hlckhhbmRsZXIiLCJtYXRjaEFsbCIsIm1hdGNoZXMiLCJwYXN0ZVJ1bGVNYXRjaCIsInBhc3RlRXZlbnQiLCJkcm9wRXZlbnQiLCJoYW5kbGVycyIsImlzVGV4dGJsb2NrIiwicmVzb2x2ZWRGcm9tIiwicmVzb2x2ZWRUbyIsIm1pbiIsInNpemUiLCJ0ZXh0VG9NYXRjaCIsInRleHRCZXR3ZWVuIiwic3RhcnQiLCJtYXBwaW5nIiwic3VjY2VzcyIsInRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IiLCJjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50IiwiQ2xpcGJvYXJkRXZlbnQiLCJjbGlwYm9hcmREYXRhIiwiRGF0YVRyYW5zZmVyIiwic2V0RGF0YSIsInBhc3RlUnVsZXNQbHVnaW4iLCJkcmFnU291cmNlRWxlbWVudCIsImlzUGFzdGVkRnJvbVByb3NlTWlycm9yIiwiaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yIiwiRHJhZ0V2ZW50IiwicHJvY2Vzc0V2ZW50IiwicGFzdGVFdnQiLCJjaGFpbmFibGVTdGF0ZSIsImIiLCJoYW5kbGVEcmFnc3RhcnQiLCJkb20iLCJwYXJlbnRFbGVtZW50IiwiY29udGFpbnMiLCJoYW5kbGVEcmFnZW5kIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZHJvcCIsImRyYWdGcm9tT3RoZXJFZGl0b3IiLCJkZWxldGVSYW5nZSIsInBhc3RlIiwiX3ZpZXciLCJodG1sIiwiZ2V0RGF0YSIsImFwcGVuZFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25zIiwib2xkU3RhdGUiLCJpc1Bhc3RlIiwiaXNEcm9wIiwic2ltdWxhdGVkUGFzdGVNZXRhIiwiaXNTaW11bGF0ZWRQYXN0ZSIsImZpbmREaWZmU3RhcnQiLCJmaW5kRGlmZkVuZCIsImZpbmREdXBsaWNhdGVzIiwiZmlsdGVyZWQiLCJlbCIsImluZGV4T2YiLCJTZXQiLCJFeHRlbnNpb25NYW5hZ2VyIiwic3BsaXR0YWJsZU1hcmtzIiwic2V0dXBFeHRlbnNpb25zIiwicmVzb2x2ZWRFeHRlbnNpb25zIiwic29ydCIsImZsYXR0ZW4iLCJkdXBsaWNhdGVkTmFtZXMiLCJhZGRFeHRlbnNpb25zIiwiZmxhdCIsImRlZmF1bHRQcmlvcml0eSIsImEiLCJwcmlvcml0eUEiLCJwcmlvcml0eUIiLCJhZGRDb21tYW5kcyIsInJldmVyc2UiLCJpbnB1dFJ1bGVzIiwicGFzdGVSdWxlcyIsImFsbFBsdWdpbnMiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImRlZmF1bHRCaW5kaW5ncyIsIkFycm93UmlnaHQiLCJiaW5kaW5ncyIsInNob3J0Y3V0Iiwia2V5TWFwUGx1Z2luIiwiYWRkSW5wdXRSdWxlcyIsImVuYWJsZUlucHV0UnVsZXMiLCJhZGRQYXN0ZVJ1bGVzIiwiZW5hYmxlUGFzdGVSdWxlcyIsImFkZFByb3NlTWlycm9yUGx1Z2lucyIsInByb3NlTWlycm9yUGx1Z2lucyIsIm5vZGVWaWV3cyIsImFkZE5vZGVWaWV3Iiwibm9kZXZpZXciLCJnZXRQb3MiLCJkZWNvcmF0aW9ucyIsImlubmVyRGVjb3JhdGlvbnMiLCJleHRlbnNpb25TdG9yYWdlIiwib25CZWZvcmVDcmVhdGUiLCJvbkNyZWF0ZSIsIm9uVXBkYXRlIiwib25TZWxlY3Rpb25VcGRhdGUiLCJvblRyYW5zYWN0aW9uIiwib25Gb2N1cyIsIm9uQmx1ciIsIm9uRGVzdHJveSIsIkV4dGVuc2lvbiIsImdldFRleHRCZXR3ZWVuIiwic3RhcnROb2RlIiwiYmxvY2tTZXBhcmF0b3IiLCJ0ZXh0U2VyaWFsaXplcnMiLCJpc0Jsb2NrIiwidGV4dFNlcmlhbGl6ZXIiLCJnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hIiwiQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIiLCJjbGlwYm9hcmRUZXh0U2VyaWFsaXplciIsInJhbmdlcyIsIiR0byIsImJsdXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJpc0Rlc3Ryb3llZCIsImdldFNlbGVjdGlvbiIsInJlbW92ZUFsbFJhbmdlcyIsImNsZWFyQ29udGVudCIsImVtaXRVcGRhdGUiLCJzZXRDb250ZW50IiwiY2xlYXJOb2RlcyIsIiRtYXBwZWRGcm9tIiwiJG1hcHBlZFRvIiwibm9kZVNpemUiLCJub2RlUmFuZ2UiLCJibG9ja1JhbmdlIiwidGFyZ2V0TGlmdERlcHRoIiwiZGVmYXVsdFR5cGUiLCJjb250ZW50TWF0Y2hBdCIsInNldE5vZGVNYXJrdXAiLCJjdXQiLCJvcmlnaW5SYW5nZSIsInRhcmdldFBvcyIsImNvbnRlbnRTbGljZSIsIm5ld1BvcyIsImluc2VydCIsInNldFNlbGVjdGlvbiIsImRlbGV0ZUN1cnJlbnROb2RlIiwiY3VycmVudE5vZGUiLCIkYW5jaG9yIiwiJHBvcyIsImRlcHRoIiwiYmVmb3JlIiwiYWZ0ZXIiLCJkZWxldGUiLCJzY3JvbGxJbnRvVmlldyIsImRlbGV0ZU5vZGUiLCJ0eXBlT3JOYW1lIiwiZW50ZXIiLCJrZXlib2FyZFNob3J0Y3V0Iiwib2JqZWN0SW5jbHVkZXMiLCJvYmplY3QxIiwib2JqZWN0MiIsInN0cmljdCIsInRlc3QiLCJmaW5kTWFya0luU2V0IiwiayIsImlzTWFya0luU2V0IiwiZ2V0TWFya1JhbmdlIiwiY2hpbGRBZnRlciIsImNoaWxkQmVmb3JlIiwic3RhcnRJbmRleCIsInN0YXJ0UG9zIiwib2Zmc2V0IiwiZW5kSW5kZXgiLCJlbmRQb3MiLCJjaGlsZENvdW50IiwiZ2V0TWFya1R5cGUiLCJleHRlbmRNYXJrUmFuZ2UiLCJuZXdTZWxlY3Rpb24iLCJmaXJzdCIsImkiLCJpc1RleHRTZWxlY3Rpb24iLCJtaW5NYXgiLCJyZXNvbHZlRm9jdXNQb3NpdGlvbiIsInBvc2l0aW9uIiwic2VsZWN0aW9uQXRTdGFydCIsImF0U3RhcnQiLCJzZWxlY3Rpb25BdEVuZCIsImF0RW5kIiwibWluUG9zIiwibWF4UG9zIiwiaXNBbmRyb2lkIiwibmF2aWdhdG9yIiwicGxhdGZvcm0iLCJ1c2VyQWdlbnQiLCJpc2lPUyIsImZvY3VzIiwiZGVsYXllZEZvY3VzIiwiaGFzRm9jdXMiLCJpc1NhbWVTZWxlY3Rpb24iLCJlcSIsInNldFN0b3JlZE1hcmtzIiwiaW5zZXJ0Q29udGVudCIsImluc2VydENvbnRlbnRBdCIsInJlbW92ZVdoaXRlc3BhY2VzIiwiY2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwibm9kZVR5cGUiLCJub2RlVmFsdWUiLCJyZW1vdmVDaGlsZCIsImVsZW1lbnRGcm9tU3RyaW5nIiwid3JhcHBlZFZhbHVlIiwicGFyc2VGcm9tU3RyaW5nIiwiYm9keSIsImNyZWF0ZU5vZGVGcm9tQ29udGVudCIsInBhcnNlT3B0aW9ucyIsImlzSlNPTkNvbnRlbnQiLCJpc1RleHRDb250ZW50IiwiaXNBcnJheUNvbnRlbnQiLCJmcm9tQXJyYXkiLCJub2RlRnJvbUpTT04iLCJlcnJvck9uSW52YWxpZENvbnRlbnQiLCJjaGVjayIsImVycm9yIiwiY2F1c2UiLCJoYXNJbnZhbGlkQ29udGVudCIsImludmFsaWRDb250ZW50IiwiY29udGVudENoZWNrU2NoZW1hIiwiYXBwZW5kIiwiX190aXB0YXBfX3ByaXZhdGVfX3Vua25vd25fX2NhdGNoX19hbGxfX25vZGUiLCJ0YWciLCJvdXRlckhUTUwiLCJwYXJzZVNsaWNlIiwicGFyc2UiLCJwYXJzZXIiLCJzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCIsInN0YXJ0TGVuIiwiYmlhcyIsImxhc3QiLCJzdGVwIiwibWFwcyIsIl9mcm9tIiwiX3RvIiwiX25ld0Zyb20iLCJuZXdUbyIsIm5lYXIiLCJpc0ZyYWdtZW50Iiwibm9kZU9yRnJhZ21lbnQiLCJ1cGRhdGVTZWxlY3Rpb24iLCJhcHBseUlucHV0UnVsZXMiLCJhcHBseVBhc3RlUnVsZXMiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJlbmFibGVDb250ZW50Q2hlY2siLCJkaXNhYmxlQ29sbGFib3JhdGlvbiIsImNvbGxhYm9yYXRpb24iLCJpc0Rpc2FibGVkIiwiaXNPbmx5VGV4dENvbnRlbnQiLCJpc09ubHlCbG9ja0NvbnRlbnQiLCJpc0VtcHR5VGV4dEJsb2NrIiwibmV3Q29udGVudCIsInYiLCJqb2luSXRlbUJhY2t3YXJkIiwicG9pbnQiLCJqb2luSXRlbUZvcndhcmQiLCJpc01hY09TIiwibm9ybWFsaXplS2V5TmFtZSIsInBhcnRzIiwiYWx0IiwiY3RybCIsInNoaWZ0IiwibWV0YSIsIm1vZCIsIktleWJvYXJkRXZlbnQiLCJhbHRLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjYXB0dXJlZFRyYW5zYWN0aW9uIiwiY2FwdHVyZVRyYW5zYWN0aW9uIiwic29tZVByb3AiLCJmIiwibmV3U3RlcCIsIm1heWJlU3RlcCIsImlzTm9kZUFjdGl2ZSIsImVtcHR5Iiwibm9kZVJhbmdlcyIsInJlbGF0aXZlRnJvbSIsInJlbGF0aXZlVG8iLCJzZWxlY3Rpb25SYW5nZSIsIm1hdGNoZWROb2RlUmFuZ2VzIiwic3VtIiwiaXNBY3RpdmUiLCJnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSIsImRlbGV0ZVByb3BzIiwib2JqIiwicHJvcE9yUHJvcHMiLCJuZXdPYmoiLCJwcm9wIiwicmVzZXRBdHRyaWJ1dGVzIiwibWFya1R5cGUiLCJzY2hlbWFUeXBlIiwiYWRkTWFyayIsInNlbGVjdEFsbCIsImNyZWF0ZURvY3VtZW50IiwiZ2V0TWFya0F0dHJpYnV0ZXMiLCIkaGVhZCIsIm1hcmtJdGVtIiwiY29tYmluZVRyYW5zYWN0aW9uU3RlcHMiLCJvbGREb2MiLCJkZWZhdWx0QmxvY2tBdCIsImVkZ2VDb3VudCIsImVkZ2UiLCJoYXNSZXF1aXJlZEF0dHJzIiwiZmluZENoaWxkcmVuIiwicHJlZGljYXRlIiwibm9kZXNXaXRoUG9zIiwiZGVzY2VuZGFudHMiLCJmaW5kQ2hpbGRyZW5JblJhbmdlIiwiZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MiLCJmaW5kUGFyZW50Tm9kZSIsImdldFNjaGVtYSIsImdlbmVyYXRlSFRNTCIsImNvbnRlbnROb2RlIiwiZnJvbUpTT04iLCJnZW5lcmF0ZUpTT04iLCJnZXRUZXh0IiwiZ2VuZXJhdGVUZXh0IiwiZ2V0Tm9kZUF0dHJpYnV0ZXMiLCJub2RlSXRlbSIsImdldEF0dHJpYnV0ZXMiLCJyZW1vdmVEdXBsaWNhdGVzIiwiYXJyYXkiLCJieSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZWVuIiwiaGFzT3duUHJvcGVydHkiLCJzaW1wbGlmeUNoYW5nZWRSYW5nZXMiLCJjaGFuZ2VzIiwidW5pcXVlQ2hhbmdlcyIsImNoYW5nZSIsInJlc3QiLCJfIiwib3RoZXJDaGFuZ2UiLCJvbGRSYW5nZSIsIm5ld1JhbmdlIiwiZ2V0Q2hhbmdlZFJhbmdlcyIsInN0ZXBNYXAiLCJuZXdTdGFydCIsIm5ld0VuZCIsIm9sZFN0YXJ0IiwiaW52ZXJ0Iiwib2xkRW5kIiwiZ2V0RGVidWdKU09OIiwic3RhcnRPZmZzZXQiLCJpc1RvcE5vZGUiLCJ0b3BOb2RlVHlwZSIsImluY3JlbWVudCIsImdldE1hcmtzQmV0d2VlbiIsImdldE5vZGVBdFBvc2l0aW9uIiwibWF4RGVwdGgiLCJjdXJyZW50RGVwdGgiLCJnZXRTcGxpdHRlZEF0dHJpYnV0ZXMiLCJ0eXBlTmFtZSIsImlzTWFya0FjdGl2ZSIsIm1hcmtSYW5nZXMiLCJtYXRjaGVkUmFuZ2UiLCJtYXJrUmFuZ2UiLCJleGNsdWRlZFJhbmdlIiwiaXNBdEVuZE9mTm9kZSIsInBhcmVudE5vZGUiLCIkcGFyZW50UG9zIiwiaXNBdFN0YXJ0T2ZOb2RlIiwiaXNMaXN0IiwiaXNOb2RlRW1wdHkiLCJjaGVja0NoaWxkcmVuIiwiaWdub3JlV2hpdGVzcGFjZSIsImlzTGVhZiIsImlzQ29udGVudEVtcHR5IiwiY2hpbGROb2RlIiwiaXNOb2RlU2VsZWN0aW9uIiwicG9zVG9ET01SZWN0IiwicmVzb2x2ZWRFbmQiLCJjb29yZHNBdFBvcyIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsIndpZHRoIiwiaGVpZ2h0IiwieCIsInkiLCJyZXdyaXRlVW5rbm93bkNvbnRlbnRJbm5lciIsImpzb24iLCJ2YWxpZE1hcmtzIiwidmFsaWROb2RlcyIsInJld3JpdHRlbkNvbnRlbnQiLCJoYXMiLCJvcmlnaW5hbCIsInVuc3VwcG9ydGVkIiwiZmFsbGJhY2tUb1BhcmFncmFwaCIsInJld3JpdGVVbmtub3duQ29udGVudCIsImNhblNldE1hcmsiLCJuZXdNYXJrVHlwZSIsImN1cnNvciIsImlzSW5TZXQiLCJzb21lTm9kZVN1cHBvcnRzTWFyayIsImlubGluZUNvbnRlbnQiLCJhbGxvd3NNYXJrVHlwZSIsIl9wb3MiLCJpc0lubGluZSIsInBhcmVudEFsbG93c01hcmtUeXBlIiwiY3VycmVudE1hcmtzQWxsb3dNYXJrVHlwZSIsIm90aGVyTWFyayIsInNldE1hcmsiLCJhZGRTdG9yZWRNYXJrIiwidHJpbW1lZEZyb20iLCJ0cmltbWVkVG8iLCJzb21lSGFzTWFyayIsInNldE5vZGUiLCJhdHRyaWJ1dGVzVG9Db3B5Iiwic2FtZVBhcmVudCIsImNhblNldEJsb2NrIiwidXBkYXRlZFN0YXRlIiwic2V0Tm9kZVNlbGVjdGlvbiIsInNldFRleHRTZWxlY3Rpb24iLCJlbnN1cmVNYXJrcyIsImZpbHRlcmVkTWFya3MiLCJzcGxpdEJsb2NrIiwia2VlcE1hcmtzIiwiZGVmbHQiLCJpbmRleEFmdGVyIiwiJGZpcnN0IiwiY2FuUmVwbGFjZVdpdGgiLCJzcGxpdExpc3RJdGVtIiwib3ZlcnJpZGVBdHRycyIsImdyYW5kUGFyZW50Iiwid3JhcCIsImRlcHRoQmVmb3JlIiwiZCIsImNvcHkiLCJkZXB0aEFmdGVyIiwibmV3TmV4dFR5cGVBdHRyaWJ1dGVzIiwibmV4dFR5cGUiLCJjb250ZW50TWF0Y2giLCJjcmVhdGVBbmRGaWxsIiwicmVwbGFjZSIsInNlbCIsIm4iLCJuZXdUeXBlQXR0cmlidXRlcyIsImpvaW5MaXN0QmFja3dhcmRzIiwibGlzdFR5cGUiLCJsaXN0Iiwibm9kZUF0IiwiY2FuSm9pbkJhY2t3YXJkcyIsImpvaW5MaXN0Rm9yd2FyZHMiLCJjYW5Kb2luRm9yd2FyZHMiLCJ0b2dnbGVMaXN0IiwibGlzdFR5cGVPck5hbWUiLCJpdGVtVHlwZU9yTmFtZSIsIml0ZW1UeXBlIiwicGFyZW50TGlzdCIsInZhbGlkQ29udGVudCIsImNhbldyYXBJbkxpc3QiLCJ0b2dnbGVNYXJrIiwiZXh0ZW5kRW1wdHlNYXJrUmFuZ2UiLCJ1bnNldE1hcmsiLCJ0b2dnbGVOb2RlIiwidG9nZ2xlVHlwZU9yTmFtZSIsInRvZ2dsZVR5cGUiLCJ0b2dnbGVXcmFwIiwidW5kb0lucHV0UnVsZSIsInVuZG9hYmxlIiwiZ2V0U3RhdGUiLCJ0b1VuZG8iLCJqIiwiZG9jcyIsInVuc2V0QWxsTWFya3MiLCJ1cGRhdGVBdHRyaWJ1dGVzIiwibGFzdFBvcyIsImxhc3ROb2RlIiwidHJpbW1lZEZyb20yIiwidHJpbW1lZFRvMiIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsIkNvbW1hbmRzIiwiRHJvcCIsImhhbmRsZURyb3AiLCJtb3ZlZCIsIkVkaXRhYmxlIiwiZWRpdGFibGUiLCJmb2N1c0V2ZW50c1BsdWdpbktleSIsIkZvY3VzRXZlbnRzIiwiaXNGb2N1c2VkIiwiS2V5bWFwIiwiaGFuZGxlQmFja3NwYWNlIiwicGFyZW50SXNJc29sYXRpbmciLCJwYXJlbnRQb3MiLCJpc0F0U3RhcnQiLCJoYW5kbGVEZWxldGUiLCJoYW5kbGVFbnRlciIsImJhc2VLZXltYXAiLCJFbnRlciIsIkJhY2tzcGFjZSIsIkRlbGV0ZSIsInBjS2V5bWFwIiwibWFjS2V5bWFwIiwibmV3U3RhdGUiLCJkb2NDaGFuZ2VzIiwiaWdub3JlVHIiLCJhbGxGcm9tIiwiYWxsRW5kIiwiYWxsV2FzU2VsZWN0ZWQiLCJpc0VtcHR5IiwiUGFzdGUiLCJoYW5kbGVQYXN0ZSIsIlRhYmluZGV4IiwiaXNFZGl0YWJsZSIsInRhYmluZGV4IiwiTm9kZVBvcyIsImFjdHVhbERlcHRoIiwicmVzb2x2ZWRQb3MiLCJlbGVtZW50IiwiZG9tQXRQb3MiLCJpc05vblRleHRBdG9tIiwiY2hpbGROb2RlUG9zIiwiZmlyc3RDaGlsZCIsImxhc3RDaGlsZCIsImNsb3Nlc3QiLCJzZWxlY3RvciIsIm5vZGVBdHRyaWJ1dGVzIiwiYXR0cktleXMiLCJxdWVyeVNlbGVjdG9yIiwicXVlcnlTZWxlY3RvckFsbCIsImZpcnN0SXRlbU9ubHkiLCJjaGlsZFBvcyIsImRvZXNBbGxBdHRyaWJ1dGVzTWF0Y2giLCJjb25jYXQiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVTdHlsZVRhZyIsIm5vbmNlIiwic3VmZml4IiwidGlwdGFwU3R5bGVUYWciLCJzdHlsZU5vZGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIkVkaXRvciIsImlzSW5pdGlhbGl6ZWQiLCJpbmplY3RDU1MiLCJpbmplY3ROb25jZSIsImF1dG9mb2N1cyIsImVkaXRvclByb3BzIiwiY29yZUV4dGVuc2lvbk9wdGlvbnMiLCJlbmFibGVDb3JlRXh0ZW5zaW9ucyIsIm9uQ29udGVudEVycm9yIiwib25QYXN0ZSIsIm9uRHJvcCIsImlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24iLCJzZXRPcHRpb25zIiwiY3JlYXRlRXh0ZW5zaW9uTWFuYWdlciIsImNyZWF0ZUNvbW1hbmRNYW5hZ2VyIiwiY3JlYXRlU2NoZW1hIiwiY3JlYXRlVmlldyIsImNvbW1hbmRNYW5hZ2VyIiwiY3NzIiwic2V0UHJvcHMiLCJ1cGRhdGVTdGF0ZSIsInNldEVkaXRhYmxlIiwicmVnaXN0ZXJQbHVnaW4iLCJoYW5kbGVQbHVnaW5zIiwidW5yZWdpc3RlclBsdWdpbiIsIm5hbWVPclBsdWdpbktleVRvUmVtb3ZlIiwicHJldlBsdWdpbnMiLCJuYW1lT3JQbHVnaW5LZXkiLCJzdGFydHNXaXRoIiwiY29yZUV4dGVuc2lvbnMiLCJleHQiLCJhbGxFeHRlbnNpb25zIiwibWVzc2FnZSIsInJvbGUiLCJkaXNwYXRjaFRyYW5zYWN0aW9uIiwiY3JlYXRlTm9kZVZpZXdzIiwicHJlcGVuZENsYXNzIiwiY2xhc3NOYW1lIiwic2VsZWN0aW9uSGFzQ2hhbmdlZCIsIm5leHRTdGF0ZSIsIm5hbWVPckF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzT3JVbmRlZmluZWQiLCJnZXRKU09OIiwiZ2V0SFRNTCIsImdldENoYXJhY3RlckNvdW50IiwiZG9jVmlldyIsIiRub2RlIiwiJGRvYyIsIiRub2RlcyIsIm1hcmtJbnB1dFJ1bGUiLCJjYXB0dXJlR3JvdXAiLCJmdWxsTWF0Y2giLCJzdGFydFNwYWNlcyIsInNlYXJjaCIsInRleHRTdGFydCIsInRleHRFbmQiLCJleGNsdWRlZE1hcmtzIiwiZXhjbHVkZWQiLCJtYXJrRW5kIiwibm9kZUlucHV0UnVsZSIsIm5ld05vZGUiLCJsYXN0SW5kZXhPZiIsIm1hdGNoU3RhcnQiLCJsYXN0Q2hhciIsImluc2VydGlvblN0YXJ0IiwidGV4dGJsb2NrVHlwZUlucHV0UnVsZSIsIiRzdGFydCIsInRleHRJbnB1dFJ1bGUiLCJjdXRPZmYiLCJ3cmFwcGluZ0lucHV0UnVsZSIsIndyYXBwaW5nIiwia2VlcEF0dHJpYnV0ZXMiLCJqb2luUHJlZGljYXRlIiwiTm9kZVZpZXciLCJjb21wb25lbnQiLCJpc0RyYWdnaW5nIiwic3RvcEV2ZW50IiwiaWdub3JlTXV0YXRpb24iLCJtb3VudCIsImNvbnRlbnRET00iLCJvbkRyYWdTdGFydCIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJkcmFnSGFuZGxlIiwiZG9tQm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaGFuZGxlQm94Iiwib2Zmc2V0WCIsIm5hdGl2ZUV2ZW50Iiwib2Zmc2V0WSIsImNsb25lZE5vZGUiLCJjbG9uZU5vZGUiLCJkYXRhVHJhbnNmZXIiLCJzZXREcmFnSW1hZ2UiLCJpc0luRWxlbWVudCIsImlzRHJhZ0V2ZW50IiwiaXNEcm9wRXZlbnQiLCJpc0lucHV0IiwidGFnTmFtZSIsImlzQ29udGVudEVkaXRhYmxlIiwiaXNEcmFnZ2FibGUiLCJpc1NlbGVjdGFibGUiLCJpc0NvcHlFdmVudCIsImlzUGFzdGVFdmVudCIsImlzQ3V0RXZlbnQiLCJpc0NsaWNrRXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImlzVmFsaWREcmFnSGFuZGxlIiwibXV0YXRpb24iLCJjaGFuZ2VkTm9kZXMiLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwibWFya1Bhc3RlUnVsZSIsImVzY2FwZUZvclJlZ0V4Iiwic3RyaW5nIiwiaXNTdHJpbmciLCJub2RlUGFzdGVSdWxlIiwiZ2V0Q29udGVudCIsInRleHRQYXN0ZVJ1bGUiLCJUcmFja2VyIiwiY3VycmVudFN0ZXAiLCJkZWxldGVkIiwibWFwcGVkUG9zaXRpb24iLCJuZXdQb3NpdGlvbiIsIm1hcFJlc3VsdCIsImdldE1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-blockquote/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blockquote: () => (/* binding */ Blockquote),\n/* harmony export */   \"default\": () => (/* binding */ Blockquote),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * Matches a blockquote to a `>` as input.\n */ const inputRegex = /^\\s*>\\s$/;\n/**\n * This extension allows you to create blockquotes.\n * @see https://tiptap.dev/api/nodes/blockquote\n */ const Blockquote = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"blockquote\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    content: \"block+\",\n    group: \"block\",\n    defining: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"blockquote\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"blockquote\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setBlockquote: ()=>({ commands })=>{\n                    return commands.wrapIn(this.name);\n                },\n            toggleBlockquote: ()=>({ commands })=>{\n                    return commands.toggleWrap(this.name);\n                },\n            unsetBlockquote: ()=>({ commands })=>{\n                    return commands.lift(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-b\": ()=>this.editor.commands.toggleBlockquote()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0U7QUFFeEU7O0NBRUMsR0FDRCxNQUFNRyxhQUFhO0FBQ25COzs7Q0FHQyxHQUNELE1BQU1DLGFBQWFKLDhDQUFJQSxDQUFDSyxNQUFNLENBQUM7SUFDM0JDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLFVBQVU7SUFDVkM7UUFDSSxPQUFPO1lBQ0g7Z0JBQUVDLEtBQUs7WUFBYTtTQUN2QjtJQUNMO0lBQ0FDLFlBQVcsRUFBRU4sY0FBYyxFQUFFO1FBQ3pCLE9BQU87WUFBQztZQUFjUCw2REFBZUEsQ0FBQyxJQUFJLENBQUNjLE9BQU8sQ0FBQ1AsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQzFGO0lBQ0FRO1FBQ0ksT0FBTztZQUNIQyxlQUFlLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQzlCLE9BQU9BLFNBQVNDLE1BQU0sQ0FBQyxJQUFJLENBQUNiLElBQUk7Z0JBQ3BDO1lBQ0FjLGtCQUFrQixJQUFNLENBQUMsRUFBRUYsUUFBUSxFQUFFO29CQUNqQyxPQUFPQSxTQUFTRyxVQUFVLENBQUMsSUFBSSxDQUFDZixJQUFJO2dCQUN4QztZQUNBZ0IsaUJBQWlCLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQ2hDLE9BQU9BLFNBQVNLLElBQUksQ0FBQyxJQUFJLENBQUNqQixJQUFJO2dCQUNsQztRQUNKO0lBQ0o7SUFDQWtCO1FBQ0ksT0FBTztZQUNILGVBQWUsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxnQkFBZ0I7UUFDOUQ7SUFDSjtJQUNBTTtRQUNJLE9BQU87WUFDSHhCLCtEQUFpQkEsQ0FBQztnQkFDZHlCLE1BQU14QjtnQkFDTnlCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1NBQ0g7SUFDTDtBQUNKO0FBRXlELENBQ3pELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZS9kaXN0L2luZGV4LmpzP2UxYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzLCB3cmFwcGluZ0lucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogTWF0Y2hlcyBhIGJsb2NrcXVvdGUgdG8gYSBgPmAgYXMgaW5wdXQuXG4gKi9cbmNvbnN0IGlucHV0UmVnZXggPSAvXlxccyo+XFxzJC87XG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIGJsb2NrcXVvdGVzLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL25vZGVzL2Jsb2NrcXVvdGVcbiAqL1xuY29uc3QgQmxvY2txdW90ZSA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAnYmxvY2txdW90ZScsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbnRlbnQ6ICdibG9jaysnLFxuICAgIGdyb3VwOiAnYmxvY2snLFxuICAgIGRlZmluaW5nOiB0cnVlLFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdGFnOiAnYmxvY2txdW90ZScgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ2Jsb2NrcXVvdGUnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLndyYXBJbih0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZUJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlV3JhcCh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2V0QmxvY2txdW90ZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLVNoaWZ0LWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCbG9ja3F1b3RlKCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBCbG9ja3F1b3RlLCBCbG9ja3F1b3RlIGFzIGRlZmF1bHQsIGlucHV0UmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJtZXJnZUF0dHJpYnV0ZXMiLCJ3cmFwcGluZ0lucHV0UnVsZSIsImlucHV0UmVnZXgiLCJCbG9ja3F1b3RlIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsImNvbnRlbnQiLCJncm91cCIsImRlZmluaW5nIiwicGFyc2VIVE1MIiwidGFnIiwicmVuZGVySFRNTCIsIm9wdGlvbnMiLCJhZGRDb21tYW5kcyIsInNldEJsb2NrcXVvdGUiLCJjb21tYW5kcyIsIndyYXBJbiIsInRvZ2dsZUJsb2NrcXVvdGUiLCJ0b2dnbGVXcmFwIiwidW5zZXRCbG9ja3F1b3RlIiwibGlmdCIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiZWRpdG9yIiwiYWRkSW5wdXRSdWxlcyIsImZpbmQiLCJ0eXBlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-bold/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bold: () => (/* binding */ Bold),\n/* harmony export */   \"default\": () => (/* binding */ Bold),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * Matches bold text via `**` as input.\n */ const starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/;\n/**\n * Matches bold text via `**` while pasting.\n */ const starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g;\n/**\n * Matches bold text via `__` as input.\n */ const underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/;\n/**\n * Matches bold text via `__` while pasting.\n */ const underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g;\n/**\n * This extension allows you to mark text as bold.\n * @see https://tiptap.dev/api/marks/bold\n */ const Bold = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"bold\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"strong\"\n            },\n            {\n                tag: \"b\",\n                getAttrs: (node)=>node.style.fontWeight !== \"normal\" && null\n            },\n            {\n                style: \"font-weight=400\",\n                clearMark: (mark)=>mark.type.name === this.name\n            },\n            {\n                style: \"font-weight\",\n                getAttrs: (value)=>/^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"strong\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setBold: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleBold: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetBold: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-b\": ()=>this.editor.commands.toggleBold(),\n            \"Mod-B\": ()=>this.editor.commands.toggleBold()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: starInputRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: underscoreInputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: starPasteRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: underscorePasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYm9sZC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUY7QUFFbkY7O0NBRUMsR0FDRCxNQUFNSSxpQkFBaUI7QUFDdkI7O0NBRUMsR0FDRCxNQUFNQyxpQkFBaUI7QUFDdkI7O0NBRUMsR0FDRCxNQUFNQyx1QkFBdUI7QUFDN0I7O0NBRUMsR0FDRCxNQUFNQyx1QkFBdUI7QUFDN0I7OztDQUdDLEdBQ0QsTUFBTUMsT0FBT1IsOENBQUlBLENBQUNTLE1BQU0sQ0FBQztJQUNyQkMsTUFBTTtJQUNOQztRQUNJLE9BQU87WUFDSEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQztRQUNJLE9BQU87WUFDSDtnQkFDSUMsS0FBSztZQUNUO1lBQ0E7Z0JBQ0lBLEtBQUs7Z0JBQ0xDLFVBQVVDLENBQUFBLE9BQVFBLEtBQUtDLEtBQUssQ0FBQ0MsVUFBVSxLQUFLLFlBQVk7WUFDNUQ7WUFDQTtnQkFDSUQsT0FBTztnQkFDUEUsV0FBV0MsQ0FBQUEsT0FBUUEsS0FBS0MsSUFBSSxDQUFDWCxJQUFJLEtBQUssSUFBSSxDQUFDQSxJQUFJO1lBQ25EO1lBQ0E7Z0JBQ0lPLE9BQU87Z0JBQ1BGLFVBQVVPLENBQUFBLFFBQVMsNEJBQTRCQyxJQUFJLENBQUNELFVBQVU7WUFDbEU7U0FDSDtJQUNMO0lBQ0FFLFlBQVcsRUFBRVosY0FBYyxFQUFFO1FBQ3pCLE9BQU87WUFBQztZQUFVWCw2REFBZUEsQ0FBQyxJQUFJLENBQUN3QixPQUFPLENBQUNiLGNBQWMsRUFBRUE7WUFBaUI7U0FBRTtJQUN0RjtJQUNBYztRQUNJLE9BQU87WUFDSEMsU0FBUyxJQUFNLENBQUMsRUFBRUMsUUFBUSxFQUFFO29CQUN4QixPQUFPQSxTQUFTQyxPQUFPLENBQUMsSUFBSSxDQUFDbkIsSUFBSTtnQkFDckM7WUFDQW9CLFlBQVksSUFBTSxDQUFDLEVBQUVGLFFBQVEsRUFBRTtvQkFDM0IsT0FBT0EsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQ3JCLElBQUk7Z0JBQ3hDO1lBQ0FzQixXQUFXLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQzFCLE9BQU9BLFNBQVNLLFNBQVMsQ0FBQyxJQUFJLENBQUN2QixJQUFJO2dCQUN2QztRQUNKO0lBQ0o7SUFDQXdCO1FBQ0ksT0FBTztZQUNILFNBQVMsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxVQUFVO1lBQzlDLFNBQVMsSUFBTSxJQUFJLENBQUNLLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxVQUFVO1FBQ2xEO0lBQ0o7SUFDQU07UUFDSSxPQUFPO1lBQ0hsQywyREFBYUEsQ0FBQztnQkFDVm1DLE1BQU1qQztnQkFDTmlCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1lBQ0FuQiwyREFBYUEsQ0FBQztnQkFDVm1DLE1BQU0vQjtnQkFDTmUsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7U0FDSDtJQUNMO0lBQ0FpQjtRQUNJLE9BQU87WUFDSG5DLDJEQUFhQSxDQUFDO2dCQUNWa0MsTUFBTWhDO2dCQUNOZ0IsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7WUFDQWxCLDJEQUFhQSxDQUFDO2dCQUNWa0MsTUFBTTlCO2dCQUNOYyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtTQUNIO0lBQ0w7QUFDSjtBQUU2RyxDQUM3RyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJvbGQvZGlzdC9pbmRleC5qcz9kZjY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogTWF0Y2hlcyBib2xkIHRleHQgdmlhIGAqKmAgYXMgaW5wdXQuXG4gKi9cbmNvbnN0IHN0YXJJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShcXCpcXCooPyFcXHMrXFwqXFwqKSgoPzpbXipdKykpXFwqXFwqKD8hXFxzK1xcKlxcKikpJC87XG4vKipcbiAqIE1hdGNoZXMgYm9sZCB0ZXh0IHZpYSBgKipgIHdoaWxlIHBhc3RpbmcuXG4gKi9cbmNvbnN0IHN0YXJQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKShcXCpcXCooPyFcXHMrXFwqXFwqKSgoPzpbXipdKykpXFwqXFwqKD8hXFxzK1xcKlxcKikpL2c7XG4vKipcbiAqIE1hdGNoZXMgYm9sZCB0ZXh0IHZpYSBgX19gIGFzIGlucHV0LlxuICovXG5jb25zdCB1bmRlcnNjb3JlSW5wdXRSZWdleCA9IC8oPzpefFxccykoX18oPyFcXHMrX18pKCg/OlteX10rKSlfXyg/IVxccytfXykpJC87XG4vKipcbiAqIE1hdGNoZXMgYm9sZCB0ZXh0IHZpYSBgX19gIHdoaWxlIHBhc3RpbmcuXG4gKi9cbmNvbnN0IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKShfXyg/IVxccytfXykoKD86W15fXSspKV9fKD8hXFxzK19fKSkvZztcbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBtYXJrIHRleHQgYXMgYm9sZC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9tYXJrcy9ib2xkXG4gKi9cbmNvbnN0IEJvbGQgPSBNYXJrLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2JvbGQnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnc3Ryb25nJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnYicsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IG5vZGUgPT4gbm9kZS5zdHlsZS5mb250V2VpZ2h0ICE9PSAnbm9ybWFsJyAmJiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2ZvbnQtd2VpZ2h0PTQwMCcsXG4gICAgICAgICAgICAgICAgY2xlYXJNYXJrOiBtYXJrID0+IG1hcmsudHlwZS5uYW1lID09PSB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0eWxlOiAnZm9udC13ZWlnaHQnLFxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiB2YWx1ZSA9PiAvXihib2xkKGVyKT98WzUtOV1cXGR7Mix9KSQvLnRlc3QodmFsdWUpICYmIG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsnc3Ryb25nJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0Qm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlQm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zZXRCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1iJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQm9sZCgpLFxuICAgICAgICAgICAgJ01vZC1CJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQm9sZCgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHN0YXJJbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogc3RhclBhc3RlUmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiB1bmRlcnNjb3JlUGFzdGVSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEJvbGQsIEJvbGQgYXMgZGVmYXVsdCwgc3RhcklucHV0UmVnZXgsIHN0YXJQYXN0ZVJlZ2V4LCB1bmRlcnNjb3JlSW5wdXRSZWdleCwgdW5kZXJzY29yZVBhc3RlUmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk1hcmsiLCJtZXJnZUF0dHJpYnV0ZXMiLCJtYXJrSW5wdXRSdWxlIiwibWFya1Bhc3RlUnVsZSIsInN0YXJJbnB1dFJlZ2V4Iiwic3RhclBhc3RlUmVnZXgiLCJ1bmRlcnNjb3JlSW5wdXRSZWdleCIsInVuZGVyc2NvcmVQYXN0ZVJlZ2V4IiwiQm9sZCIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiSFRNTEF0dHJpYnV0ZXMiLCJwYXJzZUhUTUwiLCJ0YWciLCJnZXRBdHRycyIsIm5vZGUiLCJzdHlsZSIsImZvbnRXZWlnaHQiLCJjbGVhck1hcmsiLCJtYXJrIiwidHlwZSIsInZhbHVlIiwidGVzdCIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiYWRkQ29tbWFuZHMiLCJzZXRCb2xkIiwiY29tbWFuZHMiLCJzZXRNYXJrIiwidG9nZ2xlQm9sZCIsInRvZ2dsZU1hcmsiLCJ1bnNldEJvbGQiLCJ1bnNldE1hcmsiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwiYWRkUGFzdGVSdWxlcyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bubble-menu/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubbleMenu: () => (/* binding */ BubbleMenu),\n/* harmony export */   BubbleMenuPlugin: () => (/* binding */ BubbleMenuPlugin),\n/* harmony export */   BubbleMenuView: () => (/* binding */ BubbleMenuView),\n/* harmony export */   \"default\": () => (/* binding */ BubbleMenu)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tippy.js */ \"(ssr)/./node_modules/tippy.js/dist/tippy.esm.js\");\n\n\n\nclass BubbleMenuView {\n    constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow }){\n        this.preventHide = false;\n        this.shouldShow = ({ view, state, from, to })=>{\n            const { doc, selection } = state;\n            const { empty } = selection;\n            // Sometime check for `empty` is not enough.\n            // Doubleclick an empty paragraph returns a node size of 2.\n            // So we check also for an empty text size.\n            const isEmptyTextBlock = !doc.textBetween(from, to).length && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isTextSelection)(state.selection);\n            // When clicking on a element inside the bubble menu the editor \"blur\" event\n            // is called and the bubble menu item is focussed. In this case we should\n            // consider the menu as part of the editor and keep showing the menu\n            const isChildOfMenu = this.element.contains(document.activeElement);\n            const hasEditorFocus = view.hasFocus() || isChildOfMenu;\n            if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {\n                return false;\n            }\n            return true;\n        };\n        this.mousedownHandler = ()=>{\n            this.preventHide = true;\n        };\n        this.dragstartHandler = ()=>{\n            this.hide();\n        };\n        this.focusHandler = ()=>{\n            // we use `setTimeout` to make sure `selection` is already updated\n            setTimeout(()=>this.update(this.editor.view));\n        };\n        this.blurHandler = ({ event })=>{\n            var _a;\n            if (this.preventHide) {\n                this.preventHide = false;\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {\n                return;\n            }\n            this.hide();\n        };\n        this.tippyBlurHandler = (event)=>{\n            this.blurHandler({\n                event\n            });\n        };\n        this.handleDebouncedUpdate = (view, oldState)=>{\n            const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n            const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n            if (!selectionChanged && !docChanged) {\n                return;\n            }\n            if (this.updateDebounceTimer) {\n                clearTimeout(this.updateDebounceTimer);\n            }\n            this.updateDebounceTimer = window.setTimeout(()=>{\n                this.updateHandler(view, selectionChanged, docChanged, oldState);\n            }, this.updateDelay);\n        };\n        this.updateHandler = (view, selectionChanged, docChanged, oldState)=>{\n            var _a, _b, _c;\n            const { state, composing } = view;\n            const { selection } = state;\n            const isSame = !selectionChanged && !docChanged;\n            if (composing || isSame) {\n                return;\n            }\n            this.createTooltip();\n            // support for CellSelections\n            const { ranges } = selection;\n            const from = Math.min(...ranges.map((range)=>range.$from.pos));\n            const to = Math.max(...ranges.map((range)=>range.$to.pos));\n            const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n                editor: this.editor,\n                element: this.element,\n                view,\n                state,\n                oldState,\n                from,\n                to\n            });\n            if (!shouldShow) {\n                this.hide();\n                return;\n            }\n            (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n                getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (()=>{\n                    if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(state.selection)) {\n                        let node = view.nodeDOM(from);\n                        if (node) {\n                            const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector(\"[data-node-view-wrapper]\");\n                            if (nodeViewWrapper) {\n                                node = nodeViewWrapper.firstChild;\n                            }\n                            if (node) {\n                                return node.getBoundingClientRect();\n                            }\n                        }\n                    }\n                    return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.posToDOMRect)(view, from, to);\n                })\n            });\n            this.show();\n        };\n        this.editor = editor;\n        this.element = element;\n        this.view = view;\n        this.updateDelay = updateDelay;\n        if (shouldShow) {\n            this.shouldShow = shouldShow;\n        }\n        this.element.addEventListener(\"mousedown\", this.mousedownHandler, {\n            capture: true\n        });\n        this.view.dom.addEventListener(\"dragstart\", this.dragstartHandler);\n        this.editor.on(\"focus\", this.focusHandler);\n        this.editor.on(\"blur\", this.blurHandler);\n        this.tippyOptions = tippyOptions;\n        // Detaches menu content from its current parent\n        this.element.remove();\n        this.element.style.visibility = \"visible\";\n    }\n    createTooltip() {\n        const { element: editorElement } = this.editor.options;\n        const editorIsAttached = !!editorElement.parentElement;\n        if (this.tippy || !editorIsAttached) {\n            return;\n        }\n        this.tippy = (0,tippy_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(editorElement, {\n            duration: 0,\n            getReferenceClientRect: null,\n            content: this.element,\n            interactive: true,\n            trigger: \"manual\",\n            placement: \"top\",\n            hideOnClick: \"toggle\",\n            ...this.tippyOptions\n        });\n        // maybe we have to hide tippy on its own blur event as well\n        if (this.tippy.popper.firstChild) {\n            this.tippy.popper.firstChild.addEventListener(\"blur\", this.tippyBlurHandler);\n        }\n    }\n    update(view, oldState) {\n        const { state } = view;\n        const hasValidSelection = state.selection.from !== state.selection.to;\n        if (this.updateDelay > 0 && hasValidSelection) {\n            this.handleDebouncedUpdate(view, oldState);\n            return;\n        }\n        const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n        const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n        this.updateHandler(view, selectionChanged, docChanged, oldState);\n    }\n    show() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n    }\n    hide() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    destroy() {\n        var _a, _b;\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n            this.tippy.popper.firstChild.removeEventListener(\"blur\", this.tippyBlurHandler);\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.element.removeEventListener(\"mousedown\", this.mousedownHandler, {\n            capture: true\n        });\n        this.view.dom.removeEventListener(\"dragstart\", this.dragstartHandler);\n        this.editor.off(\"focus\", this.focusHandler);\n        this.editor.off(\"blur\", this.blurHandler);\n    }\n}\nconst BubbleMenuPlugin = (options)=>{\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: typeof options.pluginKey === \"string\" ? new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(options.pluginKey) : options.pluginKey,\n        view: (view)=>new BubbleMenuView({\n                view,\n                ...options\n            })\n    });\n};\n/**\n * This extension allows you to create a bubble menu.\n * @see https://tiptap.dev/api/extensions/bubble-menu\n */ const BubbleMenu = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"bubbleMenu\",\n    addOptions () {\n        return {\n            element: null,\n            tippyOptions: {},\n            pluginKey: \"bubbleMenu\",\n            updateDelay: undefined,\n            shouldShow: null\n        };\n    },\n    addProseMirrorPlugins () {\n        if (!this.options.element) {\n            return [];\n        }\n        return [\n            BubbleMenuPlugin({\n                pluginKey: this.options.pluginKey,\n                editor: this.editor,\n                element: this.options.element,\n                tippyOptions: this.options.tippyOptions,\n                updateDelay: this.options.updateDelay,\n                shouldShow: this.options.shouldShow\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnViYmxlLW1lbnUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlGO0FBQ3BDO0FBQ3hCO0FBRTdCLE1BQU1PO0lBQ0ZDLFlBQVksRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsZUFBZSxDQUFDLENBQUMsRUFBRUMsY0FBYyxHQUFHLEVBQUVDLFVBQVUsRUFBRyxDQUFFO1FBQ3RGLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0QsVUFBVSxHQUFHLENBQUMsRUFBRUgsSUFBSSxFQUFFSyxLQUFLLEVBQUVDLElBQUksRUFBRUMsRUFBRSxFQUFHO1lBQ3pDLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxTQUFTLEVBQUUsR0FBR0o7WUFDM0IsTUFBTSxFQUFFSyxLQUFLLEVBQUUsR0FBR0Q7WUFDbEIsNENBQTRDO1lBQzVDLDJEQUEyRDtZQUMzRCwyQ0FBMkM7WUFDM0MsTUFBTUUsbUJBQW1CLENBQUNILElBQUlJLFdBQVcsQ0FBQ04sTUFBTUMsSUFBSU0sTUFBTSxJQUFJeEIsNkRBQWVBLENBQUNnQixNQUFNSSxTQUFTO1lBQzdGLDRFQUE0RTtZQUM1RSx5RUFBeUU7WUFDekUsb0VBQW9FO1lBQ3BFLE1BQU1LLGdCQUFnQixJQUFJLENBQUNmLE9BQU8sQ0FBQ2dCLFFBQVEsQ0FBQ0MsU0FBU0MsYUFBYTtZQUNsRSxNQUFNQyxpQkFBaUJsQixLQUFLbUIsUUFBUSxNQUFNTDtZQUMxQyxJQUFJLENBQUNJLGtCQUFrQlIsU0FBU0Msb0JBQW9CLENBQUMsSUFBSSxDQUFDYixNQUFNLENBQUNzQixVQUFVLEVBQUU7Z0JBQ3pFLE9BQU87WUFDWDtZQUNBLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7WUFDcEIsSUFBSSxDQUFDakIsV0FBVyxHQUFHO1FBQ3ZCO1FBQ0EsSUFBSSxDQUFDa0IsZ0JBQWdCLEdBQUc7WUFD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UUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDdEIsT0FBTyxDQUFDNUUsT0FBTyxFQUFFO1lBQ3ZCLE9BQU8sRUFBRTtRQUNiO1FBQ0EsT0FBTztZQUNIMEYsaUJBQWlCO2dCQUNiRSxXQUFXLElBQUksQ0FBQ2hCLE9BQU8sQ0FBQ2dCLFNBQVM7Z0JBQ2pDN0YsUUFBUSxJQUFJLENBQUNBLE1BQU07Z0JBQ25CQyxTQUFTLElBQUksQ0FBQzRFLE9BQU8sQ0FBQzVFLE9BQU87Z0JBQzdCRSxjQUFjLElBQUksQ0FBQzBFLE9BQU8sQ0FBQzFFLFlBQVk7Z0JBQ3ZDQyxhQUFhLElBQUksQ0FBQ3lFLE9BQU8sQ0FBQ3pFLFdBQVc7Z0JBQ3JDQyxZQUFZLElBQUksQ0FBQ3dFLE9BQU8sQ0FBQ3hFLFVBQVU7WUFDdkM7U0FDSDtJQUNMO0FBQ0o7QUFFK0UsQ0FDL0UsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudS9kaXN0L2luZGV4LmpzPzVlNDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNUZXh0U2VsZWN0aW9uLCBpc05vZGVTZWxlY3Rpb24sIHBvc1RvRE9NUmVjdCwgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5pbXBvcnQgdGlwcHkgZnJvbSAndGlwcHkuanMnO1xuXG5jbGFzcyBCdWJibGVNZW51VmlldyB7XG4gICAgY29uc3RydWN0b3IoeyBlZGl0b3IsIGVsZW1lbnQsIHZpZXcsIHRpcHB5T3B0aW9ucyA9IHt9LCB1cGRhdGVEZWxheSA9IDI1MCwgc2hvdWxkU2hvdywgfSkge1xuICAgICAgICB0aGlzLnByZXZlbnRIaWRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvdWxkU2hvdyA9ICh7IHZpZXcsIHN0YXRlLCBmcm9tLCB0bywgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IGVtcHR5IH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICAvLyBTb21ldGltZSBjaGVjayBmb3IgYGVtcHR5YCBpcyBub3QgZW5vdWdoLlxuICAgICAgICAgICAgLy8gRG91YmxlY2xpY2sgYW4gZW1wdHkgcGFyYWdyYXBoIHJldHVybnMgYSBub2RlIHNpemUgb2YgMi5cbiAgICAgICAgICAgIC8vIFNvIHdlIGNoZWNrIGFsc28gZm9yIGFuIGVtcHR5IHRleHQgc2l6ZS5cbiAgICAgICAgICAgIGNvbnN0IGlzRW1wdHlUZXh0QmxvY2sgPSAhZG9jLnRleHRCZXR3ZWVuKGZyb20sIHRvKS5sZW5ndGggJiYgaXNUZXh0U2VsZWN0aW9uKHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICAvLyBXaGVuIGNsaWNraW5nIG9uIGEgZWxlbWVudCBpbnNpZGUgdGhlIGJ1YmJsZSBtZW51IHRoZSBlZGl0b3IgXCJibHVyXCIgZXZlbnRcbiAgICAgICAgICAgIC8vIGlzIGNhbGxlZCBhbmQgdGhlIGJ1YmJsZSBtZW51IGl0ZW0gaXMgZm9jdXNzZWQuIEluIHRoaXMgY2FzZSB3ZSBzaG91bGRcbiAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBtZW51IGFzIHBhcnQgb2YgdGhlIGVkaXRvciBhbmQga2VlcCBzaG93aW5nIHRoZSBtZW51XG4gICAgICAgICAgICBjb25zdCBpc0NoaWxkT2ZNZW51ID0gdGhpcy5lbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgaGFzRWRpdG9yRm9jdXMgPSB2aWV3Lmhhc0ZvY3VzKCkgfHwgaXNDaGlsZE9mTWVudTtcbiAgICAgICAgICAgIGlmICghaGFzRWRpdG9yRm9jdXMgfHwgZW1wdHkgfHwgaXNFbXB0eVRleHRCbG9jayB8fCAhdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1vdXNlZG93bkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnRIaWRlID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kcmFnc3RhcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9jdXNIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgdXNlIGBzZXRUaW1lb3V0YCB0byBtYWtlIHN1cmUgYHNlbGVjdGlvbmAgaXMgYWxyZWFkeSB1cGRhdGVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlKHRoaXMuZWRpdG9yLnZpZXcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ibHVySGFuZGxlciA9ICh7IGV2ZW50IH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZlbnRIaWRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnJlbGF0ZWRUYXJnZXQpICYmICgoX2EgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnJlbGF0ZWRUYXJnZXQpID09PSB0aGlzLmVkaXRvci52aWV3LmRvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmx1ckhhbmRsZXIoeyBldmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEZWJvdW5jZWRVcGRhdGUgPSAodmlldywgb2xkU3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbkNoYW5nZWQgPSAhKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5zZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKTtcbiAgICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZWQgPSAhKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5kb2MuZXEodmlldy5zdGF0ZS5kb2MpKTtcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uQ2hhbmdlZCAmJiAhZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnVwZGF0ZURlYm91bmNlVGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGVib3VuY2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZXIodmlldywgc2VsZWN0aW9uQ2hhbmdlZCwgZG9jQ2hhbmdlZCwgb2xkU3RhdGUpO1xuICAgICAgICAgICAgfSwgdGhpcy51cGRhdGVEZWxheSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlSGFuZGxlciA9ICh2aWV3LCBzZWxlY3Rpb25DaGFuZ2VkLCBkb2NDaGFuZ2VkLCBvbGRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXRlLCBjb21wb3NpbmcgfSA9IHZpZXc7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBpc1NhbWUgPSAhc2VsZWN0aW9uQ2hhbmdlZCAmJiAhZG9jQ2hhbmdlZDtcbiAgICAgICAgICAgIGlmIChjb21wb3NpbmcgfHwgaXNTYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwKCk7XG4gICAgICAgICAgICAvLyBzdXBwb3J0IGZvciBDZWxsU2VsZWN0aW9uc1xuICAgICAgICAgICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBNYXRoLm1pbiguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiRmcm9tLnBvcykpO1xuICAgICAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiR0by5wb3MpKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNob3cgPSAoX2EgPSB0aGlzLnNob3VsZFNob3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICB2aWV3LFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIG9sZFN0YXRlLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghc2hvdWxkU2hvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXRQcm9wcyh7XG4gICAgICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogKChfYyA9IHRoaXMudGlwcHlPcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdClcbiAgICAgICAgICAgICAgICAgICAgfHwgKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGVTZWxlY3Rpb24oc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gdmlldy5ub2RlRE9NKGZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVWaWV3V3JhcHBlciA9IG5vZGUuZGF0YXNldC5ub2RlVmlld1dyYXBwZXIgPyBub2RlIDogbm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1ub2RlLXZpZXctd3JhcHBlcl0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVWaWV3V3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVWaWV3V3JhcHBlci5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3NUb0RPTVJlY3QodmlldywgZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnVwZGF0ZURlbGF5ID0gdXBkYXRlRGVsYXk7XG4gICAgICAgIGlmIChzaG91bGRTaG93KSB7XG4gICAgICAgICAgICB0aGlzLnNob3VsZFNob3cgPSBzaG91bGRTaG93O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLmRyYWdzdGFydEhhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vbignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcik7XG4gICAgICAgIHRoaXMudGlwcHlPcHRpb25zID0gdGlwcHlPcHRpb25zO1xuICAgICAgICAvLyBEZXRhY2hlcyBtZW51IGNvbnRlbnQgZnJvbSBpdHMgY3VycmVudCBwYXJlbnRcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICB9XG4gICAgY3JlYXRlVG9vbHRpcCgpIHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50OiBlZGl0b3JFbGVtZW50IH0gPSB0aGlzLmVkaXRvci5vcHRpb25zO1xuICAgICAgICBjb25zdCBlZGl0b3JJc0F0dGFjaGVkID0gISFlZGl0b3JFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLnRpcHB5IHx8ICFlZGl0b3JJc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aXBweSA9IHRpcHB5KGVkaXRvckVsZW1lbnQsIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogbnVsbCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgICAgICAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgICAgICAgICAgaGlkZU9uQ2xpY2s6ICd0b2dnbGUnLFxuICAgICAgICAgICAgLi4udGhpcy50aXBweU9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBtYXliZSB3ZSBoYXZlIHRvIGhpZGUgdGlwcHkgb24gaXRzIG93biBibHVyIGV2ZW50IGFzIHdlbGxcbiAgICAgICAgaWYgKHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHZpZXcsIG9sZFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgICAgIGNvbnN0IGhhc1ZhbGlkU2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLmZyb20gIT09IHN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlRGVsYXkgPiAwICYmIGhhc1ZhbGlkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURlYm91bmNlZFVwZGF0ZSh2aWV3LCBvbGRTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uQ2hhbmdlZCA9ICEob2xkU3RhdGUgPT09IG51bGwgfHwgb2xkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFN0YXRlLnNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpO1xuICAgICAgICBjb25zdCBkb2NDaGFuZ2VkID0gIShvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkU3RhdGUuZG9jLmVxKHZpZXcuc3RhdGUuZG9jKSk7XG4gICAgICAgIHRoaXMudXBkYXRlSGFuZGxlcih2aWV3LCBzZWxlY3Rpb25DaGFuZ2VkLCBkb2NDaGFuZ2VkLCBvbGRTdGF0ZSk7XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNob3coKTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGlkZSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLmRyYWdzdGFydEhhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcbiAgICB9XG59XG5jb25zdCBCdWJibGVNZW51UGx1Z2luID0gKG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogdHlwZW9mIG9wdGlvbnMucGx1Z2luS2V5ID09PSAnc3RyaW5nJyA/IG5ldyBQbHVnaW5LZXkob3B0aW9ucy5wbHVnaW5LZXkpIDogb3B0aW9ucy5wbHVnaW5LZXksXG4gICAgICAgIHZpZXc6IHZpZXcgPT4gbmV3IEJ1YmJsZU1lbnVWaWV3KHsgdmlldywgLi4ub3B0aW9ucyB9KSxcbiAgICB9KTtcbn07XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgYSBidWJibGUgbWVudS5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2J1YmJsZS1tZW51XG4gKi9cbmNvbnN0IEJ1YmJsZU1lbnUgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnYnViYmxlTWVudScsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICB0aXBweU9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgcGx1Z2luS2V5OiAnYnViYmxlTWVudScsXG4gICAgICAgICAgICB1cGRhdGVEZWxheTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2hvdWxkU2hvdzogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBCdWJibGVNZW51UGx1Z2luKHtcbiAgICAgICAgICAgICAgICBwbHVnaW5LZXk6IHRoaXMub3B0aW9ucy5wbHVnaW5LZXksXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLm9wdGlvbnMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICB0aXBweU9wdGlvbnM6IHRoaXMub3B0aW9ucy50aXBweU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgdXBkYXRlRGVsYXk6IHRoaXMub3B0aW9ucy51cGRhdGVEZWxheSxcbiAgICAgICAgICAgICAgICBzaG91bGRTaG93OiB0aGlzLm9wdGlvbnMuc2hvdWxkU2hvdyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgQnViYmxlTWVudSwgQnViYmxlTWVudVBsdWdpbiwgQnViYmxlTWVudVZpZXcsIEJ1YmJsZU1lbnUgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiaXNUZXh0U2VsZWN0aW9uIiwiaXNOb2RlU2VsZWN0aW9uIiwicG9zVG9ET01SZWN0IiwiRXh0ZW5zaW9uIiwiUGx1Z2luIiwiUGx1Z2luS2V5IiwidGlwcHkiLCJCdWJibGVNZW51VmlldyIsImNvbnN0cnVjdG9yIiwiZWRpdG9yIiwiZWxlbWVudCIsInZpZXciLCJ0aXBweU9wdGlvbnMiLCJ1cGRhdGVEZWxheSIsInNob3VsZFNob3ciLCJwcmV2ZW50SGlkZSIsInN0YXRlIiwiZnJvbSIsInRvIiwiZG9jIiwic2VsZWN0aW9uIiwiZW1wdHkiLCJpc0VtcHR5VGV4dEJsb2NrIiwidGV4dEJldHdlZW4iLCJsZW5ndGgiLCJpc0NoaWxkT2ZNZW51IiwiY29udGFpbnMiLCJkb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJoYXNFZGl0b3JGb2N1cyIsImhhc0ZvY3VzIiwiaXNFZGl0YWJsZSIsIm1vdXNlZG93bkhhbmRsZXIiLCJkcmFnc3RhcnRIYW5kbGVyIiwiaGlkZSIsImZvY3VzSGFuZGxlciIsInNldFRpbWVvdXQiLCJ1cGRhdGUiLCJibHVySGFuZGxlciIsImV2ZW50IiwiX2EiLCJyZWxhdGVkVGFyZ2V0IiwicGFyZW50Tm9kZSIsImRvbSIsInRpcHB5Qmx1ckhhbmRsZXIiLCJoYW5kbGVEZWJvdW5jZWRVcGRhdGUiLCJvbGRTdGF0ZSIsInNlbGVjdGlvbkNoYW5nZWQiLCJlcSIsImRvY0NoYW5nZWQiLCJ1cGRhdGVEZWJvdW5jZVRpbWVyIiwiY2xlYXJUaW1lb3V0Iiwid2luZG93IiwidXBkYXRlSGFuZGxlciIsIl9iIiwiX2MiLCJjb21wb3NpbmciLCJpc1NhbWUiLCJjcmVhdGVUb29sdGlwIiwicmFuZ2VzIiwiTWF0aCIsIm1pbiIsIm1hcCIsInJhbmdlIiwiJGZyb20iLCJwb3MiLCJtYXgiLCIkdG8iLCJjYWxsIiwic2V0UHJvcHMiLCJnZXRSZWZlcmVuY2VDbGllbnRSZWN0Iiwibm9kZSIsIm5vZGVET00iLCJub2RlVmlld1dyYXBwZXIiLCJkYXRhc2V0IiwicXVlcnlTZWxlY3RvciIsImZpcnN0Q2hpbGQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzaG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhcHR1cmUiLCJvbiIsInJlbW92ZSIsInN0eWxlIiwidmlzaWJpbGl0eSIsImVkaXRvckVsZW1lbnQiLCJvcHRpb25zIiwiZWRpdG9ySXNBdHRhY2hlZCIsInBhcmVudEVsZW1lbnQiLCJkdXJhdGlvbiIsImNvbnRlbnQiLCJpbnRlcmFjdGl2ZSIsInRyaWdnZXIiLCJwbGFjZW1lbnQiLCJoaWRlT25DbGljayIsInBvcHBlciIsImhhc1ZhbGlkU2VsZWN0aW9uIiwiZGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvZmYiLCJCdWJibGVNZW51UGx1Z2luIiwia2V5IiwicGx1Z2luS2V5IiwiQnViYmxlTWVudSIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwidW5kZWZpbmVkIiwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bullet-list/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bullet-list/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BulletList: () => (/* binding */ BulletList),\n/* harmony export */   \"default\": () => (/* binding */ BulletList),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\nconst ListItemName = \"listItem\";\nconst TextStyleName = \"textStyle\";\n/**\n * Matches a bullet list to a dash or asterisk.\n */ const inputRegex = /^\\s*([-+*])\\s$/;\n/**\n * This extension allows you to create bullet lists.\n * This requires the ListItem extension\n * @see https://tiptap.dev/api/nodes/bullet-list\n * @see https://tiptap.dev/api/nodes/list-item.\n */ const BulletList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"bulletList\",\n    addOptions () {\n        return {\n            itemTypeName: \"listItem\",\n            HTMLAttributes: {},\n            keepMarks: false,\n            keepAttributes: false\n        };\n    },\n    group: \"block list\",\n    content () {\n        return `${this.options.itemTypeName}+`;\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"ul\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"ul\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            toggleBulletList: ()=>({ commands, chain })=>{\n                    if (this.options.keepAttributes) {\n                        return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n                    }\n                    return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-8\": ()=>this.editor.commands.toggleBulletList()\n        };\n    },\n    addInputRules () {\n        let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n            find: inputRegex,\n            type: this.type\n        });\n        if (this.options.keepMarks || this.options.keepAttributes) {\n            inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type,\n                keepMarks: this.options.keepMarks,\n                keepAttributes: this.options.keepAttributes,\n                getAttributes: ()=>{\n                    return this.editor.getAttributes(TextStyleName);\n                },\n                editor: this.editor\n            });\n        }\n        return [\n            inputRule\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdFO0FBRXhFLE1BQU1HLGVBQWU7QUFDckIsTUFBTUMsZ0JBQWdCO0FBQ3RCOztDQUVDLEdBQ0QsTUFBTUMsYUFBYTtBQUNuQjs7Ozs7Q0FLQyxHQUNELE1BQU1DLGFBQWFOLDhDQUFJQSxDQUFDTyxNQUFNLENBQUM7SUFDM0JDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGNBQWM7WUFDZEMsZ0JBQWdCLENBQUM7WUFDakJDLFdBQVc7WUFDWEMsZ0JBQWdCO1FBQ3BCO0lBQ0o7SUFDQUMsT0FBTztJQUNQQztRQUNJLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQ0MsT0FBTyxDQUFDTixZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQzFDO0lBQ0FPO1FBQ0ksT0FBTztZQUNIO2dCQUFFQyxLQUFLO1lBQUs7U0FDZjtJQUNMO0lBQ0FDLFlBQVcsRUFBRVIsY0FBYyxFQUFFO1FBQ3pCLE9BQU87WUFBQztZQUFNViw2REFBZUEsQ0FBQyxJQUFJLENBQUNlLE9BQU8sQ0FBQ0wsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ2xGO0lBQ0FTO1FBQ0ksT0FBTztZQUNIQyxrQkFBa0IsSUFBTSxDQUFDLEVBQUVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFO29CQUN4QyxJQUFJLElBQUksQ0FBQ1AsT0FBTyxDQUFDSCxjQUFjLEVBQUU7d0JBQzdCLE9BQU9VLFFBQVFDLFVBQVUsQ0FBQyxJQUFJLENBQUNoQixJQUFJLEVBQUUsSUFBSSxDQUFDUSxPQUFPLENBQUNOLFlBQVksRUFBRSxJQUFJLENBQUNNLE9BQU8sQ0FBQ0osU0FBUyxFQUFFYSxnQkFBZ0IsQ0FBQ3RCLGNBQWMsSUFBSSxDQUFDdUIsTUFBTSxDQUFDQyxhQUFhLENBQUN2QixnQkFBZ0J3QixHQUFHO29CQUN4SztvQkFDQSxPQUFPTixTQUFTRSxVQUFVLENBQUMsSUFBSSxDQUFDaEIsSUFBSSxFQUFFLElBQUksQ0FBQ1EsT0FBTyxDQUFDTixZQUFZLEVBQUUsSUFBSSxDQUFDTSxPQUFPLENBQUNKLFNBQVM7Z0JBQzNGO1FBQ0o7SUFDSjtJQUNBaUI7UUFDSSxPQUFPO1lBQ0gsZUFBZSxJQUFNLElBQUksQ0FBQ0gsTUFBTSxDQUFDSixRQUFRLENBQUNELGdCQUFnQjtRQUM5RDtJQUNKO0lBQ0FTO1FBQ0ksSUFBSUMsWUFBWTdCLCtEQUFpQkEsQ0FBQztZQUM5QjhCLE1BQU0zQjtZQUNONEIsTUFBTSxJQUFJLENBQUNBLElBQUk7UUFDbkI7UUFDQSxJQUFJLElBQUksQ0FBQ2pCLE9BQU8sQ0FBQ0osU0FBUyxJQUFJLElBQUksQ0FBQ0ksT0FBTyxDQUFDSCxjQUFjLEVBQUU7WUFDdkRrQixZQUFZN0IsK0RBQWlCQSxDQUFDO2dCQUMxQjhCLE1BQU0zQjtnQkFDTjRCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO2dCQUNmckIsV0FBVyxJQUFJLENBQUNJLE9BQU8sQ0FBQ0osU0FBUztnQkFDakNDLGdCQUFnQixJQUFJLENBQUNHLE9BQU8sQ0FBQ0gsY0FBYztnQkFDM0NjLGVBQWU7b0JBQVEsT0FBTyxJQUFJLENBQUNELE1BQU0sQ0FBQ0MsYUFBYSxDQUFDdkI7Z0JBQWdCO2dCQUN4RXNCLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ3ZCO1FBQ0o7UUFDQSxPQUFPO1lBQ0hLO1NBQ0g7SUFDTDtBQUNKO0FBRXlELENBQ3pELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3QvZGlzdC9pbmRleC5qcz80NzRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgd3JhcHBpbmdJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG5jb25zdCBMaXN0SXRlbU5hbWUgPSAnbGlzdEl0ZW0nO1xuY29uc3QgVGV4dFN0eWxlTmFtZSA9ICd0ZXh0U3R5bGUnO1xuLyoqXG4gKiBNYXRjaGVzIGEgYnVsbGV0IGxpc3QgdG8gYSBkYXNoIG9yIGFzdGVyaXNrLlxuICovXG5jb25zdCBpbnB1dFJlZ2V4ID0gL15cXHMqKFstKypdKVxccyQvO1xuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBidWxsZXQgbGlzdHMuXG4gKiBUaGlzIHJlcXVpcmVzIHRoZSBMaXN0SXRlbSBleHRlbnNpb25cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9ub2Rlcy9idWxsZXQtbGlzdFxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL25vZGVzL2xpc3QtaXRlbS5cbiAqL1xuY29uc3QgQnVsbGV0TGlzdCA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAnYnVsbGV0TGlzdCcsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGl0ZW1UeXBlTmFtZTogJ2xpc3RJdGVtJyxcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgICAgIGtlZXBNYXJrczogZmFsc2UsXG4gICAgICAgICAgICBrZWVwQXR0cmlidXRlczogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBncm91cDogJ2Jsb2NrIGxpc3QnLFxuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgO1xuICAgIH0sXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0YWc6ICd1bCcgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ3VsJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9nZ2xlQnVsbGV0TGlzdDogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbigpLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKS51cGRhdGVBdHRyaWJ1dGVzKExpc3RJdGVtTmFtZSwgdGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGVOYW1lKSkucnVuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLVNoaWZ0LTgnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCdWxsZXRMaXN0KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICBsZXQgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcE1hcmtzIHx8IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgICAgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIGtlZXBNYXJrczogdGhpcy5vcHRpb25zLmtlZXBNYXJrcyxcbiAgICAgICAgICAgICAgICBrZWVwQXR0cmlidXRlczogdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGdldEF0dHJpYnV0ZXM6ICgpID0+IHsgcmV0dXJuIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZSk7IH0sXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBpbnB1dFJ1bGUsXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBCdWxsZXRMaXN0LCBCdWxsZXRMaXN0IGFzIGRlZmF1bHQsIGlucHV0UmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJtZXJnZUF0dHJpYnV0ZXMiLCJ3cmFwcGluZ0lucHV0UnVsZSIsIkxpc3RJdGVtTmFtZSIsIlRleHRTdHlsZU5hbWUiLCJpbnB1dFJlZ2V4IiwiQnVsbGV0TGlzdCIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiaXRlbVR5cGVOYW1lIiwiSFRNTEF0dHJpYnV0ZXMiLCJrZWVwTWFya3MiLCJrZWVwQXR0cmlidXRlcyIsImdyb3VwIiwiY29udGVudCIsIm9wdGlvbnMiLCJwYXJzZUhUTUwiLCJ0YWciLCJyZW5kZXJIVE1MIiwiYWRkQ29tbWFuZHMiLCJ0b2dnbGVCdWxsZXRMaXN0IiwiY29tbWFuZHMiLCJjaGFpbiIsInRvZ2dsZUxpc3QiLCJ1cGRhdGVBdHRyaWJ1dGVzIiwiZWRpdG9yIiwiZ2V0QXR0cmlidXRlcyIsInJ1biIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiYWRkSW5wdXRSdWxlcyIsImlucHV0UnVsZSIsImZpbmQiLCJ0eXBlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bullet-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-code-block/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodeBlock: () => (/* binding */ CodeBlock),\n/* harmony export */   backtickInputRegex: () => (/* binding */ backtickInputRegex),\n/* harmony export */   \"default\": () => (/* binding */ CodeBlock),\n/* harmony export */   tildeInputRegex: () => (/* binding */ tildeInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n\n\n/**\n * Matches a code block with backticks.\n */ const backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/;\n/**\n * Matches a code block with tildes.\n */ const tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/;\n/**\n * This extension allows you to create code blocks.\n * @see https://tiptap.dev/api/nodes/code-block\n */ const CodeBlock = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n    name: \"codeBlock\",\n    addOptions () {\n        return {\n            languageClassPrefix: \"language-\",\n            exitOnTripleEnter: true,\n            exitOnArrowDown: true,\n            defaultLanguage: null,\n            HTMLAttributes: {}\n        };\n    },\n    content: \"text*\",\n    marks: \"\",\n    group: \"block\",\n    code: true,\n    defining: true,\n    addAttributes () {\n        return {\n            language: {\n                default: this.options.defaultLanguage,\n                parseHTML: (element)=>{\n                    var _a;\n                    const { languageClassPrefix } = this.options;\n                    const classNames = [\n                        ...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []\n                    ];\n                    const languages = classNames.filter((className)=>className.startsWith(languageClassPrefix)).map((className)=>className.replace(languageClassPrefix, \"\"));\n                    const language = languages[0];\n                    if (!language) {\n                        return null;\n                    }\n                    return language;\n                },\n                rendered: false\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"pre\",\n                preserveWhitespace: \"full\"\n            }\n        ];\n    },\n    renderHTML ({ node, HTMLAttributes }) {\n        return [\n            \"pre\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            [\n                \"code\",\n                {\n                    class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null\n                },\n                0\n            ]\n        ];\n    },\n    addCommands () {\n        return {\n            setCodeBlock: (attributes)=>({ commands })=>{\n                    return commands.setNode(this.name, attributes);\n                },\n            toggleCodeBlock: (attributes)=>({ commands })=>{\n                    return commands.toggleNode(this.name, \"paragraph\", attributes);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Alt-c\": ()=>this.editor.commands.toggleCodeBlock(),\n            // remove code block when at start of document or code block is empty\n            Backspace: ()=>{\n                const { empty, $anchor } = this.editor.state.selection;\n                const isAtStart = $anchor.pos === 1;\n                if (!empty || $anchor.parent.type.name !== this.name) {\n                    return false;\n                }\n                if (isAtStart || !$anchor.parent.textContent.length) {\n                    return this.editor.commands.clearNodes();\n                }\n                return false;\n            },\n            // exit node on triple enter\n            Enter: ({ editor })=>{\n                if (!this.options.exitOnTripleEnter) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                const endsWithDoubleNewline = $from.parent.textContent.endsWith(\"\\n\\n\");\n                if (!isAtEnd || !endsWithDoubleNewline) {\n                    return false;\n                }\n                return editor.chain().command(({ tr })=>{\n                    tr.delete($from.pos - 2, $from.pos);\n                    return true;\n                }).exitCode().run();\n            },\n            // exit node on arrow down\n            ArrowDown: ({ editor })=>{\n                if (!this.options.exitOnArrowDown) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection, doc } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                if (!isAtEnd) {\n                    return false;\n                }\n                const after = $from.after();\n                if (after === undefined) {\n                    return false;\n                }\n                const nodeAfter = doc.nodeAt(after);\n                if (nodeAfter) {\n                    return editor.commands.command(({ tr })=>{\n                        tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(doc.resolve(after)));\n                        return true;\n                    });\n                }\n                return editor.commands.exitCode();\n            }\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n                find: backtickInputRegex,\n                type: this.type,\n                getAttributes: (match)=>({\n                        language: match[1]\n                    })\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n                find: tildeInputRegex,\n                type: this.type,\n                getAttributes: (match)=>({\n                        language: match[1]\n                    })\n            })\n        ];\n    },\n    addProseMirrorPlugins () {\n        return [\n            // this plugin creates a code block for pasted content from VS Code\n            // we can also detect the copied code language\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"codeBlockVSCodeHandler\"),\n                props: {\n                    handlePaste: (view, event)=>{\n                        if (!event.clipboardData) {\n                            return false;\n                        }\n                        // don’t create a new code block within code blocks\n                        if (this.editor.isActive(this.type.name)) {\n                            return false;\n                        }\n                        const text = event.clipboardData.getData(\"text/plain\");\n                        const vscode = event.clipboardData.getData(\"vscode-editor-data\");\n                        const vscodeData = vscode ? JSON.parse(vscode) : undefined;\n                        const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;\n                        if (!text || !language) {\n                            return false;\n                        }\n                        const { tr, schema } = view.state;\n                        // prepare a text node\n                        // strip carriage return chars from text pasted as code\n                        // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n                        const textNode = schema.text(text.replace(/\\r\\n?/g, \"\\n\"));\n                        // create a code block with the text node\n                        // replace selection with the code block\n                        tr.replaceSelectionWith(this.type.create({\n                            language\n                        }, textNode));\n                        if (tr.selection.$from.parent.type !== this.type) {\n                            // put cursor inside the newly created code block\n                            tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));\n                        }\n                        // store meta information\n                        // this is useful for other plugins that depends on the paste event\n                        // like the paste rule plugin\n                        tr.setMeta(\"paste\", true);\n                        view.dispatch(tr);\n                        return true;\n                    }\n                }\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RTtBQUNFO0FBRS9FOztDQUVDLEdBQ0QsTUFBTU8scUJBQXFCO0FBQzNCOztDQUVDLEdBQ0QsTUFBTUMsa0JBQWtCO0FBQ3hCOzs7Q0FHQyxHQUNELE1BQU1DLFlBQVlULDhDQUFJQSxDQUFDVSxNQUFNLENBQUM7SUFDMUJDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLHFCQUFxQjtZQUNyQkMsbUJBQW1CO1lBQ25CQyxpQkFBaUI7WUFDakJDLGlCQUFpQjtZQUNqQkMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQyxTQUFTO0lBQ1RDLE9BQU87SUFDUEMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLFVBQVU7SUFDVkM7UUFDSSxPQUFPO1lBQ0hDLFVBQVU7Z0JBQ05DLFNBQVMsSUFBSSxDQUFDQyxPQUFPLENBQUNWLGVBQWU7Z0JBQ3JDVyxXQUFXQyxDQUFBQTtvQkFDUCxJQUFJQztvQkFDSixNQUFNLEVBQUVoQixtQkFBbUIsRUFBRSxHQUFHLElBQUksQ0FBQ2EsT0FBTztvQkFDNUMsTUFBTUksYUFBYTsyQkFBSyxDQUFDLENBQUNELEtBQUtELFFBQVFHLGlCQUFpQixNQUFNLFFBQVFGLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0csU0FBUyxLQUFLLEVBQUU7cUJBQUU7b0JBQ3BILE1BQU1DLFlBQVlILFdBQ2JJLE1BQU0sQ0FBQ0MsQ0FBQUEsWUFBYUEsVUFBVUMsVUFBVSxDQUFDdkIsc0JBQ3pDd0IsR0FBRyxDQUFDRixDQUFBQSxZQUFhQSxVQUFVRyxPQUFPLENBQUN6QixxQkFBcUI7b0JBQzdELE1BQU1XLFdBQVdTLFNBQVMsQ0FBQyxFQUFFO29CQUM3QixJQUFJLENBQUNULFVBQVU7d0JBQ1gsT0FBTztvQkFDWDtvQkFDQSxPQUFPQTtnQkFDWDtnQkFDQWUsVUFBVTtZQUNkO1FB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SyxDQUFDTixNQUFNLENBQUNDLElBQUksS0FBSyxJQUFJLENBQUNBLElBQUksRUFBRTs0QkFDOUMsaURBQWlEOzRCQUNqRGEsR0FBR1UsWUFBWSxDQUFDaEYsMkRBQWFBLENBQUNpRixJQUFJLENBQUNYLEdBQUdLLEdBQUcsQ0FBQ08sT0FBTyxDQUFDdUIsS0FBS0MsR0FBRyxDQUFDLEdBQUdwQyxHQUFHakIsU0FBUyxDQUFDc0QsSUFBSSxHQUFHO3dCQUN0Rjt3QkFDQSx5QkFBeUI7d0JBQ3pCLG1FQUFtRTt3QkFDbkUsNkJBQTZCO3dCQUM3QnJDLEdBQUdzQyxPQUFPLENBQUMsU0FBUzt3QkFDcEJqQixLQUFLa0IsUUFBUSxDQUFDdkM7d0JBQ2QsT0FBTztvQkFDWDtnQkFDSjtZQUNKO1NBQ0g7SUFDTDtBQUNKO0FBRWdGLENBQ2hGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jay9kaXN0L2luZGV4LmpzP2NiYTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IFNlbGVjdGlvbiwgUGx1Z2luLCBQbHVnaW5LZXksIFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcblxuLyoqXG4gKiBNYXRjaGVzIGEgY29kZSBibG9jayB3aXRoIGJhY2t0aWNrcy5cbiAqL1xuY29uc3QgYmFja3RpY2tJbnB1dFJlZ2V4ID0gL15gYGAoW2Etel0rKT9bXFxzXFxuXSQvO1xuLyoqXG4gKiBNYXRjaGVzIGEgY29kZSBibG9jayB3aXRoIHRpbGRlcy5cbiAqL1xuY29uc3QgdGlsZGVJbnB1dFJlZ2V4ID0gL15+fn4oW2Etel0rKT9bXFxzXFxuXSQvO1xuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBjb2RlIGJsb2Nrcy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9ub2Rlcy9jb2RlLWJsb2NrXG4gKi9cbmNvbnN0IENvZGVCbG9jayA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAnY29kZUJsb2NrJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFuZ3VhZ2VDbGFzc1ByZWZpeDogJ2xhbmd1YWdlLScsXG4gICAgICAgICAgICBleGl0T25UcmlwbGVFbnRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGV4aXRPbkFycm93RG93bjogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRMYW5ndWFnZTogbnVsbCxcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbnRlbnQ6ICd0ZXh0KicsXG4gICAgbWFya3M6ICcnLFxuICAgIGdyb3VwOiAnYmxvY2snLFxuICAgIGNvZGU6IHRydWUsXG4gICAgZGVmaW5pbmc6IHRydWUsXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhbmd1YWdlOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLmRlZmF1bHRMYW5ndWFnZSxcbiAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbGFuZ3VhZ2VDbGFzc1ByZWZpeCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gWy4uLigoKF9hID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsYXNzTGlzdCkgfHwgW10pXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2VzID0gY2xhc3NOYW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihjbGFzc05hbWUgPT4gY2xhc3NOYW1lLnN0YXJ0c1dpdGgobGFuZ3VhZ2VDbGFzc1ByZWZpeCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGNsYXNzTmFtZSA9PiBjbGFzc05hbWUucmVwbGFjZShsYW5ndWFnZUNsYXNzUHJlZml4LCAnJykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGxhbmd1YWdlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdwcmUnLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJ2Z1bGwnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAncHJlJyxcbiAgICAgICAgICAgIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnY29kZScsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogbm9kZS5hdHRycy5sYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm9wdGlvbnMubGFuZ3VhZ2VDbGFzc1ByZWZpeCArIG5vZGUuYXR0cnMubGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBdLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRDb2RlQmxvY2s6IGF0dHJpYnV0ZXMgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlQ29kZUJsb2NrOiBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTm9kZSh0aGlzLm5hbWUsICdwYXJhZ3JhcGgnLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtQWx0LWMnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVDb2RlQmxvY2soKSxcbiAgICAgICAgICAgIC8vIHJlbW92ZSBjb2RlIGJsb2NrIHdoZW4gYXQgc3RhcnQgb2YgZG9jdW1lbnQgb3IgY29kZSBibG9jayBpcyBlbXB0eVxuICAgICAgICAgICAgQmFja3NwYWNlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgJGFuY2hvciB9ID0gdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXRTdGFydCA9ICRhbmNob3IucG9zID09PSAxO1xuICAgICAgICAgICAgICAgIGlmICghZW1wdHkgfHwgJGFuY2hvci5wYXJlbnQudHlwZS5uYW1lICE9PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNBdFN0YXJ0IHx8ICEkYW5jaG9yLnBhcmVudC50ZXh0Q29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGV4aXQgbm9kZSBvbiB0cmlwbGUgZW50ZXJcbiAgICAgICAgICAgIEVudGVyOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmV4aXRPblRyaXBsZUVudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmICghZW1wdHkgfHwgJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXRFbmQgPSAkZnJvbS5wYXJlbnRPZmZzZXQgPT09ICRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDI7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kc1dpdGhEb3VibGVOZXdsaW5lID0gJGZyb20ucGFyZW50LnRleHRDb250ZW50LmVuZHNXaXRoKCdcXG5cXG4nKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXRFbmQgfHwgIWVuZHNXaXRoRG91YmxlTmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgLmNoYWluKClcbiAgICAgICAgICAgICAgICAgICAgLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0ci5kZWxldGUoJGZyb20ucG9zIC0gMiwgJGZyb20ucG9zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmV4aXRDb2RlKClcbiAgICAgICAgICAgICAgICAgICAgLnJ1bigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGV4aXQgbm9kZSBvbiBhcnJvdyBkb3duXG4gICAgICAgICAgICBBcnJvd0Rvd246ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZXhpdE9uQXJyb3dEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgJGZyb20sIGVtcHR5IH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKCFlbXB0eSB8fCAkZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdEVuZCA9ICRmcm9tLnBhcmVudE9mZnNldCA9PT0gJGZyb20ucGFyZW50Lm5vZGVTaXplIC0gMjtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXRFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhZnRlciA9ICRmcm9tLmFmdGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBub2RlQWZ0ZXIgPSBkb2Mubm9kZUF0KGFmdGVyKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIoZG9jLnJlc29sdmUoYWZ0ZXIpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0b3IuY29tbWFuZHMuZXhpdENvZGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogYmFja3RpY2tJbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICBnZXRBdHRyaWJ1dGVzOiBtYXRjaCA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZTogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHRpbGRlSW5wdXRSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAvLyB0aGlzIHBsdWdpbiBjcmVhdGVzIGEgY29kZSBibG9jayBmb3IgcGFzdGVkIGNvbnRlbnQgZnJvbSBWUyBDb2RlXG4gICAgICAgICAgICAvLyB3ZSBjYW4gYWxzbyBkZXRlY3QgdGhlIGNvcGllZCBjb2RlIGxhbmd1YWdlXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NvZGVCbG9ja1ZTQ29kZUhhbmRsZXInKSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVQYXN0ZTogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb27igJl0IGNyZWF0ZSBhIG5ldyBjb2RlIGJsb2NrIHdpdGhpbiBjb2RlIGJsb2Nrc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZWRpdG9yLmlzQWN0aXZlKHRoaXMudHlwZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZzY29kZSA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndnNjb2RlLWVkaXRvci1kYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2c2NvZGVEYXRhID0gdnNjb2RlID8gSlNPTi5wYXJzZSh2c2NvZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSB2c2NvZGVEYXRhID09PSBudWxsIHx8IHZzY29kZURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZzY29kZURhdGEubW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGV4dCB8fCAhbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRyLCBzY2hlbWEgfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVwYXJlIGEgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpcCBjYXJyaWFnZSByZXR1cm4gY2hhcnMgZnJvbSB0ZXh0IHBhc3RlZCBhcyBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci12aWV3L2NvbW1pdC9hNTBhNmJjY2ViNGNlNTJhYzhmY2M2MTYyNDg4ZDg4NzU2MTNhYWNkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IHNjaGVtYS50ZXh0KHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgY29kZSBibG9jayB3aXRoIHRoZSB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2Ugc2VsZWN0aW9uIHdpdGggdGhlIGNvZGUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHRoaXMudHlwZS5jcmVhdGUoeyBsYW5ndWFnZSB9LCB0ZXh0Tm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyLnNlbGVjdGlvbi4kZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHV0IGN1cnNvciBpbnNpZGUgdGhlIG5ld2x5IGNyZWF0ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoTWF0aC5tYXgoMCwgdHIuc2VsZWN0aW9uLmZyb20gLSAyKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIG1ldGEgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciBvdGhlciBwbHVnaW5zIHRoYXQgZGVwZW5kcyBvbiB0aGUgcGFzdGUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpa2UgdGhlIHBhc3RlIHJ1bGUgcGx1Z2luXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKCdwYXN0ZScsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBDb2RlQmxvY2ssIGJhY2t0aWNrSW5wdXRSZWdleCwgQ29kZUJsb2NrIGFzIGRlZmF1bHQsIHRpbGRlSW5wdXRSZWdleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTm9kZSIsIm1lcmdlQXR0cmlidXRlcyIsInRleHRibG9ja1R5cGVJbnB1dFJ1bGUiLCJTZWxlY3Rpb24iLCJQbHVnaW4iLCJQbHVnaW5LZXkiLCJUZXh0U2VsZWN0aW9uIiwiYmFja3RpY2tJbnB1dFJlZ2V4IiwidGlsZGVJbnB1dFJlZ2V4IiwiQ29kZUJsb2NrIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJsYW5ndWFnZUNsYXNzUHJlZml4IiwiZXhpdE9uVHJpcGxlRW50ZXIiLCJleGl0T25BcnJvd0Rvd24iLCJkZWZhdWx0TGFuZ3VhZ2UiLCJIVE1MQXR0cmlidXRlcyIsImNvbnRlbnQiLCJtYXJrcyIsImdyb3VwIiwiY29kZSIsImRlZmluaW5nIiwiYWRkQXR0cmlidXRlcyIsImxhbmd1YWdlIiwiZGVmYXVsdCIsIm9wdGlvbnMiLCJwYXJzZUhUTUwiLCJlbGVtZW50IiwiX2EiLCJjbGFzc05hbWVzIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJjbGFzc0xpc3QiLCJsYW5ndWFnZXMiLCJmaWx0ZXIiLCJjbGFzc05hbWUiLCJzdGFydHNXaXRoIiwibWFwIiwicmVwbGFjZSIsInJlbmRlcmVkIiwidGFnIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwicmVuZGVySFRNTCIsIm5vZGUiLCJjbGFzcyIsImF0dHJzIiwiYWRkQ29tbWFuZHMiLCJzZXRDb2RlQmxvY2siLCJhdHRyaWJ1dGVzIiwiY29tbWFuZHMiLCJzZXROb2RlIiwidG9nZ2xlQ29kZUJsb2NrIiwidG9nZ2xlTm9kZSIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiZWRpdG9yIiwiQmFja3NwYWNlIiwiZW1wdHkiLCIkYW5jaG9yIiwic3RhdGUiLCJzZWxlY3Rpb24iLCJpc0F0U3RhcnQiLCJwb3MiLCJwYXJlbnQiLCJ0eXBlIiwidGV4dENvbnRlbnQiLCJsZW5ndGgiLCJjbGVhck5vZGVzIiwiRW50ZXIiLCIkZnJvbSIsImlzQXRFbmQiLCJwYXJlbnRPZmZzZXQiLCJub2RlU2l6ZSIsImVuZHNXaXRoRG91YmxlTmV3bGluZSIsImVuZHNXaXRoIiwiY2hhaW4iLCJjb21tYW5kIiwidHIiLCJkZWxldGUiLCJleGl0Q29kZSIsInJ1biIsIkFycm93RG93biIsImRvYyIsImFmdGVyIiwidW5kZWZpbmVkIiwibm9kZUFmdGVyIiwibm9kZUF0Iiwic2V0U2VsZWN0aW9uIiwibmVhciIsInJlc29sdmUiLCJhZGRJbnB1dFJ1bGVzIiwiZmluZCIsImdldEF0dHJpYnV0ZXMiLCJtYXRjaCIsImFkZFByb3NlTWlycm9yUGx1Z2lucyIsImtleSIsInByb3BzIiwiaGFuZGxlUGFzdGUiLCJ2aWV3IiwiZXZlbnQiLCJjbGlwYm9hcmREYXRhIiwiaXNBY3RpdmUiLCJ0ZXh0IiwiZ2V0RGF0YSIsInZzY29kZSIsInZzY29kZURhdGEiLCJKU09OIiwicGFyc2UiLCJtb2RlIiwic2NoZW1hIiwidGV4dE5vZGUiLCJyZXBsYWNlU2VsZWN0aW9uV2l0aCIsIk1hdGgiLCJtYXgiLCJmcm9tIiwic2V0TWV0YSIsImRpc3BhdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-code/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: () => (/* binding */ Code),\n/* harmony export */   \"default\": () => (/* binding */ Code),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * Regular expressions to match inline code blocks enclosed in backticks.\n *  It matches:\n *     - An opening backtick, followed by\n *     - Any text that doesn't include a backtick (captured for marking), followed by\n *     - A closing backtick.\n *  This ensures that any text between backticks is formatted as code,\n *  regardless of the surrounding characters (exception being another backtick).\n */ const inputRegex = /(^|[^`])`([^`]+)`(?!`)/;\n/**\n * Matches inline code while pasting.\n */ const pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;\n/**\n * This extension allows you to mark text as inline code.\n * @see https://tiptap.dev/api/marks/code\n */ const Code = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"code\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    excludes: \"_\",\n    code: true,\n    exitable: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"code\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"code\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setCode: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleCode: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetCode: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-e\": ()=>this.editor.commands.toggleCode()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: inputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: pasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1GO0FBRW5GOzs7Ozs7OztDQVFDLEdBQ0QsTUFBTUksYUFBYTtBQUNuQjs7Q0FFQyxHQUNELE1BQU1DLGFBQWE7QUFDbkI7OztDQUdDLEdBQ0QsTUFBTUMsT0FBT04sOENBQUlBLENBQUNPLE1BQU0sQ0FBQztJQUNyQkMsTUFBTTtJQUNOQztRQUNJLE9BQU87WUFDSEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQyxVQUFVO0lBQ1ZDLE1BQU07SUFDTkMsVUFBVTtJQUNWQztRQUNJLE9BQU87WUFDSDtnQkFBRUMsS0FBSztZQUFPO1NBQ2pCO0lBQ0w7SUFDQUMsWUFBVyxFQUFFTixjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQVFULDZEQUFlQSxDQUFDLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQ1AsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ3BGO0lBQ0FRO1FBQ0ksT0FBTztZQUNIQyxTQUFTLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQ3hCLE9BQU9BLFNBQVNDLE9BQU8sQ0FBQyxJQUFJLENBQUNiLElBQUk7Z0JBQ3JDO1lBQ0FjLFlBQVksSUFBTSxDQUFDLEVBQUVGLFFBQVEsRUFBRTtvQkFDM0IsT0FBT0EsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQ2YsSUFBSTtnQkFDeEM7WUFDQWdCLFdBQVcsSUFBTSxDQUFDLEVBQUVKLFFBQVEsRUFBRTtvQkFDMUIsT0FBT0EsU0FBU0ssU0FBUyxDQUFDLElBQUksQ0FBQ2pCLElBQUk7Z0JBQ3ZDO1FBQ0o7SUFDSjtJQUNBa0I7UUFDSSxPQUFPO1lBQ0gsU0FBUyxJQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDUCxRQUFRLENBQUNFLFVBQVU7UUFDbEQ7SUFDSjtJQUNBTTtRQUNJLE9BQU87WUFDSDFCLDJEQUFhQSxDQUFDO2dCQUNWMkIsTUFBTXpCO2dCQUNOMEIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7U0FDSDtJQUNMO0lBQ0FDO1FBQ0ksT0FBTztZQUNINUIsMkRBQWFBLENBQUM7Z0JBQ1YwQixNQUFNeEI7Z0JBQ055QixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtTQUNIO0lBQ0w7QUFDSjtBQUV5RCxDQUN6RCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUvZGlzdC9pbmRleC5qcz8zNjYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9ucyB0byBtYXRjaCBpbmxpbmUgY29kZSBibG9ja3MgZW5jbG9zZWQgaW4gYmFja3RpY2tzLlxuICogIEl0IG1hdGNoZXM6XG4gKiAgICAgLSBBbiBvcGVuaW5nIGJhY2t0aWNrLCBmb2xsb3dlZCBieVxuICogICAgIC0gQW55IHRleHQgdGhhdCBkb2Vzbid0IGluY2x1ZGUgYSBiYWNrdGljayAoY2FwdHVyZWQgZm9yIG1hcmtpbmcpLCBmb2xsb3dlZCBieVxuICogICAgIC0gQSBjbG9zaW5nIGJhY2t0aWNrLlxuICogIFRoaXMgZW5zdXJlcyB0aGF0IGFueSB0ZXh0IGJldHdlZW4gYmFja3RpY2tzIGlzIGZvcm1hdHRlZCBhcyBjb2RlLFxuICogIHJlZ2FyZGxlc3Mgb2YgdGhlIHN1cnJvdW5kaW5nIGNoYXJhY3RlcnMgKGV4Y2VwdGlvbiBiZWluZyBhbm90aGVyIGJhY2t0aWNrKS5cbiAqL1xuY29uc3QgaW5wdXRSZWdleCA9IC8oXnxbXmBdKWAoW15gXSspYCg/IWApLztcbi8qKlxuICogTWF0Y2hlcyBpbmxpbmUgY29kZSB3aGlsZSBwYXN0aW5nLlxuICovXG5jb25zdCBwYXN0ZVJlZ2V4ID0gLyhefFteYF0pYChbXmBdKylgKD8hYCkvZztcbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBtYXJrIHRleHQgYXMgaW5saW5lIGNvZGUuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbWFya3MvY29kZVxuICovXG5jb25zdCBDb2RlID0gTWFyay5jcmVhdGUoe1xuICAgIG5hbWU6ICdjb2RlJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZXhjbHVkZXM6ICdfJyxcbiAgICBjb2RlOiB0cnVlLFxuICAgIGV4aXRhYmxlOiB0cnVlLFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdGFnOiAnY29kZScgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ2NvZGUnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRDb2RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGVDb2RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldENvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLWUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVDb2RlKCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBwYXN0ZVJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgQ29kZSwgQ29kZSBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4LCBwYXN0ZVJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJNYXJrIiwibWVyZ2VBdHRyaWJ1dGVzIiwibWFya0lucHV0UnVsZSIsIm1hcmtQYXN0ZVJ1bGUiLCJpbnB1dFJlZ2V4IiwicGFzdGVSZWdleCIsIkNvZGUiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsIkhUTUxBdHRyaWJ1dGVzIiwiZXhjbHVkZXMiLCJjb2RlIiwiZXhpdGFibGUiLCJwYXJzZUhUTUwiLCJ0YWciLCJyZW5kZXJIVE1MIiwib3B0aW9ucyIsImFkZENvbW1hbmRzIiwic2V0Q29kZSIsImNvbW1hbmRzIiwic2V0TWFyayIsInRvZ2dsZUNvZGUiLCJ0b2dnbGVNYXJrIiwidW5zZXRDb2RlIiwidW5zZXRNYXJrIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJlZGl0b3IiLCJhZGRJbnB1dFJ1bGVzIiwiZmluZCIsInR5cGUiLCJhZGRQYXN0ZVJ1bGVzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-document/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tiptap/extension-document/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   \"default\": () => (/* binding */ Document)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * The default document node which represents the top level node of the editor.\n * @see https://tiptap.dev/api/nodes/document\n */ const Document = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"doc\",\n    topNode: true,\n    content: \"block+\"\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7QUFFcEM7OztDQUdDLEdBQ0QsTUFBTUMsV0FBV0QsOENBQUlBLENBQUNFLE1BQU0sQ0FBQztJQUN6QkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFNBQVM7QUFDYjtBQUV5QyxDQUN6QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWRvY3VtZW50L2Rpc3QvaW5kZXguanM/Y2NmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBkb2N1bWVudCBub2RlIHdoaWNoIHJlcHJlc2VudHMgdGhlIHRvcCBsZXZlbCBub2RlIG9mIHRoZSBlZGl0b3IuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbm9kZXMvZG9jdW1lbnRcbiAqL1xuY29uc3QgRG9jdW1lbnQgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2RvYycsXG4gICAgdG9wTm9kZTogdHJ1ZSxcbiAgICBjb250ZW50OiAnYmxvY2srJyxcbn0pO1xuXG5leHBvcnQgeyBEb2N1bWVudCwgRG9jdW1lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTm9kZSIsIkRvY3VtZW50IiwiY3JlYXRlIiwibmFtZSIsInRvcE5vZGUiLCJjb250ZW50IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-dropcursor/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-dropcursor/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dropcursor: () => (/* binding */ Dropcursor),\n/* harmony export */   \"default\": () => (/* binding */ Dropcursor)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/dropcursor */ \"(ssr)/./node_modules/@tiptap/pm/dropcursor/dist/index.js\");\n\n\n/**\n * This extension allows you to add a drop cursor to your editor.\n * A drop cursor is a line that appears when you drag and drop content\n * inbetween nodes.\n * @see https://tiptap.dev/api/extensions/dropcursor\n */ const Dropcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"dropCursor\",\n    addOptions () {\n        return {\n            color: \"currentColor\",\n            width: 1,\n            class: undefined\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            (0,_tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)(this.options)\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZHJvcGN1cnNvci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7QUFDVTtBQUVuRDs7Ozs7Q0FLQyxHQUNELE1BQU1FLGFBQWFGLG1EQUFTQSxDQUFDRyxNQUFNLENBQUM7SUFDaENDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLE9BQU87WUFDUEMsT0FBTztZQUNQQyxPQUFPQztRQUNYO0lBQ0o7SUFDQUM7UUFDSSxPQUFPO1lBQ0hULGlFQUFVQSxDQUFDLElBQUksQ0FBQ1UsT0FBTztTQUMxQjtJQUNMO0FBQ0o7QUFFNkMsQ0FDN0MsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1kcm9wY3Vyc29yL2Rpc3QvaW5kZXguanM/ZjljMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgZHJvcEN1cnNvciB9IGZyb20gJ0B0aXB0YXAvcG0vZHJvcGN1cnNvcic7XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBhZGQgYSBkcm9wIGN1cnNvciB0byB5b3VyIGVkaXRvci5cbiAqIEEgZHJvcCBjdXJzb3IgaXMgYSBsaW5lIHRoYXQgYXBwZWFycyB3aGVuIHlvdSBkcmFnIGFuZCBkcm9wIGNvbnRlbnRcbiAqIGluYmV0d2VlbiBub2Rlcy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2Ryb3BjdXJzb3JcbiAqL1xuY29uc3QgRHJvcGN1cnNvciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdkcm9wQ3Vyc29yJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICBjbGFzczogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZHJvcEN1cnNvcih0aGlzLm9wdGlvbnMpLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgRHJvcGN1cnNvciwgRHJvcGN1cnNvciBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJFeHRlbnNpb24iLCJkcm9wQ3Vyc29yIiwiRHJvcGN1cnNvciIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiY29sb3IiLCJ3aWR0aCIsImNsYXNzIiwidW5kZWZpbmVkIiwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zIiwib3B0aW9ucyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-dropcursor/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-floating-menu/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-floating-menu/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FloatingMenu: () => (/* binding */ FloatingMenu),\n/* harmony export */   FloatingMenuPlugin: () => (/* binding */ FloatingMenuPlugin),\n/* harmony export */   FloatingMenuView: () => (/* binding */ FloatingMenuView),\n/* harmony export */   \"default\": () => (/* binding */ FloatingMenu)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tippy.js */ \"(ssr)/./node_modules/tippy.js/dist/tippy.esm.js\");\n\n\n\nclass FloatingMenuView {\n    getTextContent(node) {\n        return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getText)(node, {\n            textSerializers: (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getTextSerializersFromSchema)(this.editor.schema)\n        });\n    }\n    constructor({ editor, element, view, tippyOptions = {}, shouldShow }){\n        this.preventHide = false;\n        this.shouldShow = ({ view, state })=>{\n            const { selection } = state;\n            const { $anchor, empty } = selection;\n            const isRootDepth = $anchor.depth === 1;\n            const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent && $anchor.parent.childCount === 0 && !this.getTextContent($anchor.parent);\n            if (!view.hasFocus() || !empty || !isRootDepth || !isEmptyTextBlock || !this.editor.isEditable) {\n                return false;\n            }\n            return true;\n        };\n        this.mousedownHandler = ()=>{\n            this.preventHide = true;\n        };\n        this.focusHandler = ()=>{\n            // we use `setTimeout` to make sure `selection` is already updated\n            setTimeout(()=>this.update(this.editor.view));\n        };\n        this.blurHandler = ({ event })=>{\n            var _a;\n            if (this.preventHide) {\n                this.preventHide = false;\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {\n                return;\n            }\n            this.hide();\n        };\n        this.tippyBlurHandler = (event)=>{\n            this.blurHandler({\n                event\n            });\n        };\n        this.editor = editor;\n        this.element = element;\n        this.view = view;\n        if (shouldShow) {\n            this.shouldShow = shouldShow;\n        }\n        this.element.addEventListener(\"mousedown\", this.mousedownHandler, {\n            capture: true\n        });\n        this.editor.on(\"focus\", this.focusHandler);\n        this.editor.on(\"blur\", this.blurHandler);\n        this.tippyOptions = tippyOptions;\n        // Detaches menu content from its current parent\n        this.element.remove();\n        this.element.style.visibility = \"visible\";\n    }\n    createTooltip() {\n        const { element: editorElement } = this.editor.options;\n        const editorIsAttached = !!editorElement.parentElement;\n        if (this.tippy || !editorIsAttached) {\n            return;\n        }\n        this.tippy = (0,tippy_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(editorElement, {\n            duration: 0,\n            getReferenceClientRect: null,\n            content: this.element,\n            interactive: true,\n            trigger: \"manual\",\n            placement: \"right\",\n            hideOnClick: \"toggle\",\n            ...this.tippyOptions\n        });\n        // maybe we have to hide tippy on its own blur event as well\n        if (this.tippy.popper.firstChild) {\n            this.tippy.popper.firstChild.addEventListener(\"blur\", this.tippyBlurHandler);\n        }\n    }\n    update(view, oldState) {\n        var _a, _b, _c;\n        const { state } = view;\n        const { doc, selection } = state;\n        const { from, to } = selection;\n        const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n        if (isSame) {\n            return;\n        }\n        this.createTooltip();\n        const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n            editor: this.editor,\n            view,\n            state,\n            oldState\n        });\n        if (!shouldShow) {\n            this.hide();\n            return;\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n            getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (()=>(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.posToDOMRect)(view, from, to))\n        });\n        this.show();\n    }\n    show() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n    }\n    hide() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    destroy() {\n        var _a, _b;\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n            this.tippy.popper.firstChild.removeEventListener(\"blur\", this.tippyBlurHandler);\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.element.removeEventListener(\"mousedown\", this.mousedownHandler, {\n            capture: true\n        });\n        this.editor.off(\"focus\", this.focusHandler);\n        this.editor.off(\"blur\", this.blurHandler);\n    }\n}\nconst FloatingMenuPlugin = (options)=>{\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: typeof options.pluginKey === \"string\" ? new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(options.pluginKey) : options.pluginKey,\n        view: (view)=>new FloatingMenuView({\n                view,\n                ...options\n            })\n    });\n};\n/**\n * This extension allows you to create a floating menu.\n * @see https://tiptap.dev/api/extensions/floating-menu\n */ const FloatingMenu = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"floatingMenu\",\n    addOptions () {\n        return {\n            element: null,\n            tippyOptions: {},\n            pluginKey: \"floatingMenu\",\n            shouldShow: null\n        };\n    },\n    addProseMirrorPlugins () {\n        if (!this.options.element) {\n            return [];\n        }\n        return [\n            FloatingMenuPlugin({\n                pluginKey: this.options.pluginKey,\n                editor: this.editor,\n                element: this.options.element,\n                tippyOptions: this.options.tippyOptions,\n                shouldShow: this.options.shouldShow\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZmxvYXRpbmctbWVudS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBOEY7QUFDekM7QUFDeEI7QUFFN0IsTUFBTU87SUFDRkMsZUFBZUMsSUFBSSxFQUFFO1FBQ2pCLE9BQU9ULHFEQUFPQSxDQUFDUyxNQUFNO1lBQUVDLGlCQUFpQlQsMEVBQTRCQSxDQUFDLElBQUksQ0FBQ1UsTUFBTSxDQUFDQyxNQUFNO1FBQUU7SUFDN0Y7SUFDQUMsWUFBWSxFQUFFRixNQUFNLEVBQUVHLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxlQUFlLENBQUMsQ0FBQyxFQUFFQyxVQUFVLEVBQUcsQ0FBRTtRQUNuRSxJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNELFVBQVUsR0FBRyxDQUFDLEVBQUVGLElBQUksRUFBRUksS0FBSyxFQUFFO1lBQzlCLE1BQU0sRUFBRUMsU0FBUyxFQUFFLEdBQUdEO1lBQ3RCLE1BQU0sRUFBRUUsT0FBTyxFQUFFQyxLQUFLLEVBQUUsR0FBR0Y7WUFDM0IsTUFBTUcsY0FBY0YsUUFBUUcsS0FBSyxLQUFLO1lBQ3RDLE1BQU1DLG1CQUFtQkosUUFBUUssTUFBTSxDQUFDQyxXQUFXLElBQUksQ0FBQ04sUUFBUUssTUFBTSxDQUFDRSxJQUFJLENBQUNDLElBQUksQ0FBQ0MsSUFBSSxJQUFJLENBQUNULFFBQVFLLE1BQU0sQ0FBQ0ssV0FBVyxJQUFJVixRQUFRSyxNQUFNLENBQUNNLFVBQVUsS0FBSyxLQUFLLENBQUMsSUFBSSxDQUFDeEIsY0FBYyxDQUFDYSxRQUFRSyxNQUFNO1lBQzlMLElBQUksQ0FBQ1gsS0FBS2tCLFFBQVEsTUFDWCxDQUFDWCxTQUNELENBQUNDLGVBQ0QsQ0FBQ0Usb0JBQ0QsQ0FBQyxJQUFJLENBQUNkLE1BQU0sQ0FBQ3VCLFVBQVUsRUFBRTtnQkFDNUIsT0FBTztZQUNYO1lBQ0EsT0FBTztRQUNYO1FBQ0EsSUFBSSxDQUFD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QUFTO1lBQ1RFLGNBQWMsQ0FBQztZQUNmb0UsV0FBVztZQUNYbkUsWUFBWTtRQUNoQjtJQUNKO0lBQ0F3RTtRQUNJLElBQUksQ0FBQyxJQUFJLENBQUNqQyxPQUFPLENBQUMxQyxPQUFPLEVBQUU7WUFDdkIsT0FBTyxFQUFFO1FBQ2I7UUFDQSxPQUFPO1lBQ0hvRSxtQkFBbUI7Z0JBQ2ZFLFdBQVcsSUFBSSxDQUFDNUIsT0FBTyxDQUFDNEIsU0FBUztnQkFDakN6RSxRQUFRLElBQUksQ0FBQ0EsTUFBTTtnQkFDbkJHLFNBQVMsSUFBSSxDQUFDMEMsT0FBTyxDQUFDMUMsT0FBTztnQkFDN0JFLGNBQWMsSUFBSSxDQUFDd0MsT0FBTyxDQUFDeEMsWUFBWTtnQkFDdkNDLFlBQVksSUFBSSxDQUFDdUMsT0FBTyxDQUFDdkMsVUFBVTtZQUN2QztTQUNIO0lBQ0w7QUFDSjtBQUV1RixDQUN2RixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWZsb2F0aW5nLW1lbnUvZGlzdC9pbmRleC5qcz82NWUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFRleHQsIGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEsIHBvc1RvRE9NUmVjdCwgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5pbXBvcnQgdGlwcHkgZnJvbSAndGlwcHkuanMnO1xuXG5jbGFzcyBGbG9hdGluZ01lbnVWaWV3IHtcbiAgICBnZXRUZXh0Q29udGVudChub2RlKSB7XG4gICAgICAgIHJldHVybiBnZXRUZXh0KG5vZGUsIHsgdGV4dFNlcmlhbGl6ZXJzOiBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHRoaXMuZWRpdG9yLnNjaGVtYSkgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgZWRpdG9yLCBlbGVtZW50LCB2aWV3LCB0aXBweU9wdGlvbnMgPSB7fSwgc2hvdWxkU2hvdywgfSkge1xuICAgICAgICB0aGlzLnByZXZlbnRIaWRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvdWxkU2hvdyA9ICh7IHZpZXcsIHN0YXRlIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHsgJGFuY2hvciwgZW1wdHkgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGlzUm9vdERlcHRoID0gJGFuY2hvci5kZXB0aCA9PT0gMTtcbiAgICAgICAgICAgIGNvbnN0IGlzRW1wdHlUZXh0QmxvY2sgPSAkYW5jaG9yLnBhcmVudC5pc1RleHRibG9jayAmJiAhJGFuY2hvci5wYXJlbnQudHlwZS5zcGVjLmNvZGUgJiYgISRhbmNob3IucGFyZW50LnRleHRDb250ZW50ICYmICRhbmNob3IucGFyZW50LmNoaWxkQ291bnQgPT09IDAgJiYgIXRoaXMuZ2V0VGV4dENvbnRlbnQoJGFuY2hvci5wYXJlbnQpO1xuICAgICAgICAgICAgaWYgKCF2aWV3Lmhhc0ZvY3VzKClcbiAgICAgICAgICAgICAgICB8fCAhZW1wdHlcbiAgICAgICAgICAgICAgICB8fCAhaXNSb290RGVwdGhcbiAgICAgICAgICAgICAgICB8fCAhaXNFbXB0eVRleHRCbG9ja1xuICAgICAgICAgICAgICAgIHx8ICF0aGlzLmVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubW91c2Vkb3duSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJldmVudEhpZGUgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZvY3VzSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIHVzZSBgc2V0VGltZW91dGAgdG8gbWFrZSBzdXJlIGBzZWxlY3Rpb25gIGlzIGFscmVhZHkgdXBkYXRlZFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnVwZGF0ZSh0aGlzLmVkaXRvci52aWV3KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmx1ckhhbmRsZXIgPSAoeyBldmVudCB9KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2ZW50SGlkZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmVudEhpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudC5yZWxhdGVkVGFyZ2V0KSAmJiAoKF9hID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudC5yZWxhdGVkVGFyZ2V0KSA9PT0gdGhpcy5lZGl0b3Iudmlldy5kb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50aXBweUJsdXJIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJsdXJIYW5kbGVyKHsgZXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICBpZiAoc2hvdWxkU2hvdykge1xuICAgICAgICAgICAgdGhpcy5zaG91bGRTaG93ID0gc2hvdWxkU2hvdztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd25IYW5kbGVyLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcbiAgICAgICAgdGhpcy50aXBweU9wdGlvbnMgPSB0aXBweU9wdGlvbnM7XG4gICAgICAgIC8vIERldGFjaGVzIG1lbnUgY29udGVudCBmcm9tIGl0cyBjdXJyZW50IHBhcmVudFxuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIH1cbiAgICBjcmVhdGVUb29sdGlwKCkge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQ6IGVkaXRvckVsZW1lbnQgfSA9IHRoaXMuZWRpdG9yLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGVkaXRvcklzQXR0YWNoZWQgPSAhIWVkaXRvckVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMudGlwcHkgfHwgIWVkaXRvcklzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpcHB5ID0gdGlwcHkoZWRpdG9yRWxlbWVudCwge1xuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBudWxsLFxuICAgICAgICAgICAgY29udGVudDogdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgICAgICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgICAgICAgICAgIGhpZGVPbkNsaWNrOiAndG9nZ2xlJyxcbiAgICAgICAgICAgIC4uLnRoaXMudGlwcHlPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gbWF5YmUgd2UgaGF2ZSB0byBoaWRlIHRpcHB5IG9uIGl0cyBvd24gYmx1ciBldmVudCBhcyB3ZWxsXG4gICAgICAgIGlmICh0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3LCBvbGRTdGF0ZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gdmlldztcbiAgICAgICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgY29uc3QgaXNTYW1lID0gb2xkU3RhdGUgJiYgb2xkU3RhdGUuZG9jLmVxKGRvYykgJiYgb2xkU3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbik7XG4gICAgICAgIGlmIChpc1NhbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWF0ZVRvb2x0aXAoKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkU2hvdyA9IChfYSA9IHRoaXMuc2hvdWxkU2hvdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywge1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIG9sZFN0YXRlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzaG91bGRTaG93KSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoX2IgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2V0UHJvcHMoe1xuICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogKChfYyA9IHRoaXMudGlwcHlPcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCkgfHwgKCgpID0+IHBvc1RvRE9NUmVjdCh2aWV3LCBmcm9tLCB0bykpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNob3coKTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGlkZSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcik7XG4gICAgfVxufVxuY29uc3QgRmxvYXRpbmdNZW51UGx1Z2luID0gKG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogdHlwZW9mIG9wdGlvbnMucGx1Z2luS2V5ID09PSAnc3RyaW5nJyA/IG5ldyBQbHVnaW5LZXkob3B0aW9ucy5wbHVnaW5LZXkpIDogb3B0aW9ucy5wbHVnaW5LZXksXG4gICAgICAgIHZpZXc6IHZpZXcgPT4gbmV3IEZsb2F0aW5nTWVudVZpZXcoeyB2aWV3LCAuLi5vcHRpb25zIH0pLFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBhIGZsb2F0aW5nIG1lbnUuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9mbG9hdGluZy1tZW51XG4gKi9cbmNvbnN0IEZsb2F0aW5nTWVudSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdmbG9hdGluZ01lbnUnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbGVtZW50OiBudWxsLFxuICAgICAgICAgICAgdGlwcHlPcHRpb25zOiB7fSxcbiAgICAgICAgICAgIHBsdWdpbktleTogJ2Zsb2F0aW5nTWVudScsXG4gICAgICAgICAgICBzaG91bGRTaG93OiBudWxsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEZsb2F0aW5nTWVudVBsdWdpbih7XG4gICAgICAgICAgICAgICAgcGx1Z2luS2V5OiB0aGlzLm9wdGlvbnMucGx1Z2luS2V5LFxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5vcHRpb25zLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGlwcHlPcHRpb25zOiB0aGlzLm9wdGlvbnMudGlwcHlPcHRpb25zLFxuICAgICAgICAgICAgICAgIHNob3VsZFNob3c6IHRoaXMub3B0aW9ucy5zaG91bGRTaG93LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBGbG9hdGluZ01lbnUsIEZsb2F0aW5nTWVudVBsdWdpbiwgRmxvYXRpbmdNZW51VmlldywgRmxvYXRpbmdNZW51IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbImdldFRleHQiLCJnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hIiwicG9zVG9ET01SZWN0IiwiRXh0ZW5zaW9uIiwiUGx1Z2luIiwiUGx1Z2luS2V5IiwidGlwcHkiLCJGbG9hdGluZ01lbnVWaWV3IiwiZ2V0VGV4dENvbnRlbnQiLCJub2RlIiwidGV4dFNlcmlhbGl6ZXJzIiwiZWRpdG9yIiwic2NoZW1hIiwiY29uc3RydWN0b3IiLCJlbGVtZW50IiwidmlldyIsInRpcHB5T3B0aW9ucyIsInNob3VsZFNob3ciLCJwcmV2ZW50SGlkZSIsInN0YXRlIiwic2VsZWN0aW9uIiwiJGFuY2hvciIsImVtcHR5IiwiaXNSb290RGVwdGgiLCJkZXB0aCIsImlzRW1wdHlUZXh0QmxvY2siLCJwYXJlbnQiLCJpc1RleHRibG9jayIsInR5cGUiLCJzcGVjIiwiY29kZSIsInRleHRDb250ZW50IiwiY2hpbGRDb3VudCIsImhhc0ZvY3VzIiwiaXNFZGl0YWJsZSIsIm1vdXNlZG93bkhhbmRsZXIiLCJmb2N1c0hhbmRsZXIiLCJzZXRUaW1lb3V0IiwidXBkYXRlIiwiYmx1ckhhbmRsZXIiLCJldmVudCIsIl9hIiwicmVsYXRlZFRhcmdldCIsInBhcmVudE5vZGUiLCJjb250YWlucyIsImRvbSIsImhpZGUiLCJ0aXBweUJsdXJIYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhcHR1cmUiLCJvbiIsInJlbW92ZSIsInN0eWxlIiwidmlzaWJpbGl0eSIsImNyZWF0ZVRvb2x0aXAiLCJlZGl0b3JFbGVtZW50Iiwib3B0aW9ucyIsImVkaXRvcklzQXR0YWNoZWQiLCJwYXJlbnRFbGVtZW50IiwiZHVyYXRpb24iLCJnZXRSZWZlcmVuY2VDbGllbnRSZWN0IiwiY29udGVudCIsImludGVyYWN0aXZlIiwidHJpZ2dlciIsInBsYWNlbWVudCIsImhpZGVPbkNsaWNrIiwicG9wcGVyIiwiZmlyc3RDaGlsZCIsIm9sZFN0YXRlIiwiX2IiLCJfYyIsImRvYyIsImZyb20iLCJ0byIsImlzU2FtZSIsImVxIiwiY2FsbCIsInNldFByb3BzIiwic2hvdyIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib2ZmIiwiRmxvYXRpbmdNZW51UGx1Z2luIiwia2V5IiwicGx1Z2luS2V5IiwiRmxvYXRpbmdNZW51IiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJhZGRQcm9zZU1pcnJvclBsdWdpbnMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-floating-menu/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-gapcursor/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-gapcursor/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Gapcursor: () => (/* binding */ Gapcursor),\n/* harmony export */   \"default\": () => (/* binding */ Gapcursor)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/gapcursor */ \"(ssr)/./node_modules/@tiptap/pm/gapcursor/dist/index.js\");\n\n\n/**\n * This extension allows you to add a gap cursor to your editor.\n * A gap cursor is a cursor that appears when you click on a place\n * where no content is present, for example inbetween nodes.\n * @see https://tiptap.dev/api/extensions/gapcursor\n */ const Gapcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"gapCursor\",\n    addProseMirrorPlugins () {\n        return [\n            (0,_tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)()\n        ];\n    },\n    extendNodeSchema (extension) {\n        var _a;\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage\n        };\n        return {\n            allowGapCursor: (_a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.callOrReturn)((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getExtensionField)(extension, \"allowGapCursor\", context))) !== null && _a !== void 0 ? _a : null\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZ2FwY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEwRTtBQUN6QjtBQUVqRDs7Ozs7Q0FLQyxHQUNELE1BQU1JLFlBQVlKLG1EQUFTQSxDQUFDSyxNQUFNLENBQUM7SUFDL0JDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hKLCtEQUFTQTtTQUNaO0lBQ0w7SUFDQUssa0JBQWlCQyxTQUFTO1FBQ3RCLElBQUlDO1FBQ0osTUFBTUMsVUFBVTtZQUNaTCxNQUFNRyxVQUFVSCxJQUFJO1lBQ3BCTSxTQUFTSCxVQUFVRyxPQUFPO1lBQzFCQyxTQUFTSixVQUFVSSxPQUFPO1FBQzlCO1FBQ0EsT0FBTztZQUNIQyxnQkFBZ0IsQ0FBQ0osS0FBS1QsMERBQVlBLENBQUNDLCtEQUFpQkEsQ0FBQ08sV0FBVyxrQkFBa0JFLFNBQVEsTUFBTyxRQUFRRCxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUNsSTtJQUNKO0FBQ0o7QUFFMkMsQ0FDM0MsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcz8wZGY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiwgY2FsbE9yUmV0dXJuLCBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBnYXBDdXJzb3IgfSBmcm9tICdAdGlwdGFwL3BtL2dhcGN1cnNvcic7XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBhZGQgYSBnYXAgY3Vyc29yIHRvIHlvdXIgZWRpdG9yLlxuICogQSBnYXAgY3Vyc29yIGlzIGEgY3Vyc29yIHRoYXQgYXBwZWFycyB3aGVuIHlvdSBjbGljayBvbiBhIHBsYWNlXG4gKiB3aGVyZSBubyBjb250ZW50IGlzIHByZXNlbnQsIGZvciBleGFtcGxlIGluYmV0d2VlbiBub2Rlcy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2dhcGN1cnNvclxuICovXG5jb25zdCBHYXBjdXJzb3IgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnZ2FwQ3Vyc29yJyxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBnYXBDdXJzb3IoKSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFsbG93R2FwQ3Vyc29yOiAoX2EgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWxsb3dHYXBDdXJzb3InLCBjb250ZXh0KSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBHYXBjdXJzb3IsIEdhcGN1cnNvciBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJFeHRlbnNpb24iLCJjYWxsT3JSZXR1cm4iLCJnZXRFeHRlbnNpb25GaWVsZCIsImdhcEN1cnNvciIsIkdhcGN1cnNvciIsImNyZWF0ZSIsIm5hbWUiLCJhZGRQcm9zZU1pcnJvclBsdWdpbnMiLCJleHRlbmROb2RlU2NoZW1hIiwiZXh0ZW5zaW9uIiwiX2EiLCJjb250ZXh0Iiwib3B0aW9ucyIsInN0b3JhZ2UiLCJhbGxvd0dhcEN1cnNvciIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-gapcursor/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-hard-break/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HardBreak: () => (/* binding */ HardBreak),\n/* harmony export */   \"default\": () => (/* binding */ HardBreak)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * This extension allows you to insert hard breaks.\n * @see https://www.tiptap.dev/api/nodes/hard-break\n */ const HardBreak = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"hardBreak\",\n    addOptions () {\n        return {\n            keepMarks: true,\n            HTMLAttributes: {}\n        };\n    },\n    inline: true,\n    group: \"inline\",\n    selectable: false,\n    linebreakReplacement: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"br\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"br\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)\n        ];\n    },\n    renderText () {\n        return \"\\n\";\n    },\n    addCommands () {\n        return {\n            setHardBreak: ()=>({ commands, chain, state, editor })=>{\n                    return commands.first([\n                        ()=>commands.exitCode(),\n                        ()=>commands.command(()=>{\n                                const { selection, storedMarks } = state;\n                                if (selection.$from.parent.type.spec.isolating) {\n                                    return false;\n                                }\n                                const { keepMarks } = this.options;\n                                const { splittableMarks } = editor.extensionManager;\n                                const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n                                return chain().insertContent({\n                                    type: this.name\n                                }).command(({ tr, dispatch })=>{\n                                    if (dispatch && marks && keepMarks) {\n                                        const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n                                        tr.ensureMarks(filteredMarks);\n                                    }\n                                    return true;\n                                }).run();\n                            })\n                    ]);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Enter\": ()=>this.editor.commands.setHardBreak(),\n            \"Shift-Enter\": ()=>this.editor.commands.setHardBreak()\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRDtBQUVyRDs7O0NBR0MsR0FDRCxNQUFNRSxZQUFZRiw4Q0FBSUEsQ0FBQ0csTUFBTSxDQUFDO0lBQzFCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxXQUFXO1lBQ1hDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUMsUUFBUTtJQUNSQyxPQUFPO0lBQ1BDLFlBQVk7SUFDWkMsc0JBQXNCO0lBQ3RCQztRQUNJLE9BQU87WUFDSDtnQkFBRUMsS0FBSztZQUFLO1NBQ2Y7SUFDTDtJQUNBQyxZQUFXLEVBQUVQLGNBQWMsRUFBRTtRQUN6QixPQUFPO1lBQUM7WUFBTU4sNkRBQWVBLENBQUMsSUFBSSxDQUFDYyxPQUFPLENBQUNSLGNBQWMsRUFBRUE7U0FBZ0I7SUFDL0U7SUFDQVM7UUFDSSxPQUFPO0lBQ1g7SUFDQUM7UUFDSSxPQUFPO1lBQ0hDLGNBQWMsSUFBTSxDQUFDLEVBQUVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRztvQkFDcEQsT0FBT0gsU0FBU0ksS0FBSyxDQUFDO3dCQUNsQixJQUFNSixTQUFTSyxRQUFRO3dCQUN2QixJQUFNTCxTQUFTTSxPQUFPLENBQUM7Z0NBQ25CLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxXQUFXLEVBQUUsR0FBR047Z0NBQ25DLElBQUlLLFVBQVVFLEtBQUssQ0FBQ0MsTUFBTSxDQUFDQyxJQUFJLENBQUNDLElBQUksQ0FBQ0MsU0FBUyxFQUFFO29DQUM1QyxPQUFPO2dDQUNYO2dDQUNBLE1BQU0sRUFBRTFCLFNBQVMsRUFBRSxHQUFHLElBQUksQ0FBQ1MsT0FBTztnQ0FDbEMsTUFBTSxFQUFFa0IsZUFBZSxFQUFFLEdBQUdYLE9BQU9ZLGdCQUFnQjtnQ0FDbkQsTUFBTUMsUUFBUVIsZUFDTkQsVUFBVVUsR0FBRyxDQUFDQyxZQUFZLElBQUlYLFVBQVVFLEtBQUssQ0FBQ08sS0FBSztnQ0FDM0QsT0FBT2YsUUFDRmtCLGFBQWEsQ0FBQztvQ0FBRVIsTUFBTSxJQUFJLENBQUMxQixJQUFJO2dDQUFDLEdBQ2hDcUIsT0FBTyxDQUFDLENBQUMsRUFBRWMsRUFBRSxFQUFFQyxRQUFRLEVBQUU7b0NBQzFCLElBQUlBLFlBQVlMLFNBQVM3QixXQUFXO3dDQUNoQyxNQUFNbUMsZ0JBQWdCTixNQUNqQk8sTUFBTSxDQUFDQyxDQUFBQSxPQUFRVixnQkFBZ0JXLFFBQVEsQ0FBQ0QsS0FBS2IsSUFBSSxDQUFDMUIsSUFBSTt3Q0FDM0RtQyxHQUFHTSxXQUFXLENBQUNKO29DQUNuQjtvQ0FDQSxPQUFPO2dDQUNYLEdBQ0tLLEdBQUc7NEJBQ1o7cUJBQ0g7Z0JBQ0w7UUFDSjtJQUNKO0lBQ0FDO1FBQ0ksT0FBTztZQUNILGFBQWEsSUFBTSxJQUFJLENBQUN6QixNQUFNLENBQUNILFFBQVEsQ0FBQ0QsWUFBWTtZQUNwRCxlQUFlLElBQU0sSUFBSSxDQUFDSSxNQUFNLENBQUNILFFBQVEsQ0FBQ0QsWUFBWTtRQUMxRDtJQUNKO0FBQ0o7QUFFMkMsQ0FDM0MsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oYXJkLWJyZWFrL2Rpc3QvaW5kZXguanM/MDE1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gaW5zZXJ0IGhhcmQgYnJlYWtzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9oYXJkLWJyZWFrXG4gKi9cbmNvbnN0IEhhcmRCcmVhayA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAnaGFyZEJyZWFrJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2VlcE1hcmtzOiB0cnVlLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaW5saW5lOiB0cnVlLFxuICAgIGdyb3VwOiAnaW5saW5lJyxcbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICBsaW5lYnJlYWtSZXBsYWNlbWVudDogdHJ1ZSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHRhZzogJ2JyJyB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsnYnInLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyldO1xuICAgIH0sXG4gICAgcmVuZGVyVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuICdcXG4nO1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRIYXJkQnJlYWs6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiwgc3RhdGUsIGVkaXRvciwgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5maXJzdChbXG4gICAgICAgICAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmV4aXRDb2RlKCksXG4gICAgICAgICAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGtlZXBNYXJrcyB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnNlcnRDb250ZW50KHsgdHlwZTogdGhpcy5uYW1lIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbW1hbmQoKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2ggJiYgbWFya3MgJiYga2VlcE1hcmtzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ydW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLUVudGVyJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0SGFyZEJyZWFrKCksXG4gICAgICAgICAgICAnU2hpZnQtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRIYXJkQnJlYWsoKSxcbiAgICAgICAgfTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEhhcmRCcmVhaywgSGFyZEJyZWFrIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJtZXJnZUF0dHJpYnV0ZXMiLCJIYXJkQnJlYWsiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsImtlZXBNYXJrcyIsIkhUTUxBdHRyaWJ1dGVzIiwiaW5saW5lIiwiZ3JvdXAiLCJzZWxlY3RhYmxlIiwibGluZWJyZWFrUmVwbGFjZW1lbnQiLCJwYXJzZUhUTUwiLCJ0YWciLCJyZW5kZXJIVE1MIiwib3B0aW9ucyIsInJlbmRlclRleHQiLCJhZGRDb21tYW5kcyIsInNldEhhcmRCcmVhayIsImNvbW1hbmRzIiwiY2hhaW4iLCJzdGF0ZSIsImVkaXRvciIsImZpcnN0IiwiZXhpdENvZGUiLCJjb21tYW5kIiwic2VsZWN0aW9uIiwic3RvcmVkTWFya3MiLCIkZnJvbSIsInBhcmVudCIsInR5cGUiLCJzcGVjIiwiaXNvbGF0aW5nIiwic3BsaXR0YWJsZU1hcmtzIiwiZXh0ZW5zaW9uTWFuYWdlciIsIm1hcmtzIiwiJHRvIiwicGFyZW50T2Zmc2V0IiwiaW5zZXJ0Q29udGVudCIsInRyIiwiZGlzcGF0Y2giLCJmaWx0ZXJlZE1hcmtzIiwiZmlsdGVyIiwibWFyayIsImluY2x1ZGVzIiwiZW5zdXJlTWFya3MiLCJydW4iLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-heading/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Heading: () => (/* binding */ Heading),\n/* harmony export */   \"default\": () => (/* binding */ Heading)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * This extension allows you to create headings.\n * @see https://www.tiptap.dev/api/nodes/heading\n */ const Heading = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"heading\",\n    addOptions () {\n        return {\n            levels: [\n                1,\n                2,\n                3,\n                4,\n                5,\n                6\n            ],\n            HTMLAttributes: {}\n        };\n    },\n    content: \"inline*\",\n    group: \"block\",\n    defining: true,\n    addAttributes () {\n        return {\n            level: {\n                default: 1,\n                rendered: false\n            }\n        };\n    },\n    parseHTML () {\n        return this.options.levels.map((level)=>({\n                tag: `h${level}`,\n                attrs: {\n                    level\n                }\n            }));\n    },\n    renderHTML ({ node, HTMLAttributes }) {\n        const hasLevel = this.options.levels.includes(node.attrs.level);\n        const level = hasLevel ? node.attrs.level : this.options.levels[0];\n        return [\n            `h${level}`,\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setHeading: (attributes)=>({ commands })=>{\n                    if (!this.options.levels.includes(attributes.level)) {\n                        return false;\n                    }\n                    return commands.setNode(this.name, attributes);\n                },\n            toggleHeading: (attributes)=>({ commands })=>{\n                    if (!this.options.levels.includes(attributes.level)) {\n                        return false;\n                    }\n                    return commands.toggleNode(this.name, \"paragraph\", attributes);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return this.options.levels.reduce((items, level)=>({\n                ...items,\n                ...{\n                    [`Mod-Alt-${level}`]: ()=>this.editor.commands.toggleHeading({\n                            level\n                        })\n                }\n            }), {});\n    },\n    addInputRules () {\n        return this.options.levels.map((level)=>{\n            return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule)({\n                find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\\\s$`),\n                type: this.type,\n                getAttributes: {\n                    level\n                }\n            });\n        });\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2RTtBQUU3RTs7O0NBR0MsR0FDRCxNQUFNRyxVQUFVSCw4Q0FBSUEsQ0FBQ0ksTUFBTSxDQUFDO0lBQ3hCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxRQUFRO2dCQUFDO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2FBQUU7WUFDMUJDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLFVBQVU7SUFDVkM7UUFDSSxPQUFPO1lBQ0hDLE9BQU87Z0JBQ0hDLFNBQVM7Z0JBQ1RDLFVBQVU7WUFDZDtRQUNKO0lBQ0o7SUFDQUM7UUFDSSxPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDVixNQUFNLENBQ3JCVyxHQUFHLENBQUMsQ0FBQ0wsUUFBVztnQkFDakJNLEtBQUssQ0FBQyxDQUFDLEVBQUVOLE1BQU0sQ0FBQztnQkFDaEJPLE9BQU87b0JBQUVQO2dCQUFNO1lBQ25CO0lBQ0o7SUFDQVEsWUFBVyxFQUFFQyxJQUFJLEVBQUVkLGNBQWMsRUFBRTtRQUMvQixNQUFNZSxXQUFXLElBQUksQ0FBQ04sT0FBTyxDQUFDVixNQUFNLENBQUNpQixRQUFRLENBQUNGLEtBQUtGLEtBQUssQ0FBQ1AsS0FBSztRQUM5RCxNQUFNQSxRQUFRVSxXQUNSRCxLQUFLRixLQUFLLENBQUNQLEtBQUssR0FDaEIsSUFBSSxDQUFDSSxPQUFPLENBQUNWLE1BQU0sQ0FBQyxFQUFFO1FBQzVCLE9BQU87WUFBQyxDQUFDLENBQUMsRUFBRU0sTUFBTSxDQUFDO1lBQUVaLDZEQUFlQSxDQUFDLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQ1QsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ3pGO0lBQ0FpQjtRQUNJLE9BQU87WUFDSEMsWUFBWUMsQ0FBQUEsYUFBYyxDQUFDLEVBQUVDLFFBQVEsRUFBRTtvQkFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQ1gsT0FBTyxDQUFDVixNQUFNLENBQUNpQixRQUFRLENBQUNHLFdBQVdkLEtBQUssR0FBRzt3QkFDakQsT0FBTztvQkFDWDtvQkFDQSxPQUFPZSxTQUFTQyxPQUFPLENBQUMsSUFBSSxDQUFDeEIsSUFBSSxFQUFFc0I7Z0JBQ3ZDO1lBQ0FHLGVBQWVILENBQUFBLGFBQWMsQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUNYLE9BQU8sQ0FBQ1YsTUFBTSxDQUFDaUIsUUFBUSxDQUFDRyxXQUFXZCxLQUFLLEdBQUc7d0JBQ2pELE9BQU87b0JBQ1g7b0JBQ0EsT0FBT2UsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQzFCLElBQUksRUFBRSxhQUFhc0I7Z0JBQ3ZEO1FBQ0o7SUFDSjtJQUNBSztRQUNJLE9BQU8sSUFBSSxDQUFDZixPQUFPLENBQUNWLE1BQU0sQ0FBQzBCLE1BQU0sQ0FBQyxDQUFDQyxPQUFPckIsUUFBVztnQkFDakQsR0FBR3FCLEtBQUs7Z0JBQ1IsR0FBRztvQkFDQyxDQUFDLENBQUMsUUFBUSxFQUFFckIsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFNLElBQUksQ0FBQ3NCLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxhQUFhLENBQUM7NEJBQUVqQjt3QkFBTTtnQkFDM0UsQ0FBQztZQUNMLElBQUksQ0FBQztJQUNUO0lBQ0F1QjtRQUNJLE9BQU8sSUFBSSxDQUFDbkIsT0FBTyxDQUFDVixNQUFNLENBQUNXLEdBQUcsQ0FBQ0wsQ0FBQUE7WUFDM0IsT0FBT1gsb0VBQXNCQSxDQUFDO2dCQUMxQm1DLE1BQU0sSUFBSUMsT0FBTyxDQUFDLElBQUksRUFBRUMsS0FBS0MsR0FBRyxJQUFJLElBQUksQ0FBQ3ZCLE9BQU8sQ0FBQ1YsTUFBTSxFQUFFLENBQUMsRUFBRU0sTUFBTSxNQUFNLENBQUM7Z0JBQ3pFNEIsTUFBTSxJQUFJLENBQUNBLElBQUk7Z0JBQ2ZDLGVBQWU7b0JBQ1g3QjtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtBQUNKO0FBRXVDLENBQ3ZDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9kaXN0L2luZGV4LmpzP2QzMDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBoZWFkaW5ncy5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbm9kZXMvaGVhZGluZ1xuICovXG5jb25zdCBIZWFkaW5nID0gTm9kZS5jcmVhdGUoe1xuICAgIG5hbWU6ICdoZWFkaW5nJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGV2ZWxzOiBbMSwgMiwgMywgNCwgNSwgNl0sXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb250ZW50OiAnaW5saW5lKicsXG4gICAgZ3JvdXA6ICdibG9jaycsXG4gICAgZGVmaW5pbmc6IHRydWUsXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxldmVsOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZDogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVsc1xuICAgICAgICAgICAgLm1hcCgobGV2ZWwpID0+ICh7XG4gICAgICAgICAgICB0YWc6IGBoJHtsZXZlbH1gLFxuICAgICAgICAgICAgYXR0cnM6IHsgbGV2ZWwgfSxcbiAgICAgICAgfSkpO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgY29uc3QgaGFzTGV2ZWwgPSB0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKG5vZGUuYXR0cnMubGV2ZWwpO1xuICAgICAgICBjb25zdCBsZXZlbCA9IGhhc0xldmVsXG4gICAgICAgICAgICA/IG5vZGUuYXR0cnMubGV2ZWxcbiAgICAgICAgICAgIDogdGhpcy5vcHRpb25zLmxldmVsc1swXTtcbiAgICAgICAgcmV0dXJuIFtgaCR7bGV2ZWx9YCwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0SGVhZGluZzogYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKGF0dHJpYnV0ZXMubGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGVIZWFkaW5nOiBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMoYXR0cmlidXRlcy5sZXZlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTm9kZSh0aGlzLm5hbWUsICdwYXJhZ3JhcGgnLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHMucmVkdWNlKChpdGVtcywgbGV2ZWwpID0+ICh7XG4gICAgICAgICAgICAuLi5pdGVtcyxcbiAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICBbYE1vZC1BbHQtJHtsZXZlbH1gXTogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSGVhZGluZyh7IGxldmVsIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksIHt9KTtcbiAgICB9LFxuICAgIGFkZElucHV0UnVsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzLm1hcChsZXZlbCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dGJsb2NrVHlwZUlucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogbmV3IFJlZ0V4cChgXigjeyR7TWF0aC5taW4oLi4udGhpcy5vcHRpb25zLmxldmVscyl9LCR7bGV2ZWx9fSlcXFxccyRgKSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgSGVhZGluZywgSGVhZGluZyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJOb2RlIiwibWVyZ2VBdHRyaWJ1dGVzIiwidGV4dGJsb2NrVHlwZUlucHV0UnVsZSIsIkhlYWRpbmciLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsImxldmVscyIsIkhUTUxBdHRyaWJ1dGVzIiwiY29udGVudCIsImdyb3VwIiwiZGVmaW5pbmciLCJhZGRBdHRyaWJ1dGVzIiwibGV2ZWwiLCJkZWZhdWx0IiwicmVuZGVyZWQiLCJwYXJzZUhUTUwiLCJvcHRpb25zIiwibWFwIiwidGFnIiwiYXR0cnMiLCJyZW5kZXJIVE1MIiwibm9kZSIsImhhc0xldmVsIiwiaW5jbHVkZXMiLCJhZGRDb21tYW5kcyIsInNldEhlYWRpbmciLCJhdHRyaWJ1dGVzIiwiY29tbWFuZHMiLCJzZXROb2RlIiwidG9nZ2xlSGVhZGluZyIsInRvZ2dsZU5vZGUiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsInJlZHVjZSIsIml0ZW1zIiwiZWRpdG9yIiwiYWRkSW5wdXRSdWxlcyIsImZpbmQiLCJSZWdFeHAiLCJNYXRoIiwibWluIiwidHlwZSIsImdldEF0dHJpYnV0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-history/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-history/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   History: () => (/* binding */ History),\n/* harmony export */   \"default\": () => (/* binding */ History)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/history */ \"(ssr)/./node_modules/@tiptap/pm/history/dist/index.js\");\n\n\n/**\n * This extension allows you to undo and redo recent changes.\n * @see https://www.tiptap.dev/api/extensions/history\n *\n * **Important**: If the `@tiptap/extension-collaboration` package is used, make sure to remove\n * the `history` extension, as it is not compatible with the `collaboration` extension.\n *\n * `@tiptap/extension-collaboration` uses its own history implementation.\n */ const History = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"history\",\n    addOptions () {\n        return {\n            depth: 100,\n            newGroupDelay: 500\n        };\n    },\n    addCommands () {\n        return {\n            undo: ()=>({ state, dispatch })=>{\n                    return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.undo)(state, dispatch);\n                },\n            redo: ()=>({ state, dispatch })=>{\n                    return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.redo)(state, dispatch);\n                }\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.history)(this.options)\n        ];\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-z\": ()=>this.editor.commands.undo(),\n            \"Shift-Mod-z\": ()=>this.editor.commands.redo(),\n            \"Mod-y\": ()=>this.editor.commands.redo(),\n            // Russian keyboard layouts\n            \"Mod-я\": ()=>this.editor.commands.undo(),\n            \"Shift-Mod-я\": ()=>this.editor.commands.redo()\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGlzdG9yeS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7QUFDZ0I7QUFFekQ7Ozs7Ozs7O0NBUUMsR0FDRCxNQUFNSSxVQUFVSixtREFBU0EsQ0FBQ0ssTUFBTSxDQUFDO0lBQzdCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxPQUFPO1lBQ1BDLGVBQWU7UUFDbkI7SUFDSjtJQUNBQztRQUNJLE9BQU87WUFDSFQsTUFBTSxJQUFNLENBQUMsRUFBRVUsS0FBSyxFQUFFQyxRQUFRLEVBQUU7b0JBQzVCLE9BQU9YLHdEQUFJQSxDQUFDVSxPQUFPQztnQkFDdkI7WUFDQVYsTUFBTSxJQUFNLENBQUMsRUFBRVMsS0FBSyxFQUFFQyxRQUFRLEVBQUU7b0JBQzVCLE9BQU9WLHdEQUFJQSxDQUFDUyxPQUFPQztnQkFDdkI7UUFDSjtJQUNKO0lBQ0FDO1FBQ0ksT0FBTztZQUNIViwyREFBT0EsQ0FBQyxJQUFJLENBQUNXLE9BQU87U0FDdkI7SUFDTDtJQUNBQztRQUNJLE9BQU87WUFDSCxTQUFTLElBQU0sSUFBSSxDQUFDQyxNQUFNLENBQUNDLFFBQVEsQ0FBQ2hCLElBQUk7WUFDeEMsZUFBZSxJQUFNLElBQUksQ0FBQ2UsTUFBTSxDQUFDQyxRQUFRLENBQUNmLElBQUk7WUFDOUMsU0FBUyxJQUFNLElBQUksQ0FBQ2MsTUFBTSxDQUFDQyxRQUFRLENBQUNmLElBQUk7WUFDeEMsMkJBQTJCO1lBQzNCLFNBQVMsSUFBTSxJQUFJLENBQUNjLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDaEIsSUFBSTtZQUN4QyxlQUFlLElBQU0sSUFBSSxDQUFDZSxNQUFNLENBQUNDLFFBQVEsQ0FBQ2YsSUFBSTtRQUNsRDtJQUNKO0FBQ0o7QUFFdUMsQ0FDdkMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oaXN0b3J5L2Rpc3QvaW5kZXguanM/MjZkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgdW5kbywgcmVkbywgaGlzdG9yeSB9IGZyb20gJ0B0aXB0YXAvcG0vaGlzdG9yeSc7XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byB1bmRvIGFuZCByZWRvIHJlY2VudCBjaGFuZ2VzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2hpc3RvcnlcbiAqXG4gKiAqKkltcG9ydGFudCoqOiBJZiB0aGUgYEB0aXB0YXAvZXh0ZW5zaW9uLWNvbGxhYm9yYXRpb25gIHBhY2thZ2UgaXMgdXNlZCwgbWFrZSBzdXJlIHRvIHJlbW92ZVxuICogdGhlIGBoaXN0b3J5YCBleHRlbnNpb24sIGFzIGl0IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIGBjb2xsYWJvcmF0aW9uYCBleHRlbnNpb24uXG4gKlxuICogYEB0aXB0YXAvZXh0ZW5zaW9uLWNvbGxhYm9yYXRpb25gIHVzZXMgaXRzIG93biBoaXN0b3J5IGltcGxlbWVudGF0aW9uLlxuICovXG5jb25zdCBIaXN0b3J5ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2hpc3RvcnknLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZXB0aDogMTAwLFxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogNTAwLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bmRvOiAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRvKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVkbzogKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVkbyhzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGhpc3RvcnkodGhpcy5vcHRpb25zKSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC16JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudW5kbygpLFxuICAgICAgICAgICAgJ1NoaWZ0LU1vZC16JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuICAgICAgICAgICAgJ01vZC15JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuICAgICAgICAgICAgLy8gUnVzc2lhbiBrZXlib2FyZCBsYXlvdXRzXG4gICAgICAgICAgICAnTW9kLdGPJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudW5kbygpLFxuICAgICAgICAgICAgJ1NoaWZ0LU1vZC3Rjyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcbiAgICAgICAgfTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEhpc3RvcnksIEhpc3RvcnkgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiRXh0ZW5zaW9uIiwidW5kbyIsInJlZG8iLCJoaXN0b3J5IiwiSGlzdG9yeSIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiZGVwdGgiLCJuZXdHcm91cERlbGF5IiwiYWRkQ29tbWFuZHMiLCJzdGF0ZSIsImRpc3BhdGNoIiwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zIiwib3B0aW9ucyIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiZWRpdG9yIiwiY29tbWFuZHMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-history/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-horizontal-rule/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HorizontalRule: () => (/* binding */ HorizontalRule),\n/* harmony export */   \"default\": () => (/* binding */ HorizontalRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */ const HorizontalRule = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n    name: \"horizontalRule\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    group: \"block\",\n    parseHTML () {\n        return [\n            {\n                tag: \"hr\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"hr\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)\n        ];\n    },\n    addCommands () {\n        return {\n            setHorizontalRule: ()=>({ chain, state })=>{\n                    const { selection } = state;\n                    const { $from: $originFrom, $to: $originTo } = selection;\n                    const currentChain = chain();\n                    if ($originFrom.parentOffset === 0) {\n                        currentChain.insertContentAt({\n                            from: Math.max($originFrom.pos - 1, 0),\n                            to: $originTo.pos\n                        }, {\n                            type: this.name\n                        });\n                    } else if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(selection)) {\n                        currentChain.insertContentAt($originTo.pos, {\n                            type: this.name\n                        });\n                    } else {\n                        currentChain.insertContent({\n                            type: this.name\n                        });\n                    }\n                    return currentChain// set cursor after horizontal rule\n                    .command(({ tr, dispatch })=>{\n                        var _a;\n                        if (dispatch) {\n                            const { $to } = tr.selection;\n                            const posAfter = $to.end();\n                            if ($to.nodeAfter) {\n                                if ($to.nodeAfter.isTextblock) {\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos + 1));\n                                } else if ($to.nodeAfter.isBlock) {\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(tr.doc, $to.pos));\n                                } else {\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos));\n                                }\n                            } else {\n                                // add node after horizontal rule if it’s the end of the document\n                                const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n                                if (node) {\n                                    tr.insert(posAfter, node);\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, posAfter + 1));\n                                }\n                            }\n                            tr.scrollIntoView();\n                        }\n                        return true;\n                    }).run();\n                }\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.nodeInputRule)({\n                find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFxRjtBQUNyQjtBQUVoRTs7O0NBR0MsR0FDRCxNQUFNTSxpQkFBaUJOLDhDQUFJQSxDQUFDTyxNQUFNLENBQUM7SUFDL0JDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUMsT0FBTztJQUNQQztRQUNJLE9BQU87WUFBQztnQkFBRUMsS0FBSztZQUFLO1NBQUU7SUFDMUI7SUFDQUMsWUFBVyxFQUFFSixjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQU1ULDZEQUFlQSxDQUFDLElBQUksQ0FBQ2MsT0FBTyxDQUFDTCxjQUFjLEVBQUVBO1NBQWdCO0lBQy9FO0lBQ0FNO1FBQ0ksT0FBTztZQUNIQyxtQkFBbUIsSUFBTSxDQUFDLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFO29CQUN0QyxNQUFNLEVBQUVDLFNBQVMsRUFBRSxHQUFHRDtvQkFDdEIsTUFBTSxFQUFFRSxPQUFPQyxXQUFXLEVBQUVDLEtBQUtDLFNBQVMsRUFBRSxHQUFHSjtvQkFDL0MsTUFBTUssZUFBZVA7b0JBQ3JCLElBQUlJLFlBQVlJLFlBQVksS0FBSyxHQUFHO3dCQUNoQ0QsYUFBYUUsZUFBZSxDQUFDOzRCQUN6QkMsTUFBTUMsS0FBS0MsR0FBRyxDQUFDUixZQUFZUyxHQUFHLEdBQUcsR0FBRzs0QkFDcENDLElBQUlSLFVBQVVPLEdBQUc7d0JBQ3JCLEdBQUc7NEJBQ0NFLE1BQU0sSUFBSSxDQUFDekIsSUFBSTt3QkFDbkI7b0JBQ0osT0FDSyxJQUFJTiw2REFBZUEsQ0FBQ2tCLFlBQVk7d0JBQ2pDSyxhQUFhRSxlQUFlLENBQUNILFVBQVVPLEdBQUcsRUFBRTs0QkFDeENFLE1BQU0sSUFBSSxDQUFDekIsSUFBSTt3QkFDbkI7b0JBQ0osT0FDSzt3QkFDRGlCLGFBQWFTLGFBQWEsQ0FBQzs0QkFBRUQsTUFBTSxJQUFJLENBQUN6QixJQUFJO3dCQUFDO29CQUNqRDtvQkFDQSxPQUFRaUIsWUFDSixtQ0FBbUM7cUJBQ2xDVSxPQUFPLENBQUMsQ0FBQyxFQUFFQyxFQUFFLEVBQUVDLFFBQVEsRUFBRTt3QkFDMUIsSUFBSUM7d0JBQ0osSUFBSUQsVUFBVTs0QkFDVixNQUFNLEVBQUVkLEdBQUcsRUFBRSxHQUFHYSxHQUFHaEIsU0FBUzs0QkFDNUIsTUFBTW1CLFdBQVdoQixJQUFJaUIsR0FBRzs0QkFDeEIsSUFBSWpCLElBQUlrQixTQUFTLEVBQUU7Z0NBQ2YsSUFBSWxCLElBQUlrQixTQUFTLENBQUNDLFdBQVcsRUFBRTtvQ0FDM0JOLEdBQUdPLFlBQVksQ0FBQ3ZDLDJEQUFhQSxDQUFDRyxNQUFNLENBQUM2QixHQUFHUSxHQUFHLEVBQUVyQixJQUFJUSxHQUFHLEdBQUc7Z0NBQzNELE9BQ0ssSUFBSVIsSUFBSWtCLFNBQVMsQ0FBQ0ksT0FBTyxFQUFFO29DQUM1QlQsR0FBR08sWUFBWSxDQUFDdEMsMkRBQWFBLENBQUNFLE1BQU0sQ0FBQzZCLEdBQUdRLEdBQUcsRUFBRXJCLElBQUlRLEdBQUc7Z0NBQ3hELE9BQ0s7b0NBQ0RLLEdBQUdPLFlBQVksQ0FBQ3ZDLDJEQUFhQSxDQUFDRyxNQUFNLENBQUM2QixHQUFHUSxHQUFHLEVBQUVyQixJQUFJUSxHQUFHO2dDQUN4RDs0QkFDSixPQUNLO2dDQUNELGlFQUFpRTtnQ0FDakUsTUFBTWUsT0FBTyxDQUFDUixLQUFLZixJQUFJd0IsTUFBTSxDQUFDZCxJQUFJLENBQUNlLFlBQVksQ0FBQ0MsV0FBVyxNQUFNLFFBQVFYLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRy9CLE1BQU07Z0NBQzNHLElBQUl1QyxNQUFNO29DQUNOVixHQUFHYyxNQUFNLENBQUNYLFVBQVVPO29DQUNwQlYsR0FBR08sWUFBWSxDQUFDdkMsMkRBQWFBLENBQUNHLE1BQU0sQ0FBQzZCLEdBQUdRLEdBQUcsRUFBRUwsV0FBVztnQ0FDNUQ7NEJBQ0o7NEJBQ0FILEdBQUdlLGNBQWM7d0JBQ3JCO3dCQUNBLE9BQU87b0JBQ1gsR0FDS0MsR0FBRztnQkFDWjtRQUNKO0lBQ0o7SUFDQUM7UUFDSSxPQUFPO1lBQ0hsRCwyREFBYUEsQ0FBQztnQkFDVm1ELE1BQU07Z0JBQ05yQixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtTQUNIO0lBQ0w7QUFDSjtBQUVxRCxDQUNyRCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhvcml6b250YWwtcnVsZS9kaXN0L2luZGV4LmpzPzI3MDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzLCBpc05vZGVTZWxlY3Rpb24sIG5vZGVJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiwgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gaW5zZXJ0IGhvcml6b250YWwgcnVsZXMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL2hvcml6b250YWwtcnVsZVxuICovXG5jb25zdCBIb3Jpem9udGFsUnVsZSA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAnaG9yaXpvbnRhbFJ1bGUnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBncm91cDogJ2Jsb2NrJyxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbeyB0YWc6ICdocicgfV07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydocicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKV07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldEhvcml6b250YWxSdWxlOiAoKSA9PiAoeyBjaGFpbiwgc3RhdGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7ICRmcm9tOiAkb3JpZ2luRnJvbSwgJHRvOiAkb3JpZ2luVG8gfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2hhaW4gPSBjaGFpbigpO1xuICAgICAgICAgICAgICAgIGlmICgkb3JpZ2luRnJvbS5wYXJlbnRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYWluLmluc2VydENvbnRlbnRBdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBNYXRoLm1heCgkb3JpZ2luRnJvbS5wb3MgLSAxLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAkb3JpZ2luVG8ucG9zLFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhaW4uaW5zZXJ0Q29udGVudEF0KCRvcmlnaW5Uby5wb3MsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhaW4uaW5zZXJ0Q29udGVudCh7IHR5cGU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjdXJyZW50Q2hhaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGN1cnNvciBhZnRlciBob3Jpem9udGFsIHJ1bGVcbiAgICAgICAgICAgICAgICAgICAgLmNvbW1hbmQoKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgJHRvIH0gPSB0ci5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NBZnRlciA9ICR0by5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdG8ubm9kZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR0by5ub2RlQWZ0ZXIuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcyArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoJHRvLm5vZGVBZnRlci5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICR0by5wb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICR0by5wb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgbm9kZSBhZnRlciBob3Jpem9udGFsIHJ1bGUgaWYgaXTigJlzIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IChfYSA9ICR0by5wYXJlbnQudHlwZS5jb250ZW50TWF0Y2guZGVmYXVsdFR5cGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5pbnNlcnQocG9zQWZ0ZXIsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb3NBZnRlciArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5ydW4oKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5vZGVJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IC9eKD86LS0tfOKAlC18X19fXFxzfFxcKlxcKlxcKlxccykkLyxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEhvcml6b250YWxSdWxlLCBIb3Jpem9udGFsUnVsZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJOb2RlIiwibWVyZ2VBdHRyaWJ1dGVzIiwiaXNOb2RlU2VsZWN0aW9uIiwibm9kZUlucHV0UnVsZSIsIlRleHRTZWxlY3Rpb24iLCJOb2RlU2VsZWN0aW9uIiwiSG9yaXpvbnRhbFJ1bGUiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsIkhUTUxBdHRyaWJ1dGVzIiwiZ3JvdXAiLCJwYXJzZUhUTUwiLCJ0YWciLCJyZW5kZXJIVE1MIiwib3B0aW9ucyIsImFkZENvbW1hbmRzIiwic2V0SG9yaXpvbnRhbFJ1bGUiLCJjaGFpbiIsInN0YXRlIiwic2VsZWN0aW9uIiwiJGZyb20iLCIkb3JpZ2luRnJvbSIsIiR0byIsIiRvcmlnaW5UbyIsImN1cnJlbnRDaGFpbiIsInBhcmVudE9mZnNldCIsImluc2VydENvbnRlbnRBdCIsImZyb20iLCJNYXRoIiwibWF4IiwicG9zIiwidG8iLCJ0eXBlIiwiaW5zZXJ0Q29udGVudCIsImNvbW1hbmQiLCJ0ciIsImRpc3BhdGNoIiwiX2EiLCJwb3NBZnRlciIsImVuZCIsIm5vZGVBZnRlciIsImlzVGV4dGJsb2NrIiwic2V0U2VsZWN0aW9uIiwiZG9jIiwiaXNCbG9jayIsIm5vZGUiLCJwYXJlbnQiLCJjb250ZW50TWF0Y2giLCJkZWZhdWx0VHlwZSIsImluc2VydCIsInNjcm9sbEludG9WaWV3IiwicnVuIiwiYWRkSW5wdXRSdWxlcyIsImZpbmQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-italic/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Italic: () => (/* binding */ Italic),\n/* harmony export */   \"default\": () => (/* binding */ Italic),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * Matches an italic to a *italic* on input.\n */ const starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/;\n/**\n * Matches an italic to a *italic* on paste.\n */ const starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g;\n/**\n * Matches an italic to a _italic_ on input.\n */ const underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/;\n/**\n * Matches an italic to a _italic_ on paste.\n */ const underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g;\n/**\n * This extension allows you to create italic text.\n * @see https://www.tiptap.dev/api/marks/italic\n */ const Italic = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"italic\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"em\"\n            },\n            {\n                tag: \"i\",\n                getAttrs: (node)=>node.style.fontStyle !== \"normal\" && null\n            },\n            {\n                style: \"font-style=normal\",\n                clearMark: (mark)=>mark.type.name === this.name\n            },\n            {\n                style: \"font-style=italic\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"em\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setItalic: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleItalic: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetItalic: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-i\": ()=>this.editor.commands.toggleItalic(),\n            \"Mod-I\": ()=>this.editor.commands.toggleItalic()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: starInputRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: underscoreInputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: starPasteRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: underscorePasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtRjtBQUVuRjs7Q0FFQyxHQUNELE1BQU1JLGlCQUFpQjtBQUN2Qjs7Q0FFQyxHQUNELE1BQU1DLGlCQUFpQjtBQUN2Qjs7Q0FFQyxHQUNELE1BQU1DLHVCQUF1QjtBQUM3Qjs7Q0FFQyxHQUNELE1BQU1DLHVCQUF1QjtBQUM3Qjs7O0NBR0MsR0FDRCxNQUFNQyxTQUFTUiw4Q0FBSUEsQ0FBQ1MsTUFBTSxDQUFDO0lBQ3ZCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxnQkFBZ0IsQ0FBQztRQUNyQjtJQUNKO0lBQ0FDO1FBQ0ksT0FBTztZQUNIO2dCQUNJQyxLQUFLO1lBQ1Q7WUFDQTtnQkFDSUEsS0FBSztnQkFDTEMsVUFBVUMsQ0FBQUEsT0FBUUEsS0FBS0MsS0FBSyxDQUFDQyxTQUFTLEtBQUssWUFBWTtZQUMzRDtZQUNBO2dCQUNJRCxPQUFPO2dCQUNQRSxXQUFXQyxDQUFBQSxPQUFRQSxLQUFLQyxJQUFJLENBQUNYLElBQUksS0FBSyxJQUFJLENBQUNBLElBQUk7WUFDbkQ7WUFDQTtnQkFDSU8sT0FBTztZQUNYO1NBQ0g7SUFDTDtJQUNBSyxZQUFXLEVBQUVWLGNBQWMsRUFBRTtRQUN6QixPQUFPO1lBQUM7WUFBTVgsNkRBQWVBLENBQUMsSUFBSSxDQUFDc0IsT0FBTyxDQUFDWCxjQUFjLEVBQUVBO1lBQWlCO1NBQUU7SUFDbEY7SUFDQVk7UUFDSSxPQUFPO1lBQ0hDLFdBQVcsSUFBTSxDQUFDLEVBQUVDLFFBQVEsRUFBRTtvQkFDMUIsT0FBT0EsU0FBU0MsT0FBTyxDQUFDLElBQUksQ0FBQ2pCLElBQUk7Z0JBQ3JDO1lBQ0FrQixjQUFjLElBQU0sQ0FBQyxFQUFFRixRQUFRLEVBQUU7b0JBQzdCLE9BQU9BLFNBQVNHLFVBQVUsQ0FBQyxJQUFJLENBQUNuQixJQUFJO2dCQUN4QztZQUNBb0IsYUFBYSxJQUFNLENBQUMsRUFBRUosUUFBUSxFQUFFO29CQUM1QixPQUFPQSxTQUFTSyxTQUFTLENBQUMsSUFBSSxDQUFDckIsSUFBSTtnQkFDdkM7UUFDSjtJQUNKO0lBQ0FzQjtRQUNJLE9BQU87WUFDSCxTQUFTLElBQU0sSUFBSSxDQUFDQyxNQUFNLENBQUNQLFFBQVEsQ0FBQ0UsWUFBWTtZQUNoRCxTQUFTLElBQU0sSUFBSSxDQUFDSyxNQUFNLENBQUNQLFFBQVEsQ0FBQ0UsWUFBWTtRQUNwRDtJQUNKO0lBQ0FNO1FBQ0ksT0FBTztZQUNIaEMsMkRBQWFBLENBQUM7Z0JBQ1ZpQyxNQUFNL0I7Z0JBQ05pQixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtZQUNBbkIsMkRBQWFBLENBQUM7Z0JBQ1ZpQyxNQUFNN0I7Z0JBQ05lLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1NBQ0g7SUFDTDtJQUNBZTtRQUNJLE9BQU87WUFDSGpDLDJEQUFhQSxDQUFDO2dCQUNWZ0MsTUFBTTlCO2dCQUNOZ0IsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7WUFDQWxCLDJEQUFhQSxDQUFDO2dCQUNWZ0MsTUFBTTVCO2dCQUNOYyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtTQUNIO0lBQ0w7QUFDSjtBQUVpSCxDQUNqSCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWl0YWxpYy9kaXN0L2luZGV4LmpzPzEzNzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFyaywgbWVyZ2VBdHRyaWJ1dGVzLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBNYXRjaGVzIGFuIGl0YWxpYyB0byBhICppdGFsaWMqIG9uIGlucHV0LlxuICovXG5jb25zdCBzdGFySW5wdXRSZWdleCA9IC8oPzpefFxccykoXFwqKD8hXFxzK1xcKikoKD86W14qXSspKVxcKig/IVxccytcXCopKSQvO1xuLyoqXG4gKiBNYXRjaGVzIGFuIGl0YWxpYyB0byBhICppdGFsaWMqIG9uIHBhc3RlLlxuICovXG5jb25zdCBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoXFwqKD8hXFxzK1xcKikoKD86W14qXSspKVxcKig/IVxccytcXCopKS9nO1xuLyoqXG4gKiBNYXRjaGVzIGFuIGl0YWxpYyB0byBhIF9pdGFsaWNfIG9uIGlucHV0LlxuICovXG5jb25zdCB1bmRlcnNjb3JlSW5wdXRSZWdleCA9IC8oPzpefFxccykoXyg/IVxccytfKSgoPzpbXl9dKykpXyg/IVxccytfKSkkLztcbi8qKlxuICogTWF0Y2hlcyBhbiBpdGFsaWMgdG8gYSBfaXRhbGljXyBvbiBwYXN0ZS5cbiAqL1xuY29uc3QgdW5kZXJzY29yZVBhc3RlUmVnZXggPSAvKD86XnxcXHMpKF8oPyFcXHMrXykoKD86W15fXSspKV8oPyFcXHMrXykpL2c7XG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIGl0YWxpYyB0ZXh0LlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9tYXJrcy9pdGFsaWNcbiAqL1xuY29uc3QgSXRhbGljID0gTWFyay5jcmVhdGUoe1xuICAgIG5hbWU6ICdpdGFsaWMnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnZW0nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdpJyxcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogbm9kZSA9PiBub2RlLnN0eWxlLmZvbnRTdHlsZSAhPT0gJ25vcm1hbCcgJiYgbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3R5bGU6ICdmb250LXN0eWxlPW5vcm1hbCcsXG4gICAgICAgICAgICAgICAgY2xlYXJNYXJrOiBtYXJrID0+IG1hcmsudHlwZS5uYW1lID09PSB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0eWxlOiAnZm9udC1zdHlsZT1pdGFsaWMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ2VtJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0SXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGVJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2V0SXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1pJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSXRhbGljKCksXG4gICAgICAgICAgICAnTW9kLUknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVJdGFsaWMoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZElucHV0UnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVJbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHN0YXJQYXN0ZVJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogdW5kZXJzY29yZVBhc3RlUmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBJdGFsaWMsIEl0YWxpYyBhcyBkZWZhdWx0LCBzdGFySW5wdXRSZWdleCwgc3RhclBhc3RlUmVnZXgsIHVuZGVyc2NvcmVJbnB1dFJlZ2V4LCB1bmRlcnNjb3JlUGFzdGVSZWdleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTWFyayIsIm1lcmdlQXR0cmlidXRlcyIsIm1hcmtJbnB1dFJ1bGUiLCJtYXJrUGFzdGVSdWxlIiwic3RhcklucHV0UmVnZXgiLCJzdGFyUGFzdGVSZWdleCIsInVuZGVyc2NvcmVJbnB1dFJlZ2V4IiwidW5kZXJzY29yZVBhc3RlUmVnZXgiLCJJdGFsaWMiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsIkhUTUxBdHRyaWJ1dGVzIiwicGFyc2VIVE1MIiwidGFnIiwiZ2V0QXR0cnMiLCJub2RlIiwic3R5bGUiLCJmb250U3R5bGUiLCJjbGVhck1hcmsiLCJtYXJrIiwidHlwZSIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiYWRkQ29tbWFuZHMiLCJzZXRJdGFsaWMiLCJjb21tYW5kcyIsInNldE1hcmsiLCJ0b2dnbGVJdGFsaWMiLCJ0b2dnbGVNYXJrIiwidW5zZXRJdGFsaWMiLCJ1bnNldE1hcmsiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwiYWRkUGFzdGVSdWxlcyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-link/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-link/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   \"default\": () => (/* binding */ Link),\n/* harmony export */   isAllowedUri: () => (/* binding */ isAllowedUri),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var linkifyjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! linkifyjs */ \"(ssr)/./node_modules/linkifyjs/dist/linkify.es.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n\n\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */ function isValidLinkStructure(tokens) {\n    if (tokens.length === 1) {\n        return tokens[0].isLink;\n    }\n    if (tokens.length === 3 && tokens[1].isLink) {\n        return [\n            \"()\",\n            \"[]\"\n        ].includes(tokens[0].value + tokens[2].value);\n    }\n    return false;\n}\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */ function autolink(options) {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"autolink\"),\n        appendTransaction: (transactions, oldState, newState)=>{\n            /**\n             * Does the transaction change the document?\n             */ const docChanges = transactions.some((transaction)=>transaction.docChanged) && !oldState.doc.eq(newState.doc);\n            /**\n             * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n             */ const preventAutolink = transactions.some((transaction)=>transaction.getMeta(\"preventAutolink\"));\n            /**\n             * Prevent autolink if the transaction is not a document change\n             * or if the transaction has the meta `preventAutolink`.\n             */ if (!docChanges || preventAutolink) {\n                return;\n            }\n            const { tr } = newState;\n            const transform = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.combineTransactionSteps)(oldState.doc, [\n                ...transactions\n            ]);\n            const changes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getChangedRanges)(transform);\n            changes.forEach(({ newRange })=>{\n                // Now let’s see if we can add new links.\n                const nodesInChangedRanges = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildrenInRange)(newState.doc, newRange, (node)=>node.isTextblock);\n                let textBlock;\n                let textBeforeWhitespace;\n                if (nodesInChangedRanges.length > 1) {\n                    // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n                    textBlock = nodesInChangedRanges[0];\n                    textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, \" \");\n                } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, \" \", \" \").endsWith(\" \")) {\n                    textBlock = nodesInChangedRanges[0];\n                    textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, \" \");\n                }\n                if (textBlock && textBeforeWhitespace) {\n                    const wordsBeforeWhitespace = textBeforeWhitespace.split(\" \").filter((s)=>s !== \"\");\n                    if (wordsBeforeWhitespace.length <= 0) {\n                        return false;\n                    }\n                    const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n                    const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n                    if (!lastWordBeforeSpace) {\n                        return false;\n                    }\n                    const linksBeforeSpace = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.tokenize)(lastWordBeforeSpace).map((t)=>t.toObject(options.defaultProtocol));\n                    if (!isValidLinkStructure(linksBeforeSpace)) {\n                        return false;\n                    }\n                    linksBeforeSpace.filter((link)=>link.isLink)// Calculate link position.\n                    .map((link)=>({\n                            ...link,\n                            from: lastWordAndBlockOffset + link.start + 1,\n                            to: lastWordAndBlockOffset + link.end + 1\n                        }))// ignore link inside code mark\n                    .filter((link)=>{\n                        if (!newState.schema.marks.code) {\n                            return true;\n                        }\n                        return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);\n                    })// validate link\n                    .filter((link)=>options.validate(link.value))// check whether should autolink\n                    .filter((link)=>options.shouldAutoLink(link.value))// Add link mark.\n                    .forEach((link)=>{\n                        if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarksBetween)(link.from, link.to, newState.doc).some((item)=>item.mark.type === options.type)) {\n                            return;\n                        }\n                        tr.addMark(link.from, link.to, options.type.create({\n                            href: link.href\n                        }));\n                    });\n                }\n            });\n            if (!tr.steps.length) {\n                return;\n            }\n            return tr;\n        }\n    });\n}\nfunction clickHandler(options) {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"handleClickLink\"),\n        props: {\n            handleClick: (view, pos, event)=>{\n                var _a, _b;\n                if (event.button !== 0) {\n                    return false;\n                }\n                if (!view.editable) {\n                    return false;\n                }\n                let a = event.target;\n                const els = [];\n                while(a.nodeName !== \"DIV\"){\n                    els.push(a);\n                    a = a.parentNode;\n                }\n                if (!els.find((value)=>value.nodeName === \"A\")) {\n                    return false;\n                }\n                const attrs = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributes)(view.state, options.type.name);\n                const link = event.target;\n                const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;\n                const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;\n                if (link && href) {\n                    window.open(href, target);\n                    return true;\n                }\n                return false;\n            }\n        }\n    });\n}\nfunction pasteHandler(options) {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"handlePasteLink\"),\n        props: {\n            handlePaste: (view, event, slice)=>{\n                const { state } = view;\n                const { selection } = state;\n                const { empty } = selection;\n                if (empty) {\n                    return false;\n                }\n                let textContent = \"\";\n                slice.content.forEach((node)=>{\n                    textContent += node.textContent;\n                });\n                const link = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(textContent, {\n                    defaultProtocol: options.defaultProtocol\n                }).find((item)=>item.isLink && item.value === textContent);\n                if (!textContent || !link) {\n                    return false;\n                }\n                return options.editor.commands.setMark(options.type, {\n                    href: link.href\n                });\n            }\n        }\n    });\n}\nconst pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;\n// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.js\n// eslint-disable-next-line no-control-regex\nconst ATTR_WHITESPACE = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g;\nfunction isAllowedUri(uri, protocols) {\n    const allowedProtocols = [\n        \"http\",\n        \"https\",\n        \"ftp\",\n        \"ftps\",\n        \"mailto\",\n        \"tel\",\n        \"callto\",\n        \"sms\",\n        \"cid\",\n        \"xmpp\"\n    ];\n    if (protocols) {\n        protocols.forEach((protocol)=>{\n            const nextProtocol = typeof protocol === \"string\" ? protocol : protocol.scheme;\n            if (nextProtocol) {\n                allowedProtocols.push(nextProtocol);\n            }\n        });\n    }\n    return !uri || uri.replace(ATTR_WHITESPACE, \"\").match(new RegExp(// eslint-disable-next-line no-useless-escape\n    `^(?:(?:${allowedProtocols.join(\"|\")}):|[^a-z]|[a-z0-9+.\\-]+(?:[^a-z+.\\-:]|$))`, \"i\"));\n}\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */ const Link = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Mark.create({\n    name: \"link\",\n    priority: 1000,\n    keepOnSplit: false,\n    exitable: true,\n    onCreate () {\n        if (this.options.validate && !this.options.shouldAutoLink) {\n            // Copy the validate function to the shouldAutoLink option\n            this.options.shouldAutoLink = this.options.validate;\n            console.warn(\"The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.\");\n        }\n        this.options.protocols.forEach((protocol)=>{\n            if (typeof protocol === \"string\") {\n                (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol);\n                return;\n            }\n            (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol.scheme, protocol.optionalSlashes);\n        });\n    },\n    onDestroy () {\n        (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.reset)();\n    },\n    inclusive () {\n        return this.options.autolink;\n    },\n    addOptions () {\n        return {\n            openOnClick: true,\n            linkOnPaste: true,\n            autolink: true,\n            protocols: [],\n            defaultProtocol: \"http\",\n            HTMLAttributes: {\n                target: \"_blank\",\n                rel: \"noopener noreferrer nofollow\",\n                class: null\n            },\n            isAllowedUri: (url, ctx)=>!!isAllowedUri(url, ctx.protocols),\n            validate: (url)=>!!url,\n            shouldAutoLink: (url)=>!!url\n        };\n    },\n    addAttributes () {\n        return {\n            href: {\n                default: null,\n                parseHTML (element) {\n                    return element.getAttribute(\"href\");\n                }\n            },\n            target: {\n                default: this.options.HTMLAttributes.target\n            },\n            rel: {\n                default: this.options.HTMLAttributes.rel\n            },\n            class: {\n                default: this.options.HTMLAttributes.class\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"a[href]\",\n                getAttrs: (dom)=>{\n                    const href = dom.getAttribute(\"href\");\n                    // prevent XSS attacks\n                    if (!href || !this.options.isAllowedUri(href, {\n                        defaultValidate: (url)=>!!isAllowedUri(url, this.options.protocols),\n                        protocols: this.options.protocols,\n                        defaultProtocol: this.options.defaultProtocol\n                    })) {\n                        return false;\n                    }\n                    return null;\n                }\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        // prevent XSS attacks\n        if (!this.options.isAllowedUri(HTMLAttributes.href, {\n            defaultValidate: (href)=>!!isAllowedUri(href, this.options.protocols),\n            protocols: this.options.protocols,\n            defaultProtocol: this.options.defaultProtocol\n        })) {\n            // strip out the href\n            return [\n                \"a\",\n                (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, {\n                    ...HTMLAttributes,\n                    href: \"\"\n                }),\n                0\n            ];\n        }\n        return [\n            \"a\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setLink: (attributes)=>({ chain })=>{\n                    const { href } = attributes;\n                    if (!this.options.isAllowedUri(href, {\n                        defaultValidate: (url)=>!!isAllowedUri(url, this.options.protocols),\n                        protocols: this.options.protocols,\n                        defaultProtocol: this.options.defaultProtocol\n                    })) {\n                        return false;\n                    }\n                    return chain().setMark(this.name, attributes).setMeta(\"preventAutolink\", true).run();\n                },\n            toggleLink: (attributes)=>({ chain })=>{\n                    const { href } = attributes;\n                    if (!this.options.isAllowedUri(href, {\n                        defaultValidate: (url)=>!!isAllowedUri(url, this.options.protocols),\n                        protocols: this.options.protocols,\n                        defaultProtocol: this.options.defaultProtocol\n                    })) {\n                        return false;\n                    }\n                    return chain().toggleMark(this.name, attributes, {\n                        extendEmptyMarkRange: true\n                    }).setMeta(\"preventAutolink\", true).run();\n                },\n            unsetLink: ()=>({ chain })=>{\n                    return chain().unsetMark(this.name, {\n                        extendEmptyMarkRange: true\n                    }).setMeta(\"preventAutolink\", true).run();\n                }\n        };\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markPasteRule)({\n                find: (text)=>{\n                    const foundLinks = [];\n                    if (text) {\n                        const { protocols, defaultProtocol } = this.options;\n                        const links = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(text).filter((item)=>item.isLink && this.options.isAllowedUri(item.value, {\n                                defaultValidate: (href)=>!!isAllowedUri(href, protocols),\n                                protocols,\n                                defaultProtocol\n                            }));\n                        if (links.length) {\n                            links.forEach((link)=>foundLinks.push({\n                                    text: link.value,\n                                    data: {\n                                        href: link.href\n                                    },\n                                    index: link.start\n                                }));\n                        }\n                    }\n                    return foundLinks;\n                },\n                type: this.type,\n                getAttributes: (match)=>{\n                    var _a;\n                    return {\n                        href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href\n                    };\n                }\n            })\n        ];\n    },\n    addProseMirrorPlugins () {\n        const plugins = [];\n        const { protocols, defaultProtocol } = this.options;\n        if (this.options.autolink) {\n            plugins.push(autolink({\n                type: this.type,\n                defaultProtocol: this.options.defaultProtocol,\n                validate: (url)=>this.options.isAllowedUri(url, {\n                        defaultValidate: (href)=>!!isAllowedUri(href, protocols),\n                        protocols,\n                        defaultProtocol\n                    }),\n                shouldAutoLink: this.options.shouldAutoLink\n            }));\n        }\n        if (this.options.openOnClick === true) {\n            plugins.push(clickHandler({\n                type: this.type\n            }));\n        }\n        if (this.options.linkOnPaste) {\n            plugins.push(pasteHandler({\n                editor: this.editor,\n                defaultProtocol: this.options.defaultProtocol,\n                type: this.type\n            }));\n        }\n        return plugins;\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBb0s7QUFDMUY7QUFDckI7QUFFckQ7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU2MscUJBQXFCQyxNQUFNO0lBQ2hDLElBQUlBLE9BQU9DLE1BQU0sS0FBSyxHQUFHO1FBQ3JCLE9BQU9ELE1BQU0sQ0FBQyxFQUFFLENBQUNFLE1BQU07SUFDM0I7SUFDQSxJQUFJRixPQUFPQyxNQUFNLEtBQUssS0FBS0QsTUFBTSxDQUFDLEVBQUUsQ0FBQ0UsTUFBTSxFQUFFO1FBQ3pDLE9BQU87WUFBQztZQUFNO1NBQUssQ0FBQ0MsUUFBUSxDQUFDSCxNQUFNLENBQUMsRUFBRSxDQUFDSSxLQUFLLEdBQUdKLE1BQU0sQ0FBQyxFQUFFLENBQUNJLEtBQUs7SUFDbEU7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU0MsU0FBU0MsT0FBTztJQUNyQixPQUFPLElBQUlULG9EQUFNQSxDQUFDO1FBQ2RVLEtBQUssSUFBSVQsdURBQVNBLENBQUM7UUFDbkJVLG1CQUFtQixDQUFDQyxjQUFjQyxVQUFVQztZQUN4Qzs7YUFFQyxHQUNELE1BQU1DLGFBQWFILGFBQWFJLElBQUksQ0FBQ0MsQ0FBQUEsY0FBZUEsWUFBWUMsVUFBVSxLQUFLLENBQUNMLFNBQVNNLEdBQUcsQ0FBQ0MsRUFBRSxDQUFDTixTQUFTSyxHQUFHO1lBQzVHOzthQUVDLEdBQ0QsTUFBTUUsa0JBQWtCVCxhQUFhSSxJQUFJLENBQUNDLENBQUFBLGNBQWVBLFlBQVlLLE9BQU8sQ0FBQztZQUM3RTs7O2FBR0MsR0FDRCxJQUFJLENBQUNQLGNBQWNNLGlCQUFpQjtnQkFDaEM7WUFDSjtZQUNBLE1BQU0sRUFBRUUsRUFBRSxFQUFFLEdBQUdUO1lBQ2YsTUFBTVUsWUFBWXBDLHFFQUF1QkEsQ0FBQ3lCLFNBQVNNLEdBQUcsRUFBRTttQkFBSVA7YUFBYTtZQUN6RSxN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O29CQUN4RTtnQkFDSjtZQUNKO1NBQ0g7SUFDTDtJQUNBMEY7UUFDSSxNQUFNQyxVQUFVLEVBQUU7UUFDbEIsTUFBTSxFQUFFdkQsU0FBUyxFQUFFbkQsZUFBZSxFQUFFLEdBQUcsSUFBSSxDQUFDMUMsT0FBTztRQUNuRCxJQUFJLElBQUksQ0FBQ0EsT0FBTyxDQUFDRCxRQUFRLEVBQUU7WUFDdkJxSixRQUFRNUUsSUFBSSxDQUFDekUsU0FBUztnQkFDbEJ1RCxNQUFNLElBQUksQ0FBQ0EsSUFBSTtnQkFDZlosaUJBQWlCLElBQUksQ0FBQzFDLE9BQU8sQ0FBQzBDLGVBQWU7Z0JBQzdDUSxVQUFVb0UsQ0FBQUEsTUFBTyxJQUFJLENBQUN0SCxPQUFPLENBQUMyRixZQUFZLENBQUMyQixLQUFLO3dCQUM1Q1UsaUJBQWlCdkUsQ0FBQUEsT0FBUSxDQUFDLENBQUNrQyxhQUFhbEMsTUFBTW9DO3dCQUM5Q0E7d0JBQ0FuRDtvQkFDSjtnQkFDQVMsZ0JBQWdCLElBQUksQ0FBQ25ELE9BQU8sQ0FBQ21ELGNBQWM7WUFDL0M7UUFDSjtRQUNBLElBQUksSUFBSSxDQUFDbkQsT0FBTyxDQUFDaUgsV0FBVyxLQUFLLE1BQU07WUFDbkNtQyxRQUFRNUUsSUFBSSxDQUFDYixhQUFhO2dCQUN0QkwsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7UUFDSjtRQUNBLElBQUksSUFBSSxDQUFDdEQsT0FBTyxDQUFDa0gsV0FBVyxFQUFFO1lBQzFCa0MsUUFBUTVFLElBQUksQ0FBQ08sYUFBYTtnQkFDdEJPLFFBQVEsSUFBSSxDQUFDQSxNQUFNO2dCQUNuQjVDLGlCQUFpQixJQUFJLENBQUMxQyxPQUFPLENBQUMwQyxlQUFlO2dCQUM3Q1ksTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7UUFDSjtRQUNBLE9BQU84RjtJQUNYO0FBQ0o7QUFFMkQsQ0FDM0QsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saW5rL2Rpc3QvaW5kZXguanM/MDUwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcywgZ2V0Q2hhbmdlZFJhbmdlcywgZmluZENoaWxkcmVuSW5SYW5nZSwgZ2V0TWFya3NCZXR3ZWVuLCBnZXRBdHRyaWJ1dGVzLCBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMsIG1hcmtQYXN0ZVJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgdG9rZW5pemUsIGZpbmQsIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wsIHJlc2V0IH0gZnJvbSAnbGlua2lmeWpzJztcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHByb3ZpZGVkIHRva2VucyBmb3JtIGEgdmFsaWQgbGluayBzdHJ1Y3R1cmUsIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBzaW5nbGUgbGluayB0b2tlblxuICogb3IgYSBsaW5rIHRva2VuIHN1cnJvdW5kZWQgYnkgcGFyZW50aGVzZXMgb3Igc3F1YXJlIGJyYWNrZXRzLlxuICpcbiAqIFRoaXMgZW5zdXJlcyB0aGF0IG9ubHkgY29tcGxldGUgYW5kIHZhbGlkIHRleHQgaXMgaHlwZXJsaW5rZWQsIHByZXZlbnRpbmcgY2FzZXMgd2hlcmUgYSB2YWxpZFxuICogdG9wLWxldmVsIGRvbWFpbiAoVExEKSBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBpbnZhbGlkIGNoYXJhY3RlciwgbGlrZSBhIG51bWJlci4gRm9yXG4gKiBleGFtcGxlLCB3aXRoIHRoZSBgZmluZGAgbWV0aG9kIGZyb20gTGlua2lmeSwgZW50ZXJpbmcgYGV4YW1wbGUuY29tMWAgd291bGQgcmVzdWx0IGluXG4gKiBgZXhhbXBsZS5jb21gIGJlaW5nIGxpbmtlZCBhbmQgdGhlIHRyYWlsaW5nIGAxYCBsZWZ0IGFzIHBsYWluIHRleHQuIEJ5IHVzaW5nIHRoZSBgdG9rZW5pemVgXG4gKiBtZXRob2QsIHdlIGNhbiBwZXJmb3JtIG1vcmUgY29tcHJlaGVuc2l2ZSB2YWxpZGF0aW9uIG9uIHRoZSBpbnB1dCB0ZXh0LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkTGlua1N0cnVjdHVyZSh0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdG9rZW5zWzBdLmlzTGluaztcbiAgICB9XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDMgJiYgdG9rZW5zWzFdLmlzTGluaykge1xuICAgICAgICByZXR1cm4gWycoKScsICdbXSddLmluY2x1ZGVzKHRva2Vuc1swXS52YWx1ZSArIHRva2Vuc1syXS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogVGhpcyBwbHVnaW4gYWxsb3dzIHlvdSB0byBhdXRvbWF0aWNhbGx5IGFkZCBsaW5rcyB0byB5b3VyIGVkaXRvci5cbiAqIEBwYXJhbSBvcHRpb25zIFRoZSBwbHVnaW4gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIHBsdWdpbiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhdXRvbGluayhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2F1dG9saW5rJyksXG4gICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRG9lcyB0aGUgdHJhbnNhY3Rpb24gY2hhbmdlIHRoZSBkb2N1bWVudD9cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IHRyYW5zYWN0aW9ucy5zb21lKHRyYW5zYWN0aW9uID0+IHRyYW5zYWN0aW9uLmRvY0NoYW5nZWQpICYmICFvbGRTdGF0ZS5kb2MuZXEobmV3U3RhdGUuZG9jKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJldmVudCBhdXRvbGluayBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgbm90IGEgZG9jdW1lbnQgY2hhbmdlIG9yIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgdGhlIG1ldGEgYHByZXZlbnRBdXRvbGlua2AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHByZXZlbnRBdXRvbGluayA9IHRyYW5zYWN0aW9ucy5zb21lKHRyYW5zYWN0aW9uID0+IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3ByZXZlbnRBdXRvbGluaycpKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJldmVudCBhdXRvbGluayBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgbm90IGEgZG9jdW1lbnQgY2hhbmdlXG4gICAgICAgICAgICAgKiBvciBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIHRoZSBtZXRhIGBwcmV2ZW50QXV0b2xpbmtgLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIWRvY0NoYW5nZXMgfHwgcHJldmVudEF1dG9saW5rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0ciB9ID0gbmV3U3RhdGU7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcyhvbGRTdGF0ZS5kb2MsIFsuLi50cmFuc2FjdGlvbnNdKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRDaGFuZ2VkUmFuZ2VzKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2goKHsgbmV3UmFuZ2UgfSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE5vdyBsZXTigJlzIHNlZSBpZiB3ZSBjYW4gYWRkIG5ldyBsaW5rcy5cbiAgICAgICAgICAgICAgICBjb25zdCBub2Rlc0luQ2hhbmdlZFJhbmdlcyA9IGZpbmRDaGlsZHJlbkluUmFuZ2UobmV3U3RhdGUuZG9jLCBuZXdSYW5nZSwgbm9kZSA9PiBub2RlLmlzVGV4dGJsb2NrKTtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dEJsb2NrO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0QmVmb3JlV2hpdGVzcGFjZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXNJbkNoYW5nZWRSYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHcmFiIHRoZSBmaXJzdCBub2RlIHdpdGhpbiB0aGUgY2hhbmdlZCByYW5nZXMgKGV4LiB0aGUgZmlyc3Qgb2YgdHdvIHBhcmFncmFwaHMgd2hlbiBoaXR0aW5nIGVudGVyKS5cbiAgICAgICAgICAgICAgICAgICAgdGV4dEJsb2NrID0gbm9kZXNJbkNoYW5nZWRSYW5nZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHRleHRCZWZvcmVXaGl0ZXNwYWNlID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKHRleHRCbG9jay5wb3MsIHRleHRCbG9jay5wb3MgKyB0ZXh0QmxvY2subm9kZS5ub2RlU2l6ZSwgdW5kZWZpbmVkLCAnICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2Rlc0luQ2hhbmdlZFJhbmdlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBtYWtlIHN1cmUgdG8gaW5jbHVkZSB0aGUgYmxvY2sgc2VwZXJhdG9yIGFyZ3VtZW50IHRvIHRyZWF0IGhhcmQgYnJlYWtzIGxpa2Ugc3BhY2VzLlxuICAgICAgICAgICAgICAgICAgICAmJiBuZXdTdGF0ZS5kb2MudGV4dEJldHdlZW4obmV3UmFuZ2UuZnJvbSwgbmV3UmFuZ2UudG8sICcgJywgJyAnKS5lbmRzV2l0aCgnICcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRCbG9jayA9IG5vZGVzSW5DaGFuZ2VkUmFuZ2VzWzBdO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QmVmb3JlV2hpdGVzcGFjZSA9IG5ld1N0YXRlLmRvYy50ZXh0QmV0d2Vlbih0ZXh0QmxvY2sucG9zLCBuZXdSYW5nZS50bywgdW5kZWZpbmVkLCAnICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dEJsb2NrICYmIHRleHRCZWZvcmVXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdvcmRzQmVmb3JlV2hpdGVzcGFjZSA9IHRleHRCZWZvcmVXaGl0ZXNwYWNlLnNwbGl0KCcgJykuZmlsdGVyKHMgPT4gcyAhPT0gJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod29yZHNCZWZvcmVXaGl0ZXNwYWNlLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFdvcmRCZWZvcmVTcGFjZSA9IHdvcmRzQmVmb3JlV2hpdGVzcGFjZVt3b3Jkc0JlZm9yZVdoaXRlc3BhY2UubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RXb3JkQW5kQmxvY2tPZmZzZXQgPSB0ZXh0QmxvY2sucG9zICsgdGV4dEJlZm9yZVdoaXRlc3BhY2UubGFzdEluZGV4T2YobGFzdFdvcmRCZWZvcmVTcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGFzdFdvcmRCZWZvcmVTcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtzQmVmb3JlU3BhY2UgPSB0b2tlbml6ZShsYXN0V29yZEJlZm9yZVNwYWNlKS5tYXAodCA9PiB0LnRvT2JqZWN0KG9wdGlvbnMuZGVmYXVsdFByb3RvY29sKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZExpbmtTdHJ1Y3R1cmUobGlua3NCZWZvcmVTcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaW5rc0JlZm9yZVNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGxpbmsgPT4gbGluay5pc0xpbmspXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgbGluayBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobGluayA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IGxhc3RXb3JkQW5kQmxvY2tPZmZzZXQgKyBsaW5rLnN0YXJ0ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBsYXN0V29yZEFuZEJsb2NrT2Zmc2V0ICsgbGluay5lbmQgKyAxLFxuICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBsaW5rIGluc2lkZSBjb2RlIG1hcmtcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobGluayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1N0YXRlLnNjaGVtYS5tYXJrcy5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIW5ld1N0YXRlLmRvYy5yYW5nZUhhc01hcmsobGluay5mcm9tLCBsaW5rLnRvLCBuZXdTdGF0ZS5zY2hlbWEubWFya3MuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWxpZGF0ZSBsaW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGxpbmsgPT4gb3B0aW9ucy52YWxpZGF0ZShsaW5rLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgc2hvdWxkIGF1dG9saW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGxpbmsgPT4gb3B0aW9ucy5zaG91bGRBdXRvTGluayhsaW5rLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBsaW5rIG1hcmsuXG4gICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChsaW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRNYXJrc0JldHdlZW4obGluay5mcm9tLCBsaW5rLnRvLCBuZXdTdGF0ZS5kb2MpLnNvbWUoaXRlbSA9PiBpdGVtLm1hcmsudHlwZSA9PT0gb3B0aW9ucy50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsobGluay5mcm9tLCBsaW5rLnRvLCBvcHRpb25zLnR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiBsaW5rLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsaWNrSGFuZGxlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2hhbmRsZUNsaWNrTGluaycpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlQ2xpY2s6ICh2aWV3LCBwb3MsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3LmVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGEgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxzID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUgKGEubm9kZU5hbWUgIT09ICdESVYnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVscy5wdXNoKGEpO1xuICAgICAgICAgICAgICAgICAgICBhID0gYS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVscy5maW5kKHZhbHVlID0+IHZhbHVlLm5vZGVOYW1lID09PSAnQScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBnZXRBdHRyaWJ1dGVzKHZpZXcuc3RhdGUsIG9wdGlvbnMudHlwZS5uYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSAoX2EgPSBsaW5rID09PSBudWxsIHx8IGxpbmsgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmsuaHJlZikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYXR0cnMuaHJlZjtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoX2IgPSBsaW5rID09PSBudWxsIHx8IGxpbmsgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmsudGFyZ2V0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBhdHRycy50YXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsgJiYgaHJlZikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cub3BlbihocmVmLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFzdGVIYW5kbGVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnaGFuZGxlUGFzdGVMaW5rJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBoYW5kbGVQYXN0ZTogKHZpZXcsIGV2ZW50LCBzbGljZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1wdHkgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICBzbGljZS5jb250ZW50LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50ICs9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluayA9IGZpbmQodGV4dENvbnRlbnQsIHsgZGVmYXVsdFByb3RvY29sOiBvcHRpb25zLmRlZmF1bHRQcm90b2NvbCB9KS5maW5kKGl0ZW0gPT4gaXRlbS5pc0xpbmsgJiYgaXRlbS52YWx1ZSA9PT0gdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGlmICghdGV4dENvbnRlbnQgfHwgIWxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5lZGl0b3IuY29tbWFuZHMuc2V0TWFyayhvcHRpb25zLnR5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogbGluay5ocmVmLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuY29uc3QgcGFzdGVSZWdleCA9IC9odHRwcz86XFwvXFwvKD86d3d3XFwuKT9bLWEtekEtWjAtOUA6JS5fK34jPV17MSwyNTZ9XFwuW2EtekEtWl17Mix9XFxiKD86Wy1hLXpBLVowLTlAOiUuXyt+Iz0/ISYvXSopKD86Wy1hLXpBLVowLTlAOiUuXyt+Iz0/ISYvXSopL2dpO1xuLy8gRnJvbSBET01QdXJpZnlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jdXJlNTMvRE9NUHVyaWZ5L2Jsb2IvbWFpbi9zcmMvcmVnZXhwLmpzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuY29uc3QgQVRUUl9XSElURVNQQUNFID0gL1tcXHUwMDAwLVxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMjlcXHUyMDVGXFx1MzAwMF0vZztcbmZ1bmN0aW9uIGlzQWxsb3dlZFVyaSh1cmksIHByb3RvY29scykge1xuICAgIGNvbnN0IGFsbG93ZWRQcm90b2NvbHMgPSBbXG4gICAgICAgICdodHRwJyxcbiAgICAgICAgJ2h0dHBzJyxcbiAgICAgICAgJ2Z0cCcsXG4gICAgICAgICdmdHBzJyxcbiAgICAgICAgJ21haWx0bycsXG4gICAgICAgICd0ZWwnLFxuICAgICAgICAnY2FsbHRvJyxcbiAgICAgICAgJ3NtcycsXG4gICAgICAgICdjaWQnLFxuICAgICAgICAneG1wcCcsXG4gICAgXTtcbiAgICBpZiAocHJvdG9jb2xzKSB7XG4gICAgICAgIHByb3RvY29scy5mb3JFYWNoKHByb3RvY29sID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRQcm90b2NvbCA9IHR5cGVvZiBwcm90b2NvbCA9PT0gJ3N0cmluZycgPyBwcm90b2NvbCA6IHByb3RvY29sLnNjaGVtZTtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICBhbGxvd2VkUHJvdG9jb2xzLnB1c2gobmV4dFByb3RvY29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoIXVyaVxuICAgICAgICB8fCB1cmlcbiAgICAgICAgICAgIC5yZXBsYWNlKEFUVFJfV0hJVEVTUEFDRSwgJycpXG4gICAgICAgICAgICAubWF0Y2gobmV3IFJlZ0V4cChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgICAgIGBeKD86KD86JHthbGxvd2VkUHJvdG9jb2xzLmpvaW4oJ3wnKX0pOnxbXmEtel18W2EtejAtOSsuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpYCwgJ2knKSkpO1xufVxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBsaW5rcy5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbWFya3MvbGlua1xuICovXG5jb25zdCBMaW5rID0gTWFyay5jcmVhdGUoe1xuICAgIG5hbWU6ICdsaW5rJyxcbiAgICBwcmlvcml0eTogMTAwMCxcbiAgICBrZWVwT25TcGxpdDogZmFsc2UsXG4gICAgZXhpdGFibGU6IHRydWUsXG4gICAgb25DcmVhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsaWRhdGUgJiYgIXRoaXMub3B0aW9ucy5zaG91bGRBdXRvTGluaykge1xuICAgICAgICAgICAgLy8gQ29weSB0aGUgdmFsaWRhdGUgZnVuY3Rpb24gdG8gdGhlIHNob3VsZEF1dG9MaW5rIG9wdGlvblxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNob3VsZEF1dG9MaW5rID0gdGhpcy5vcHRpb25zLnZhbGlkYXRlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgYHZhbGlkYXRlYCBvcHRpb24gaXMgZGVwcmVjYXRlZC4gUmVuYW1lIHRvIHRoZSBgc2hvdWxkQXV0b0xpbmtgIG9wdGlvbiBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5wcm90b2NvbHMuZm9yRWFjaChwcm90b2NvbCA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3RvY29sID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wocHJvdG9jb2wpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wocHJvdG9jb2wuc2NoZW1lLCBwcm90b2NvbC5vcHRpb25hbFNsYXNoZXMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIG9uRGVzdHJveSgpIHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICB9LFxuICAgIGluY2x1c2l2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hdXRvbGluaztcbiAgICB9LFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcGVuT25DbGljazogdHJ1ZSxcbiAgICAgICAgICAgIGxpbmtPblBhc3RlOiB0cnVlLFxuICAgICAgICAgICAgYXV0b2xpbms6IHRydWUsXG4gICAgICAgICAgICBwcm90b2NvbHM6IFtdLFxuICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sOiAnaHR0cCcsXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIHRhcmdldDogJ19ibGFuaycsXG4gICAgICAgICAgICAgICAgcmVsOiAnbm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvdycsXG4gICAgICAgICAgICAgICAgY2xhc3M6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNBbGxvd2VkVXJpOiAodXJsLCBjdHgpID0+ICEhaXNBbGxvd2VkVXJpKHVybCwgY3R4LnByb3RvY29scyksXG4gICAgICAgICAgICB2YWxpZGF0ZTogdXJsID0+ICEhdXJsLFxuICAgICAgICAgICAgc2hvdWxkQXV0b0xpbms6IHVybCA9PiAhIXVybCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBocmVmOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJzZUhUTUwoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcy50YXJnZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVsOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLnJlbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcy5jbGFzcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnYVtocmVmXScsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGRvbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBkb20uZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgWFNTIGF0dGFja3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFocmVmXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAhdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaShocmVmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiB1cmwgPT4gISFpc0FsbG93ZWRVcmkodXJsLCB0aGlzLm9wdGlvbnMucHJvdG9jb2xzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIC8vIHByZXZlbnQgWFNTIGF0dGFja3NcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKEhUTUxBdHRyaWJ1dGVzLmhyZWYsIHtcbiAgICAgICAgICAgIGRlZmF1bHRWYWxpZGF0ZTogaHJlZiA9PiAhIWlzQWxsb3dlZFVyaShocmVmLCB0aGlzLm9wdGlvbnMucHJvdG9jb2xzKSxcbiAgICAgICAgICAgIHByb3RvY29sczogdGhpcy5vcHRpb25zLnByb3RvY29scyxcbiAgICAgICAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbCxcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIC8vIHN0cmlwIG91dCB0aGUgaHJlZlxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgeyAuLi5IVE1MQXR0cmlidXRlcywgaHJlZjogJycgfSksXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsnYScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldExpbms6IGF0dHJpYnV0ZXMgPT4gKHsgY2hhaW4gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaHJlZiB9ID0gYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoaHJlZiwge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6IHVybCA9PiAhIWlzQWxsb3dlZFVyaSh1cmwsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbCxcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbigpLnNldE1hcmsodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKS5zZXRNZXRhKCdwcmV2ZW50QXV0b2xpbmsnLCB0cnVlKS5ydW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGVMaW5rOiBhdHRyaWJ1dGVzID0+ICh7IGNoYWluIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGhyZWYgfSA9IGF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKGhyZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiB1cmwgPT4gISFpc0FsbG93ZWRVcmkodXJsLCB0aGlzLm9wdGlvbnMucHJvdG9jb2xzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xzOiB0aGlzLm9wdGlvbnMucHJvdG9jb2xzLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgICAgICAgICAgICAgICAudG9nZ2xlTWFyayh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMsIHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2U6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgLnNldE1ldGEoJ3ByZXZlbnRBdXRvbGluaycsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC5ydW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldExpbms6ICgpID0+ICh7IGNoYWluIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgICAgICAgICAgICAgICAudW5zZXRNYXJrKHRoaXMubmFtZSwgeyBleHRlbmRFbXB0eU1hcmtSYW5nZTogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TWV0YSgncHJldmVudEF1dG9saW5rJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLnJ1bigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiB0ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm91bmRMaW5rcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwcm90b2NvbHMsIGRlZmF1bHRQcm90b2NvbCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua3MgPSBmaW5kKHRleHQpLmZpbHRlcihpdGVtID0+IGl0ZW0uaXNMaW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaShpdGVtLnZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWxpZGF0ZTogaHJlZiA9PiAhIWlzQWxsb3dlZFVyaShocmVmLCBwcm90b2NvbHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQcm90b2NvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3MuZm9yRWFjaChsaW5rID0+IGZvdW5kTGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGxpbmsudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGxpbmsuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZExpbmtzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogKF9hID0gbWF0Y2guZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICBjb25zdCBwbHVnaW5zID0gW107XG4gICAgICAgIGNvbnN0IHsgcHJvdG9jb2xzLCBkZWZhdWx0UHJvdG9jb2wgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvbGluaykge1xuICAgICAgICAgICAgcGx1Z2lucy5wdXNoKGF1dG9saW5rKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRlOiB1cmwgPT4gdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaSh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiBocmVmID0+ICEhaXNBbGxvd2VkVXJpKGhyZWYsIHByb3RvY29scyksXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHNob3VsZEF1dG9MaW5rOiB0aGlzLm9wdGlvbnMuc2hvdWxkQXV0b0xpbmssXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcGVuT25DbGljayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcGx1Z2lucy5wdXNoKGNsaWNrSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGlua09uUGFzdGUpIHtcbiAgICAgICAgICAgIHBsdWdpbnMucHVzaChwYXN0ZUhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sLFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGx1Z2lucztcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IExpbmssIExpbmsgYXMgZGVmYXVsdCwgaXNBbGxvd2VkVXJpLCBwYXN0ZVJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjb21iaW5lVHJhbnNhY3Rpb25TdGVwcyIsImdldENoYW5nZWRSYW5nZXMiLCJmaW5kQ2hpbGRyZW5JblJhbmdlIiwiZ2V0TWFya3NCZXR3ZWVuIiwiZ2V0QXR0cmlidXRlcyIsIk1hcmsiLCJtZXJnZUF0dHJpYnV0ZXMiLCJtYXJrUGFzdGVSdWxlIiwidG9rZW5pemUiLCJmaW5kIiwicmVnaXN0ZXJDdXN0b21Qcm90b2NvbCIsInJlc2V0IiwiUGx1Z2luIiwiUGx1Z2luS2V5IiwiaXNWYWxpZExpbmtTdHJ1Y3R1cmUiLCJ0b2tlbnMiLCJsZW5ndGgiLCJpc0xpbmsiLCJpbmNsdWRlcyIsInZhbHVlIiwiYXV0b2xpbmsiLCJvcHRpb25zIiwia2V5IiwiYXBwZW5kVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbnMiLCJvbGRTdGF0ZSIsIm5ld1N0YXRlIiwiZG9jQ2hhbmdlcyIsInNvbWUiLCJ0cmFuc2FjdGlvbiIsImRvY0NoYW5nZWQiLCJkb2MiLCJlcSIsInByZXZlbnRBdXRvbGluayIsImdldE1ldGEiLCJ0ciIsInRyYW5zZm9ybSIsImNoYW5nZXMiLCJmb3JFYWNoIiwibmV3UmFuZ2UiLCJub2Rlc0luQ2hhbmdlZFJhbmdlcyIsIm5vZGUiLCJpc1RleHRibG9jayIsInRleHRCbG9jayIsInRleHRCZWZvcmVXaGl0ZXNwYWNlIiwidGV4dEJldHdlZW4iLCJwb3MiLCJub2RlU2l6ZSIsInVuZGVmaW5lZCIsImZyb20iLCJ0byIsImVuZHNXaXRoIiwid29yZHNCZWZvcmVXaGl0ZXNwYWNlIiwic3BsaXQiLCJmaWx0ZXIiLCJzIiwibGFzdFdvcmRCZWZvcmVTcGFjZSIsImxhc3RXb3JkQW5kQmxvY2tPZmZzZXQiLCJsYXN0SW5kZXhPZiIsImxpbmtzQmVmb3JlU3BhY2UiLCJtYXAiLCJ0IiwidG9PYmplY3QiLCJkZWZhdWx0UHJvdG9jb2wiLCJsaW5rIiwic3RhcnQiLCJlbmQiLCJzY2hlbWEiLCJtYXJrcyIsImNvZGUiLCJyYW5nZUhhc01hcmsiLCJ2YWxpZGF0ZSIsInNob3VsZEF1dG9MaW5rIiwiaXRlbSIsIm1hcmsiLCJ0eXBlIiwiYWRkTWFyayIsImNyZWF0ZSIsImhyZWYiLCJzdGVwcyIsImNsaWNrSGFuZGxlciIsInByb3BzIiwiaGFuZGxlQ2xpY2siLCJ2aWV3IiwiZXZlbnQiLCJfYSIsIl9iIiwiYnV0dG9uIiwiZWRpdGFibGUiLCJhIiwidGFyZ2V0IiwiZWxzIiwibm9kZU5hbWUiLCJwdXNoIiwicGFyZW50Tm9kZSIsImF0dHJzIiwic3RhdGUiLCJuYW1lIiwid2luZG93Iiwib3BlbiIsInBhc3RlSGFuZGxlciIsImhhbmRsZVBhc3RlIiwic2xpY2UiLCJzZWxlY3Rpb24iLCJlbXB0eSIsInRleHRDb250ZW50IiwiY29udGVudCIsImVkaXRvciIsImNvbW1hbmRzIiwic2V0TWFyayIsInBhc3RlUmVnZXgiLCJBVFRSX1dISVRFU1BBQ0UiLCJpc0FsbG93ZWRVcmkiLCJ1cmkiLCJwcm90b2NvbHMiLCJhbGxvd2VkUHJvdG9jb2xzIiwicHJvdG9jb2wiLCJuZXh0UHJvdG9jb2wiLCJzY2hlbWUiLCJyZXBsYWNlIiwibWF0Y2giLCJSZWdFeHAiLCJqb2luIiwiTGluayIsInByaW9yaXR5Iiwia2VlcE9uU3BsaXQiLCJleGl0YWJsZSIsIm9uQ3JlYXRlIiwiY29uc29sZSIsIndhcm4iLCJvcHRpb25hbFNsYXNoZXMiLCJvbkRlc3Ryb3kiLCJpbmNsdXNpdmUiLCJhZGRPcHRpb25zIiwib3Blbk9uQ2xpY2siLCJsaW5rT25QYXN0ZSIsIkhUTUxBdHRyaWJ1dGVzIiwicmVsIiwiY2xhc3MiLCJ1cmwiLCJjdHgiLCJhZGRBdHRyaWJ1dGVzIiwiZGVmYXVsdCIsInBhcnNlSFRNTCIsImVsZW1lbnQiLCJnZXRBdHRyaWJ1dGUiLCJ0YWciLCJnZXRBdHRycyIsImRvbSIsImRlZmF1bHRWYWxpZGF0ZSIsInJlbmRlckhUTUwiLCJhZGRDb21tYW5kcyIsInNldExpbmsiLCJhdHRyaWJ1dGVzIiwiY2hhaW4iLCJzZXRNZXRhIiwicnVuIiwidG9nZ2xlTGluayIsInRvZ2dsZU1hcmsiLCJleHRlbmRFbXB0eU1hcmtSYW5nZSIsInVuc2V0TGluayIsInVuc2V0TWFyayIsImFkZFBhc3RlUnVsZXMiLCJ0ZXh0IiwiZm91bmRMaW5rcyIsImxpbmtzIiwiZGF0YSIsImluZGV4IiwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zIiwicGx1Z2lucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-link/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-list-item/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-list-item/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListItem: () => (/* binding */ ListItem),\n/* harmony export */   \"default\": () => (/* binding */ ListItem)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */ const ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"listItem\",\n    addOptions () {\n        return {\n            HTMLAttributes: {},\n            bulletListTypeName: \"bulletList\",\n            orderedListTypeName: \"orderedList\"\n        };\n    },\n    content: \"paragraph block*\",\n    defining: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"li\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"li\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addKeyboardShortcuts () {\n        return {\n            Enter: ()=>this.editor.commands.splitListItem(this.name),\n            Tab: ()=>this.editor.commands.sinkListItem(this.name),\n            \"Shift-Tab\": ()=>this.editor.commands.liftListItem(this.name)\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC1pdGVtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEO0FBRXJEOzs7Q0FHQyxHQUNELE1BQU1FLFdBQVdGLDhDQUFJQSxDQUFDRyxNQUFNLENBQUM7SUFDekJDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGdCQUFnQixDQUFDO1lBQ2pCQyxvQkFBb0I7WUFDcEJDLHFCQUFxQjtRQUN6QjtJQUNKO0lBQ0FDLFNBQVM7SUFDVEMsVUFBVTtJQUNWQztRQUNJLE9BQU87WUFDSDtnQkFDSUMsS0FBSztZQUNUO1NBQ0g7SUFDTDtJQUNBQyxZQUFXLEVBQUVQLGNBQWMsRUFBRTtRQUN6QixPQUFPO1lBQUM7WUFBTUwsNkRBQWVBLENBQUMsSUFBSSxDQUFDYSxPQUFPLENBQUNSLGNBQWMsRUFBRUE7WUFBaUI7U0FBRTtJQUNsRjtJQUNBUztRQUNJLE9BQU87WUFDSEMsT0FBTyxJQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxRQUFRLENBQUNDLGFBQWEsQ0FBQyxJQUFJLENBQUNmLElBQUk7WUFDekRnQixLQUFLLElBQU0sSUFBSSxDQUFDSCxNQUFNLENBQUNDLFFBQVEsQ0FBQ0csWUFBWSxDQUFDLElBQUksQ0FBQ2pCLElBQUk7WUFDdEQsYUFBYSxJQUFNLElBQUksQ0FBQ2EsTUFBTSxDQUFDQyxRQUFRLENBQUNJLFlBQVksQ0FBQyxJQUFJLENBQUNsQixJQUFJO1FBQ2xFO0lBQ0o7QUFDSjtBQUV5QyxDQUN6QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QtaXRlbS9kaXN0L2luZGV4LmpzPzVlMjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBsaXN0IGl0ZW1zLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9saXN0LWl0ZW1cbiAqL1xuY29uc3QgTGlzdEl0ZW0gPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2xpc3RJdGVtJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgICAgYnVsbGV0TGlzdFR5cGVOYW1lOiAnYnVsbGV0TGlzdCcsXG4gICAgICAgICAgICBvcmRlcmVkTGlzdFR5cGVOYW1lOiAnb3JkZXJlZExpc3QnLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29udGVudDogJ3BhcmFncmFwaCBibG9jayonLFxuICAgIGRlZmluaW5nOiB0cnVlLFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdsaScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsnbGknLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBFbnRlcjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc3BsaXRMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgICAgICAgVGFiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgICAgfTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IExpc3RJdGVtLCBMaXN0SXRlbSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJOb2RlIiwibWVyZ2VBdHRyaWJ1dGVzIiwiTGlzdEl0ZW0iLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsIkhUTUxBdHRyaWJ1dGVzIiwiYnVsbGV0TGlzdFR5cGVOYW1lIiwib3JkZXJlZExpc3RUeXBlTmFtZSIsImNvbnRlbnQiLCJkZWZpbmluZyIsInBhcnNlSFRNTCIsInRhZyIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJFbnRlciIsImVkaXRvciIsImNvbW1hbmRzIiwic3BsaXRMaXN0SXRlbSIsIlRhYiIsInNpbmtMaXN0SXRlbSIsImxpZnRMaXN0SXRlbSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-list-item/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-ordered-list/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-ordered-list/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrderedList: () => (/* binding */ OrderedList),\n/* harmony export */   \"default\": () => (/* binding */ OrderedList),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\nconst ListItemName = \"listItem\";\nconst TextStyleName = \"textStyle\";\n/**\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\n */ const inputRegex = /^(\\d+)\\.\\s$/;\n/**\n * This extension allows you to create ordered lists.\n * This requires the ListItem extension\n * @see https://www.tiptap.dev/api/nodes/ordered-list\n * @see https://www.tiptap.dev/api/nodes/list-item\n */ const OrderedList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"orderedList\",\n    addOptions () {\n        return {\n            itemTypeName: \"listItem\",\n            HTMLAttributes: {},\n            keepMarks: false,\n            keepAttributes: false\n        };\n    },\n    group: \"block list\",\n    content () {\n        return `${this.options.itemTypeName}+`;\n    },\n    addAttributes () {\n        return {\n            start: {\n                default: 1,\n                parseHTML: (element)=>{\n                    return element.hasAttribute(\"start\") ? parseInt(element.getAttribute(\"start\") || \"\", 10) : 1;\n                }\n            },\n            type: {\n                default: null,\n                parseHTML: (element)=>element.getAttribute(\"type\")\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"ol\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        const { start, ...attributesWithoutStart } = HTMLAttributes;\n        return start === 1 ? [\n            \"ol\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart),\n            0\n        ] : [\n            \"ol\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            toggleOrderedList: ()=>({ commands, chain })=>{\n                    if (this.options.keepAttributes) {\n                        return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n                    }\n                    return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-7\": ()=>this.editor.commands.toggleOrderedList()\n        };\n    },\n    addInputRules () {\n        let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n            find: inputRegex,\n            type: this.type,\n            getAttributes: (match)=>({\n                    start: +match[1]\n                }),\n            joinPredicate: (match, node)=>node.childCount + node.attrs.start === +match[1]\n        });\n        if (this.options.keepMarks || this.options.keepAttributes) {\n            inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type,\n                keepMarks: this.options.keepMarks,\n                keepAttributes: this.options.keepAttributes,\n                getAttributes: (match)=>({\n                        start: +match[1],\n                        ...this.editor.getAttributes(TextStyleName)\n                    }),\n                joinPredicate: (match, node)=>node.childCount + node.attrs.start === +match[1],\n                editor: this.editor\n            });\n        }\n        return [\n            inputRule\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tb3JkZXJlZC1saXN0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3RTtBQUV4RSxNQUFNRyxlQUFlO0FBQ3JCLE1BQU1DLGdCQUFnQjtBQUN0Qjs7Q0FFQyxHQUNELE1BQU1DLGFBQWE7QUFDbkI7Ozs7O0NBS0MsR0FDRCxNQUFNQyxjQUFjTiw4Q0FBSUEsQ0FBQ08sTUFBTSxDQUFDO0lBQzVCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxjQUFjO1lBQ2RDLGdCQUFnQixDQUFDO1lBQ2pCQyxXQUFXO1lBQ1hDLGdCQUFnQjtRQUNwQjtJQUNKO0lBQ0FDLE9BQU87SUFDUEM7UUFDSSxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUNDLE9BQU8sQ0FBQ04sWUFBWSxDQUFDLENBQUMsQ0FBQztJQUMxQztJQUNBTztRQUNJLE9BQU87WUFDSEMsT0FBTztnQkFDSEMsU0FBUztnQkFDVEMsV0FBV0MsQ0FBQUE7b0JBQ1AsT0FBT0EsUUFBUUMsWUFBWSxDQUFDLFdBQ3RCQyxTQUFTRixRQUFRRyxZQUFZLENBQUMsWUFBWSxJQUFJLE1BQzlDO2dCQUNWO1lBQ0o7WUFDQUMsTUFBTTtnQkFDRk4sU0FBUztnQkFDVEMsV0FBV0MsQ0FBQUEsVUFBV0EsUUFBUUcsWUFBWSxDQUFDO1lBQy9DO1FBQ0o7SUFDSjtJQUNBSjtRQUNJLE9BQU87WUFDSDtnQkFDSU0sS0FBSztZQUNUO1NBQ0g7SUFDTDtJQUNBQyxZQUFXLEVBQUVoQixjQUFjLEVBQUU7UUFDekIsTUFBTSxFQUFFTyxLQUFLLEVBQUUsR0FBR1Usd0JBQXdCLEdBQUdqQjtRQUM3QyxPQUFPTyxVQUFVLElBQ1g7WUFBQztZQUFNakIsNkRBQWVBLENBQUMsSUFBSSxDQUFDZSxPQUFPLENBQUNMLGNBQWMsRUFBRWlCO1lBQXlCO1NBQUUsR0FDL0U7WUFBQztZQUFNM0IsNkRBQWVBLENBQUMsSUFBSSxDQUFDZSxPQUFPLENBQUNMLGNBQWMsRUFBRUE7WUFBaUI7U0FBRTtJQUNqRjtJQUNBa0I7UUFDSSxPQUFPO1lBQ0hDLG1CQUFtQixJQUFNLENBQUMsRUFBRUMsUUFBUSxFQUFFQyxLQUFLLEVBQUU7b0JBQ3pDLElBQUksSUFBSSxDQUFDaEIsT0FBTyxDQUFDSCxjQUFjLEVBQUU7d0JBQzdCLE9BQU9tQixRQUFRQyxVQUFVLENBQUMsSUFBSSxDQUFDekIsSUFBSSxFQUFFLElBQUksQ0FBQ1EsT0FBTyxDQUFDTixZQUFZLEVBQUUsSUFBSSxDQUFDTSxPQUFPLENBQUNKLFNBQVMsRUFBRXNCLGdCQUFnQixDQUFDL0IsY0FBYyxJQUFJLENBQUNnQyxNQUFNLENBQUNDLGFBQWEsQ0FBQ2hDLGdCQUFnQmlDLEdBQUc7b0JBQ3hLO29CQUNBLE9BQU9OLFNBQVNFLFVBQVUsQ0FBQyxJQUFJLENBQUN6QixJQUFJLEVBQUUsSUFBSSxDQUFDUSxPQUFPLENBQUNOLFlBQVksRUFBRSxJQUFJLENBQUNNLE9BQU8sQ0FBQ0osU0FBUztnQkFDM0Y7UUFDSjtJQUNKO0lBQ0EwQjtRQUNJLE9BQU87WUFDSCxlQUFlLElBQU0sSUFBSSxDQUFDSCxNQUFNLENBQUNKLFFBQVEsQ0FBQ0QsaUJBQWlCO1FBQy9EO0lBQ0o7SUFDQVM7UUFDSSxJQUFJQyxZQUFZdEMsK0RBQWlCQSxDQUFDO1lBQzlCdUMsTUFBTXBDO1lBQ05vQixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmVyxlQUFlTSxDQUFBQSxRQUFVO29CQUFFeEIsT0FBTyxDQUFDd0IsS0FBSyxDQUFDLEVBQUU7Z0JBQUM7WUFDNUNDLGVBQWUsQ0FBQ0QsT0FBT0UsT0FBU0EsS0FBS0MsVUFBVSxHQUFHRCxLQUFLRSxLQUFLLENBQUM1QixLQUFLLEtBQUssQ0FBQ3dCLEtBQUssQ0FBQyxFQUFFO1FBQ3BGO1FBQ0EsSUFBSSxJQUFJLENBQUMxQixPQUFPLENBQUNKLFNBQVMsSUFBSSxJQUFJLENBQUNJLE9BQU8sQ0FBQ0gsY0FBYyxFQUFFO1lBQ3ZEMkIsWUFBWXRDLCtEQUFpQkEsQ0FBQztnQkFDMUJ1QyxNQUFNcEM7Z0JBQ05vQixNQUFNLElBQUksQ0FBQ0EsSUFBSTtnQkFDZmIsV0FBVyxJQUFJLENBQUNJLE9BQU8sQ0FBQ0osU0FBUztnQkFDakNDLGdCQUFnQixJQUFJLENBQUNHLE9BQU8sQ0FBQ0gsY0FBYztnQkFDM0N1QixlQUFlTSxDQUFBQSxRQUFVO3dCQUFFeEIsT0FBTyxDQUFDd0IsS0FBSyxDQUFDLEVBQUU7d0JBQUUsR0FBRyxJQUFJLENBQUNQLE1BQU0sQ0FBQ0MsYUFBYSxDQUFDaEMsY0FBYztvQkFBQztnQkFDekZ1QyxlQUFlLENBQUNELE9BQU9FLE9BQVNBLEtBQUtDLFVBQVUsR0FBR0QsS0FBS0UsS0FBSyxDQUFDNUIsS0FBSyxLQUFLLENBQUN3QixLQUFLLENBQUMsRUFBRTtnQkFDaEZQLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ3ZCO1FBQ0o7UUFDQSxPQUFPO1lBQ0hLO1NBQ0g7SUFDTDtBQUNKO0FBRTJELENBQzNELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tb3JkZXJlZC1saXN0L2Rpc3QvaW5kZXguanM/M2VkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuY29uc3QgTGlzdEl0ZW1OYW1lID0gJ2xpc3RJdGVtJztcbmNvbnN0IFRleHRTdHlsZU5hbWUgPSAndGV4dFN0eWxlJztcbi8qKlxuICogTWF0Y2hlcyBhbiBvcmRlcmVkIGxpc3QgdG8gYSAxLiBvbiBpbnB1dCAob3IgYW55IG51bWJlciBmb2xsb3dlZCBieSBhIGRvdCkuXG4gKi9cbmNvbnN0IGlucHV0UmVnZXggPSAvXihcXGQrKVxcLlxccyQvO1xuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBvcmRlcmVkIGxpc3RzLlxuICogVGhpcyByZXF1aXJlcyB0aGUgTGlzdEl0ZW0gZXh0ZW5zaW9uXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL29yZGVyZWQtbGlzdFxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9saXN0LWl0ZW1cbiAqL1xuY29uc3QgT3JkZXJlZExpc3QgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ29yZGVyZWRMaXN0JyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXRlbVR5cGVOYW1lOiAnbGlzdEl0ZW0nLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgICAga2VlcE1hcmtzOiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBBdHRyaWJ1dGVzOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGdyb3VwOiAnYmxvY2sgbGlzdCcsXG4gICAgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWV9K2A7XG4gICAgfSxcbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnc3RhcnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3RhcnQnKSB8fCAnJywgMTApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnb2wnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIC4uLmF0dHJpYnV0ZXNXaXRob3V0U3RhcnQgfSA9IEhUTUxBdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gc3RhcnQgPT09IDFcbiAgICAgICAgICAgID8gWydvbCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNXaXRob3V0U3RhcnQpLCAwXVxuICAgICAgICAgICAgOiBbJ29sJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9nZ2xlT3JkZXJlZExpc3Q6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW4oKS50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcykudXBkYXRlQXR0cmlidXRlcyhMaXN0SXRlbU5hbWUsIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZSkpLnJ1bigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1TaGlmdC03JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlT3JkZXJlZExpc3QoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZElucHV0UnVsZXMoKSB7XG4gICAgICAgIGxldCBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHsgc3RhcnQ6ICttYXRjaFsxXSB9KSxcbiAgICAgICAgICAgIGpvaW5QcmVkaWNhdGU6IChtYXRjaCwgbm9kZSkgPT4gbm9kZS5jaGlsZENvdW50ICsgbm9kZS5hdHRycy5zdGFydCA9PT0gK21hdGNoWzFdLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwTWFya3MgfHwgdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAga2VlcE1hcmtzOiB0aGlzLm9wdGlvbnMua2VlcE1hcmtzLFxuICAgICAgICAgICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHsgc3RhcnQ6ICttYXRjaFsxXSwgLi4udGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGVOYW1lKSB9KSxcbiAgICAgICAgICAgICAgICBqb2luUHJlZGljYXRlOiAobWF0Y2gsIG5vZGUpID0+IG5vZGUuY2hpbGRDb3VudCArIG5vZGUuYXR0cnMuc3RhcnQgPT09ICttYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGlucHV0UnVsZSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IE9yZGVyZWRMaXN0LCBPcmRlcmVkTGlzdCBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJOb2RlIiwibWVyZ2VBdHRyaWJ1dGVzIiwid3JhcHBpbmdJbnB1dFJ1bGUiLCJMaXN0SXRlbU5hbWUiLCJUZXh0U3R5bGVOYW1lIiwiaW5wdXRSZWdleCIsIk9yZGVyZWRMaXN0IiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJpdGVtVHlwZU5hbWUiLCJIVE1MQXR0cmlidXRlcyIsImtlZXBNYXJrcyIsImtlZXBBdHRyaWJ1dGVzIiwiZ3JvdXAiLCJjb250ZW50Iiwib3B0aW9ucyIsImFkZEF0dHJpYnV0ZXMiLCJzdGFydCIsImRlZmF1bHQiLCJwYXJzZUhUTUwiLCJlbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicGFyc2VJbnQiLCJnZXRBdHRyaWJ1dGUiLCJ0eXBlIiwidGFnIiwicmVuZGVySFRNTCIsImF0dHJpYnV0ZXNXaXRob3V0U3RhcnQiLCJhZGRDb21tYW5kcyIsInRvZ2dsZU9yZGVyZWRMaXN0IiwiY29tbWFuZHMiLCJjaGFpbiIsInRvZ2dsZUxpc3QiLCJ1cGRhdGVBdHRyaWJ1dGVzIiwiZWRpdG9yIiwiZ2V0QXR0cmlidXRlcyIsInJ1biIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiYWRkSW5wdXRSdWxlcyIsImlucHV0UnVsZSIsImZpbmQiLCJtYXRjaCIsImpvaW5QcmVkaWNhdGUiLCJub2RlIiwiY2hpbGRDb3VudCIsImF0dHJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-ordered-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-paragraph/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Paragraph: () => (/* binding */ Paragraph),\n/* harmony export */   \"default\": () => (/* binding */ Paragraph)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * This extension allows you to create paragraphs.\n * @see https://www.tiptap.dev/api/nodes/paragraph\n */ const Paragraph = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"paragraph\",\n    priority: 1000,\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    group: \"block\",\n    content: \"inline*\",\n    parseHTML () {\n        return [\n            {\n                tag: \"p\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"p\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setParagraph: ()=>({ commands })=>{\n                    return commands.setNode(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Alt-0\": ()=>this.editor.commands.setParagraph()\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEO0FBRXJEOzs7Q0FHQyxHQUNELE1BQU1FLFlBQVlGLDhDQUFJQSxDQUFDRyxNQUFNLENBQUM7SUFDMUJDLE1BQU07SUFDTkMsVUFBVTtJQUNWQztRQUNJLE9BQU87WUFDSEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQyxPQUFPO0lBQ1BDLFNBQVM7SUFDVEM7UUFDSSxPQUFPO1lBQ0g7Z0JBQUVDLEtBQUs7WUFBSTtTQUNkO0lBQ0w7SUFDQUMsWUFBVyxFQUFFTCxjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQUtOLDZEQUFlQSxDQUFDLElBQUksQ0FBQ1ksT0FBTyxDQUFDTixjQUFjLEVBQUVBO1lBQWlCO1NBQUU7SUFDakY7SUFDQU87UUFDSSxPQUFPO1lBQ0hDLGNBQWMsSUFBTSxDQUFDLEVBQUVDLFFBQVEsRUFBRTtvQkFDN0IsT0FBT0EsU0FBU0MsT0FBTyxDQUFDLElBQUksQ0FBQ2IsSUFBSTtnQkFDckM7UUFDSjtJQUNKO0lBQ0FjO1FBQ0ksT0FBTztZQUNILGFBQWEsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ0gsUUFBUSxDQUFDRCxZQUFZO1FBQ3hEO0lBQ0o7QUFDSjtBQUUyQyxDQUMzQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXBhcmFncmFwaC9kaXN0L2luZGV4LmpzPzhiYTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBwYXJhZ3JhcGhzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9wYXJhZ3JhcGhcbiAqL1xuY29uc3QgUGFyYWdyYXBoID0gTm9kZS5jcmVhdGUoe1xuICAgIG5hbWU6ICdwYXJhZ3JhcGgnLFxuICAgIHByaW9yaXR5OiAxMDAwLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBncm91cDogJ2Jsb2NrJyxcbiAgICBjb250ZW50OiAnaW5saW5lKicsXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0YWc6ICdwJyB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsncCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldFBhcmFncmFwaDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLUFsdC0wJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0UGFyYWdyYXBoKCksXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBQYXJhZ3JhcGgsIFBhcmFncmFwaCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJOb2RlIiwibWVyZ2VBdHRyaWJ1dGVzIiwiUGFyYWdyYXBoIiwiY3JlYXRlIiwibmFtZSIsInByaW9yaXR5IiwiYWRkT3B0aW9ucyIsIkhUTUxBdHRyaWJ1dGVzIiwiZ3JvdXAiLCJjb250ZW50IiwicGFyc2VIVE1MIiwidGFnIiwicmVuZGVySFRNTCIsIm9wdGlvbnMiLCJhZGRDb21tYW5kcyIsInNldFBhcmFncmFwaCIsImNvbW1hbmRzIiwic2V0Tm9kZSIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiZWRpdG9yIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-placeholder/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-placeholder/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Placeholder: () => (/* binding */ Placeholder),\n/* harmony export */   \"default\": () => (/* binding */ Placeholder)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/view/dist/index.js\");\n\n\n\n/**\n * This extension allows you to add a placeholder to your editor.\n * A placeholder is a text that appears when the editor or a node is empty.\n * @see https://www.tiptap.dev/api/extensions/placeholder\n */ const Placeholder = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Extension.create({\n    name: \"placeholder\",\n    addOptions () {\n        return {\n            emptyEditorClass: \"is-editor-empty\",\n            emptyNodeClass: \"is-empty\",\n            placeholder: \"Write something …\",\n            showOnlyWhenEditable: true,\n            showOnlyCurrent: true,\n            includeChildren: false\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"placeholder\"),\n                props: {\n                    decorations: ({ doc, selection })=>{\n                        const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;\n                        const { anchor } = selection;\n                        const decorations = [];\n                        if (!active) {\n                            return null;\n                        }\n                        const isEmptyDoc = this.editor.isEmpty;\n                        doc.descendants((node, pos)=>{\n                            const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n                            const isEmpty = !node.isLeaf && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeEmpty)(node);\n                            if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                                const classes = [\n                                    this.options.emptyNodeClass\n                                ];\n                                if (isEmptyDoc) {\n                                    classes.push(this.options.emptyEditorClass);\n                                }\n                                const decoration = _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.node(pos, pos + node.nodeSize, {\n                                    class: classes.join(\" \"),\n                                    \"data-placeholder\": typeof this.options.placeholder === \"function\" ? this.options.placeholder({\n                                        editor: this.editor,\n                                        node,\n                                        pos,\n                                        hasAnchor\n                                    }) : this.options.placeholder\n                                });\n                                decorations.push(decoration);\n                            }\n                            return this.options.includeChildren;\n                        });\n                        return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.DecorationSet.create(doc, decorations);\n                    }\n                }\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGxhY2Vob2xkZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFzRDtBQUNEO0FBQ087QUFFNUQ7Ozs7Q0FJQyxHQUNELE1BQU1NLGNBQWNOLG1EQUFTQSxDQUFDTyxNQUFNLENBQUM7SUFDakNDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGtCQUFrQjtZQUNsQkMsZ0JBQWdCO1lBQ2hCQyxhQUFhO1lBQ2JDLHNCQUFzQjtZQUN0QkMsaUJBQWlCO1lBQ2pCQyxpQkFBaUI7UUFDckI7SUFDSjtJQUNBQztRQUNJLE9BQU87WUFDSCxJQUFJZCxvREFBTUEsQ0FBQztnQkFDUGUsS0FBSyxJQUFJZCx1REFBU0EsQ0FBQztnQkFDbkJlLE9BQU87b0JBQ0hDLGFBQWEsQ0FBQyxFQUFFQyxHQUFHLEVBQUVDLFNBQVMsRUFBRTt3QkFDNUIsTUFBTUMsU0FBUyxJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDQyxPQUFPLENBQUNaLG9CQUFvQjt3QkFDM0UsTUFBTSxFQUFFYSxNQUFNLEVBQUUsR0FBR0w7d0JBQ25CLE1BQU1GLGNBQWMsRUFBRTt3QkFDdEIsSUFBSSxDQUFDRyxRQUFROzRCQUNULE9BQU87d0JBQ1g7d0JBQ0EsTUFBTUssYUFBYSxJQUFJLENBQUNKLE1BQU0sQ0FBQ0ssT0FBTzt3QkFDdENSLElBQUlTLFdBQVcsQ0FBQyxDQUFDQyxNQUFNQzs0QkFDbkIsTUFBTUMsWUFBWU4sVUFBVUssT0FBT0wsVUFBVUssTUFBTUQsS0FBS0csUUFBUTs0QkFDaEUsTUFBTUwsVUFBVSxDQUFDRSxLQUFLSSxNQUFNLElBQUlqQyx5REFBV0EsQ0FBQzZCOzRCQUM1QyxJQUFJLENBQUNFLGFBQWEsQ0FBQyxJQUFJLENBQUNQLE9BQU8sQ0FBQ1gsZUFBZSxLQUFLYyxTQUFTO2dDQUN6RCxNQUFNTyxVQUFVO29DQUFDLElBQUksQ0FBQ1YsT0FBTyxDQUFDZCxjQUFjO2lDQUFDO2dDQUM3QyxJQUFJZ0IsWUFBWTtvQ0FDWlEsUUFBUUMsSUFBSSxDQUFDLElBQUksQ0FBQ1gsT0FBTyxDQUFDZixnQkFBZ0I7Z0NBQzlDO2dDQUNBLE1BQU0yQixhQUFhakMsdURBQVVBLENBQUMwQixJQUFJLENBQUNDLEtBQUtBLE1BQU1ELEtBQUtHLFFBQVEsRUFBRTtvQ0FDekRLLE9BQU9ILFFBQVFJLElBQUksQ0FBQztvQ0FDcEIsb0JBQW9CLE9BQU8sSUFBSSxDQUFDZCxPQUFPLENBQUNiLFdBQVcsS0FBSyxhQUNsRCxJQUFJLENBQUNhLE9BQU8sQ0FBQ2IsV0FBVyxDQUFDO3dDQUN2QlcsUUFBUSxJQUFJLENBQUNBLE1BQU07d0NBQ25CTzt3Q0FDQUM7d0NBQ0FDO29DQUNKLEtBQ0UsSUFBSSxDQUFDUCxPQUFPLENBQUNiLFdBQVc7Z0NBQ2xDO2dDQUNBTyxZQUFZaUIsSUFBSSxDQUFDQzs0QkFDckI7NEJBQ0EsT0FBTyxJQUFJLENBQUNaLE9BQU8sQ0FBQ1YsZUFBZTt3QkFDdkM7d0JBQ0EsT0FBT1YsMERBQWFBLENBQUNFLE1BQU0sQ0FBQ2EsS0FBS0Q7b0JBQ3JDO2dCQUNKO1lBQ0o7U0FDSDtJQUNMO0FBQ0o7QUFFK0MsQ0FDL0MsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1wbGFjZWhvbGRlci9kaXN0L2luZGV4LmpzPzIzYTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uLCBpc05vZGVFbXB0eSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldyc7XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBhZGQgYSBwbGFjZWhvbGRlciB0byB5b3VyIGVkaXRvci5cbiAqIEEgcGxhY2Vob2xkZXIgaXMgYSB0ZXh0IHRoYXQgYXBwZWFycyB3aGVuIHRoZSBlZGl0b3Igb3IgYSBub2RlIGlzIGVtcHR5LlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL3BsYWNlaG9sZGVyXG4gKi9cbmNvbnN0IFBsYWNlaG9sZGVyID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3BsYWNlaG9sZGVyJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHlFZGl0b3JDbGFzczogJ2lzLWVkaXRvci1lbXB0eScsXG4gICAgICAgICAgICBlbXB0eU5vZGVDbGFzczogJ2lzLWVtcHR5JyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnV3JpdGUgc29tZXRoaW5nIOKApicsXG4gICAgICAgICAgICBzaG93T25seVdoZW5FZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHNob3dPbmx5Q3VycmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGluY2x1ZGVDaGlsZHJlbjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ3BsYWNlaG9sZGVyJyksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdGlvbnM6ICh7IGRvYywgc2VsZWN0aW9uIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZWRpdG9yLmlzRWRpdGFibGUgfHwgIXRoaXMub3B0aW9ucy5zaG93T25seVdoZW5FZGl0YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYW5jaG9yIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRW1wdHlEb2MgPSB0aGlzLmVkaXRvci5pc0VtcHR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNBbmNob3IgPSBhbmNob3IgPj0gcG9zICYmIGFuY2hvciA8PSBwb3MgKyBub2RlLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRW1wdHkgPSAhbm9kZS5pc0xlYWYgJiYgaXNOb2RlRW1wdHkobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChoYXNBbmNob3IgfHwgIXRoaXMub3B0aW9ucy5zaG93T25seUN1cnJlbnQpICYmIGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IFt0aGlzLm9wdGlvbnMuZW1wdHlOb2RlQ2xhc3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eURvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHRoaXMub3B0aW9ucy5lbXB0eUVkaXRvckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uID0gRGVjb3JhdGlvbi5ub2RlKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGNsYXNzZXMuam9pbignICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtcGxhY2Vob2xkZXInOiB0eXBlb2YgdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0FuY2hvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChkZWNvcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmNsdWRlQ2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBQbGFjZWhvbGRlciwgUGxhY2Vob2xkZXIgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiRXh0ZW5zaW9uIiwiaXNOb2RlRW1wdHkiLCJQbHVnaW4iLCJQbHVnaW5LZXkiLCJEZWNvcmF0aW9uIiwiRGVjb3JhdGlvblNldCIsIlBsYWNlaG9sZGVyIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJlbXB0eUVkaXRvckNsYXNzIiwiZW1wdHlOb2RlQ2xhc3MiLCJwbGFjZWhvbGRlciIsInNob3dPbmx5V2hlbkVkaXRhYmxlIiwic2hvd09ubHlDdXJyZW50IiwiaW5jbHVkZUNoaWxkcmVuIiwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zIiwia2V5IiwicHJvcHMiLCJkZWNvcmF0aW9ucyIsImRvYyIsInNlbGVjdGlvbiIsImFjdGl2ZSIsImVkaXRvciIsImlzRWRpdGFibGUiLCJvcHRpb25zIiwiYW5jaG9yIiwiaXNFbXB0eURvYyIsImlzRW1wdHkiLCJkZXNjZW5kYW50cyIsIm5vZGUiLCJwb3MiLCJoYXNBbmNob3IiLCJub2RlU2l6ZSIsImlzTGVhZiIsImNsYXNzZXMiLCJwdXNoIiwiZGVjb3JhdGlvbiIsImNsYXNzIiwiam9pbiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-placeholder/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-strike/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Strike: () => (/* binding */ Strike),\n/* harmony export */   \"default\": () => (/* binding */ Strike),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * Matches a strike to a ~~strike~~ on input.\n */ const inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/;\n/**\n * Matches a strike to a ~~strike~~ on paste.\n */ const pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g;\n/**\n * This extension allows you to create strike text.\n * @see https://www.tiptap.dev/api/marks/strike\n */ const Strike = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"strike\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"s\"\n            },\n            {\n                tag: \"del\"\n            },\n            {\n                tag: \"strike\"\n            },\n            {\n                style: \"text-decoration\",\n                consuming: false,\n                getAttrs: (style)=>style.includes(\"line-through\") ? {} : false\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"s\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setStrike: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleStrike: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetStrike: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-s\": ()=>this.editor.commands.toggleStrike()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: inputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: pasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUY7QUFFbkY7O0NBRUMsR0FDRCxNQUFNSSxhQUFhO0FBQ25COztDQUVDLEdBQ0QsTUFBTUMsYUFBYTtBQUNuQjs7O0NBR0MsR0FDRCxNQUFNQyxTQUFTTiw4Q0FBSUEsQ0FBQ08sTUFBTSxDQUFDO0lBQ3ZCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxnQkFBZ0IsQ0FBQztRQUNyQjtJQUNKO0lBQ0FDO1FBQ0ksT0FBTztZQUNIO2dCQUNJQyxLQUFLO1lBQ1Q7WUFDQTtnQkFDSUEsS0FBSztZQUNUO1lBQ0E7Z0JBQ0lBLEtBQUs7WUFDVDtZQUNBO2dCQUNJQyxPQUFPO2dCQUNQQyxXQUFXO2dCQUNYQyxVQUFVRixDQUFBQSxRQUFVQSxNQUFNRyxRQUFRLENBQUMsa0JBQWtCLENBQUMsSUFBSTtZQUM5RDtTQUNIO0lBQ0w7SUFDQUMsWUFBVyxFQUFFUCxjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQUtULDZEQUFlQSxDQUFDLElBQUksQ0FBQ2lCLE9BQU8sQ0FBQ1IsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ2pGO0lBQ0FTO1FBQ0ksT0FBTztZQUNIQyxXQUFXLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQzFCLE9BQU9BLFNBQVNDLE9BQU8sQ0FBQyxJQUFJLENBQUNkLElBQUk7Z0JBQ3JDO1lBQ0FlLGNBQWMsSUFBTSxDQUFDLEVBQUVGLFFBQVEsRUFBRTtvQkFDN0IsT0FBT0EsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQ2hCLElBQUk7Z0JBQ3hDO1lBQ0FpQixhQUFhLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQzVCLE9BQU9BLFNBQVNLLFNBQVMsQ0FBQyxJQUFJLENBQUNsQixJQUFJO2dCQUN2QztRQUNKO0lBQ0o7SUFDQW1CO1FBQ0ksT0FBTztZQUNILGVBQWUsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxZQUFZO1FBQzFEO0lBQ0o7SUFDQU07UUFDSSxPQUFPO1lBQ0gzQiwyREFBYUEsQ0FBQztnQkFDVjRCLE1BQU0xQjtnQkFDTjJCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1NBQ0g7SUFDTDtJQUNBQztRQUNJLE9BQU87WUFDSDdCLDJEQUFhQSxDQUFDO2dCQUNWMkIsTUFBTXpCO2dCQUNOMEIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7U0FDSDtJQUNMO0FBQ0o7QUFFNkQsQ0FDN0QsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1zdHJpa2UvZGlzdC9pbmRleC5qcz84ZTQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogTWF0Y2hlcyBhIHN0cmlrZSB0byBhIH5+c3RyaWtlfn4gb24gaW5wdXQuXG4gKi9cbmNvbnN0IGlucHV0UmVnZXggPSAvKD86XnxcXHMpKH5+KD8hXFxzK35+KSgoPzpbXn5dKykpfn4oPyFcXHMrfn4pKSQvO1xuLyoqXG4gKiBNYXRjaGVzIGEgc3RyaWtlIHRvIGEgfn5zdHJpa2V+fiBvbiBwYXN0ZS5cbiAqL1xuY29uc3QgcGFzdGVSZWdleCA9IC8oPzpefFxccykofn4oPyFcXHMrfn4pKCg/Oltefl0rKSl+fig/IVxccyt+fikpL2c7XG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIHN0cmlrZSB0ZXh0LlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9tYXJrcy9zdHJpa2VcbiAqL1xuY29uc3QgU3RyaWtlID0gTWFyay5jcmVhdGUoe1xuICAgIG5hbWU6ICdzdHJpa2UnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAncycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogJ2RlbCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogJ3N0cmlrZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0eWxlOiAndGV4dC1kZWNvcmF0aW9uJyxcbiAgICAgICAgICAgICAgICBjb25zdW1pbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiBzdHlsZSA9PiAoc3R5bGUuaW5jbHVkZXMoJ2xpbmUtdGhyb3VnaCcpID8ge30gOiBmYWxzZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsncycsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldFN0cmlrZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlU3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldFN0cmlrZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtU2hpZnQtcyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVN0cmlrZSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogcGFzdGVSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IFN0cmlrZSwgU3RyaWtlIGFzIGRlZmF1bHQsIGlucHV0UmVnZXgsIHBhc3RlUmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk1hcmsiLCJtZXJnZUF0dHJpYnV0ZXMiLCJtYXJrSW5wdXRSdWxlIiwibWFya1Bhc3RlUnVsZSIsImlucHV0UmVnZXgiLCJwYXN0ZVJlZ2V4IiwiU3RyaWtlIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsInBhcnNlSFRNTCIsInRhZyIsInN0eWxlIiwiY29uc3VtaW5nIiwiZ2V0QXR0cnMiLCJpbmNsdWRlcyIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiYWRkQ29tbWFuZHMiLCJzZXRTdHJpa2UiLCJjb21tYW5kcyIsInNldE1hcmsiLCJ0b2dnbGVTdHJpa2UiLCJ0b2dnbGVNYXJrIiwidW5zZXRTdHJpa2UiLCJ1bnNldE1hcmsiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwidHlwZSIsImFkZFBhc3RlUnVsZXMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-task-item/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-task-item/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaskItem: () => (/* binding */ TaskItem),\n/* harmony export */   \"default\": () => (/* binding */ TaskItem),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * Matches a task item to a - [ ] on input.\n */ const inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/;\n/**\n * This extension allows you to create task items.\n * @see https://www.tiptap.dev/api/nodes/task-item\n */ const TaskItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"taskItem\",\n    addOptions () {\n        return {\n            nested: false,\n            HTMLAttributes: {},\n            taskListTypeName: \"taskList\"\n        };\n    },\n    content () {\n        return this.options.nested ? \"paragraph block*\" : \"paragraph+\";\n    },\n    defining: true,\n    addAttributes () {\n        return {\n            checked: {\n                default: false,\n                keepOnSplit: false,\n                parseHTML: (element)=>{\n                    const dataChecked = element.getAttribute(\"data-checked\");\n                    return dataChecked === \"\" || dataChecked === \"true\";\n                },\n                renderHTML: (attributes)=>({\n                        \"data-checked\": attributes.checked\n                    })\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: `li[data-type=\"${this.name}\"]`,\n                priority: 51\n            }\n        ];\n    },\n    renderHTML ({ node, HTMLAttributes }) {\n        return [\n            \"li\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, {\n                \"data-type\": this.name\n            }),\n            [\n                \"label\",\n                [\n                    \"input\",\n                    {\n                        type: \"checkbox\",\n                        checked: node.attrs.checked ? \"checked\" : null\n                    }\n                ],\n                [\n                    \"span\"\n                ]\n            ],\n            [\n                \"div\",\n                0\n            ]\n        ];\n    },\n    addKeyboardShortcuts () {\n        const shortcuts = {\n            Enter: ()=>this.editor.commands.splitListItem(this.name),\n            \"Shift-Tab\": ()=>this.editor.commands.liftListItem(this.name)\n        };\n        if (!this.options.nested) {\n            return shortcuts;\n        }\n        return {\n            ...shortcuts,\n            Tab: ()=>this.editor.commands.sinkListItem(this.name)\n        };\n    },\n    addNodeView () {\n        return ({ node, HTMLAttributes, getPos, editor })=>{\n            const listItem = document.createElement(\"li\");\n            const checkboxWrapper = document.createElement(\"label\");\n            const checkboxStyler = document.createElement(\"span\");\n            const checkbox = document.createElement(\"input\");\n            const content = document.createElement(\"div\");\n            checkboxWrapper.contentEditable = \"false\";\n            checkbox.type = \"checkbox\";\n            checkbox.addEventListener(\"mousedown\", (event)=>event.preventDefault());\n            checkbox.addEventListener(\"change\", (event)=>{\n                // if the editor isn’t editable and we don't have a handler for\n                // readonly checks we have to undo the latest change\n                if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n                    checkbox.checked = !checkbox.checked;\n                    return;\n                }\n                const { checked } = event.target;\n                if (editor.isEditable && typeof getPos === \"function\") {\n                    editor.chain().focus(undefined, {\n                        scrollIntoView: false\n                    }).command(({ tr })=>{\n                        const position = getPos();\n                        if (typeof position !== \"number\") {\n                            return false;\n                        }\n                        const currentNode = tr.doc.nodeAt(position);\n                        tr.setNodeMarkup(position, undefined, {\n                            ...currentNode === null || currentNode === void 0 ? void 0 : currentNode.attrs,\n                            checked\n                        });\n                        return true;\n                    }).run();\n                }\n                if (!editor.isEditable && this.options.onReadOnlyChecked) {\n                    // Reset state if onReadOnlyChecked returns false\n                    if (!this.options.onReadOnlyChecked(node, checked)) {\n                        checkbox.checked = !checkbox.checked;\n                    }\n                }\n            });\n            Object.entries(this.options.HTMLAttributes).forEach(([key, value])=>{\n                listItem.setAttribute(key, value);\n            });\n            listItem.dataset.checked = node.attrs.checked;\n            checkbox.checked = node.attrs.checked;\n            checkboxWrapper.append(checkbox, checkboxStyler);\n            listItem.append(checkboxWrapper, content);\n            Object.entries(HTMLAttributes).forEach(([key, value])=>{\n                listItem.setAttribute(key, value);\n            });\n            return {\n                dom: listItem,\n                contentDOM: content,\n                update: (updatedNode)=>{\n                    if (updatedNode.type !== this.type) {\n                        return false;\n                    }\n                    listItem.dataset.checked = updatedNode.attrs.checked;\n                    checkbox.checked = updatedNode.attrs.checked;\n                    return true;\n                }\n            };\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type,\n                getAttributes: (match)=>({\n                        checked: match[match.length - 1] === \"x\"\n                    })\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGFzay1pdGVtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3RTtBQUV4RTs7Q0FFQyxHQUNELE1BQU1HLGFBQWE7QUFDbkI7OztDQUdDLEdBQ0QsTUFBTUMsV0FBV0osOENBQUlBLENBQUNLLE1BQU0sQ0FBQztJQUN6QkMsTUFBTTtJQUNOQztRQUNJLE9BQU87WUFDSEMsUUFBUTtZQUNSQyxnQkFBZ0IsQ0FBQztZQUNqQkMsa0JBQWtCO1FBQ3RCO0lBQ0o7SUFDQUM7UUFDSSxPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDSixNQUFNLEdBQUcscUJBQXFCO0lBQ3REO0lBQ0FLLFVBQVU7SUFDVkM7UUFDSSxPQUFPO1lBQ0hDLFNBQVM7Z0JBQ0xDLFNBQVM7Z0JBQ1RDLGFBQWE7Z0JBQ2JDLFdBQVdDLENBQUFBO29CQUNQLE1BQU1DLGNBQWNELFFBQVFFLFlBQVksQ0FBQztvQkFDekMsT0FBT0QsZ0JBQWdCLE1BQU1BLGdCQUFnQjtnQkFDakQ7Z0JBQ0FFLFlBQVlDLENBQUFBLGFBQWU7d0JBQ3ZCLGdCQUFnQkEsV0FBV1IsT0FBTztvQkFDdEM7WUFDSjtRQUNKO0lBQ0o7SUFDQUc7UUFDSSxPQUFPO1lBQ0g7Z0JBQ0lNLEtBQUssQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDbEIsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDbkNtQixVQUFVO1lBQ2Q7U0FDSDtJQUNMO0lBQ0FILFlBQVcsRUFBRUksSUFBSSxFQUFFakIsY0FBYyxFQUFFO1FBQy9CLE9BQU87WUFDSDtZQUNBUiw2REFBZUEsQ0FBQyxJQUFJLENBQUNXLE9BQU8sQ0FBQ0gsY0FBYyxFQUFFQSxnQkFBZ0I7Z0JBQ3pELGFBQWEsSUFBSSxDQUFDSCxJQUFJO1lBQzFCO1lBQ0E7Z0JBQ0k7Z0JBQ0E7b0JBQ0k7b0JBQ0E7d0JBQ0lxQixNQUFNO3dCQUNOWixTQUFTVyxLQUFLRSxLQUFLLENBQUNiLE9BQU8sR0FBRyxZ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LENBQUN4RCxPQUFPLEdBQUdXLEtBQUtFLEtBQUssQ0FBQ2IsT0FBTztZQUM3QzhCLFNBQVM5QixPQUFPLEdBQUdXLEtBQUtFLEtBQUssQ0FBQ2IsT0FBTztZQUNyQzRCLGdCQUFnQjZCLE1BQU0sQ0FBQzNCLFVBQVVEO1lBQ2pDSixTQUFTZ0MsTUFBTSxDQUFDN0IsaUJBQWlCaEM7WUFDakNzRCxPQUFPQyxPQUFPLENBQUN6RCxnQkFBZ0IwRCxPQUFPLENBQUMsQ0FBQyxDQUFDQyxLQUFLQyxNQUFNO2dCQUNoRDdCLFNBQVM4QixZQUFZLENBQUNGLEtBQUtDO1lBQy9CO1lBQ0EsT0FBTztnQkFDSEksS0FBS2pDO2dCQUNMa0MsWUFBWS9EO2dCQUNaZ0UsUUFBUUMsQ0FBQUE7b0JBQ0osSUFBSUEsWUFBWWpELElBQUksS0FBSyxJQUFJLENBQUNBLElBQUksRUFBRTt3QkFDaEMsT0FBTztvQkFDWDtvQkFDQWEsU0FBUytCLE9BQU8sQ0FBQ3hELE9BQU8sR0FBRzZELFlBQVloRCxLQUFLLENBQUNiLE9BQU87b0JBQ3BEOEIsU0FBUzlCLE9BQU8sR0FBRzZELFlBQVloRCxLQUFLLENBQUNiLE9BQU87b0JBQzVDLE9BQU87Z0JBQ1g7WUFDSjtRQUNKO0lBQ0o7SUFDQThEO1FBQ0ksT0FBTztZQUNIM0UsK0RBQWlCQSxDQUFDO2dCQUNkNEUsTUFBTTNFO2dCQUNOd0IsTUFBTSxJQUFJLENBQUNBLElBQUk7Z0JBQ2ZvRCxlQUFlQyxDQUFBQSxRQUFVO3dCQUNyQmpFLFNBQVNpRSxLQUFLLENBQUNBLE1BQU1DLE1BQU0sR0FBRyxFQUFFLEtBQUs7b0JBQ3pDO1lBQ0o7U0FDSDtJQUNMO0FBQ0o7QUFFcUQsQ0FDckQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10YXNrLWl0ZW0vZGlzdC9pbmRleC5qcz8zN2NlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgd3JhcHBpbmdJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIE1hdGNoZXMgYSB0YXNrIGl0ZW0gdG8gYSAtIFsgXSBvbiBpbnB1dC5cbiAqL1xuY29uc3QgaW5wdXRSZWdleCA9IC9eXFxzKihcXFsoWyggfHhdKT9cXF0pXFxzJC87XG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIHRhc2sgaXRlbXMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL3Rhc2staXRlbVxuICovXG5jb25zdCBUYXNrSXRlbSA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAndGFza0l0ZW0nLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgICAgdGFza0xpc3RUeXBlTmFtZTogJ3Rhc2tMaXN0JyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubmVzdGVkID8gJ3BhcmFncmFwaCBibG9jayonIDogJ3BhcmFncmFwaCsnO1xuICAgIH0sXG4gICAgZGVmaW5pbmc6IHRydWUsXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoZWNrZWQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBrZWVwT25TcGxpdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUNoZWNrZWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jaGVja2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhQ2hlY2tlZCA9PT0gJycgfHwgZGF0YUNoZWNrZWQgPT09ICd0cnVlJztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbmRlckhUTUw6IGF0dHJpYnV0ZXMgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY2hlY2tlZCc6IGF0dHJpYnV0ZXMuY2hlY2tlZCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiBgbGlbZGF0YS10eXBlPVwiJHt0aGlzLm5hbWV9XCJdYCxcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogNTEsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcywge1xuICAgICAgICAgICAgICAgICdkYXRhLXR5cGUnOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IG5vZGUuYXR0cnMuY2hlY2tlZCA/ICdjaGVja2VkJyA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBbJ3NwYW4nXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbJ2RpdicsIDBdLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIGNvbnN0IHNob3J0Y3V0cyA9IHtcbiAgICAgICAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICAgICAgICAnU2hpZnQtVGFiJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLm5lc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNob3J0Y3V0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc2hvcnRjdXRzLFxuICAgICAgICAgICAgVGFiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZE5vZGVWaWV3KCkge1xuICAgICAgICByZXR1cm4gKHsgbm9kZSwgSFRNTEF0dHJpYnV0ZXMsIGdldFBvcywgZWRpdG9yLCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaXN0SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgICAgICBjb25zdCBjaGVja2JveFdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tib3hTdHlsZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBjb25zdCBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBjaGVja2JveFdyYXBwZXIuY29udGVudEVkaXRhYmxlID0gJ2ZhbHNlJztcbiAgICAgICAgICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICAgICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZXZlbnQgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKSk7XG4gICAgICAgICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVkaXRvciBpc27igJl0IGVkaXRhYmxlIGFuZCB3ZSBkb24ndCBoYXZlIGEgaGFuZGxlciBmb3JcbiAgICAgICAgICAgICAgICAvLyByZWFkb25seSBjaGVja3Mgd2UgaGF2ZSB0byB1bmRvIHRoZSBsYXRlc3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKCFlZGl0b3IuaXNFZGl0YWJsZSAmJiAhdGhpcy5vcHRpb25zLm9uUmVhZE9ubHlDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSAhY2hlY2tib3guY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGNoZWNrZWQgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yLmlzRWRpdGFibGUgJiYgdHlwZW9mIGdldFBvcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jaGFpbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZm9jdXModW5kZWZpbmVkLCB7IHNjcm9sbEludG9WaWV3OiBmYWxzZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRQb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSB0ci5kb2Mubm9kZUF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zaXRpb24sIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN1cnJlbnROb2RlID09PSBudWxsIHx8IGN1cnJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5ydW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlZGl0b3IuaXNFZGl0YWJsZSAmJiB0aGlzLm9wdGlvbnMub25SZWFkT25seUNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgc3RhdGUgaWYgb25SZWFkT25seUNoZWNrZWQgcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5vblJlYWRPbmx5Q2hlY2tlZChub2RlLCBjaGVja2VkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9ICFjaGVja2JveC5jaGVja2VkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGlzdEl0ZW0uZGF0YXNldC5jaGVja2VkID0gbm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IG5vZGUuYXR0cnMuY2hlY2tlZDtcbiAgICAgICAgICAgIGNoZWNrYm94V3JhcHBlci5hcHBlbmQoY2hlY2tib3gsIGNoZWNrYm94U3R5bGVyKTtcbiAgICAgICAgICAgIGxpc3RJdGVtLmFwcGVuZChjaGVja2JveFdyYXBwZXIsIGNvbnRlbnQpO1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoSFRNTEF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb206IGxpc3RJdGVtLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRET006IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgdXBkYXRlOiB1cGRhdGVkTm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkTm9kZS50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaXN0SXRlbS5kYXRhc2V0LmNoZWNrZWQgPSB1cGRhdGVkTm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgICAgICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdXBkYXRlZE5vZGUuYXR0cnMuY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdID09PSAneCcsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IFRhc2tJdGVtLCBUYXNrSXRlbSBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJOb2RlIiwibWVyZ2VBdHRyaWJ1dGVzIiwid3JhcHBpbmdJbnB1dFJ1bGUiLCJpbnB1dFJlZ2V4IiwiVGFza0l0ZW0iLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsIm5lc3RlZCIsIkhUTUxBdHRyaWJ1dGVzIiwidGFza0xpc3RUeXBlTmFtZSIsImNvbnRlbnQiLCJvcHRpb25zIiwiZGVmaW5pbmciLCJhZGRBdHRyaWJ1dGVzIiwiY2hlY2tlZCIsImRlZmF1bHQiLCJrZWVwT25TcGxpdCIsInBhcnNlSFRNTCIsImVsZW1lbnQiLCJkYXRhQ2hlY2tlZCIsImdldEF0dHJpYnV0ZSIsInJlbmRlckhUTUwiLCJhdHRyaWJ1dGVzIiwidGFnIiwicHJpb3JpdHkiLCJub2RlIiwidHlwZSIsImF0dHJzIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJzaG9ydGN1dHMiLCJFbnRlciIsImVkaXRvciIsImNvbW1hbmRzIiwic3BsaXRMaXN0SXRlbSIsImxpZnRMaXN0SXRlbSIsIlRhYiIsInNpbmtMaXN0SXRlbSIsImFkZE5vZGVWaWV3IiwiZ2V0UG9zIiwibGlzdEl0ZW0iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjaGVja2JveFdyYXBwZXIiLCJjaGVja2JveFN0eWxlciIsImNoZWNrYm94IiwiY29udGVudEVkaXRhYmxlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJpc0VkaXRhYmxlIiwib25SZWFkT25seUNoZWNrZWQiLCJ0YXJnZXQiLCJjaGFpbiIsImZvY3VzIiwidW5kZWZpbmVkIiwic2Nyb2xsSW50b1ZpZXciLCJjb21tYW5kIiwidHIiLCJwb3NpdGlvbiIsImN1cnJlbnROb2RlIiwiZG9jIiwibm9kZUF0Iiwic2V0Tm9kZU1hcmt1cCIsInJ1biIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJzZXRBdHRyaWJ1dGUiLCJkYXRhc2V0IiwiYXBwZW5kIiwiZG9tIiwiY29udGVudERPTSIsInVwZGF0ZSIsInVwZGF0ZWROb2RlIiwiYWRkSW5wdXRSdWxlcyIsImZpbmQiLCJnZXRBdHRyaWJ1dGVzIiwibWF0Y2giLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-task-item/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-task-list/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-task-list/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaskList: () => (/* binding */ TaskList),\n/* harmony export */   \"default\": () => (/* binding */ TaskList)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * This extension allows you to create task lists.\n * @see https://www.tiptap.dev/api/nodes/task-list\n */ const TaskList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"taskList\",\n    addOptions () {\n        return {\n            itemTypeName: \"taskItem\",\n            HTMLAttributes: {}\n        };\n    },\n    group: \"block list\",\n    content () {\n        return `${this.options.itemTypeName}+`;\n    },\n    parseHTML () {\n        return [\n            {\n                tag: `ul[data-type=\"${this.name}\"]`,\n                priority: 51\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"ul\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, {\n                \"data-type\": this.name\n            }),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            toggleTaskList: ()=>({ commands })=>{\n                    return commands.toggleList(this.name, this.options.itemTypeName);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-9\": ()=>this.editor.commands.toggleTaskList()\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGFzay1saXN0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEO0FBRXJEOzs7Q0FHQyxHQUNELE1BQU1FLFdBQVdGLDhDQUFJQSxDQUFDRyxNQUFNLENBQUM7SUFDekJDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGNBQWM7WUFDZEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQyxPQUFPO0lBQ1BDO1FBQ0ksT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDQyxPQUFPLENBQUNKLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDMUM7SUFDQUs7UUFDSSxPQUFPO1lBQ0g7Z0JBQ0lDLEtBQUssQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDUixJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUNuQ1MsVUFBVTtZQUNkO1NBQ0g7SUFDTDtJQUNBQyxZQUFXLEVBQUVQLGNBQWMsRUFBRTtRQUN6QixPQUFPO1lBQUM7WUFBTU4sNkRBQWVBLENBQUMsSUFBSSxDQUFDUyxPQUFPLENBQUNILGNBQWMsRUFBRUEsZ0JBQWdCO2dCQUFFLGFBQWEsSUFBSSxDQUFDSCxJQUFJO1lBQUM7WUFBSTtTQUFFO0lBQzlHO0lBQ0FXO1FBQ0ksT0FBTztZQUNIQyxnQkFBZ0IsSUFBTSxDQUFDLEVBQUVDLFFBQVEsRUFBRTtvQkFDL0IsT0FBT0EsU0FBU0MsVUFBVSxDQUFDLElBQUksQ0FBQ2QsSUFBSSxFQUFFLElBQUksQ0FBQ00sT0FBTyxDQUFDSixZQUFZO2dCQUNuRTtRQUNKO0lBQ0o7SUFDQWE7UUFDSSxPQUFPO1lBQ0gsZUFBZSxJQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDSCxRQUFRLENBQUNELGNBQWM7UUFDNUQ7SUFDSjtBQUNKO0FBRXlDLENBQ3pDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGFzay1saXN0L2Rpc3QvaW5kZXguanM/MjBjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIHRhc2sgbGlzdHMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL3Rhc2stbGlzdFxuICovXG5jb25zdCBUYXNrTGlzdCA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAndGFza0xpc3QnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpdGVtVHlwZU5hbWU6ICd0YXNrSXRlbScsXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBncm91cDogJ2Jsb2NrIGxpc3QnLFxuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgO1xuICAgIH0sXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogYHVsW2RhdGEtdHlwZT1cIiR7dGhpcy5uYW1lfVwiXWAsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IDUxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ3VsJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMsIHsgJ2RhdGEtdHlwZSc6IHRoaXMubmFtZSB9KSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvZ2dsZVRhc2tMaXN0OiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtU2hpZnQtOSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVRhc2tMaXN0KCksXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBUYXNrTGlzdCwgVGFza0xpc3QgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTm9kZSIsIm1lcmdlQXR0cmlidXRlcyIsIlRhc2tMaXN0IiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJpdGVtVHlwZU5hbWUiLCJIVE1MQXR0cmlidXRlcyIsImdyb3VwIiwiY29udGVudCIsIm9wdGlvbnMiLCJwYXJzZUhUTUwiLCJ0YWciLCJwcmlvcml0eSIsInJlbmRlckhUTUwiLCJhZGRDb21tYW5kcyIsInRvZ2dsZVRhc2tMaXN0IiwiY29tbWFuZHMiLCJ0b2dnbGVMaXN0IiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJlZGl0b3IiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-task-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-text/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-text/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   \"default\": () => (/* binding */ Text)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * This extension allows you to create text nodes.\n * @see https://www.tiptap.dev/api/nodes/text\n */ const Text = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"text\",\n    group: \"inline\"\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUVwQzs7O0NBR0MsR0FDRCxNQUFNQyxPQUFPRCw4Q0FBSUEsQ0FBQ0UsTUFBTSxDQUFDO0lBQ3JCQyxNQUFNO0lBQ05DLE9BQU87QUFDWDtBQUVpQyxDQUNqQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXRleHQvZGlzdC9pbmRleC5qcz85ZTQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIHRleHQgbm9kZXMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL3RleHRcbiAqL1xuY29uc3QgVGV4dCA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAndGV4dCcsXG4gICAgZ3JvdXA6ICdpbmxpbmUnLFxufSk7XG5cbmV4cG9ydCB7IFRleHQsIFRleHQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTm9kZSIsIlRleHQiLCJjcmVhdGUiLCJuYW1lIiwiZ3JvdXAiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/commands/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/pm/commands/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.autoJoin),\n/* harmony export */   baseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.baseKeymap),\n/* harmony export */   chainCommands: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.chainCommands),\n/* harmony export */   createParagraphNear: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.deleteSelection),\n/* harmony export */   exitCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.exitCode),\n/* harmony export */   joinBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinBackward),\n/* harmony export */   joinDown: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinDown),\n/* harmony export */   joinForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockForward),\n/* harmony export */   joinUp: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinUp),\n/* harmony export */   lift: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.lift),\n/* harmony export */   liftEmptyBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectAll),\n/* harmony export */   selectNodeBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.setBlockType),\n/* harmony export */   splitBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlock),\n/* harmony export */   splitBlockAs: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.toggleMark),\n/* harmony export */   wrapIn: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-commands */ \"(ssr)/./node_modules/prosemirror-commands/dist/index.js\");\n// commands/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9jb21tYW5kcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9CQUFvQjtBQUNpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9jb21tYW5kcy9kaXN0L2luZGV4LmpzPzkxMmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29tbWFuZHMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1jb21tYW5kc1wiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/commands/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dropcursor/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dropcursor/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dropCursor: () => (/* reexport safe */ prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-dropcursor */ \"(ssr)/./node_modules/prosemirror-dropcursor/dist/index.js\");\n// dropcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kcm9wY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxzQkFBc0I7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZHJvcGN1cnNvci9kaXN0L2luZGV4LmpzP2JkMzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZHJvcGN1cnNvci9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLWRyb3BjdXJzb3JcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dropcursor/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/gapcursor/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/gapcursor/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.GapCursor),\n/* harmony export */   gapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-gapcursor */ \"(ssr)/./node_modules/prosemirror-gapcursor/dist/index.js\");\n// gapcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9nYXBjdXJzb3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxxQkFBcUI7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZ2FwY3Vyc29yL2Rpc3QvaW5kZXguanM/YzBiMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBnYXBjdXJzb3IvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1nYXBjdXJzb3JcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/gapcursor/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/history/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/pm/history/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.closeHistory),\n/* harmony export */   history: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.history),\n/* harmony export */   redo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redo),\n/* harmony export */   redoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoDepth),\n/* harmony export */   redoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoNoScroll),\n/* harmony export */   undo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undo),\n/* harmony export */   undoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoDepth),\n/* harmony export */   undoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoNoScroll)\n/* harmony export */ });\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-history */ \"(ssr)/./node_modules/prosemirror-history/dist/index.js\");\n// history/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9oaXN0b3J5L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsbUJBQW1CO0FBQ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2hpc3RvcnkvZGlzdC9pbmRleC5qcz8xNjY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGhpc3RvcnkvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1oaXN0b3J5XCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/history/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/keymap/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tiptap/pm/keymap/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keydownHandler),\n/* harmony export */   keymap: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n// keymap/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9rZXltYXAvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxrQkFBa0I7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0va2V5bWFwL2Rpc3QvaW5kZXguanM/NGJlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBrZXltYXAvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1rZXltYXBcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/keymap/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/model/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/model/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ContentMatch),\n/* harmony export */   DOMParser: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser),\n/* harmony export */   DOMSerializer: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer),\n/* harmony export */   Fragment: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment),\n/* harmony export */   Mark: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark),\n/* harmony export */   MarkType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType),\n/* harmony export */   Node: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node),\n/* harmony export */   NodeRange: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange),\n/* harmony export */   NodeType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeType),\n/* harmony export */   ReplaceError: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ResolvedPos),\n/* harmony export */   Schema: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema),\n/* harmony export */   Slice: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n// model/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9tb2RlbC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUJBQWlCO0FBQ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL21vZGVsL2Rpc3QvaW5kZXguanM/YTVhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBtb2RlbC9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLW1vZGVsXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/model/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/schema-list/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/pm/schema-list/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.addListNodes),\n/* harmony export */   bulletList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.bulletList),\n/* harmony export */   liftListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.liftListItem),\n/* harmony export */   listItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.listItem),\n/* harmony export */   orderedList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.orderedList),\n/* harmony export */   sinkListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.sinkListItem),\n/* harmony export */   splitListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItem),\n/* harmony export */   splitListItemKeepMarks: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItemKeepMarks),\n/* harmony export */   wrapInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapInList),\n/* harmony export */   wrapRangeInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapRangeInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-schema-list */ \"(ssr)/./node_modules/prosemirror-schema-list/dist/index.js\");\n// schema-list/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdUJBQXVCO0FBQ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3NjaGVtYS1saXN0L2Rpc3QvaW5kZXguanM/NTRlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzY2hlbWEtbGlzdC9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLXNjaGVtYS1saXN0XCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/schema-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/state/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/state/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection),\n/* harmony export */   EditorState: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState),\n/* harmony export */   NodeSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection),\n/* harmony export */   Plugin: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin),\n/* harmony export */   PluginKey: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey),\n/* harmony export */   Selection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection),\n/* harmony export */   SelectionRange: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange),\n/* harmony export */   TextSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection),\n/* harmony export */   Transaction: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n// state/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9zdGF0ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUI7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vc3RhdGUvZGlzdC9pbmRleC5qcz83MmVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0YXRlL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/transform/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/transform/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AttrStep),\n/* harmony export */   DocAttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.DocAttrStep),\n/* harmony export */   MapResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.MapResult),\n/* harmony export */   Mapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep),\n/* harmony export */   Step: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Step),\n/* harmony export */   StepMap: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepMap),\n/* harmony export */   StepResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepResult),\n/* harmony export */   Transform: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Transform),\n/* harmony export */   TransformError: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.TransformError),\n/* harmony export */   canJoin: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin),\n/* harmony export */   canSplit: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit),\n/* harmony export */   dropPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.dropPoint),\n/* harmony export */   findWrapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping),\n/* harmony export */   insertPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.insertPoint),\n/* harmony export */   joinPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint),\n/* harmony export */   liftTarget: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget),\n/* harmony export */   replaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n// transform/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS90cmFuc2Zvcm0vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxQkFBcUI7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vdHJhbnNmb3JtL2Rpc3QvaW5kZXguanM/OGE0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0cmFuc2Zvcm0vaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci10cmFuc2Zvcm1cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/transform/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/view/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@tiptap/pm/view/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration),\n/* harmony export */   DecorationSet: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.DecorationSet),\n/* harmony export */   EditorView: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView),\n/* harmony export */   __endComposition: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__parseFromClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n// view/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS92aWV3L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsZ0JBQWdCO0FBQ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3ZpZXcvZGlzdC9pbmRleC5qcz83NTkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHZpZXcvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci12aWV3XCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/view/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/react/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@tiptap/react/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubbleMenu: () => (/* binding */ BubbleMenu),\n/* harmony export */   CommandManager: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.CommandManager),\n/* harmony export */   Editor: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Editor),\n/* harmony export */   EditorConsumer: () => (/* binding */ EditorConsumer),\n/* harmony export */   EditorContent: () => (/* binding */ EditorContent),\n/* harmony export */   EditorContext: () => (/* binding */ EditorContext),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   Extension: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Extension),\n/* harmony export */   FloatingMenu: () => (/* binding */ FloatingMenu),\n/* harmony export */   InputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.InputRule),\n/* harmony export */   Mark: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Mark),\n/* harmony export */   Node: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Node),\n/* harmony export */   NodePos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodePos),\n/* harmony export */   NodeView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodeView),\n/* harmony export */   NodeViewContent: () => (/* binding */ NodeViewContent),\n/* harmony export */   NodeViewWrapper: () => (/* binding */ NodeViewWrapper),\n/* harmony export */   PasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.PasteRule),\n/* harmony export */   PureEditorContent: () => (/* binding */ PureEditorContent),\n/* harmony export */   ReactNodeView: () => (/* binding */ ReactNodeView),\n/* harmony export */   ReactNodeViewContext: () => (/* binding */ ReactNodeViewContext),\n/* harmony export */   ReactNodeViewRenderer: () => (/* binding */ ReactNodeViewRenderer),\n/* harmony export */   ReactRenderer: () => (/* binding */ ReactRenderer),\n/* harmony export */   Tracker: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Tracker),\n/* harmony export */   callOrReturn: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.callOrReturn),\n/* harmony export */   combineTransactionSteps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.combineTransactionSteps),\n/* harmony export */   createChainableState: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createChainableState),\n/* harmony export */   createDocument: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createDocument),\n/* harmony export */   createNodeFromContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.deleteProps),\n/* harmony export */   elementFromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.escapeForRegEx),\n/* harmony export */   extensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.extensions),\n/* harmony export */   findChildren: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildren),\n/* harmony export */   findChildrenInRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findDuplicates),\n/* harmony export */   findParentNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findParentNodeClosestToPos),\n/* harmony export */   fromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.fromString),\n/* harmony export */   generateHTML: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateHTML),\n/* harmony export */   generateJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateJSON),\n/* harmony export */   generateText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateText),\n/* harmony export */   getAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkRange),\n/* harmony export */   getMarkType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkType),\n/* harmony export */   getMarksBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSplittedAttributes),\n/* harmony export */   getText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getText),\n/* harmony export */   getTextBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextSerializersFromSchema),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.inputRulesPlugin),\n/* harmony export */   isActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isActive),\n/* harmony export */   isAtEndOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isFunction),\n/* harmony export */   isList: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isList),\n/* harmony export */   isMacOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isMacOS),\n/* harmony export */   isMarkActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isMarkActive),\n/* harmony export */   isNodeActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeSelection),\n/* harmony export */   isNumber: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNumber),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isPlainObject),\n/* harmony export */   isRegExp: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isRegExp),\n/* harmony export */   isString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isString),\n/* harmony export */   isTextSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isTextSelection),\n/* harmony export */   isiOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isiOS),\n/* harmony export */   markInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markInputRule),\n/* harmony export */   markPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markPasteRule),\n/* harmony export */   mergeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeDeep),\n/* harmony export */   minMax: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.minMax),\n/* harmony export */   nodeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.objectIncludes),\n/* harmony export */   pasteRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.removeDuplicates),\n/* harmony export */   resolveFocusPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.selectionToInsertionEnd),\n/* harmony export */   splitExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.splitExtensions),\n/* harmony export */   textInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textInputRule),\n/* harmony export */   textPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textblockTypeInputRule),\n/* harmony export */   useCurrentEditor: () => (/* binding */ useCurrentEditor),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useEditorState: () => (/* binding */ useEditorState),\n/* harmony export */   useReactNodeView: () => (/* binding */ useReactNodeView),\n/* harmony export */   wrappingInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_extension_bubble_menu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-bubble-menu */ \"(ssr)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_floating_menu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-floating-menu */ \"(ssr)/./node_modules/@tiptap/extension-floating-menu/dist/index.js\");\n\n\n\n\n\n\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar shim = {\n    exports: {}\n};\nvar useSyncExternalStoreShim_production_min = {};\n/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredUseSyncExternalStoreShim_production_min;\nfunction requireUseSyncExternalStoreShim_production_min() {\n    if (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min;\n    hasRequiredUseSyncExternalStoreShim_production_min = 1;\n    var e = react__WEBPACK_IMPORTED_MODULE_0__;\n    function h(a, b) {\n        return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;\n    }\n    var k = \"function\" === typeof Object.is ? Object.is : h, l = e.useState, m = e.useEffect, n = e.useLayoutEffect, p = e.useDebugValue;\n    function q(a, b) {\n        var d = b(), f = l({\n            inst: {\n                value: d,\n                getSnapshot: b\n            }\n        }), c = f[0].inst, g = f[1];\n        n(function() {\n            c.value = d;\n            c.getSnapshot = b;\n            r(c) && g({\n                inst: c\n            });\n        }, [\n            a,\n            d,\n            b\n        ]);\n        m(function() {\n            r(c) && g({\n                inst: c\n            });\n            return a(function() {\n                r(c) && g({\n                    inst: c\n                });\n            });\n        }, [\n            a\n        ]);\n        p(d);\n        return d;\n    }\n    function r(a) {\n        var b = a.getSnapshot;\n        a = a.value;\n        try {\n            var d = b();\n            return !k(a, d);\n        } catch (f) {\n            return !0;\n        }\n    }\n    function t(a, b) {\n        return b();\n    }\n    var u =  true ? t : 0;\n    useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e.useSyncExternalStore ? e.useSyncExternalStore : u;\n    return useSyncExternalStoreShim_production_min;\n}\nvar useSyncExternalStoreShim_development = {};\n/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredUseSyncExternalStoreShim_development;\nfunction requireUseSyncExternalStoreShim_development() {\n    if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;\n    hasRequiredUseSyncExternalStoreShim_development = 1;\n    if (true) {\n        (function() {\n            /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n                __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n            }\n            var React$1 = react__WEBPACK_IMPORTED_MODULE_0__;\n            var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n            function error(format) {\n                {\n                    {\n                        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                            args[_key2 - 1] = arguments[_key2];\n                        }\n                        printWarning(\"error\", format, args);\n                    }\n                }\n            }\n            function printWarning(level, format, args) {\n                // When changing this logic, you might want to also\n                // update consoleWithStackDev.www.js as well.\n                {\n                    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                    var stack = ReactDebugCurrentFrame.getStackAddendum();\n                    if (stack !== \"\") {\n                        format += \"%s\";\n                        args = args.concat([\n                            stack\n                        ]);\n                    } // eslint-disable-next-line react-internal/safe-string-coercion\n                    var argsWithFormat = args.map(function(item) {\n                        return String(item);\n                    }); // Careful: RN currently depends on this prefix\n                    argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                    // breaks IE9: https://github.com/facebook/react/issues/13610\n                    // eslint-disable-next-line react-internal/no-production-logging\n                    Function.prototype.apply.call(console[level], console, argsWithFormat);\n                }\n            }\n            /**\n\t * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t */ function is(x, y) {\n                return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n                ;\n            }\n            var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n            // dispatch for CommonJS interop named imports.\n            var useState = React$1.useState, useEffect = React$1.useEffect, useLayoutEffect = React$1.useLayoutEffect, useDebugValue = React$1.useDebugValue;\n            var didWarnOld18Alpha = false;\n            var didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n            // because of a very particular set of implementation details and assumptions\n            // -- change any one of them and it will break. The most important assumption\n            // is that updates are always synchronous, because concurrent rendering is\n            // only available in versions of React that also have a built-in\n            // useSyncExternalStore API. And we only use this shim when the built-in API\n            // does not exist.\n            //\n            // Do not assume that the clever hacks used by this hook also work in general.\n            // The point of this shim is to replace the need for hacks by other libraries.\n            function useSyncExternalStore(subscribe, getSnapshot, // React do not expose a way to check if we're hydrating. So users of the shim\n            // will need to track that themselves and return the correct value\n            // from `getSnapshot`.\n            getServerSnapshot) {\n                {\n                    if (!didWarnOld18Alpha) {\n                        if (React$1.startTransition !== undefined) {\n                            didWarnOld18Alpha = true;\n                            error(\"You are using an outdated, pre-release alpha of React 18 that \" + \"does not support useSyncExternalStore. The \" + \"use-sync-external-store shim will not work correctly. Upgrade \" + \"to a newer pre-release.\");\n                        }\n                    }\n                }\n                // breaks the rules of React, and only works here because of specific\n                // implementation details, most importantly that updates are\n                // always synchronous.\n                var value = getSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        var cachedValue = getSnapshot();\n                        if (!objectIs(value, cachedValue)) {\n                            error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n                // re-render whenever the subscribed state changes by updating an some\n                // arbitrary useState hook. Then, during render, we call getSnapshot to read\n                // the current value.\n                //\n                // Because we don't actually use the state returned by the useState hook, we\n                // can save a bit of memory by storing other stuff in that slot.\n                //\n                // To implement the early bailout, we need to track some things on a mutable\n                // object. Usually, we would put that in a useRef hook, but we can stash it in\n                // our useState hook instead.\n                //\n                // To force a re-render, we call forceUpdate({inst}). That works because the\n                // new object always fails an equality check.\n                var _useState = useState({\n                    inst: {\n                        value: value,\n                        getSnapshot: getSnapshot\n                    }\n                }), inst = _useState[0].inst, forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n                // in the layout phase so we can access it during the tearing check that\n                // happens on subscribe.\n                useLayoutEffect(function() {\n                    inst.value = value;\n                    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n                    // commit phase if there was an interleaved mutation. In concurrent mode\n                    // this can happen all the time, but even in synchronous mode, an earlier\n                    // effect may have mutated the store.\n                    if (checkIfSnapshotChanged(inst)) {\n                        // Force a re-render.\n                        forceUpdate({\n                            inst: inst\n                        });\n                    }\n                }, [\n                    subscribe,\n                    value,\n                    getSnapshot\n                ]);\n                useEffect(function() {\n                    // Check for changes right before subscribing. Subsequent changes will be\n                    // detected in the subscription handler.\n                    if (checkIfSnapshotChanged(inst)) {\n                        // Force a re-render.\n                        forceUpdate({\n                            inst: inst\n                        });\n                    }\n                    var handleStoreChange = function() {\n                        // TODO: Because there is no cross-renderer API for batching updates, it's\n                        // up to the consumer of this library to wrap their subscription event\n                        // with unstable_batchedUpdates. Should we try to detect when this isn't\n                        // the case and print a warning in development?\n                        // The store changed. Check if the snapshot changed since the last time we\n                        // read from the store.\n                        if (checkIfSnapshotChanged(inst)) {\n                            // Force a re-render.\n                            forceUpdate({\n                                inst: inst\n                            });\n                        }\n                    }; // Subscribe to the store and return a clean-up function.\n                    return subscribe(handleStoreChange);\n                }, [\n                    subscribe\n                ]);\n                useDebugValue(value);\n                return value;\n            }\n            function checkIfSnapshotChanged(inst) {\n                var latestGetSnapshot = inst.getSnapshot;\n                var prevValue = inst.value;\n                try {\n                    var nextValue = latestGetSnapshot();\n                    return !objectIs(prevValue, nextValue);\n                } catch (error) {\n                    return true;\n                }\n            }\n            function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n                // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n                // React do not expose a way to check if we're hydrating. So users of the shim\n                // will need to track that themselves and return the correct value\n                // from `getSnapshot`.\n                return getSnapshot();\n            }\n            var canUseDOM = !!( false && 0);\n            var isServerEnvironment = !canUseDOM;\n            var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\n            var useSyncExternalStore$2 = React$1.useSyncExternalStore !== undefined ? React$1.useSyncExternalStore : shim;\n            useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;\n            /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n                __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n            }\n        })();\n    }\n    return useSyncExternalStoreShim_development;\n}\nif (false) {} else {\n    shim.exports = requireUseSyncExternalStoreShim_development();\n}\nvar shimExports = shim.exports;\nconst mergeRefs = (...refs)=>{\n    return (node)=>{\n        refs.forEach((ref)=>{\n            if (typeof ref === \"function\") {\n                ref(node);\n            } else if (ref) {\n                ref.current = node;\n            }\n        });\n    };\n};\n/**\n * This component renders all of the editor's node views.\n */ const Portals = ({ contentComponent })=>{\n    // For performance reasons, we render the node view portals on state changes only\n    const renderers = shimExports.useSyncExternalStore(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);\n    // This allows us to directly render the portals without any additional wrapper\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, Object.values(renderers));\n};\nfunction getInstance() {\n    const subscribers = new Set();\n    let renderers = {};\n    return {\n        /**\n         * Subscribe to the editor instance's changes.\n         */ subscribe (callback) {\n            subscribers.add(callback);\n            return ()=>{\n                subscribers.delete(callback);\n            };\n        },\n        getSnapshot () {\n            return renderers;\n        },\n        getServerSnapshot () {\n            return renderers;\n        },\n        /**\n         * Adds a new NodeView Renderer to the editor.\n         */ setRenderer (id, renderer) {\n            renderers = {\n                ...renderers,\n                [id]: /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(renderer.reactElement, renderer.element, id)\n            };\n            subscribers.forEach((subscriber)=>subscriber());\n        },\n        /**\n         * Removes a NodeView Renderer from the editor.\n         */ removeRenderer (id) {\n            const nextRenderers = {\n                ...renderers\n            };\n            delete nextRenderers[id];\n            renderers = nextRenderers;\n            subscribers.forEach((subscriber)=>subscriber());\n        }\n    };\n}\nclass PureEditorContent extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        var _a;\n        super(props);\n        this.editorContentRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.initialized = false;\n        this.state = {\n            hasContentComponentInitialized: Boolean((_a = props.editor) === null || _a === void 0 ? void 0 : _a.contentComponent)\n        };\n    }\n    componentDidMount() {\n        this.init();\n    }\n    componentDidUpdate() {\n        this.init();\n    }\n    init() {\n        const editor = this.props.editor;\n        if (editor && !editor.isDestroyed && editor.options.element) {\n            if (editor.contentComponent) {\n                return;\n            }\n            const element = this.editorContentRef.current;\n            element.append(...editor.options.element.childNodes);\n            editor.setOptions({\n                element\n            });\n            editor.contentComponent = getInstance();\n            // Has the content component been initialized?\n            if (!this.state.hasContentComponentInitialized) {\n                // Subscribe to the content component\n                this.unsubscribeToContentComponent = editor.contentComponent.subscribe(()=>{\n                    this.setState((prevState)=>{\n                        if (!prevState.hasContentComponentInitialized) {\n                            return {\n                                hasContentComponentInitialized: true\n                            };\n                        }\n                        return prevState;\n                    });\n                    // Unsubscribe to previous content component\n                    if (this.unsubscribeToContentComponent) {\n                        this.unsubscribeToContentComponent();\n                    }\n                });\n            }\n            editor.createNodeViews();\n            this.initialized = true;\n        }\n    }\n    componentWillUnmount() {\n        const editor = this.props.editor;\n        if (!editor) {\n            return;\n        }\n        this.initialized = false;\n        if (!editor.isDestroyed) {\n            editor.view.setProps({\n                nodeViews: {}\n            });\n        }\n        if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent();\n        }\n        editor.contentComponent = null;\n        if (!editor.options.element.firstChild) {\n            return;\n        }\n        const newElement = document.createElement(\"div\");\n        newElement.append(...editor.options.element.childNodes);\n        editor.setOptions({\n            element: newElement\n        });\n    }\n    render() {\n        const { editor, innerRef, ...rest } = this.props;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ref: mergeRefs(innerRef, this.editorContentRef),\n            ...rest\n        }), (editor === null || editor === void 0 ? void 0 : editor.contentComponent) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Portals, {\n            contentComponent: editor.contentComponent\n        }));\n    }\n}\n// EditorContent should be re-created whenever the Editor instance changes\nconst EditorContentWithKey = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>{\n    const key = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return Math.floor(Math.random() * 0xffffffff).toString();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        props.editor\n    ]);\n    // Can't use JSX here because it conflicts with the type definition of Vue's JSX, so use createElement\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PureEditorContent, {\n        key,\n        innerRef: ref,\n        ...props\n    });\n});\nconst EditorContent = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(EditorContentWithKey);\nvar react = function equal(a, b) {\n    if (a === b) return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        if (a.constructor !== b.constructor) return false;\n        var length, i, keys;\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;\n            return true;\n        }\n        if (a instanceof Map && b instanceof Map) {\n            if (a.size !== b.size) return false;\n            for (i of a.entries())if (!b.has(i[0])) return false;\n            for (i of a.entries())if (!equal(i[1], b.get(i[0]))) return false;\n            return true;\n        }\n        if (a instanceof Set && b instanceof Set) {\n            if (a.size !== b.size) return false;\n            for (i of a.entries())if (!b.has(i[0])) return false;\n            return true;\n        }\n        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;)if (a[i] !== b[i]) return false;\n            return true;\n        }\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) return false;\n        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n        for(i = length; i-- !== 0;){\n            var key = keys[i];\n            if (key === \"_owner\" && a.$$typeof) {\n                continue;\n            }\n            if (!equal(a[key], b[key])) return false;\n        }\n        return true;\n    }\n    // true if both NaN, false otherwise\n    return a !== a && b !== b;\n};\nvar deepEqual = /*@__PURE__*/ getDefaultExportFromCjs(react);\nvar withSelector = {\n    exports: {}\n};\nvar withSelector_production_min = {};\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredWithSelector_production_min;\nfunction requireWithSelector_production_min() {\n    if (hasRequiredWithSelector_production_min) return withSelector_production_min;\n    hasRequiredWithSelector_production_min = 1;\n    var h = react__WEBPACK_IMPORTED_MODULE_0__, n = shimExports;\n    function p(a, b) {\n        return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;\n    }\n    var q = \"function\" === typeof Object.is ? Object.is : p, r = n.useSyncExternalStore, t = h.useRef, u = h.useEffect, v = h.useMemo, w = h.useDebugValue;\n    withSelector_production_min.useSyncExternalStoreWithSelector = function(a, b, e, l, g) {\n        var c = t(null);\n        if (null === c.current) {\n            var f = {\n                hasValue: !1,\n                value: null\n            };\n            c.current = f;\n        } else f = c.current;\n        c = v(function() {\n            function a(a) {\n                if (!c) {\n                    c = !0;\n                    d = a;\n                    a = l(a);\n                    if (void 0 !== g && f.hasValue) {\n                        var b = f.value;\n                        if (g(b, a)) return k = b;\n                    }\n                    return k = a;\n                }\n                b = k;\n                if (q(d, a)) return b;\n                var e = l(a);\n                if (void 0 !== g && g(b, e)) return b;\n                d = a;\n                return k = e;\n            }\n            var c = !1, d, k, m = void 0 === e ? null : e;\n            return [\n                function() {\n                    return a(b());\n                },\n                null === m ? void 0 : function() {\n                    return a(m());\n                }\n            ];\n        }, [\n            b,\n            e,\n            l,\n            g\n        ]);\n        var d = r(a, c[0], c[1]);\n        u(function() {\n            f.hasValue = !0;\n            f.value = d;\n        }, [\n            d\n        ]);\n        w(d);\n        return d;\n    };\n    return withSelector_production_min;\n}\nvar withSelector_development = {};\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredWithSelector_development;\nfunction requireWithSelector_development() {\n    if (hasRequiredWithSelector_development) return withSelector_development;\n    hasRequiredWithSelector_development = 1;\n    if (true) {\n        (function() {\n            /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n                __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n            }\n            var React$1 = react__WEBPACK_IMPORTED_MODULE_0__;\n            var shim = shimExports;\n            /**\n\t * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t */ function is(x, y) {\n                return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n                ;\n            }\n            var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n            var useSyncExternalStore = shim.useSyncExternalStore;\n            // for CommonJS interop.\n            var useRef = React$1.useRef, useEffect = React$1.useEffect, useMemo = React$1.useMemo, useDebugValue = React$1.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n            function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n                // Use this to track the rendered snapshot.\n                var instRef = useRef(null);\n                var inst;\n                if (instRef.current === null) {\n                    inst = {\n                        hasValue: false,\n                        value: null\n                    };\n                    instRef.current = inst;\n                } else {\n                    inst = instRef.current;\n                }\n                var _useMemo = useMemo(function() {\n                    // Track the memoized state using closure variables that are local to this\n                    // memoized instance of a getSnapshot function. Intentionally not using a\n                    // useRef hook, because that state would be shared across all concurrent\n                    // copies of the hook/component.\n                    var hasMemo = false;\n                    var memoizedSnapshot;\n                    var memoizedSelection;\n                    var memoizedSelector = function(nextSnapshot) {\n                        if (!hasMemo) {\n                            // The first time the hook is called, there is no memoized result.\n                            hasMemo = true;\n                            memoizedSnapshot = nextSnapshot;\n                            var _nextSelection = selector(nextSnapshot);\n                            if (isEqual !== undefined) {\n                                // Even if the selector has changed, the currently rendered selection\n                                // may be equal to the new selection. We should attempt to reuse the\n                                // current value if possible, to preserve downstream memoizations.\n                                if (inst.hasValue) {\n                                    var currentSelection = inst.value;\n                                    if (isEqual(currentSelection, _nextSelection)) {\n                                        memoizedSelection = currentSelection;\n                                        return currentSelection;\n                                    }\n                                }\n                            }\n                            memoizedSelection = _nextSelection;\n                            return _nextSelection;\n                        } // We may be able to reuse the previous invocation's result.\n                        // We may be able to reuse the previous invocation's result.\n                        var prevSnapshot = memoizedSnapshot;\n                        var prevSelection = memoizedSelection;\n                        if (objectIs(prevSnapshot, nextSnapshot)) {\n                            // The snapshot is the same as last time. Reuse the previous selection.\n                            return prevSelection;\n                        } // The snapshot has changed, so we need to compute a new selection.\n                        // The snapshot has changed, so we need to compute a new selection.\n                        var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n                        // has changed. If it hasn't, return the previous selection. That signals\n                        // to React that the selections are conceptually equal, and we can bail\n                        // out of rendering.\n                        // If a custom isEqual function is provided, use that to check if the data\n                        // has changed. If it hasn't, return the previous selection. That signals\n                        // to React that the selections are conceptually equal, and we can bail\n                        // out of rendering.\n                        if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n                            return prevSelection;\n                        }\n                        memoizedSnapshot = nextSnapshot;\n                        memoizedSelection = nextSelection;\n                        return nextSelection;\n                    }; // Assigning this to a constant so that Flow knows it can't change.\n                    // Assigning this to a constant so that Flow knows it can't change.\n                    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n                    var getSnapshotWithSelector = function() {\n                        return memoizedSelector(getSnapshot());\n                    };\n                    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function() {\n                        return memoizedSelector(maybeGetServerSnapshot());\n                    };\n                    return [\n                        getSnapshotWithSelector,\n                        getServerSnapshotWithSelector\n                    ];\n                }, [\n                    getSnapshot,\n                    getServerSnapshot,\n                    selector,\n                    isEqual\n                ]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];\n                var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n                useEffect(function() {\n                    inst.hasValue = true;\n                    inst.value = value;\n                }, [\n                    value\n                ]);\n                useDebugValue(value);\n                return value;\n            }\n            withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n            /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n                __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n            }\n        })();\n    }\n    return withSelector_development;\n}\nif (false) {} else {\n    withSelector.exports = requireWithSelector_development();\n}\nvar withSelectorExports = withSelector.exports;\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n/**\n * To synchronize the editor instance with the component state,\n * we need to create a separate instance that is not affected by the component re-renders.\n */ class EditorStateManager {\n    constructor(initialEditor){\n        this.transactionNumber = 0;\n        this.lastTransactionNumber = 0;\n        this.subscribers = new Set();\n        this.editor = initialEditor;\n        this.lastSnapshot = {\n            editor: initialEditor,\n            transactionNumber: 0\n        };\n        this.getSnapshot = this.getSnapshot.bind(this);\n        this.getServerSnapshot = this.getServerSnapshot.bind(this);\n        this.watch = this.watch.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n    }\n    /**\n     * Get the current editor instance.\n     */ getSnapshot() {\n        if (this.transactionNumber === this.lastTransactionNumber) {\n            return this.lastSnapshot;\n        }\n        this.lastTransactionNumber = this.transactionNumber;\n        this.lastSnapshot = {\n            editor: this.editor,\n            transactionNumber: this.transactionNumber\n        };\n        return this.lastSnapshot;\n    }\n    /**\n     * Always disable the editor on the server-side.\n     */ getServerSnapshot() {\n        return {\n            editor: null,\n            transactionNumber: 0\n        };\n    }\n    /**\n     * Subscribe to the editor instance's changes.\n     */ subscribe(callback) {\n        this.subscribers.add(callback);\n        return ()=>{\n            this.subscribers.delete(callback);\n        };\n    }\n    /**\n     * Watch the editor instance for changes.\n     */ watch(nextEditor) {\n        this.editor = nextEditor;\n        if (this.editor) {\n            /**\n             * This will force a re-render when the editor state changes.\n             * This is to support things like `editor.can().toggleBold()` in components that `useEditor`.\n             * This could be more efficient, but it's a good trade-off for now.\n             */ const fn = ()=>{\n                this.transactionNumber += 1;\n                this.subscribers.forEach((callback)=>callback());\n            };\n            const currentEditor = this.editor;\n            currentEditor.on(\"transaction\", fn);\n            return ()=>{\n                currentEditor.off(\"transaction\", fn);\n            };\n        }\n        return undefined;\n    }\n}\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */ function useEditorState(options) {\n    var _a;\n    const [editorStateManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new EditorStateManager(options.editor));\n    // Using the `useSyncExternalStore` hook to sync the editor instance with the component state\n    const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(editorStateManager.subscribe, editorStateManager.getSnapshot, editorStateManager.getServerSnapshot, options.selector, (_a = options.equalityFn) !== null && _a !== void 0 ? _a : deepEqual);\n    useIsomorphicLayoutEffect(()=>{\n        return editorStateManager.watch(options.editor);\n    }, [\n        options.editor,\n        editorStateManager\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(selectedState);\n    return selectedState;\n}\nconst isDev = \"development\" !== \"production\";\nconst isSSR = \"undefined\" === \"undefined\";\nconst isNext = isSSR || Boolean( false && 0);\n/**\n * This class handles the creation, destruction, and re-creation of the editor instance.\n */ class EditorInstanceManager {\n    constructor(options){\n        /**\n         * The current editor instance.\n         */ this.editor = null;\n        /**\n         * The subscriptions to notify when the editor instance\n         * has been created or destroyed.\n         */ this.subscriptions = new Set();\n        /**\n         * Whether the editor has been mounted.\n         */ this.isComponentMounted = false;\n        /**\n         * The most recent dependencies array.\n         */ this.previousDeps = null;\n        /**\n         * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n         */ this.instanceId = \"\";\n        this.options = options;\n        this.subscriptions = new Set();\n        this.setEditor(this.getInitialEditor());\n        this.scheduleDestroy();\n        this.getEditor = this.getEditor.bind(this);\n        this.getServerSnapshot = this.getServerSnapshot.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n        this.refreshEditorInstance = this.refreshEditorInstance.bind(this);\n        this.scheduleDestroy = this.scheduleDestroy.bind(this);\n        this.onRender = this.onRender.bind(this);\n        this.createEditor = this.createEditor.bind(this);\n    }\n    setEditor(editor) {\n        this.editor = editor;\n        this.instanceId = Math.random().toString(36).slice(2, 9);\n        // Notify all subscribers that the editor instance has been created\n        this.subscriptions.forEach((cb)=>cb());\n    }\n    getInitialEditor() {\n        if (this.options.current.immediatelyRender === undefined) {\n            if (isSSR || isNext) {\n                // TODO in the next major release, we should throw an error here\n                if (isDev) {\n                    /**\n                     * Throw an error in development, to make sure the developer is aware that tiptap cannot be SSR'd\n                     * and that they need to set `immediatelyRender` to `false` to avoid hydration mismatches.\n                     */ console.warn(\"Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.\");\n                }\n                // Best faith effort in production, run the code in the legacy mode to avoid hydration mismatches and errors in production\n                return null;\n            }\n            // Default to immediately rendering when client-side rendering\n            return this.createEditor();\n        }\n        if (this.options.current.immediatelyRender && isSSR && isDev) {\n            // Warn in development, to make sure the developer is aware that tiptap cannot be SSR'd, set `immediatelyRender` to `false` to avoid hydration mismatches.\n            throw new Error(\"Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.\");\n        }\n        if (this.options.current.immediatelyRender) {\n            return this.createEditor();\n        }\n        return null;\n    }\n    /**\n     * Create a new editor instance. And attach event listeners.\n     */ createEditor() {\n        const optionsToApply = {\n            ...this.options.current,\n            // Always call the most recent version of the callback function by default\n            onBeforeCreate: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onBeforeCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onBlur: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onCreate: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onDestroy: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onDestroy) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onFocus: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onSelectionUpdate: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onSelectionUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onTransaction: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onTransaction) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onUpdate: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onContentError: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onContentError) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onDrop: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onDrop) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onPaste: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onPaste) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            }\n        };\n        const editor = new _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Editor(optionsToApply);\n        // no need to keep track of the event listeners, they will be removed when the editor is destroyed\n        return editor;\n    }\n    /**\n     * Get the current editor instance.\n     */ getEditor() {\n        return this.editor;\n    }\n    /**\n     * Always disable the editor on the server-side.\n     */ getServerSnapshot() {\n        return null;\n    }\n    /**\n     * Subscribe to the editor instance's changes.\n     */ subscribe(onStoreChange) {\n        this.subscriptions.add(onStoreChange);\n        return ()=>{\n            this.subscriptions.delete(onStoreChange);\n        };\n    }\n    static compareOptions(a, b) {\n        return Object.keys(a).every((key)=>{\n            if ([\n                \"onCreate\",\n                \"onBeforeCreate\",\n                \"onDestroy\",\n                \"onUpdate\",\n                \"onTransaction\",\n                \"onFocus\",\n                \"onBlur\",\n                \"onSelectionUpdate\",\n                \"onContentError\",\n                \"onDrop\",\n                \"onPaste\"\n            ].includes(key)) {\n                // we don't want to compare callbacks, they are always different and only registered once\n                return true;\n            }\n            // We often encourage putting extensions inlined in the options object, so we will do a slightly deeper comparison here\n            if (key === \"extensions\" && a.extensions && b.extensions) {\n                if (a.extensions.length !== b.extensions.length) {\n                    return false;\n                }\n                return a.extensions.every((extension, index)=>{\n                    var _a;\n                    if (extension !== ((_a = b.extensions) === null || _a === void 0 ? void 0 : _a[index])) {\n                        return false;\n                    }\n                    return true;\n                });\n            }\n            if (a[key] !== b[key]) {\n                // if any of the options have changed, we should update the editor options\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n     * On each render, we will create, update, or destroy the editor instance.\n     * @param deps The dependencies to watch for changes\n     * @returns A cleanup function\n     */ onRender(deps) {\n        // The returned callback will run on each render\n        return ()=>{\n            this.isComponentMounted = true;\n            // Cleanup any scheduled destructions, since we are currently rendering\n            clearTimeout(this.scheduledDestructionTimeout);\n            if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n                // if the editor does exist & deps are empty, we don't need to re-initialize the editor generally\n                if (!EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n                    // But, the options are different, so we need to update the editor options\n                    // Still, this is faster than re-creating the editor\n                    this.editor.setOptions({\n                        ...this.options.current,\n                        editable: this.editor.isEditable\n                    });\n                }\n            } else {\n                // When the editor:\n                // - does not yet exist\n                // - is destroyed\n                // - the deps array changes\n                // We need to destroy the editor instance and re-initialize it\n                this.refreshEditorInstance(deps);\n            }\n            return ()=>{\n                this.isComponentMounted = false;\n                this.scheduleDestroy();\n            };\n        };\n    }\n    /**\n     * Recreate the editor instance if the dependencies have changed.\n     */ refreshEditorInstance(deps) {\n        if (this.editor && !this.editor.isDestroyed) {\n            // Editor instance already exists\n            if (this.previousDeps === null) {\n                // If lastDeps has not yet been initialized, reuse the current editor instance\n                this.previousDeps = deps;\n                return;\n            }\n            const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index)=>dep === deps[index]);\n            if (depsAreEqual) {\n                // deps exist and are equal, no need to recreate\n                return;\n            }\n        }\n        if (this.editor && !this.editor.isDestroyed) {\n            // Destroy the editor instance if it exists\n            this.editor.destroy();\n        }\n        this.setEditor(this.createEditor());\n        // Update the lastDeps to the current deps\n        this.previousDeps = deps;\n    }\n    /**\n     * Schedule the destruction of the editor instance.\n     * This will only destroy the editor if it was not mounted on the next tick.\n     * This is to avoid destroying the editor instance when it's actually still mounted.\n     */ scheduleDestroy() {\n        const currentInstanceId = this.instanceId;\n        const currentEditor = this.editor;\n        // Wait two ticks to see if the component is still mounted\n        this.scheduledDestructionTimeout = setTimeout(()=>{\n            if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n                // If still mounted on the following tick, with the same instanceId, do not destroy the editor\n                if (currentEditor) {\n                    // just re-apply options as they might have changed\n                    currentEditor.setOptions(this.options.current);\n                }\n                return;\n            }\n            if (currentEditor && !currentEditor.isDestroyed) {\n                currentEditor.destroy();\n                if (this.instanceId === currentInstanceId) {\n                    this.setEditor(null);\n                }\n            }\n        // This allows the effect to run again between ticks\n        // which may save us from having to re-create the editor\n        }, 1);\n    }\n}\nfunction useEditor(options = {}, deps = []) {\n    const mostRecentOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(options);\n    mostRecentOptions.current = options;\n    const [instanceManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new EditorInstanceManager(mostRecentOptions));\n    const editor = shimExports.useSyncExternalStore(instanceManager.subscribe, instanceManager.getEditor, instanceManager.getServerSnapshot);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(editor);\n    // This effect will handle creating/updating the editor instance\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(instanceManager.onRender(deps));\n    // The default behavior is to re-render on each transaction\n    // This is legacy behavior that will be removed in future versions\n    useEditorState({\n        editor,\n        selector: ({ transactionNumber })=>{\n            if (options.shouldRerenderOnTransaction === false) {\n                // This will prevent the editor from re-rendering on each transaction\n                return null;\n            }\n            // This will avoid re-rendering on the first transaction when `immediatelyRender` is set to `true`\n            if (options.immediatelyRender && transactionNumber === 0) {\n                return 0;\n            }\n            return transactionNumber + 1;\n        }\n    });\n    return editor;\n}\nconst EditorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    editor: null\n});\nconst EditorConsumer = EditorContext.Consumer;\n/**\n * A hook to get the current editor instance.\n */ const useCurrentEditor = ()=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorContext);\n/**\n * This is the provider component for the editor.\n * It allows the editor to be accessible across the entire component tree\n * with `useCurrentEditor`.\n */ function EditorProvider({ children, slotAfter, slotBefore, editorContainerProps = {}, ...editorOptions }) {\n    const editor = useEditor(editorOptions);\n    if (!editor) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorContext.Provider, {\n        value: {\n            editor\n        }\n    }, slotBefore, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorConsumer, null, ({ editor: currentEditor })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorContent, {\n            editor: currentEditor,\n            ...editorContainerProps\n        })), children, slotAfter);\n}\nconst BubbleMenu = (props)=>{\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { editor: currentEditor } = useCurrentEditor();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        if (!element) {\n            return;\n        }\n        if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n            return;\n        }\n        const { pluginKey = \"bubbleMenu\", editor, tippyOptions = {}, updateDelay, shouldShow = null } = props;\n        const menuEditor = editor || currentEditor;\n        if (!menuEditor) {\n            console.warn(\"BubbleMenu component is not rendered inside of an editor component or does not have editor prop.\");\n            return;\n        }\n        const plugin = (0,_tiptap_extension_bubble_menu__WEBPACK_IMPORTED_MODULE_3__.BubbleMenuPlugin)({\n            updateDelay,\n            editor: menuEditor,\n            element,\n            pluginKey,\n            shouldShow,\n            tippyOptions\n        });\n        menuEditor.registerPlugin(plugin);\n        return ()=>{\n            menuEditor.unregisterPlugin(pluginKey);\n        };\n    }, [\n        props.editor,\n        currentEditor,\n        element\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: setElement,\n        className: props.className,\n        style: {\n            visibility: \"hidden\"\n        }\n    }, props.children);\n};\nconst FloatingMenu = (props)=>{\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { editor: currentEditor } = useCurrentEditor();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        if (!element) {\n            return;\n        }\n        if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n            return;\n        }\n        const { pluginKey = \"floatingMenu\", editor, tippyOptions = {}, shouldShow = null } = props;\n        const menuEditor = editor || currentEditor;\n        if (!menuEditor) {\n            console.warn(\"FloatingMenu component is not rendered inside of an editor component or does not have editor prop.\");\n            return;\n        }\n        const plugin = (0,_tiptap_extension_floating_menu__WEBPACK_IMPORTED_MODULE_4__.FloatingMenuPlugin)({\n            pluginKey,\n            editor: menuEditor,\n            element,\n            tippyOptions,\n            shouldShow\n        });\n        menuEditor.registerPlugin(plugin);\n        return ()=>{\n            menuEditor.unregisterPlugin(pluginKey);\n        };\n    }, [\n        props.editor,\n        currentEditor,\n        element\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: setElement,\n        className: props.className,\n        style: {\n            visibility: \"hidden\"\n        }\n    }, props.children);\n};\nconst ReactNodeViewContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    onDragStart: undefined\n});\nconst useReactNodeView = ()=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ReactNodeViewContext);\nconst NodeViewContent = (props)=>{\n    const Tag = props.as || \"div\";\n    const { nodeViewContentRef } = useReactNodeView();\n    return(// @ts-ignore\n    /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, {\n        ...props,\n        ref: nodeViewContentRef,\n        \"data-node-view-content\": \"\",\n        style: {\n            whiteSpace: \"pre-wrap\",\n            ...props.style\n        }\n    }));\n};\nconst NodeViewWrapper = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref)=>{\n    const { onDragStart } = useReactNodeView();\n    const Tag = props.as || \"div\";\n    return(// @ts-ignore\n    /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, {\n        ...props,\n        ref: ref,\n        \"data-node-view-wrapper\": \"\",\n        onDragStart: onDragStart,\n        style: {\n            whiteSpace: \"normal\",\n            ...props.style\n        }\n    }));\n});\n/**\n * Check if a component is a class component.\n * @param Component\n * @returns {boolean}\n */ function isClassComponent(Component) {\n    return !!(typeof Component === \"function\" && Component.prototype && Component.prototype.isReactComponent);\n}\n/**\n * Check if a component is a forward ref component.\n * @param Component\n * @returns {boolean}\n */ function isForwardRefComponent(Component) {\n    var _a;\n    return !!(typeof Component === \"object\" && ((_a = Component.$$typeof) === null || _a === void 0 ? void 0 : _a.toString()) === \"Symbol(react.forward_ref)\");\n}\n/**\n * The ReactRenderer class. It's responsible for rendering React components inside the editor.\n * @example\n * new ReactRenderer(MyComponent, {\n *   editor,\n *   props: {\n *     foo: 'bar',\n *   },\n *   as: 'span',\n * })\n*/ class ReactRenderer {\n    /**\n     * Immediately creates element and renders the provided React component.\n     */ constructor(component, { editor, props = {}, as = \"div\", className = \"\" }){\n        this.ref = null;\n        this.id = Math.floor(Math.random() * 0xFFFFFFFF).toString();\n        this.component = component;\n        this.editor = editor;\n        this.props = props;\n        this.element = document.createElement(as);\n        this.element.classList.add(\"react-renderer\");\n        if (className) {\n            this.element.classList.add(...className.split(\" \"));\n        }\n        if (this.editor.isInitialized) {\n            // On first render, we need to flush the render synchronously\n            // Renders afterwards can be async, but this fixes a cursor positioning issue\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n                this.render();\n            });\n        } else {\n            this.render();\n        }\n    }\n    /**\n     * Render the React component.\n     */ render() {\n        var _a;\n        const Component = this.component;\n        const props = this.props;\n        const editor = this.editor;\n        if (isClassComponent(Component) || isForwardRefComponent(Component)) {\n            // @ts-ignore This is a hack to make the ref work\n            props.ref = (ref)=>{\n                this.ref = ref;\n            };\n        }\n        this.reactElement = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n            ...props\n        });\n        (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.setRenderer(this.id, this);\n    }\n    /**\n     * Re-renders the React component with new props.\n     */ updateProps(props = {}) {\n        this.props = {\n            ...this.props,\n            ...props\n        };\n        this.render();\n    }\n    /**\n     * Destroy the React component.\n     */ destroy() {\n        var _a;\n        const editor = this.editor;\n        (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.removeRenderer(this.id);\n    }\n    /**\n     * Update the attributes of the element that holds the React component.\n     */ updateAttributes(attributes) {\n        Object.keys(attributes).forEach((key)=>{\n            this.element.setAttribute(key, attributes[key]);\n        });\n    }\n}\nclass ReactNodeView extends _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodeView {\n    /**\n     * Setup the React component.\n     * Called on initialization.\n     */ mount() {\n        const props = {\n            editor: this.editor,\n            node: this.node,\n            decorations: this.decorations,\n            innerDecorations: this.innerDecorations,\n            view: this.view,\n            selected: false,\n            extension: this.extension,\n            HTMLAttributes: this.HTMLAttributes,\n            getPos: ()=>this.getPos(),\n            updateAttributes: (attributes = {})=>this.updateAttributes(attributes),\n            deleteNode: ()=>this.deleteNode()\n        };\n        if (!this.component.displayName) {\n            const capitalizeFirstChar = (string)=>{\n                return string.charAt(0).toUpperCase() + string.substring(1);\n            };\n            this.component.displayName = capitalizeFirstChar(this.extension.name);\n        }\n        const onDragStart = this.onDragStart.bind(this);\n        const nodeViewContentRef = (element)=>{\n            if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n                element.appendChild(this.contentDOMElement);\n            }\n        };\n        const context = {\n            onDragStart,\n            nodeViewContentRef\n        };\n        const Component = this.component;\n        // For performance reasons, we memoize the provider component\n        // And all of the things it requires are declared outside of the component, so it doesn't need to re-render\n        const ReactNodeViewProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo((componentProps)=>{\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ReactNodeViewContext.Provider, {\n                value: context\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, componentProps));\n        });\n        ReactNodeViewProvider.displayName = \"ReactNodeView\";\n        if (this.node.isLeaf) {\n            this.contentDOMElement = null;\n        } else if (this.options.contentDOMElementTag) {\n            this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);\n        } else {\n            this.contentDOMElement = document.createElement(this.node.isInline ? \"span\" : \"div\");\n        }\n        if (this.contentDOMElement) {\n            this.contentDOMElement.dataset.nodeViewContentReact = \"\";\n            // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari\n            // With this fix it seems to work fine\n            // See: https://github.com/ueberdosis/tiptap/issues/1197\n            this.contentDOMElement.style.whiteSpace = \"inherit\";\n        }\n        let as = this.node.isInline ? \"span\" : \"div\";\n        if (this.options.as) {\n            as = this.options.as;\n        }\n        const { className = \"\" } = this.options;\n        this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);\n        this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n            editor: this.editor,\n            props,\n            as,\n            className: `node-${this.node.type.name} ${className}`.trim()\n        });\n        this.editor.on(\"selectionUpdate\", this.handleSelectionUpdate);\n        this.updateElementAttributes();\n    }\n    /**\n     * Return the DOM element.\n     * This is the element that will be used to display the node view.\n     */ get dom() {\n        var _a;\n        if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) === null || _a === void 0 ? void 0 : _a.hasAttribute(\"data-node-view-wrapper\"))) {\n            throw Error(\"Please use the NodeViewWrapper component for your node view.\");\n        }\n        return this.renderer.element;\n    }\n    /**\n     * Return the content DOM element.\n     * This is the element that will be used to display the rich-text content of the node.\n     */ get contentDOM() {\n        if (this.node.isLeaf) {\n            return null;\n        }\n        return this.contentDOMElement;\n    }\n    /**\n     * On editor selection update, check if the node is selected.\n     * If it is, call `selectNode`, otherwise call `deselectNode`.\n     */ handleSelectionUpdate() {\n        const { from, to } = this.editor.state.selection;\n        const pos = this.getPos();\n        if (typeof pos !== \"number\") {\n            return;\n        }\n        if (from <= pos && to >= pos + this.node.nodeSize) {\n            if (this.renderer.props.selected) {\n                return;\n            }\n            this.selectNode();\n        } else {\n            if (!this.renderer.props.selected) {\n                return;\n            }\n            this.deselectNode();\n        }\n    }\n    /**\n     * On update, update the React component.\n     * To prevent unnecessary updates, the `update` option can be used.\n     */ update(node, decorations, innerDecorations) {\n        const rerenderComponent = (props)=>{\n            this.renderer.updateProps(props);\n            if (typeof this.options.attrs === \"function\") {\n                this.updateElementAttributes();\n            }\n        };\n        if (node.type !== this.node.type) {\n            return false;\n        }\n        if (typeof this.options.update === \"function\") {\n            const oldNode = this.node;\n            const oldDecorations = this.decorations;\n            const oldInnerDecorations = this.innerDecorations;\n            this.node = node;\n            this.decorations = decorations;\n            this.innerDecorations = innerDecorations;\n            return this.options.update({\n                oldNode,\n                oldDecorations,\n                newNode: node,\n                newDecorations: decorations,\n                oldInnerDecorations,\n                innerDecorations,\n                updateProps: ()=>rerenderComponent({\n                        node,\n                        decorations,\n                        innerDecorations\n                    })\n            });\n        }\n        if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {\n            return true;\n        }\n        this.node = node;\n        this.decorations = decorations;\n        this.innerDecorations = innerDecorations;\n        rerenderComponent({\n            node,\n            decorations,\n            innerDecorations\n        });\n        return true;\n    }\n    /**\n     * Select the node.\n     * Add the `selected` prop and the `ProseMirror-selectednode` class.\n     */ selectNode() {\n        this.renderer.updateProps({\n            selected: true\n        });\n        this.renderer.element.classList.add(\"ProseMirror-selectednode\");\n    }\n    /**\n     * Deselect the node.\n     * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n     */ deselectNode() {\n        this.renderer.updateProps({\n            selected: false\n        });\n        this.renderer.element.classList.remove(\"ProseMirror-selectednode\");\n    }\n    /**\n     * Destroy the React component instance.\n     */ destroy() {\n        this.renderer.destroy();\n        this.editor.off(\"selectionUpdate\", this.handleSelectionUpdate);\n        this.contentDOMElement = null;\n    }\n    /**\n     * Update the attributes of the top-level element that holds the React component.\n     * Applying the attributes defined in the `attrs` option.\n     */ updateElementAttributes() {\n        if (this.options.attrs) {\n            let attrsObj = {};\n            if (typeof this.options.attrs === \"function\") {\n                const extensionAttributes = this.editor.extensionManager.attributes;\n                const HTMLAttributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getRenderedAttributes)(this.node, extensionAttributes);\n                attrsObj = this.options.attrs({\n                    node: this.node,\n                    HTMLAttributes\n                });\n            } else {\n                attrsObj = this.options.attrs;\n            }\n            this.renderer.updateAttributes(attrsObj);\n        }\n    }\n}\n/**\n * Create a React node view renderer.\n */ function ReactNodeViewRenderer(component, options) {\n    return (props)=>{\n        // try to get the parent component\n        // this is important for vue devtools to show the component hierarchy correctly\n        // maybe it’s `undefined` because <editor-content> isn’t rendered yet\n        if (!props.editor.contentComponent) {\n            return {};\n        }\n        return new ReactNodeView(component, props, options);\n    };\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTtBQUNpRTtBQUNsRjtBQUN1QjtBQUMxQztBQUN3QztBQUVyRSxTQUFTZ0Isd0JBQXlCQyxDQUFDO0lBQ2xDLE9BQU9BLEtBQUtBLEVBQUVDLFVBQVUsSUFBSUMsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0wsR0FBRyxhQUFhQSxDQUFDLENBQUMsVUFBVSxHQUFHQTtBQUNqRztBQUVBLElBQUlNLE9BQU87SUFBQ0MsU0FBUyxDQUFDO0FBQUM7QUFFdkIsSUFBSUMsMENBQTBDLENBQUM7QUFFL0M7Ozs7Ozs7O0NBUUMsR0FFRCxJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsb0RBQW9ELE9BQU9EO0lBQy9EQyxxREFBcUQ7SUFDdEQsSUFBSUUsSUFBRTNCLGtDQUFLQTtJQUFDLFNBQVM0QixFQUFFQyxDQUFDLEVBQUNDLENBQUM7UUFBRSxPQUFPRCxNQUFJQyxLQUFJLE9BQUlELEtBQUcsSUFBRUEsTUFBSSxJQUFFQyxDQUFBQSxLQUFJRCxNQUFJQSxLQUFHQyxNQUFJQTtJQUFDO0lBQUMsSUFBSUMsSUFBRSxlQUFhLE9BQU9iLE9BQU9jLEVBQUUsR0FBQ2QsT0FBT2MsRUFBRSxHQUFDSixHQUFFSyxJQUFFTixFQUFFekIsUUFBUSxFQUFDZ0MsSUFBRVAsRUFBRXRCLFNBQVMsRUFBQzhCLElBQUVSLEVBQUV2QixlQUFlLEVBQUNnQyxJQUFFVCxFQUFFeEIsYUFBYTtJQUFDLFNBQVNrQyxFQUFFUixDQUFDLEVBQUNDLENBQUM7UUFBRSxJQUFJUSxJQUFFUixLQUFJUyxJQUFFTixFQUFFO1lBQUNPLE1BQUs7Z0JB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aXN0L2luZGV4LmpzP2FiYmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnViYmxlTWVudVBsdWdpbiB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJ1YmJsZS1tZW51JztcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VTdGF0ZSwgdXNlRGVidWdWYWx1ZSwgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QsIHVzZVJlZiwgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSwgeyBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgRWRpdG9yLCBOb2RlVmlldywgZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBGbG9hdGluZ01lbnVQbHVnaW4gfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1mbG9hdGluZy1tZW51JztcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIHNoaW0gPSB7ZXhwb3J0czoge319O1xuXG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluID0ge307XG5cbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW47XG5cbmZ1bmN0aW9uIHJlcXVpcmVVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW4gKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW4pIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW47XG5cdGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluID0gMTtcbnZhciBlPVJlYWN0O2Z1bmN0aW9uIGgoYSxiKXtyZXR1cm4gYT09PWImJigwIT09YXx8MS9hPT09MS9iKXx8YSE9PWEmJmIhPT1ifXZhciBrPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBPYmplY3QuaXM/T2JqZWN0LmlzOmgsbD1lLnVzZVN0YXRlLG09ZS51c2VFZmZlY3Qsbj1lLnVzZUxheW91dEVmZmVjdCxwPWUudXNlRGVidWdWYWx1ZTtmdW5jdGlvbiBxKGEsYil7dmFyIGQ9YigpLGY9bCh7aW5zdDp7dmFsdWU6ZCxnZXRTbmFwc2hvdDpifX0pLGM9ZlswXS5pbnN0LGc9ZlsxXTtuKGZ1bmN0aW9uKCl7Yy52YWx1ZT1kO2MuZ2V0U25hcHNob3Q9YjtyKGMpJiZnKHtpbnN0OmN9KTt9LFthLGQsYl0pO20oZnVuY3Rpb24oKXtyKGMpJiZnKHtpbnN0OmN9KTtyZXR1cm4gYShmdW5jdGlvbigpe3IoYykmJmcoe2luc3Q6Y30pO30pfSxbYV0pO3AoZCk7cmV0dXJuIGR9XG5cdGZ1bmN0aW9uIHIoYSl7dmFyIGI9YS5nZXRTbmFwc2hvdDthPWEudmFsdWU7dHJ5e3ZhciBkPWIoKTtyZXR1cm4gIWsoYSxkKX1jYXRjaChmKXtyZXR1cm4gITB9fWZ1bmN0aW9uIHQoYSxiKXtyZXR1cm4gYigpfXZhciB1PVwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvdy5kb2N1bWVudHx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudD90OnE7dXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluLnVzZVN5bmNFeHRlcm5hbFN0b3JlPXZvaWQgMCE9PWUudXNlU3luY0V4dGVybmFsU3RvcmU/ZS51c2VTeW5jRXh0ZXJuYWxTdG9yZTp1O1xuXHRyZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluO1xufVxuXG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50ID0ge307XG5cbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQpIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQ7XG5cdGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50ID0gMTtcblxuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG5cdCAgKGZ1bmN0aW9uKCkge1xuXG5cdC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cblx0aWYgKFxuXHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG5cdCAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG5cdCAgICAnZnVuY3Rpb24nXG5cdCkge1xuXHQgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xuXHR9XG5cdCAgICAgICAgICB2YXIgUmVhY3QkMSA9IFJlYWN0O1xuXG5cdHZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0JDEuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cblx0ZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG5cdCAge1xuXHQgICAge1xuXHQgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHQgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdCAgICAgIH1cblxuXHQgICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuXHQgIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuXHQgIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuXHQgIHtcblx0ICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblx0ICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG5cdCAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG5cdCAgICAgIGZvcm1hdCArPSAnJXMnO1xuXHQgICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG5cdCAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cblx0ICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG5cdCAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuXHQgICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG5cdCAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cblx0ICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cblx0ICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG5cdCAqL1xuXHRmdW5jdGlvbiBpcyh4LCB5KSB7XG5cdCAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcblx0ICA7XG5cdH1cblxuXHR2YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cblx0Ly8gZGlzcGF0Y2ggZm9yIENvbW1vbkpTIGludGVyb3AgbmFtZWQgaW1wb3J0cy5cblxuXHR2YXIgdXNlU3RhdGUgPSBSZWFjdCQxLnVzZVN0YXRlLFxuXHQgICAgdXNlRWZmZWN0ID0gUmVhY3QkMS51c2VFZmZlY3QsXG5cdCAgICB1c2VMYXlvdXRFZmZlY3QgPSBSZWFjdCQxLnVzZUxheW91dEVmZmVjdCxcblx0ICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdCQxLnVzZURlYnVnVmFsdWU7XG5cdHZhciBkaWRXYXJuT2xkMThBbHBoYSA9IGZhbHNlO1xuXHR2YXIgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSBmYWxzZTsgLy8gRGlzY2xhaW1lcjogVGhpcyBzaGltIGJyZWFrcyBtYW55IG9mIHRoZSBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3Ncblx0Ly8gYmVjYXVzZSBvZiBhIHZlcnkgcGFydGljdWxhciBzZXQgb2YgaW1wbGVtZW50YXRpb24gZGV0YWlscyBhbmQgYXNzdW1wdGlvbnNcblx0Ly8gLS0gY2hhbmdlIGFueSBvbmUgb2YgdGhlbSBhbmQgaXQgd2lsbCBicmVhay4gVGhlIG1vc3QgaW1wb3J0YW50IGFzc3VtcHRpb25cblx0Ly8gaXMgdGhhdCB1cGRhdGVzIGFyZSBhbHdheXMgc3luY2hyb25vdXMsIGJlY2F1c2UgY29uY3VycmVudCByZW5kZXJpbmcgaXNcblx0Ly8gb25seSBhdmFpbGFibGUgaW4gdmVyc2lvbnMgb2YgUmVhY3QgdGhhdCBhbHNvIGhhdmUgYSBidWlsdC1pblxuXHQvLyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBBUEkuIEFuZCB3ZSBvbmx5IHVzZSB0aGlzIHNoaW0gd2hlbiB0aGUgYnVpbHQtaW4gQVBJXG5cdC8vIGRvZXMgbm90IGV4aXN0LlxuXHQvL1xuXHQvLyBEbyBub3QgYXNzdW1lIHRoYXQgdGhlIGNsZXZlciBoYWNrcyB1c2VkIGJ5IHRoaXMgaG9vayBhbHNvIHdvcmsgaW4gZ2VuZXJhbC5cblx0Ly8gVGhlIHBvaW50IG9mIHRoaXMgc2hpbSBpcyB0byByZXBsYWNlIHRoZSBuZWVkIGZvciBoYWNrcyBieSBvdGhlciBsaWJyYXJpZXMuXG5cblx0ZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuXHQvLyBSZWFjdCBkbyBub3QgZXhwb3NlIGEgd2F5IHRvIGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZy4gU28gdXNlcnMgb2YgdGhlIHNoaW1cblx0Ly8gd2lsbCBuZWVkIHRvIHRyYWNrIHRoYXQgdGhlbXNlbHZlcyBhbmQgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlXG5cdC8vIGZyb20gYGdldFNuYXBzaG90YC5cblx0Z2V0U2VydmVyU25hcHNob3QpIHtcblx0ICB7XG5cdCAgICBpZiAoIWRpZFdhcm5PbGQxOEFscGhhKSB7XG5cdCAgICAgIGlmIChSZWFjdCQxLnN0YXJ0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgZGlkV2Fybk9sZDE4QWxwaGEgPSB0cnVlO1xuXG5cdCAgICAgICAgZXJyb3IoJ1lvdSBhcmUgdXNpbmcgYW4gb3V0ZGF0ZWQsIHByZS1yZWxlYXNlIGFscGhhIG9mIFJlYWN0IDE4IHRoYXQgJyArICdkb2VzIG5vdCBzdXBwb3J0IHVzZVN5bmNFeHRlcm5hbFN0b3JlLiBUaGUgJyArICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZSBzaGltIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5LiBVcGdyYWRlICcgKyAndG8gYSBuZXdlciBwcmUtcmVsZWFzZS4nKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gLy8gUmVhZCB0aGUgY3VycmVudCBzbmFwc2hvdCBmcm9tIHRoZSBzdG9yZSBvbiBldmVyeSByZW5kZXIuIEFnYWluLCB0aGlzXG5cdCAgLy8gYnJlYWtzIHRoZSBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgaGVyZSBiZWNhdXNlIG9mIHNwZWNpZmljXG5cdCAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscywgbW9zdCBpbXBvcnRhbnRseSB0aGF0IHVwZGF0ZXMgYXJlXG5cdCAgLy8gYWx3YXlzIHN5bmNocm9ub3VzLlxuXG5cblx0ICB2YXIgdmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuXG5cdCAge1xuXHQgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuXHQgICAgICB2YXIgY2FjaGVkVmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuXG5cdCAgICAgIGlmICghb2JqZWN0SXModmFsdWUsIGNhY2hlZFZhbHVlKSkge1xuXHQgICAgICAgIGVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuXG5cdCAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSAvLyBCZWNhdXNlIHVwZGF0ZXMgYXJlIHN5bmNocm9ub3VzLCB3ZSBkb24ndCBxdWV1ZSB0aGVtLiBJbnN0ZWFkIHdlIGZvcmNlIGFcblx0ICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG5cdCAgLy8gYXJiaXRyYXJ5IHVzZVN0YXRlIGhvb2suIFRoZW4sIGR1cmluZyByZW5kZXIsIHdlIGNhbGwgZ2V0U25hcHNob3QgdG8gcmVhZFxuXHQgIC8vIHRoZSBjdXJyZW50IHZhbHVlLlxuXHQgIC8vXG5cdCAgLy8gQmVjYXVzZSB3ZSBkb24ndCBhY3R1YWxseSB1c2UgdGhlIHN0YXRlIHJldHVybmVkIGJ5IHRoZSB1c2VTdGF0ZSBob29rLCB3ZVxuXHQgIC8vIGNhbiBzYXZlIGEgYml0IG9mIG1lbW9yeSBieSBzdG9yaW5nIG90aGVyIHN0dWZmIGluIHRoYXQgc2xvdC5cblx0ICAvL1xuXHQgIC8vIFRvIGltcGxlbWVudCB0aGUgZWFybHkgYmFpbG91dCwgd2UgbmVlZCB0byB0cmFjayBzb21lIHRoaW5ncyBvbiBhIG11dGFibGVcblx0ICAvLyBvYmplY3QuIFVzdWFsbHksIHdlIHdvdWxkIHB1dCB0aGF0IGluIGEgdXNlUmVmIGhvb2ssIGJ1dCB3ZSBjYW4gc3Rhc2ggaXQgaW5cblx0ICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuXHQgIC8vXG5cdCAgLy8gVG8gZm9yY2UgYSByZS1yZW5kZXIsIHdlIGNhbGwgZm9yY2VVcGRhdGUoe2luc3R9KS4gVGhhdCB3b3JrcyBiZWNhdXNlIHRoZVxuXHQgIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuXG5cblx0ICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoe1xuXHQgICAgaW5zdDoge1xuXHQgICAgICB2YWx1ZTogdmFsdWUsXG5cdCAgICAgIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdFxuXHQgICAgfVxuXHQgIH0pLFxuXHQgICAgICBpbnN0ID0gX3VzZVN0YXRlWzBdLmluc3QsXG5cdCAgICAgIGZvcmNlVXBkYXRlID0gX3VzZVN0YXRlWzFdOyAvLyBUcmFjayB0aGUgbGF0ZXN0IGdldFNuYXBzaG90IGZ1bmN0aW9uIHdpdGggYSByZWYuIFRoaXMgbmVlZHMgdG8gYmUgdXBkYXRlZFxuXHQgIC8vIGluIHRoZSBsYXlvdXQgcGhhc2Ugc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIHRlYXJpbmcgY2hlY2sgdGhhdFxuXHQgIC8vIGhhcHBlbnMgb24gc3Vic2NyaWJlLlxuXG5cblx0ICB1c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuXHQgICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuXHQgICAgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90OyAvLyBXaGVuZXZlciBnZXRTbmFwc2hvdCBvciBzdWJzY3JpYmUgY2hhbmdlcywgd2UgbmVlZCB0byBjaGVjayBpbiB0aGVcblx0ICAgIC8vIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgbXV0YXRpb24uIEluIGNvbmN1cnJlbnQgbW9kZVxuXHQgICAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuXHQgICAgLy8gZWZmZWN0IG1heSBoYXZlIG11dGF0ZWQgdGhlIHN0b3JlLlxuXG5cdCAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuXHQgICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cblx0ICAgICAgZm9yY2VVcGRhdGUoe1xuXHQgICAgICAgIGluc3Q6IGluc3Rcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwgW3N1YnNjcmliZSwgdmFsdWUsIGdldFNuYXBzaG90XSk7XG5cdCAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIENoZWNrIGZvciBjaGFuZ2VzIHJpZ2h0IGJlZm9yZSBzdWJzY3JpYmluZy4gU3Vic2VxdWVudCBjaGFuZ2VzIHdpbGwgYmVcblx0ICAgIC8vIGRldGVjdGVkIGluIHRoZSBzdWJzY3JpcHRpb24gaGFuZGxlci5cblx0ICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG5cdCAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuXHQgICAgICBmb3JjZVVwZGF0ZSh7XG5cdCAgICAgICAgaW5zdDogaW5zdFxuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAvLyBUT0RPOiBCZWNhdXNlIHRoZXJlIGlzIG5vIGNyb3NzLXJlbmRlcmVyIEFQSSBmb3IgYmF0Y2hpbmcgdXBkYXRlcywgaXQnc1xuXHQgICAgICAvLyB1cCB0byB0aGUgY29uc3VtZXIgb2YgdGhpcyBsaWJyYXJ5IHRvIHdyYXAgdGhlaXIgc3Vic2NyaXB0aW9uIGV2ZW50XG5cdCAgICAgIC8vIHdpdGggdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMuIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZWN0IHdoZW4gdGhpcyBpc24ndFxuXHQgICAgICAvLyB0aGUgY2FzZSBhbmQgcHJpbnQgYSB3YXJuaW5nIGluIGRldmVsb3BtZW50P1xuXHQgICAgICAvLyBUaGUgc3RvcmUgY2hhbmdlZC4gQ2hlY2sgaWYgdGhlIHNuYXBzaG90IGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZVxuXHQgICAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuXHQgICAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuXHQgICAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuXHQgICAgICAgIGZvcmNlVXBkYXRlKHtcblx0ICAgICAgICAgIGluc3Q6IGluc3Rcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgfTsgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIGEgY2xlYW4tdXAgZnVuY3Rpb24uXG5cblxuXHQgICAgcmV0dXJuIHN1YnNjcmliZShoYW5kbGVTdG9yZUNoYW5nZSk7XG5cdCAgfSwgW3N1YnNjcmliZV0pO1xuXHQgIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuXHQgIHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkge1xuXHQgIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG5cdCAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cblx0ICB0cnkge1xuXHQgICAgdmFyIG5leHRWYWx1ZSA9IGxhdGVzdEdldFNuYXBzaG90KCk7XG5cdCAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUkMShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuXHQgIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2Zcblx0ICAvLyBSZWFjdCBkbyBub3QgZXhwb3NlIGEgd2F5IHRvIGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZy4gU28gdXNlcnMgb2YgdGhlIHNoaW1cblx0ICAvLyB3aWxsIG5lZWQgdG8gdHJhY2sgdGhhdCB0aGVtc2VsdmVzIGFuZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWVcblx0ICAvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG5cdCAgcmV0dXJuIGdldFNuYXBzaG90KCk7XG5cdH1cblxuXHR2YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cblx0dmFyIGlzU2VydmVyRW52aXJvbm1lbnQgPSAhY2FuVXNlRE9NO1xuXG5cdHZhciBzaGltID0gaXNTZXJ2ZXJFbnZpcm9ubWVudCA/IHVzZVN5bmNFeHRlcm5hbFN0b3JlJDEgOiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTtcblx0dmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDIgPSBSZWFjdCQxLnVzZVN5bmNFeHRlcm5hbFN0b3JlICE9PSB1bmRlZmluZWQgPyBSZWFjdCQxLnVzZVN5bmNFeHRlcm5hbFN0b3JlIDogc2hpbTtcblxuXHR1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQudXNlU3luY0V4dGVybmFsU3RvcmUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQyO1xuXHQgICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuXHRpZiAoXG5cdCAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuXHQgICAgJ2Z1bmN0aW9uJ1xuXHQpIHtcblx0ICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xuXHR9XG5cdCAgICAgICAgXG5cdCAgfSkoKTtcblx0fVxuXHRyZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50O1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBzaGltLmV4cG9ydHMgPSByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluKCk7XG59IGVsc2Uge1xuICBzaGltLmV4cG9ydHMgPSByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50KCk7XG59XG5cbnZhciBzaGltRXhwb3J0cyA9IHNoaW0uZXhwb3J0cztcblxuY29uc3QgbWVyZ2VSZWZzID0gKC4uLnJlZnMpID0+IHtcbiAgICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICAgICAgcmVmcy5mb3JFYWNoKHJlZiA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlZihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHJlbmRlcnMgYWxsIG9mIHRoZSBlZGl0b3IncyBub2RlIHZpZXdzLlxuICovXG5jb25zdCBQb3J0YWxzID0gKHsgY29udGVudENvbXBvbmVudCwgfSkgPT4ge1xuICAgIC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSByZW5kZXIgdGhlIG5vZGUgdmlldyBwb3J0YWxzIG9uIHN0YXRlIGNoYW5nZXMgb25seVxuICAgIGNvbnN0IHJlbmRlcmVycyA9IHNoaW1FeHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlKGNvbnRlbnRDb21wb25lbnQuc3Vic2NyaWJlLCBjb250ZW50Q29tcG9uZW50LmdldFNuYXBzaG90LCBjb250ZW50Q29tcG9uZW50LmdldFNlcnZlclNuYXBzaG90KTtcbiAgICAvLyBUaGlzIGFsbG93cyB1cyB0byBkaXJlY3RseSByZW5kZXIgdGhlIHBvcnRhbHMgd2l0aG91dCBhbnkgYWRkaXRpb25hbCB3cmFwcGVyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBPYmplY3QudmFsdWVzKHJlbmRlcmVycykpKTtcbn07XG5mdW5jdGlvbiBnZXRJbnN0YW5jZSgpIHtcbiAgICBjb25zdCBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgcmVuZGVyZXJzID0ge307XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnNjcmliZSB0byB0aGUgZWRpdG9yIGluc3RhbmNlJ3MgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNuYXBzaG90KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVycztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZXJzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIG5ldyBOb2RlVmlldyBSZW5kZXJlciB0byB0aGUgZWRpdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UmVuZGVyZXIoaWQsIHJlbmRlcmVyKSB7XG4gICAgICAgICAgICByZW5kZXJlcnMgPSB7XG4gICAgICAgICAgICAgICAgLi4ucmVuZGVyZXJzLFxuICAgICAgICAgICAgICAgIFtpZF06IFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChyZW5kZXJlci5yZWFjdEVsZW1lbnQsIHJlbmRlcmVyLmVsZW1lbnQsIGlkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKHN1YnNjcmliZXIgPT4gc3Vic2NyaWJlcigpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBOb2RlVmlldyBSZW5kZXJlciBmcm9tIHRoZSBlZGl0b3IuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVSZW5kZXJlcihpZCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFJlbmRlcmVycyA9IHsgLi4ucmVuZGVyZXJzIH07XG4gICAgICAgICAgICBkZWxldGUgbmV4dFJlbmRlcmVyc1tpZF07XG4gICAgICAgICAgICByZW5kZXJlcnMgPSBuZXh0UmVuZGVyZXJzO1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaChzdWJzY3JpYmVyID0+IHN1YnNjcmliZXIoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmNsYXNzIFB1cmVFZGl0b3JDb250ZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5lZGl0b3JDb250ZW50UmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZDogQm9vbGVhbigoX2EgPSBwcm9wcy5lZGl0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50Q29tcG9uZW50KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvcjtcbiAgICAgICAgaWYgKGVkaXRvciAmJiAhZWRpdG9yLmlzRGVzdHJveWVkICYmIGVkaXRvci5vcHRpb25zLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlZGl0b3IuY29udGVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVkaXRvckNvbnRlbnRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKC4uLmVkaXRvci5vcHRpb25zLmVsZW1lbnQuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWRpdG9yLmNvbnRlbnRDb21wb25lbnQgPSBnZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgLy8gSGFzIHRoZSBjb250ZW50IGNvbXBvbmVudCBiZWVuIGluaXRpYWxpemVkP1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgY29udGVudCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50ID0gZWRpdG9yLmNvbnRlbnRDb21wb25lbnQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShwcmV2U3RhdGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2U3RhdGUuaGFzQ29udGVudENvbXBvbmVudEluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29udGVudENvbXBvbmVudEluaXRpYWxpemVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5zdWJzY3JpYmUgdG8gcHJldmlvdXMgY29udGVudCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWRpdG9yLmNyZWF0ZU5vZGVWaWV3cygpO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yO1xuICAgICAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFlZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIGVkaXRvci52aWV3LnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICBub2RlVmlld3M6IHt9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IuY29udGVudENvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIGlmICghZWRpdG9yLm9wdGlvbnMuZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBuZXdFbGVtZW50LmFwcGVuZCguLi5lZGl0b3Iub3B0aW9ucy5lbGVtZW50LmNoaWxkTm9kZXMpO1xuICAgICAgICBlZGl0b3Iuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBlbGVtZW50OiBuZXdFbGVtZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGVkaXRvciwgaW5uZXJSZWYsIC4uLnJlc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IG1lcmdlUmVmcyhpbm5lclJlZiwgdGhpcy5lZGl0b3JDb250ZW50UmVmKSwgLi4ucmVzdCB9KSxcbiAgICAgICAgICAgIChlZGl0b3IgPT09IG51bGwgfHwgZWRpdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGl0b3IuY29udGVudENvbXBvbmVudCkgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChQb3J0YWxzLCB7IGNvbnRlbnRDb21wb25lbnQ6IGVkaXRvci5jb250ZW50Q29tcG9uZW50IH0pKSk7XG4gICAgfVxufVxuLy8gRWRpdG9yQ29udGVudCBzaG91bGQgYmUgcmUtY3JlYXRlZCB3aGVuZXZlciB0aGUgRWRpdG9yIGluc3RhbmNlIGNoYW5nZXNcbmNvbnN0IEVkaXRvckNvbnRlbnRXaXRoS2V5ID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgIGNvbnN0IGtleSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZikudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtwcm9wcy5lZGl0b3JdKTtcbiAgICAvLyBDYW4ndCB1c2UgSlNYIGhlcmUgYmVjYXVzZSBpdCBjb25mbGljdHMgd2l0aCB0aGUgdHlwZSBkZWZpbml0aW9uIG9mIFZ1ZSdzIEpTWCwgc28gdXNlIGNyZWF0ZUVsZW1lbnRcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChQdXJlRWRpdG9yQ29udGVudCwge1xuICAgICAgICBrZXksXG4gICAgICAgIGlubmVyUmVmOiByZWYsXG4gICAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xufSk7XG5jb25zdCBFZGl0b3JDb250ZW50ID0gUmVhY3QubWVtbyhFZGl0b3JDb250ZW50V2l0aEtleSk7XG5cbnZhciByZWFjdCA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG4gICAgaWYgKChhIGluc3RhbmNlb2YgTWFwKSAmJiAoYiBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpIG9mIGEuZW50cmllcygpKVxuICAgICAgICBpZiAoIWIuaGFzKGlbMF0pKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgb2YgYS5lbnRyaWVzKCkpXG4gICAgICAgIGlmICghZXF1YWwoaVsxXSwgYi5nZXQoaVswXSkpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoKGEgaW5zdGFuY2VvZiBTZXQpICYmIChiIGluc3RhbmNlb2YgU2V0KSkge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgb2YgYS5lbnRyaWVzKCkpXG4gICAgICAgIGlmICghYi5oYXMoaVswXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGIpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgPT09ICdfb3duZXInICYmIGEuJCR0eXBlb2YpIHtcbiAgICAgICAgLy8gUmVhY3Qtc3BlY2lmaWM6IGF2b2lkIHRyYXZlcnNpbmcgUmVhY3QgZWxlbWVudHMnIF9vd25lci5cbiAgICAgICAgLy8gIF9vd25lciBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgIC8vIGFuZCBpcyBub3QgbmVlZGVkIHdoZW4gY29tcGFyaW5nIHRoZSBhY3R1YWwgZWxlbWVudHMgKGFuZCBub3QgdGhlaXIgb3duZXJzKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuXG52YXIgZGVlcEVxdWFsID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHJlYWN0KTtcblxudmFyIHdpdGhTZWxlY3RvciA9IHtleHBvcnRzOiB7fX07XG5cbnZhciB3aXRoU2VsZWN0b3JfcHJvZHVjdGlvbl9taW4gPSB7fTtcblxuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluO1xuXG5mdW5jdGlvbiByZXF1aXJlV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluKSByZXR1cm4gd2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluO1xuXHRoYXNSZXF1aXJlZFdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbiA9IDE7XG52YXIgaD1SZWFjdCxuPXNoaW1FeHBvcnRzO2Z1bmN0aW9uIHAoYSxiKXtyZXR1cm4gYT09PWImJigwIT09YXx8MS9hPT09MS9iKXx8YSE9PWEmJmIhPT1ifXZhciBxPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBPYmplY3QuaXM/T2JqZWN0LmlzOnAscj1uLnVzZVN5bmNFeHRlcm5hbFN0b3JlLHQ9aC51c2VSZWYsdT1oLnVzZUVmZmVjdCx2PWgudXNlTWVtbyx3PWgudXNlRGVidWdWYWx1ZTtcblx0d2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluLnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yPWZ1bmN0aW9uKGEsYixlLGwsZyl7dmFyIGM9dChudWxsKTtpZihudWxsPT09Yy5jdXJyZW50KXt2YXIgZj17aGFzVmFsdWU6ITEsdmFsdWU6bnVsbH07Yy5jdXJyZW50PWY7fWVsc2UgZj1jLmN1cnJlbnQ7Yz12KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXtpZighYyl7Yz0hMDtkPWE7YT1sKGEpO2lmKHZvaWQgMCE9PWcmJmYuaGFzVmFsdWUpe3ZhciBiPWYudmFsdWU7aWYoZyhiLGEpKXJldHVybiBrPWJ9cmV0dXJuIGs9YX1iPWs7aWYocShkLGEpKXJldHVybiBiO3ZhciBlPWwoYSk7aWYodm9pZCAwIT09ZyYmZyhiLGUpKXJldHVybiBiO2Q9YTtyZXR1cm4gaz1lfXZhciBjPSExLGQsayxtPXZvaWQgMD09PWU/bnVsbDplO3JldHVybiBbZnVuY3Rpb24oKXtyZXR1cm4gYShiKCkpfSxudWxsPT09bT92b2lkIDA6ZnVuY3Rpb24oKXtyZXR1cm4gYShtKCkpfV19LFtiLGUsbCxnXSk7dmFyIGQ9cihhLGNbMF0sY1sxXSk7XG5cdHUoZnVuY3Rpb24oKXtmLmhhc1ZhbHVlPSEwO2YudmFsdWU9ZDt9LFtkXSk7dyhkKTtyZXR1cm4gZH07XG5cdHJldHVybiB3aXRoU2VsZWN0b3JfcHJvZHVjdGlvbl9taW47XG59XG5cbnZhciB3aXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQgPSB7fTtcblxuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50O1xuXG5mdW5jdGlvbiByZXF1aXJlV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50KSByZXR1cm4gd2l0aFNlbGVjdG9yX2RldmVsb3BtZW50O1xuXHRoYXNSZXF1aXJlZFdpdGhTZWxlY3Rvcl9kZXZlbG9wbWVudCA9IDE7XG5cblx0aWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuXHQgIChmdW5jdGlvbigpIHtcblxuXHQvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5cdGlmIChcblx0ICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuXHQgICAgJ2Z1bmN0aW9uJ1xuXHQpIHtcblx0ICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcblx0fVxuXHQgICAgICAgICAgdmFyIFJlYWN0JDEgPSBSZWFjdDtcblx0dmFyIHNoaW0gPSBzaGltRXhwb3J0cztcblxuXHQvKipcblx0ICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuXHQgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcblx0ICovXG5cdGZ1bmN0aW9uIGlzKHgsIHkpIHtcblx0ICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuXHQgIDtcblx0fVxuXG5cdHZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxuXHR2YXIgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBzaGltLnVzZVN5bmNFeHRlcm5hbFN0b3JlO1xuXG5cdC8vIGZvciBDb21tb25KUyBpbnRlcm9wLlxuXG5cdHZhciB1c2VSZWYgPSBSZWFjdCQxLnVzZVJlZixcblx0ICAgIHVzZUVmZmVjdCA9IFJlYWN0JDEudXNlRWZmZWN0LFxuXHQgICAgdXNlTWVtbyA9IFJlYWN0JDEudXNlTWVtbyxcblx0ICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdCQxLnVzZURlYnVnVmFsdWU7IC8vIFNhbWUgYXMgdXNlU3luY0V4dGVybmFsU3RvcmUsIGJ1dCBzdXBwb3J0cyBzZWxlY3RvciBhbmQgaXNFcXVhbCBhcmd1bWVudHMuXG5cblx0ZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3Ioc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG5cdCAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgdGhlIHJlbmRlcmVkIHNuYXBzaG90LlxuXHQgIHZhciBpbnN0UmVmID0gdXNlUmVmKG51bGwpO1xuXHQgIHZhciBpbnN0O1xuXG5cdCAgaWYgKGluc3RSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuXHQgICAgaW5zdCA9IHtcblx0ICAgICAgaGFzVmFsdWU6IGZhbHNlLFxuXHQgICAgICB2YWx1ZTogbnVsbFxuXHQgICAgfTtcblx0ICAgIGluc3RSZWYuY3VycmVudCA9IGluc3Q7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGluc3QgPSBpbnN0UmVmLmN1cnJlbnQ7XG5cdCAgfVxuXG5cdCAgdmFyIF91c2VNZW1vID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBUcmFjayB0aGUgbWVtb2l6ZWQgc3RhdGUgdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMgdGhhdCBhcmUgbG9jYWwgdG8gdGhpc1xuXHQgICAgLy8gbWVtb2l6ZWQgaW5zdGFuY2Ugb2YgYSBnZXRTbmFwc2hvdCBmdW5jdGlvbi4gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgYVxuXHQgICAgLy8gdXNlUmVmIGhvb2ssIGJlY2F1c2UgdGhhdCBzdGF0ZSB3b3VsZCBiZSBzaGFyZWQgYWNyb3NzIGFsbCBjb25jdXJyZW50XG5cdCAgICAvLyBjb3BpZXMgb2YgdGhlIGhvb2svY29tcG9uZW50LlxuXHQgICAgdmFyIGhhc01lbW8gPSBmYWxzZTtcblx0ICAgIHZhciBtZW1vaXplZFNuYXBzaG90O1xuXHQgICAgdmFyIG1lbW9pemVkU2VsZWN0aW9uO1xuXG5cdCAgICB2YXIgbWVtb2l6ZWRTZWxlY3RvciA9IGZ1bmN0aW9uIChuZXh0U25hcHNob3QpIHtcblx0ICAgICAgaWYgKCFoYXNNZW1vKSB7XG5cdCAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgdGhlIGhvb2sgaXMgY2FsbGVkLCB0aGVyZSBpcyBubyBtZW1vaXplZCByZXN1bHQuXG5cdCAgICAgICAgaGFzTWVtbyA9IHRydWU7XG5cdCAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcblxuXHQgICAgICAgIHZhciBfbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7XG5cblx0ICAgICAgICBpZiAoaXNFcXVhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAvLyBFdmVuIGlmIHRoZSBzZWxlY3RvciBoYXMgY2hhbmdlZCwgdGhlIGN1cnJlbnRseSByZW5kZXJlZCBzZWxlY3Rpb25cblx0ICAgICAgICAgIC8vIG1heSBiZSBlcXVhbCB0byB0aGUgbmV3IHNlbGVjdGlvbi4gV2Ugc2hvdWxkIGF0dGVtcHQgdG8gcmV1c2UgdGhlXG5cdCAgICAgICAgICAvLyBjdXJyZW50IHZhbHVlIGlmIHBvc3NpYmxlLCB0byBwcmVzZXJ2ZSBkb3duc3RyZWFtIG1lbW9pemF0aW9ucy5cblx0ICAgICAgICAgIGlmIChpbnN0Lmhhc1ZhbHVlKSB7XG5cdCAgICAgICAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gaW5zdC52YWx1ZTtcblxuXHQgICAgICAgICAgICBpZiAoaXNFcXVhbChjdXJyZW50U2VsZWN0aW9uLCBfbmV4dFNlbGVjdGlvbikpIHtcblx0ICAgICAgICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cdCAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IF9uZXh0U2VsZWN0aW9uO1xuXHQgICAgICAgIHJldHVybiBfbmV4dFNlbGVjdGlvbjtcblx0ICAgICAgfSAvLyBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSB0aGUgcHJldmlvdXMgaW52b2NhdGlvbidzIHJlc3VsdC5cblxuXG5cdCAgICAgIC8vIFdlIG1heSBiZSBhYmxlIHRvIHJldXNlIHRoZSBwcmV2aW91cyBpbnZvY2F0aW9uJ3MgcmVzdWx0LlxuXHQgICAgICB2YXIgcHJldlNuYXBzaG90ID0gbWVtb2l6ZWRTbmFwc2hvdDtcblx0ICAgICAgdmFyIHByZXZTZWxlY3Rpb24gPSBtZW1vaXplZFNlbGVjdGlvbjtcblxuXHQgICAgICBpZiAob2JqZWN0SXMocHJldlNuYXBzaG90LCBuZXh0U25hcHNob3QpKSB7XG5cdCAgICAgICAgLy8gVGhlIHNuYXBzaG90IGlzIHRoZSBzYW1lIGFzIGxhc3QgdGltZS4gUmV1c2UgdGhlIHByZXZpb3VzIHNlbGVjdGlvbi5cblx0ICAgICAgICByZXR1cm4gcHJldlNlbGVjdGlvbjtcblx0ICAgICAgfSAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG5cblxuXHQgICAgICAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG5cdCAgICAgIHZhciBuZXh0U2VsZWN0aW9uID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTsgLy8gSWYgYSBjdXN0b20gaXNFcXVhbCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdXNlIHRoYXQgdG8gY2hlY2sgaWYgdGhlIGRhdGFcblx0ICAgICAgLy8gaGFzIGNoYW5nZWQuIElmIGl0IGhhc24ndCwgcmV0dXJuIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uIFRoYXQgc2lnbmFsc1xuXHQgICAgICAvLyB0byBSZWFjdCB0aGF0IHRoZSBzZWxlY3Rpb25zIGFyZSBjb25jZXB0dWFsbHkgZXF1YWwsIGFuZCB3ZSBjYW4gYmFpbFxuXHQgICAgICAvLyBvdXQgb2YgcmVuZGVyaW5nLlxuXG5cdCAgICAgIC8vIElmIGEgY3VzdG9tIGlzRXF1YWwgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZSB0aGF0IHRvIGNoZWNrIGlmIHRoZSBkYXRhXG5cdCAgICAgIC8vIGhhcyBjaGFuZ2VkLiBJZiBpdCBoYXNuJ3QsIHJldHVybiB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLiBUaGF0IHNpZ25hbHNcblx0ICAgICAgLy8gdG8gUmVhY3QgdGhhdCB0aGUgc2VsZWN0aW9ucyBhcmUgY29uY2VwdHVhbGx5IGVxdWFsLCBhbmQgd2UgY2FuIGJhaWxcblx0ICAgICAgLy8gb3V0IG9mIHJlbmRlcmluZy5cblx0ICAgICAgaWYgKGlzRXF1YWwgIT09IHVuZGVmaW5lZCAmJiBpc0VxdWFsKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pKSB7XG5cdCAgICAgICAgcmV0dXJuIHByZXZTZWxlY3Rpb247XG5cdCAgICAgIH1cblxuXHQgICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuXHQgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTZWxlY3Rpb247XG5cdCAgICAgIHJldHVybiBuZXh0U2VsZWN0aW9uO1xuXHQgICAgfTsgLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdGFudCBzbyB0aGF0IEZsb3cga25vd3MgaXQgY2FuJ3QgY2hhbmdlLlxuXG5cblx0ICAgIC8vIEFzc2lnbmluZyB0aGlzIHRvIGEgY29uc3RhbnQgc28gdGhhdCBGbG93IGtub3dzIGl0IGNhbid0IGNoYW5nZS5cblx0ICAgIHZhciBtYXliZUdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnZXRTZXJ2ZXJTbmFwc2hvdDtcblxuXHQgICAgdmFyIGdldFNuYXBzaG90V2l0aFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihnZXRTbmFwc2hvdCgpKTtcblx0ICAgIH07XG5cblx0ICAgIHZhciBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3RvciA9IG1heWJlR2V0U2VydmVyU25hcHNob3QgPT09IG51bGwgPyB1bmRlZmluZWQgOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKG1heWJlR2V0U2VydmVyU25hcHNob3QoKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFtnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciwgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3JdO1xuXHQgIH0sIFtnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsXSksXG5cdCAgICAgIGdldFNlbGVjdGlvbiA9IF91c2VNZW1vWzBdLFxuXHQgICAgICBnZXRTZXJ2ZXJTZWxlY3Rpb24gPSBfdXNlTWVtb1sxXTtcblxuXHQgIHZhciB2YWx1ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U2VsZWN0aW9uLCBnZXRTZXJ2ZXJTZWxlY3Rpb24pO1xuXHQgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG5cdCAgICBpbnN0Lmhhc1ZhbHVlID0gdHJ1ZTtcblx0ICAgIGluc3QudmFsdWUgPSB2YWx1ZTtcblx0ICB9LCBbdmFsdWVdKTtcblx0ICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcblx0ICByZXR1cm4gdmFsdWU7XG5cdH1cblxuXHR3aXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQudXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3Rvcjtcblx0ICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cblx0aWYgKFxuXHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG5cdCAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cblx0ICAgICdmdW5jdGlvbidcblx0KSB7XG5cdCAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcblx0fVxuXHQgICAgICAgIFxuXHQgIH0pKCk7XG5cdH1cblx0cmV0dXJuIHdpdGhTZWxlY3Rvcl9kZXZlbG9wbWVudDtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgd2l0aFNlbGVjdG9yLmV4cG9ydHMgPSByZXF1aXJlV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluKCk7XG59IGVsc2Uge1xuICB3aXRoU2VsZWN0b3IuZXhwb3J0cyA9IHJlcXVpcmVXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQoKTtcbn1cblxudmFyIHdpdGhTZWxlY3RvckV4cG9ydHMgPSB3aXRoU2VsZWN0b3IuZXhwb3J0cztcblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuLyoqXG4gKiBUbyBzeW5jaHJvbml6ZSB0aGUgZWRpdG9yIGluc3RhbmNlIHdpdGggdGhlIGNvbXBvbmVudCBzdGF0ZSxcbiAqIHdlIG5lZWQgdG8gY3JlYXRlIGEgc2VwYXJhdGUgaW5zdGFuY2UgdGhhdCBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJzLlxuICovXG5jbGFzcyBFZGl0b3JTdGF0ZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxFZGl0b3IpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbk51bWJlciA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uTnVtYmVyID0gMDtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBpbml0aWFsRWRpdG9yO1xuICAgICAgICB0aGlzLmxhc3RTbmFwc2hvdCA9IHsgZWRpdG9yOiBpbml0aWFsRWRpdG9yLCB0cmFuc2FjdGlvbk51bWJlcjogMCB9O1xuICAgICAgICB0aGlzLmdldFNuYXBzaG90ID0gdGhpcy5nZXRTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFNlcnZlclNuYXBzaG90ID0gdGhpcy5nZXRTZXJ2ZXJTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLndhdGNoID0gdGhpcy53YXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZSA9IHRoaXMuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0U25hcHNob3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uTnVtYmVyID09PSB0aGlzLmxhc3RUcmFuc2FjdGlvbk51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFNuYXBzaG90O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uTnVtYmVyID0gdGhpcy50cmFuc2FjdGlvbk51bWJlcjtcbiAgICAgICAgdGhpcy5sYXN0U25hcHNob3QgPSB7IGVkaXRvcjogdGhpcy5lZGl0b3IsIHRyYW5zYWN0aW9uTnVtYmVyOiB0aGlzLnRyYW5zYWN0aW9uTnVtYmVyIH07XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RTbmFwc2hvdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWx3YXlzIGRpc2FibGUgdGhlIGVkaXRvciBvbiB0aGUgc2VydmVyLXNpZGUuXG4gICAgICovXG4gICAgZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgICAgIHJldHVybiB7IGVkaXRvcjogbnVsbCwgdHJhbnNhY3Rpb25OdW1iZXI6IDAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UncyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhdGNoIHRoZSBlZGl0b3IgaW5zdGFuY2UgZm9yIGNoYW5nZXMuXG4gICAgICovXG4gICAgd2F0Y2gobmV4dEVkaXRvcikge1xuICAgICAgICB0aGlzLmVkaXRvciA9IG5leHRFZGl0b3I7XG4gICAgICAgIGlmICh0aGlzLmVkaXRvcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIHdpbGwgZm9yY2UgYSByZS1yZW5kZXIgd2hlbiB0aGUgZWRpdG9yIHN0YXRlIGNoYW5nZXMuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIHRvIHN1cHBvcnQgdGhpbmdzIGxpa2UgYGVkaXRvci5jYW4oKS50b2dnbGVCb2xkKClgIGluIGNvbXBvbmVudHMgdGhhdCBgdXNlRWRpdG9yYC5cbiAgICAgICAgICAgICAqIFRoaXMgY291bGQgYmUgbW9yZSBlZmZpY2llbnQsIGJ1dCBpdCdzIGEgZ29vZCB0cmFkZS1vZmYgZm9yIG5vdy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgZm4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbk51bWJlciArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgICAgICBjdXJyZW50RWRpdG9yLm9uKCd0cmFuc2FjdGlvbicsIGZuKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3VycmVudEVkaXRvci5vZmYoJ3RyYW5zYWN0aW9uJywgZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBob29rIGFsbG93cyB5b3UgdG8gd2F0Y2ggZm9yIGNoYW5nZXMgb24gdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAqIEl0IHdpbGwgYWxsb3cgeW91IHRvIHNlbGVjdCBhIHBhcnQgb2YgdGhlIGVkaXRvciBzdGF0ZSBhbmQgcmUtcmVuZGVyIHRoZSBjb21wb25lbnQgd2hlbiBpdCBjaGFuZ2VzLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKHsuLi5vcHRpb25zfSlcbiAqIGNvbnN0IHsgY3VycmVudFNlbGVjdGlvbiB9ID0gdXNlRWRpdG9yU3RhdGUoe1xuICogIGVkaXRvcixcbiAqICBzZWxlY3Rvcjogc25hcHNob3QgPT4gKHsgY3VycmVudFNlbGVjdGlvbjogc25hcHNob3QuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbiB9KSxcbiAqIH0pXG4gKi9cbmZ1bmN0aW9uIHVzZUVkaXRvclN0YXRlKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgW2VkaXRvclN0YXRlTWFuYWdlcl0gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgRWRpdG9yU3RhdGVNYW5hZ2VyKG9wdGlvbnMuZWRpdG9yKSk7XG4gICAgLy8gVXNpbmcgdGhlIGB1c2VTeW5jRXh0ZXJuYWxTdG9yZWAgaG9vayB0byBzeW5jIHRoZSBlZGl0b3IgaW5zdGFuY2Ugd2l0aCB0aGUgY29tcG9uZW50IHN0YXRlXG4gICAgY29uc3Qgc2VsZWN0ZWRTdGF0ZSA9IHdpdGhTZWxlY3RvckV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoZWRpdG9yU3RhdGVNYW5hZ2VyLnN1YnNjcmliZSwgZWRpdG9yU3RhdGVNYW5hZ2VyLmdldFNuYXBzaG90LCBlZGl0b3JTdGF0ZU1hbmFnZXIuZ2V0U2VydmVyU25hcHNob3QsIG9wdGlvbnMuc2VsZWN0b3IsIChfYSA9IG9wdGlvbnMuZXF1YWxpdHlGbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVlcEVxdWFsKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGVkaXRvclN0YXRlTWFuYWdlci53YXRjaChvcHRpb25zLmVkaXRvcik7XG4gICAgfSwgW29wdGlvbnMuZWRpdG9yLCBlZGl0b3JTdGF0ZU1hbmFnZXJdKTtcbiAgICB1c2VEZWJ1Z1ZhbHVlKHNlbGVjdGVkU3RhdGUpO1xuICAgIHJldHVybiBzZWxlY3RlZFN0YXRlO1xufVxuXG5jb25zdCBpc0RldiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG5jb25zdCBpc1NTUiA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuY29uc3QgaXNOZXh0ID0gaXNTU1IgfHwgQm9vbGVhbih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmV4dCk7XG4vKipcbiAqIFRoaXMgY2xhc3MgaGFuZGxlcyB0aGUgY3JlYXRpb24sIGRlc3RydWN0aW9uLCBhbmQgcmUtY3JlYXRpb24gb2YgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAqL1xuY2xhc3MgRWRpdG9ySW5zdGFuY2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkaXRvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3Vic2NyaXB0aW9ucyB0byBub3RpZnkgd2hlbiB0aGUgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAqIGhhcyBiZWVuIGNyZWF0ZWQgb3IgZGVzdHJveWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgZWRpdG9yIGhhcyBiZWVuIG1vdW50ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQ29tcG9uZW50TW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vc3QgcmVjZW50IGRlcGVuZGVuY2llcyBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldmlvdXNEZXBzID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmlxdWUgaW5zdGFuY2UgSUQuIFRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgZWRpdG9yIGluc3RhbmNlLiBBbmQgd2lsbCBiZSByZS1nZW5lcmF0ZWQgZm9yIGVhY2ggbmV3IGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnN0YW5jZUlkID0gJyc7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5zZXRFZGl0b3IodGhpcy5nZXRJbml0aWFsRWRpdG9yKCkpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSgpO1xuICAgICAgICB0aGlzLmdldEVkaXRvciA9IHRoaXMuZ2V0RWRpdG9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0U2VydmVyU25hcHNob3QgPSB0aGlzLmdldFNlcnZlclNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlID0gdGhpcy5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoRWRpdG9ySW5zdGFuY2UgPSB0aGlzLnJlZnJlc2hFZGl0b3JJbnN0YW5jZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSA9IHRoaXMuc2NoZWR1bGVEZXN0cm95LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZW5kZXIgPSB0aGlzLm9uUmVuZGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY3JlYXRlRWRpdG9yID0gdGhpcy5jcmVhdGVFZGl0b3IuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgc2V0RWRpdG9yKGVkaXRvcikge1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5pbnN0YW5jZUlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgOSk7XG4gICAgICAgIC8vIE5vdGlmeSBhbGwgc3Vic2NyaWJlcnMgdGhhdCB0aGUgZWRpdG9yIGluc3RhbmNlIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goY2IgPT4gY2IoKSk7XG4gICAgfVxuICAgIGdldEluaXRpYWxFZGl0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VycmVudC5pbW1lZGlhdGVseVJlbmRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaXNTU1IgfHwgaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLCB3ZSBzaG91bGQgdGhyb3cgYW4gZXJyb3IgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChpc0Rldikge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGhyb3cgYW4gZXJyb3IgaW4gZGV2ZWxvcG1lbnQsIHRvIG1ha2Ugc3VyZSB0aGUgZGV2ZWxvcGVyIGlzIGF3YXJlIHRoYXQgdGlwdGFwIGNhbm5vdCBiZSBTU1InZFxuICAgICAgICAgICAgICAgICAgICAgKiBhbmQgdGhhdCB0aGV5IG5lZWQgdG8gc2V0IGBpbW1lZGlhdGVseVJlbmRlcmAgdG8gYGZhbHNlYCB0byBhdm9pZCBoeWRyYXRpb24gbWlzbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGlwdGFwIEVycm9yOiBTU1IgaGFzIGJlZW4gZGV0ZWN0ZWQsIHBsZWFzZSBzZXQgYGltbWVkaWF0ZWx5UmVuZGVyYCBleHBsaWNpdGx5IHRvIGBmYWxzZWAgdG8gYXZvaWQgaHlkcmF0aW9uIG1pc21hdGNoZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJlc3QgZmFpdGggZWZmb3J0IGluIHByb2R1Y3Rpb24sIHJ1biB0aGUgY29kZSBpbiB0aGUgbGVnYWN5IG1vZGUgdG8gYXZvaWQgaHlkcmF0aW9uIG1pc21hdGNoZXMgYW5kIGVycm9ycyBpbiBwcm9kdWN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGltbWVkaWF0ZWx5IHJlbmRlcmluZyB3aGVuIGNsaWVudC1zaWRlIHJlbmRlcmluZ1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRWRpdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdXJyZW50LmltbWVkaWF0ZWx5UmVuZGVyICYmIGlzU1NSICYmIGlzRGV2KSB7XG4gICAgICAgICAgICAvLyBXYXJuIGluIGRldmVsb3BtZW50LCB0byBtYWtlIHN1cmUgdGhlIGRldmVsb3BlciBpcyBhd2FyZSB0aGF0IHRpcHRhcCBjYW5ub3QgYmUgU1NSJ2QsIHNldCBgaW1tZWRpYXRlbHlSZW5kZXJgIHRvIGBmYWxzZWAgdG8gYXZvaWQgaHlkcmF0aW9uIG1pc21hdGNoZXMuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpcHRhcCBFcnJvcjogU1NSIGhhcyBiZWVuIGRldGVjdGVkLCBhbmQgYGltbWVkaWF0ZWx5UmVuZGVyYCBoYXMgYmVlbiBzZXQgdG8gYHRydWVgIHRoaXMgaXMgYW4gdW5zdXBwb3J0ZWQgY29uZmlndXJhdGlvbiB0aGF0IG1heSByZXN1bHQgaW4gZXJyb3JzLCBleHBsaWNpdGx5IHNldCBgaW1tZWRpYXRlbHlSZW5kZXJgIHRvIGBmYWxzZWAgdG8gYXZvaWQgaHlkcmF0aW9uIG1pc21hdGNoZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdXJyZW50LmltbWVkaWF0ZWx5UmVuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFZGl0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGVkaXRvciBpbnN0YW5jZS4gQW5kIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgY3JlYXRlRWRpdG9yKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zVG9BcHBseSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5jdXJyZW50LFxuICAgICAgICAgICAgLy8gQWx3YXlzIGNhbGwgdGhlIG1vc3QgcmVjZW50IHZlcnNpb24gb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIG9uQmVmb3JlQ3JlYXRlOiAoLi4uYXJncykgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uQmVmb3JlQ3JlYXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvbkJsdXI6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25CbHVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvbkNyZWF0ZTogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkNyZWF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25EZXN0cm95OiAoLi4uYXJncykgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uRGVzdHJveSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25Gb2N1czogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkZvY3VzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvblNlbGVjdGlvblVwZGF0ZTogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblNlbGVjdGlvblVwZGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25UcmFuc2FjdGlvbjogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvblVwZGF0ZTogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblVwZGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25Db250ZW50RXJyb3I6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25Db250ZW50RXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTsgfSxcbiAgICAgICAgICAgIG9uRHJvcDogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkRyb3ApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTsgfSxcbiAgICAgICAgICAgIG9uUGFzdGU6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25QYXN0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBuZXcgRWRpdG9yKG9wdGlvbnNUb0FwcGx5KTtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCBiZSByZW1vdmVkIHdoZW4gdGhlIGVkaXRvciBpcyBkZXN0cm95ZWRcbiAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXRFZGl0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWx3YXlzIGRpc2FibGUgdGhlIGVkaXRvciBvbiB0aGUgc2VydmVyLXNpZGUuXG4gICAgICovXG4gICAgZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIGVkaXRvciBpbnN0YW5jZSdzIGNoYW5nZXMuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKG9uU3RvcmVDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChvblN0b3JlQ2hhbmdlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUob25TdG9yZUNoYW5nZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlT3B0aW9ucyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhKS5ldmVyeShrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKFsnb25DcmVhdGUnLCAnb25CZWZvcmVDcmVhdGUnLCAnb25EZXN0cm95JywgJ29uVXBkYXRlJywgJ29uVHJhbnNhY3Rpb24nLCAnb25Gb2N1cycsICdvbkJsdXInLCAnb25TZWxlY3Rpb25VcGRhdGUnLCAnb25Db250ZW50RXJyb3InLCAnb25Ecm9wJywgJ29uUGFzdGUnXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBjb21wYXJlIGNhbGxiYWNrcywgdGhleSBhcmUgYWx3YXlzIGRpZmZlcmVudCBhbmQgb25seSByZWdpc3RlcmVkIG9uY2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIG9mdGVuIGVuY291cmFnZSBwdXR0aW5nIGV4dGVuc2lvbnMgaW5saW5lZCBpbiB0aGUgb3B0aW9ucyBvYmplY3QsIHNvIHdlIHdpbGwgZG8gYSBzbGlnaHRseSBkZWVwZXIgY29tcGFyaXNvbiBoZXJlXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnZXh0ZW5zaW9ucycgJiYgYS5leHRlbnNpb25zICYmIGIuZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChhLmV4dGVuc2lvbnMubGVuZ3RoICE9PSBiLmV4dGVuc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuZXh0ZW5zaW9ucy5ldmVyeSgoZXh0ZW5zaW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb24gIT09ICgoX2EgPSBiLmV4dGVuc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYVtrZXldICE9PSBiW2tleV0pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhbnkgb2YgdGhlIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkLCB3ZSBzaG91bGQgdXBkYXRlIHRoZSBlZGl0b3Igb3B0aW9uc1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT24gZWFjaCByZW5kZXIsIHdlIHdpbGwgY3JlYXRlLCB1cGRhdGUsIG9yIGRlc3Ryb3kgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gZGVwcyBUaGUgZGVwZW5kZW5jaWVzIHRvIHdhdGNoIGZvciBjaGFuZ2VzXG4gICAgICogQHJldHVybnMgQSBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgICovXG4gICAgb25SZW5kZXIoZGVwcykge1xuICAgICAgICAvLyBUaGUgcmV0dXJuZWQgY2FsbGJhY2sgd2lsbCBydW4gb24gZWFjaCByZW5kZXJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNDb21wb25lbnRNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIENsZWFudXAgYW55IHNjaGVkdWxlZCBkZXN0cnVjdGlvbnMsIHNpbmNlIHdlIGFyZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zY2hlZHVsZWREZXN0cnVjdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdG9yICYmICF0aGlzLmVkaXRvci5pc0Rlc3Ryb3llZCAmJiBkZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBlZGl0b3IgZG9lcyBleGlzdCAmIGRlcHMgYXJlIGVtcHR5LCB3ZSBkb24ndCBuZWVkIHRvIHJlLWluaXRpYWxpemUgdGhlIGVkaXRvciBnZW5lcmFsbHlcbiAgICAgICAgICAgICAgICBpZiAoIUVkaXRvckluc3RhbmNlTWFuYWdlci5jb21wYXJlT3B0aW9ucyh0aGlzLm9wdGlvbnMuY3VycmVudCwgdGhpcy5lZGl0b3Iub3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0LCB0aGUgb3B0aW9ucyBhcmUgZGlmZmVyZW50LCBzbyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgZWRpdG9yIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RpbGwsIHRoaXMgaXMgZmFzdGVyIHRoYW4gcmUtY3JlYXRpbmcgdGhlIGVkaXRvclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IHRoaXMuZWRpdG9yLmlzRWRpdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGVkaXRvcjpcbiAgICAgICAgICAgICAgICAvLyAtIGRvZXMgbm90IHlldCBleGlzdFxuICAgICAgICAgICAgICAgIC8vIC0gaXMgZGVzdHJveWVkXG4gICAgICAgICAgICAgICAgLy8gLSB0aGUgZGVwcyBhcnJheSBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBkZXN0cm95IHRoZSBlZGl0b3IgaW5zdGFuY2UgYW5kIHJlLWluaXRpYWxpemUgaXRcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hFZGl0b3JJbnN0YW5jZShkZXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0NvbXBvbmVudE1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjcmVhdGUgdGhlIGVkaXRvciBpbnN0YW5jZSBpZiB0aGUgZGVwZW5kZW5jaWVzIGhhdmUgY2hhbmdlZC5cbiAgICAgKi9cbiAgICByZWZyZXNoRWRpdG9ySW5zdGFuY2UoZGVwcykge1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IgJiYgIXRoaXMuZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAvLyBFZGl0b3IgaW5zdGFuY2UgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzRGVwcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGxhc3REZXBzIGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQsIHJldXNlIHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNEZXBzID0gZGVwcztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXBzQXJlRXF1YWwgPSB0aGlzLnByZXZpb3VzRGVwcy5sZW5ndGggPT09IGRlcHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5wcmV2aW91c0RlcHMuZXZlcnkoKGRlcCwgaW5kZXgpID0+IGRlcCA9PT0gZGVwc1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKGRlcHNBcmVFcXVhbCkge1xuICAgICAgICAgICAgICAgIC8vIGRlcHMgZXhpc3QgYW5kIGFyZSBlcXVhbCwgbm8gbmVlZCB0byByZWNyZWF0ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3IgJiYgIXRoaXMuZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAvLyBEZXN0cm95IHRoZSBlZGl0b3IgaW5zdGFuY2UgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRFZGl0b3IodGhpcy5jcmVhdGVFZGl0b3IoKSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFzdERlcHMgdG8gdGhlIGN1cnJlbnQgZGVwc1xuICAgICAgICB0aGlzLnByZXZpb3VzRGVwcyA9IGRlcHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlIHRoZSBkZXN0cnVjdGlvbiBvZiB0aGUgZWRpdG9yIGluc3RhbmNlLlxuICAgICAqIFRoaXMgd2lsbCBvbmx5IGRlc3Ryb3kgdGhlIGVkaXRvciBpZiBpdCB3YXMgbm90IG1vdW50ZWQgb24gdGhlIG5leHQgdGljay5cbiAgICAgKiBUaGlzIGlzIHRvIGF2b2lkIGRlc3Ryb3lpbmcgdGhlIGVkaXRvciBpbnN0YW5jZSB3aGVuIGl0J3MgYWN0dWFsbHkgc3RpbGwgbW91bnRlZC5cbiAgICAgKi9cbiAgICBzY2hlZHVsZURlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbnN0YW5jZUlkID0gdGhpcy5pbnN0YW5jZUlkO1xuICAgICAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIC8vIFdhaXQgdHdvIHRpY2tzIHRvIHNlZSBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWRcbiAgICAgICAgdGhpcy5zY2hlZHVsZWREZXN0cnVjdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcG9uZW50TW91bnRlZCAmJiB0aGlzLmluc3RhbmNlSWQgPT09IGN1cnJlbnRJbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc3RpbGwgbW91bnRlZCBvbiB0aGUgZm9sbG93aW5nIHRpY2ssIHdpdGggdGhlIHNhbWUgaW5zdGFuY2VJZCwgZG8gbm90IGRlc3Ryb3kgdGhlIGVkaXRvclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgcmUtYXBwbHkgb3B0aW9ucyBhcyB0aGV5IG1pZ2h0IGhhdmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWRpdG9yLnNldE9wdGlvbnModGhpcy5vcHRpb25zLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudEVkaXRvciAmJiAhY3VycmVudEVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRFZGl0b3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlSWQgPT09IGN1cnJlbnRJbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RWRpdG9yKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHRoZSBlZmZlY3QgdG8gcnVuIGFnYWluIGJldHdlZW4gdGlja3NcbiAgICAgICAgICAgIC8vIHdoaWNoIG1heSBzYXZlIHVzIGZyb20gaGF2aW5nIHRvIHJlLWNyZWF0ZSB0aGUgZWRpdG9yXG4gICAgICAgIH0sIDEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVzZUVkaXRvcihvcHRpb25zID0ge30sIGRlcHMgPSBbXSkge1xuICAgIGNvbnN0IG1vc3RSZWNlbnRPcHRpb25zID0gdXNlUmVmKG9wdGlvbnMpO1xuICAgIG1vc3RSZWNlbnRPcHRpb25zLmN1cnJlbnQgPSBvcHRpb25zO1xuICAgIGNvbnN0IFtpbnN0YW5jZU1hbmFnZXJdID0gdXNlU3RhdGUoKCkgPT4gbmV3IEVkaXRvckluc3RhbmNlTWFuYWdlcihtb3N0UmVjZW50T3B0aW9ucykpO1xuICAgIGNvbnN0IGVkaXRvciA9IHNoaW1FeHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlKGluc3RhbmNlTWFuYWdlci5zdWJzY3JpYmUsIGluc3RhbmNlTWFuYWdlci5nZXRFZGl0b3IsIGluc3RhbmNlTWFuYWdlci5nZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgdXNlRGVidWdWYWx1ZShlZGl0b3IpO1xuICAgIC8vIFRoaXMgZWZmZWN0IHdpbGwgaGFuZGxlIGNyZWF0aW5nL3VwZGF0aW5nIHRoZSBlZGl0b3IgaW5zdGFuY2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgdXNlRWZmZWN0KGluc3RhbmNlTWFuYWdlci5vblJlbmRlcihkZXBzKSk7XG4gICAgLy8gVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmUtcmVuZGVyIG9uIGVhY2ggdHJhbnNhY3Rpb25cbiAgICAvLyBUaGlzIGlzIGxlZ2FjeSBiZWhhdmlvciB0aGF0IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnNcbiAgICB1c2VFZGl0b3JTdGF0ZSh7XG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgc2VsZWN0b3I6ICh7IHRyYW5zYWN0aW9uTnVtYmVyIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZFJlcmVuZGVyT25UcmFuc2FjdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcHJldmVudCB0aGUgZWRpdG9yIGZyb20gcmUtcmVuZGVyaW5nIG9uIGVhY2ggdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBhdm9pZCByZS1yZW5kZXJpbmcgb24gdGhlIGZpcnN0IHRyYW5zYWN0aW9uIHdoZW4gYGltbWVkaWF0ZWx5UmVuZGVyYCBpcyBzZXQgdG8gYHRydWVgXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGVseVJlbmRlciAmJiB0cmFuc2FjdGlvbk51bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uTnVtYmVyICsgMTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gZWRpdG9yO1xufVxuXG5jb25zdCBFZGl0b3JDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gICAgZWRpdG9yOiBudWxsLFxufSk7XG5jb25zdCBFZGl0b3JDb25zdW1lciA9IEVkaXRvckNvbnRleHQuQ29uc3VtZXI7XG4vKipcbiAqIEEgaG9vayB0byBnZXQgdGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlLlxuICovXG5jb25zdCB1c2VDdXJyZW50RWRpdG9yID0gKCkgPT4gdXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcbi8qKlxuICogVGhpcyBpcyB0aGUgcHJvdmlkZXIgY29tcG9uZW50IGZvciB0aGUgZWRpdG9yLlxuICogSXQgYWxsb3dzIHRoZSBlZGl0b3IgdG8gYmUgYWNjZXNzaWJsZSBhY3Jvc3MgdGhlIGVudGlyZSBjb21wb25lbnQgdHJlZVxuICogd2l0aCBgdXNlQ3VycmVudEVkaXRvcmAuXG4gKi9cbmZ1bmN0aW9uIEVkaXRvclByb3ZpZGVyKHsgY2hpbGRyZW4sIHNsb3RBZnRlciwgc2xvdEJlZm9yZSwgZWRpdG9yQ29udGFpbmVyUHJvcHMgPSB7fSwgLi4uZWRpdG9yT3B0aW9ucyB9KSB7XG4gICAgY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKGVkaXRvck9wdGlvbnMpO1xuICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRpdG9yQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyBlZGl0b3IgfSB9LFxuICAgICAgICBzbG90QmVmb3JlLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvckNvbnN1bWVyLCBudWxsLCAoeyBlZGl0b3I6IGN1cnJlbnRFZGl0b3IgfSkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRpdG9yQ29udGVudCwgeyBlZGl0b3I6IGN1cnJlbnRFZGl0b3IsIC4uLmVkaXRvckNvbnRhaW5lclByb3BzIH0pKSksXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBzbG90QWZ0ZXIpKTtcbn1cblxuY29uc3QgQnViYmxlTWVudSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IFtlbGVtZW50LCBzZXRFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHsgZWRpdG9yOiBjdXJyZW50RWRpdG9yIH0gPSB1c2VDdXJyZW50RWRpdG9yKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfYSA9IHByb3BzLmVkaXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRGVzdHJveWVkKSB8fCAoY3VycmVudEVkaXRvciA9PT0gbnVsbCB8fCBjdXJyZW50RWRpdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RWRpdG9yLmlzRGVzdHJveWVkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGx1Z2luS2V5ID0gJ2J1YmJsZU1lbnUnLCBlZGl0b3IsIHRpcHB5T3B0aW9ucyA9IHt9LCB1cGRhdGVEZWxheSwgc2hvdWxkU2hvdyA9IG51bGwsIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgbWVudUVkaXRvciA9IGVkaXRvciB8fCBjdXJyZW50RWRpdG9yO1xuICAgICAgICBpZiAoIW1lbnVFZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQnViYmxlTWVudSBjb21wb25lbnQgaXMgbm90IHJlbmRlcmVkIGluc2lkZSBvZiBhbiBlZGl0b3IgY29tcG9uZW50IG9yIGRvZXMgbm90IGhhdmUgZWRpdG9yIHByb3AuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGx1Z2luID0gQnViYmxlTWVudVBsdWdpbih7XG4gICAgICAgICAgICB1cGRhdGVEZWxheSxcbiAgICAgICAgICAgIGVkaXRvcjogbWVudUVkaXRvcixcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBwbHVnaW5LZXksXG4gICAgICAgICAgICBzaG91bGRTaG93LFxuICAgICAgICAgICAgdGlwcHlPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgbWVudUVkaXRvci5yZWdpc3RlclBsdWdpbihwbHVnaW4pO1xuICAgICAgICByZXR1cm4gKCkgPT4geyBtZW51RWRpdG9yLnVucmVnaXN0ZXJQbHVnaW4ocGx1Z2luS2V5KTsgfTtcbiAgICB9LCBbcHJvcHMuZWRpdG9yLCBjdXJyZW50RWRpdG9yLCBlbGVtZW50XSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBzZXRFbGVtZW50LCBjbGFzc05hbWU6IHByb3BzLmNsYXNzTmFtZSwgc3R5bGU6IHsgdmlzaWJpbGl0eTogJ2hpZGRlbicgfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xufTtcblxuY29uc3QgRmxvYXRpbmdNZW51ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgW2VsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgeyBlZGl0b3I6IGN1cnJlbnRFZGl0b3IgfSA9IHVzZUN1cnJlbnRFZGl0b3IoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gcHJvcHMuZWRpdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEZXN0cm95ZWQpIHx8IChjdXJyZW50RWRpdG9yID09PSBudWxsIHx8IGN1cnJlbnRFZGl0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRFZGl0b3IuaXNEZXN0cm95ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwbHVnaW5LZXkgPSAnZmxvYXRpbmdNZW51JywgZWRpdG9yLCB0aXBweU9wdGlvbnMgPSB7fSwgc2hvdWxkU2hvdyA9IG51bGwsIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgbWVudUVkaXRvciA9IGVkaXRvciB8fCBjdXJyZW50RWRpdG9yO1xuICAgICAgICBpZiAoIW1lbnVFZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmxvYXRpbmdNZW51IGNvbXBvbmVudCBpcyBub3QgcmVuZGVyZWQgaW5zaWRlIG9mIGFuIGVkaXRvciBjb21wb25lbnQgb3IgZG9lcyBub3QgaGF2ZSBlZGl0b3IgcHJvcC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbHVnaW4gPSBGbG9hdGluZ01lbnVQbHVnaW4oe1xuICAgICAgICAgICAgcGx1Z2luS2V5LFxuICAgICAgICAgICAgZWRpdG9yOiBtZW51RWRpdG9yLFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIHRpcHB5T3B0aW9ucyxcbiAgICAgICAgICAgIHNob3VsZFNob3csXG4gICAgICAgIH0pO1xuICAgICAgICBtZW51RWRpdG9yLnJlZ2lzdGVyUGx1Z2luKHBsdWdpbik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7IG1lbnVFZGl0b3IudW5yZWdpc3RlclBsdWdpbihwbHVnaW5LZXkpOyB9O1xuICAgIH0sIFtcbiAgICAgICAgcHJvcHMuZWRpdG9yLFxuICAgICAgICBjdXJyZW50RWRpdG9yLFxuICAgICAgICBlbGVtZW50LFxuICAgIF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogc2V0RWxlbWVudCwgY2xhc3NOYW1lOiBwcm9wcy5jbGFzc05hbWUsIHN0eWxlOiB7IHZpc2liaWxpdHk6ICdoaWRkZW4nIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn07XG5cbmNvbnN0IFJlYWN0Tm9kZVZpZXdDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gICAgb25EcmFnU3RhcnQ6IHVuZGVmaW5lZCxcbn0pO1xuY29uc3QgdXNlUmVhY3ROb2RlVmlldyA9ICgpID0+IHVzZUNvbnRleHQoUmVhY3ROb2RlVmlld0NvbnRleHQpO1xuXG5jb25zdCBOb2RlVmlld0NvbnRlbnQgPSBwcm9wcyA9PiB7XG4gICAgY29uc3QgVGFnID0gcHJvcHMuYXMgfHwgJ2Rpdic7XG4gICAgY29uc3QgeyBub2RlVmlld0NvbnRlbnRSZWYgfSA9IHVzZVJlYWN0Tm9kZVZpZXcoKTtcbiAgICByZXR1cm4gKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRhZywgeyAuLi5wcm9wcywgcmVmOiBub2RlVmlld0NvbnRlbnRSZWYsIFwiZGF0YS1ub2RlLXZpZXctY29udGVudFwiOiBcIlwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2hpdGVTcGFjZTogJ3ByZS13cmFwJyxcbiAgICAgICAgICAgIC4uLnByb3BzLnN0eWxlLFxuICAgICAgICB9IH0pKTtcbn07XG5cbmNvbnN0IE5vZGVWaWV3V3JhcHBlciA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCB7IG9uRHJhZ1N0YXJ0IH0gPSB1c2VSZWFjdE5vZGVWaWV3KCk7XG4gICAgY29uc3QgVGFnID0gcHJvcHMuYXMgfHwgJ2Rpdic7XG4gICAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIHsgLi4ucHJvcHMsIHJlZjogcmVmLCBcImRhdGEtbm9kZS12aWV3LXdyYXBwZXJcIjogXCJcIiwgb25EcmFnU3RhcnQ6IG9uRHJhZ1N0YXJ0LCBzdHlsZToge1xuICAgICAgICAgICAgd2hpdGVTcGFjZTogJ25vcm1hbCcsXG4gICAgICAgICAgICAuLi5wcm9wcy5zdHlsZSxcbiAgICAgICAgfSB9KSk7XG59KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGNvbXBvbmVudCBpcyBhIGNsYXNzIGNvbXBvbmVudC5cbiAqIEBwYXJhbSBDb21wb25lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KENvbXBvbmVudCkge1xuICAgIHJldHVybiAhISh0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICYmIENvbXBvbmVudC5wcm90b3R5cGVcbiAgICAgICAgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBjb21wb25lbnQgaXMgYSBmb3J3YXJkIHJlZiBjb21wb25lbnQuXG4gKiBAcGFyYW0gQ29tcG9uZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGb3J3YXJkUmVmQ29tcG9uZW50KENvbXBvbmVudCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gISEodHlwZW9mIENvbXBvbmVudCA9PT0gJ29iamVjdCdcbiAgICAgICAgJiYgKChfYSA9IENvbXBvbmVudC4kJHR5cGVvZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkpID09PSAnU3ltYm9sKHJlYWN0LmZvcndhcmRfcmVmKScpO1xufVxuLyoqXG4gKiBUaGUgUmVhY3RSZW5kZXJlciBjbGFzcy4gSXQncyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgaW5zaWRlIHRoZSBlZGl0b3IuXG4gKiBAZXhhbXBsZVxuICogbmV3IFJlYWN0UmVuZGVyZXIoTXlDb21wb25lbnQsIHtcbiAqICAgZWRpdG9yLFxuICogICBwcm9wczoge1xuICogICAgIGZvbzogJ2JhcicsXG4gKiAgIH0sXG4gKiAgIGFzOiAnc3BhbicsXG4gKiB9KVxuKi9cbmNsYXNzIFJlYWN0UmVuZGVyZXIge1xuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGNyZWF0ZXMgZWxlbWVudCBhbmQgcmVuZGVycyB0aGUgcHJvdmlkZWQgUmVhY3QgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgeyBlZGl0b3IsIHByb3BzID0ge30sIGFzID0gJ2RpdicsIGNsYXNzTmFtZSA9ICcnLCB9KSB7XG4gICAgICAgIHRoaXMucmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5pZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4RkZGRkZGRkYpLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGFzKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3JlYWN0LXJlbmRlcmVyJyk7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZS5zcGxpdCgnICcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3IuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgLy8gT24gZmlyc3QgcmVuZGVyLCB3ZSBuZWVkIHRvIGZsdXNoIHRoZSByZW5kZXIgc3luY2hyb25vdXNseVxuICAgICAgICAgICAgLy8gUmVuZGVycyBhZnRlcndhcmRzIGNhbiBiZSBhc3luYywgYnV0IHRoaXMgZml4ZXMgYSBjdXJzb3IgcG9zaXRpb25pbmcgaXNzdWVcbiAgICAgICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIGlmIChpc0NsYXNzQ29tcG9uZW50KENvbXBvbmVudCkgfHwgaXNGb3J3YXJkUmVmQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSB0aGUgcmVmIHdvcmtcbiAgICAgICAgICAgIHByb3BzLnJlZiA9IChyZWYpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFjdEVsZW1lbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgeyAuLi5wcm9wcyB9KTtcbiAgICAgICAgKF9hID0gZWRpdG9yID09PSBudWxsIHx8IGVkaXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRSZW5kZXJlcih0aGlzLmlkLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmUtcmVuZGVycyB0aGUgUmVhY3QgY29tcG9uZW50IHdpdGggbmV3IHByb3BzLlxuICAgICAqL1xuICAgIHVwZGF0ZVByb3BzKHByb3BzID0ge30pIHtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMucHJvcHMsXG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIChfYSA9IGVkaXRvciA9PT0gbnVsbCB8fCBlZGl0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVkaXRvci5jb250ZW50Q29tcG9uZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlUmVuZGVyZXIodGhpcy5pZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudCB0aGF0IGhvbGRzIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAgICovXG4gICAgdXBkYXRlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIFJlYWN0Tm9kZVZpZXcgZXh0ZW5kcyBOb2RlVmlldyB7XG4gICAgLyoqXG4gICAgICogU2V0dXAgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICAgKiBDYWxsZWQgb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICovXG4gICAgbW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgIG5vZGU6IHRoaXMubm9kZSxcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiB0aGlzLmRlY29yYXRpb25zLFxuICAgICAgICAgICAgaW5uZXJEZWNvcmF0aW9uczogdGhpcy5pbm5lckRlY29yYXRpb25zLFxuICAgICAgICAgICAgdmlldzogdGhpcy52aWV3LFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgZXh0ZW5zaW9uOiB0aGlzLmV4dGVuc2lvbixcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB0aGlzLkhUTUxBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgZ2V0UG9zOiAoKSA9PiB0aGlzLmdldFBvcygpLFxuICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlczogKGF0dHJpYnV0ZXMgPSB7fSkgPT4gdGhpcy51cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgZGVsZXRlTm9kZTogKCkgPT4gdGhpcy5kZWxldGVOb2RlKCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5jb21wb25lbnQuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcGl0YWxpemVGaXJzdENoYXIgPSAoc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuZGlzcGxheU5hbWUgPSBjYXBpdGFsaXplRmlyc3RDaGFyKHRoaXMuZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRHJhZ1N0YXJ0ID0gdGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBub2RlVmlld0NvbnRlbnRSZWYgPSBlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHRoaXMuY29udGVudERPTUVsZW1lbnQgJiYgZWxlbWVudC5maXJzdENoaWxkICE9PSB0aGlzLmNvbnRlbnRET01FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET01FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHsgb25EcmFnU3RhcnQsIG5vZGVWaWV3Q29udGVudFJlZiB9O1xuICAgICAgICBjb25zdCBDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgLy8gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIG1lbW9pemUgdGhlIHByb3ZpZGVyIGNvbXBvbmVudFxuICAgICAgICAvLyBBbmQgYWxsIG9mIHRoZSB0aGluZ3MgaXQgcmVxdWlyZXMgYXJlIGRlY2xhcmVkIG91dHNpZGUgb2YgdGhlIGNvbXBvbmVudCwgc28gaXQgZG9lc24ndCBuZWVkIHRvIHJlLXJlbmRlclxuICAgICAgICBjb25zdCBSZWFjdE5vZGVWaWV3UHJvdmlkZXIgPSBSZWFjdC5tZW1vKGNvbXBvbmVudFByb3BzID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdE5vZGVWaWV3Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgY29tcG9uZW50UHJvcHMpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBSZWFjdE5vZGVWaWV3UHJvdmlkZXIuZGlzcGxheU5hbWUgPSAnUmVhY3ROb2RlVmlldyc7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNMZWFmKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnMuY29udGVudERPTUVsZW1lbnRUYWcpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMub3B0aW9ucy5jb250ZW50RE9NRWxlbWVudFRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm5vZGUuaXNJbmxpbmUgPyAnc3BhbicgOiAnZGl2Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQuZGF0YXNldC5ub2RlVmlld0NvbnRlbnRSZWFjdCA9ICcnO1xuICAgICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uIHRoZSB3aGl0ZVNwYWNlIHByb3AgaXMgbm90IGluaGVyaXRlZCBwcm9wZXJseSBpbiBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgICAgLy8gV2l0aCB0aGlzIGZpeCBpdCBzZWVtcyB0byB3b3JrIGZpbmVcbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xMTk3XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSAnaW5oZXJpdCc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFzID0gdGhpcy5ub2RlLmlzSW5saW5lID8gJ3NwYW4nIDogJ2Rpdic7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXMpIHtcbiAgICAgICAgICAgIGFzID0gdGhpcy5vcHRpb25zLmFzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lID0gJycgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUgPSB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlYWN0UmVuZGVyZXIoUmVhY3ROb2RlVmlld1Byb3ZpZGVyLCB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogYG5vZGUtJHt0aGlzLm5vZGUudHlwZS5uYW1lfSAke2NsYXNzTmFtZX1gLnRyaW0oKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdzZWxlY3Rpb25VcGRhdGUnLCB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudEF0dHJpYnV0ZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBET00gZWxlbWVudC5cbiAgICAgKiBUaGlzIGlzIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRpc3BsYXkgdGhlIG5vZGUgdmlldy5cbiAgICAgKi9cbiAgICBnZXQgZG9tKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLmVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgICAgICAgICYmICEoKF9hID0gdGhpcy5yZW5kZXJlci5lbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzQXR0cmlidXRlKCdkYXRhLW5vZGUtdmlldy13cmFwcGVyJykpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUGxlYXNlIHVzZSB0aGUgTm9kZVZpZXdXcmFwcGVyIGNvbXBvbmVudCBmb3IgeW91ciBub2RlIHZpZXcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjb250ZW50IERPTSBlbGVtZW50LlxuICAgICAqIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGlzcGxheSB0aGUgcmljaC10ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgZ2V0IGNvbnRlbnRET00oKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNMZWFmKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT24gZWRpdG9yIHNlbGVjdGlvbiB1cGRhdGUsIGNoZWNrIGlmIHRoZSBub2RlIGlzIHNlbGVjdGVkLlxuICAgICAqIElmIGl0IGlzLCBjYWxsIGBzZWxlY3ROb2RlYCwgb3RoZXJ3aXNlIGNhbGwgYGRlc2VsZWN0Tm9kZWAuXG4gICAgICovXG4gICAgaGFuZGxlU2VsZWN0aW9uVXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgICAgIGlmICh0eXBlb2YgcG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tIDw9IHBvcyAmJiB0byA+PSBwb3MgKyB0aGlzLm5vZGUubm9kZVNpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLnByb3BzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3ROb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVuZGVyZXIucHJvcHMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0Tm9kZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uIHVwZGF0ZSwgdXBkYXRlIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAgICogVG8gcHJldmVudCB1bm5lY2Vzc2FyeSB1cGRhdGVzLCB0aGUgYHVwZGF0ZWAgb3B0aW9uIGNhbiBiZSB1c2VkLlxuICAgICAqL1xuICAgIHVwZGF0ZShub2RlLCBkZWNvcmF0aW9ucywgaW5uZXJEZWNvcmF0aW9ucykge1xuICAgICAgICBjb25zdCByZXJlbmRlckNvbXBvbmVudCA9IChwcm9wcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hdHRycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gdGhpcy5ub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy51cGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZE5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgICAgICBjb25zdCBvbGREZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBvbGRJbm5lckRlY29yYXRpb25zID0gdGhpcy5pbm5lckRlY29yYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucztcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEZWNvcmF0aW9ucyA9IGlubmVyRGVjb3JhdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgb2xkTm9kZSxcbiAgICAgICAgICAgICAgICBvbGREZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgICBuZXdOb2RlOiBub2RlLFxuICAgICAgICAgICAgICAgIG5ld0RlY29yYXRpb25zOiBkZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgICBvbGRJbm5lckRlY29yYXRpb25zLFxuICAgICAgICAgICAgICAgIGlubmVyRGVjb3JhdGlvbnMsXG4gICAgICAgICAgICAgICAgdXBkYXRlUHJvcHM6ICgpID0+IHJlcmVuZGVyQ29tcG9uZW50KHsgbm9kZSwgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5ub2RlXG4gICAgICAgICAgICAmJiB0aGlzLmRlY29yYXRpb25zID09PSBkZWNvcmF0aW9uc1xuICAgICAgICAgICAgJiYgdGhpcy5pbm5lckRlY29yYXRpb25zID09PSBpbm5lckRlY29yYXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4gICAgICAgIHRoaXMuaW5uZXJEZWNvcmF0aW9ucyA9IGlubmVyRGVjb3JhdGlvbnM7XG4gICAgICAgIHJlcmVuZGVyQ29tcG9uZW50KHsgbm9kZSwgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIG5vZGUuXG4gICAgICogQWRkIHRoZSBgc2VsZWN0ZWRgIHByb3AgYW5kIHRoZSBgUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlYCBjbGFzcy5cbiAgICAgKi9cbiAgICBzZWxlY3ROb2RlKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVByb3BzKHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ1Byb3NlTWlycm9yLXNlbGVjdGVkbm9kZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdCB0aGUgbm9kZS5cbiAgICAgKiBSZW1vdmUgdGhlIGBzZWxlY3RlZGAgcHJvcCBhbmQgdGhlIGBQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVgIGNsYXNzLlxuICAgICAqL1xuICAgIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyh7XG4gICAgICAgICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKCdzZWxlY3Rpb25VcGRhdGUnLCB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZSk7XG4gICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHRvcC1sZXZlbCBlbGVtZW50IHRoYXQgaG9sZHMgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICAgKiBBcHBseWluZyB0aGUgYXR0cmlidXRlcyBkZWZpbmVkIGluIHRoZSBgYXR0cnNgIG9wdGlvbi5cbiAgICAgKi9cbiAgICB1cGRhdGVFbGVtZW50QXR0cmlidXRlcygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdHRycykge1xuICAgICAgICAgICAgbGV0IGF0dHJzT2JqID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hdHRycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXModGhpcy5ub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICBhdHRyc09iaiA9IHRoaXMub3B0aW9ucy5hdHRycyh7IG5vZGU6IHRoaXMubm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyc09iaiA9IHRoaXMub3B0aW9ucy5hdHRycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQXR0cmlidXRlcyhhdHRyc09iaik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIFJlYWN0IG5vZGUgdmlldyByZW5kZXJlci5cbiAqL1xuZnVuY3Rpb24gUmVhY3ROb2RlVmlld1JlbmRlcmVyKGNvbXBvbmVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBwcm9wcyA9PiB7XG4gICAgICAgIC8vIHRyeSB0byBnZXQgdGhlIHBhcmVudCBjb21wb25lbnRcbiAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgZm9yIHZ1ZSBkZXZ0b29scyB0byBzaG93IHRoZSBjb21wb25lbnQgaGllcmFyY2h5IGNvcnJlY3RseVxuICAgICAgICAvLyBtYXliZSBpdOKAmXMgYHVuZGVmaW5lZGAgYmVjYXVzZSA8ZWRpdG9yLWNvbnRlbnQ+IGlzbuKAmXQgcmVuZGVyZWQgeWV0XG4gICAgICAgIGlmICghcHJvcHMuZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlYWN0Tm9kZVZpZXcoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgQnViYmxlTWVudSwgRWRpdG9yQ29uc3VtZXIsIEVkaXRvckNvbnRlbnQsIEVkaXRvckNvbnRleHQsIEVkaXRvclByb3ZpZGVyLCBGbG9hdGluZ01lbnUsIE5vZGVWaWV3Q29udGVudCwgTm9kZVZpZXdXcmFwcGVyLCBQdXJlRWRpdG9yQ29udGVudCwgUmVhY3ROb2RlVmlldywgUmVhY3ROb2RlVmlld0NvbnRleHQsIFJlYWN0Tm9kZVZpZXdSZW5kZXJlciwgUmVhY3RSZW5kZXJlciwgdXNlQ3VycmVudEVkaXRvciwgdXNlRWRpdG9yLCB1c2VFZGl0b3JTdGF0ZSwgdXNlUmVhY3ROb2RlVmlldyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiQnViYmxlTWVudVBsdWdpbiIsIlJlYWN0IiwiZm9yd2FyZFJlZiIsInVzZVN0YXRlIiwidXNlRGVidWdWYWx1ZSIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwiUmVhY3RET00iLCJmbHVzaFN5bmMiLCJFZGl0b3IiLCJOb2RlVmlldyIsImdldFJlbmRlcmVkQXR0cmlidXRlcyIsIkZsb2F0aW5nTWVudVBsdWdpbiIsImdldERlZmF1bHRFeHBvcnRGcm9tQ2pzIiwieCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJzaGltIiwiZXhwb3J0cyIsInVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9wcm9kdWN0aW9uX21pbiIsImhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluIiwicmVxdWlyZVVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9wcm9kdWN0aW9uX21pbiIsImUiLCJoIiwiYSIsImIiLCJrIiwiaXMiLCJsIiwibSIsIm4iLCJwIiwicSIsImQiLCJmIiwiaW5zdCIsInZhbHVlIiwiZ2V0U25hcHNob3QiLCJjIiwiZyIsInIiLCJ0IiwidSIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50IiwiaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQiLCJyZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50IiwicHJvY2VzcyIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCIsIkVycm9yIiwiUmVhY3QkMSIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJlcnJvciIsImZvcm1hdCIsIl9sZW4yIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleTIiLCJwcmludFdhcm5pbmciLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJhcHBseSIsImNvbnNvbGUiLCJ5Iiwib2JqZWN0SXMiLCJkaWRXYXJuT2xkMThBbHBoYSIsImRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90Iiwic3Vic2NyaWJlIiwiZ2V0U2VydmVyU25hcHNob3QiLCJzdGFydFRyYW5zaXRpb24iLCJ1bmRlZmluZWQiLCJjYWNoZWRWYWx1ZSIsIl91c2VTdGF0ZSIsImZvcmNlVXBkYXRlIiwiY2hlY2tJZlNuYXBzaG90Q2hhbmdlZCIsImhhbmRsZVN0b3JlQ2hhbmdlIiwibGF0ZXN0R2V0U25hcHNob3QiLCJwcmV2VmFsdWUiLCJuZXh0VmFsdWUiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxIiwiY2FuVXNlRE9NIiwiaXNTZXJ2ZXJFbnZpcm9ubWVudCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlJDIiLCJyZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCIsInNoaW1FeHBvcnRzIiwibWVyZ2VSZWZzIiwicmVmcyIsIm5vZGUiLCJmb3JFYWNoIiwicmVmIiwiY3VycmVudCIsIlBvcnRhbHMiLCJjb250ZW50Q29tcG9uZW50IiwicmVuZGVyZXJzIiwiRnJhZ21lbnQiLCJ2YWx1ZXMiLCJnZXRJbnN0YW5jZSIsInN1YnNjcmliZXJzIiwiU2V0IiwiY2FsbGJhY2siLCJhZGQiLCJkZWxldGUiLCJzZXRSZW5kZXJlciIsImlkIiwicmVuZGVyZXIiLCJjcmVhdGVQb3J0YWwiLCJyZWFjdEVsZW1lbnQiLCJlbGVtZW50Iiwic3Vic2NyaWJlciIsInJlbW92ZVJlbmRlcmVyIiwibmV4dFJlbmRlcmVycyIsIlB1cmVFZGl0b3JDb250ZW50IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsIl9hIiwiZWRpdG9yQ29udGVudFJlZiIsImNyZWF0ZVJlZiIsImluaXRpYWxpemVkIiwic3RhdGUiLCJoYXNDb250ZW50Q29tcG9uZW50SW5pdGlhbGl6ZWQiLCJCb29sZWFuIiwiZWRpdG9yIiwiY29tcG9uZW50RGlkTW91bnQiLCJpbml0IiwiY29tcG9uZW50RGlkVXBkYXRlIiwiaXNEZXN0cm95ZWQiLCJvcHRpb25zIiwiYXBwZW5kIiwiY2hpbGROb2RlcyIsInNldE9wdGlvbnMiLCJ1bnN1YnNjcmliZVRvQ29udGVudENvbXBvbmVudCIsInNldFN0YXRlIiwicHJldlN0YXRlIiwiY3JlYXRlTm9kZVZpZXdzIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJ2aWV3Iiwic2V0UHJvcHMiLCJub2RlVmlld3MiLCJmaXJzdENoaWxkIiwibmV3RWxlbWVudCIsInJlbmRlciIsImlubmVyUmVmIiwicmVzdCIsIkVkaXRvckNvbnRlbnRXaXRoS2V5Iiwia2V5IiwidXNlTWVtbyIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInRvU3RyaW5nIiwiRWRpdG9yQ29udGVudCIsIm1lbW8iLCJyZWFjdCIsImVxdWFsIiwiaSIsImtleXMiLCJpc0FycmF5IiwiTWFwIiwic2l6ZSIsImVudHJpZXMiLCJoYXMiLCJnZXQiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsIlJlZ0V4cCIsInNvdXJjZSIsImZsYWdzIiwidmFsdWVPZiIsIiQkdHlwZW9mIiwiZGVlcEVxdWFsIiwid2l0aFNlbGVjdG9yIiwid2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluIiwiaGFzUmVxdWlyZWRXaXRoU2VsZWN0b3JfcHJvZHVjdGlvbl9taW4iLCJyZXF1aXJlV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluIiwidiIsInciLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciIsImhhc1ZhbHVlIiwid2l0aFNlbGVjdG9yX2RldmVsb3BtZW50IiwiaGFzUmVxdWlyZWRXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQiLCJyZXF1aXJlV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50Iiwic2VsZWN0b3IiLCJpc0VxdWFsIiwiaW5zdFJlZiIsIl91c2VNZW1vIiwiaGFzTWVtbyIsIm1lbW9pemVkU25hcHNob3QiLCJtZW1vaXplZFNlbGVjdGlvbiIsIm1lbW9pemVkU2VsZWN0b3IiLCJuZXh0U25hcHNob3QiLCJfbmV4dFNlbGVjdGlvbiIsImN1cnJlbnRTZWxlY3Rpb24iLCJwcmV2U25hcHNob3QiLCJwcmV2U2VsZWN0aW9uIiwibmV4dFNlbGVjdGlvbiIsIm1heWJlR2V0U2VydmVyU25hcHNob3QiLCJnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciIsImdldFNlcnZlclNuYXBzaG90V2l0aFNlbGVjdG9yIiwiZ2V0U2VsZWN0aW9uIiwiZ2V0U2VydmVyU2VsZWN0aW9uIiwid2l0aFNlbGVjdG9yRXhwb3J0cyIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJFZGl0b3JTdGF0ZU1hbmFnZXIiLCJpbml0aWFsRWRpdG9yIiwidHJhbnNhY3Rpb25OdW1iZXIiLCJsYXN0VHJhbnNhY3Rpb25OdW1iZXIiLCJsYXN0U25hcHNob3QiLCJiaW5kIiwid2F0Y2giLCJuZXh0RWRpdG9yIiwiZm4iLCJjdXJyZW50RWRpdG9yIiwib24iLCJvZmYiLCJ1c2VFZGl0b3JTdGF0ZSIsImVkaXRvclN0YXRlTWFuYWdlciIsInNlbGVjdGVkU3RhdGUiLCJlcXVhbGl0eUZuIiwiaXNEZXYiLCJpc1NTUiIsImlzTmV4dCIsIm5leHQiLCJFZGl0b3JJbnN0YW5jZU1hbmFnZXIiLCJzdWJzY3JpcHRpb25zIiwiaXNDb21wb25lbnRNb3VudGVkIiwicHJldmlvdXNEZXBzIiwiaW5zdGFuY2VJZCIsInNldEVkaXRvciIsImdldEluaXRpYWxFZGl0b3IiLCJzY2hlZHVsZURlc3Ryb3kiLCJnZXRFZGl0b3IiLCJyZWZyZXNoRWRpdG9ySW5zdGFuY2UiLCJvblJlbmRlciIsImNyZWF0ZUVkaXRvciIsInNsaWNlIiwiY2IiLCJpbW1lZGlhdGVseVJlbmRlciIsIndhcm4iLCJvcHRpb25zVG9BcHBseSIsIm9uQmVmb3JlQ3JlYXRlIiwiX2IiLCJvbkJsdXIiLCJvbkNyZWF0ZSIsIm9uRGVzdHJveSIsIm9uRm9jdXMiLCJvblNlbGVjdGlvblVwZGF0ZSIsIm9uVHJhbnNhY3Rpb24iLCJvblVwZGF0ZSIsIm9uQ29udGVudEVycm9yIiwib25Ecm9wIiwib25QYXN0ZSIsIm9uU3RvcmVDaGFuZ2UiLCJjb21wYXJlT3B0aW9ucyIsImV2ZXJ5IiwiaW5jbHVkZXMiLCJleHRlbnNpb25zIiwiZXh0ZW5zaW9uIiwiaW5kZXgiLCJkZXBzIiwiY2xlYXJUaW1lb3V0Iiwic2NoZWR1bGVkRGVzdHJ1Y3Rpb25UaW1lb3V0IiwiZWRpdGFibGUiLCJpc0VkaXRhYmxlIiwiZGVwc0FyZUVxdWFsIiwiZGVwIiwiZGVzdHJveSIsImN1cnJlbnRJbnN0YW5jZUlkIiwic2V0VGltZW91dCIsInVzZUVkaXRvciIsIm1vc3RSZWNlbnRPcHRpb25zIiwiaW5zdGFuY2VNYW5hZ2VyIiwic2hvdWxkUmVyZW5kZXJPblRyYW5zYWN0aW9uIiwiRWRpdG9yQ29udGV4dCIsIkVkaXRvckNvbnN1bWVyIiwiQ29uc3VtZXIiLCJ1c2VDdXJyZW50RWRpdG9yIiwiRWRpdG9yUHJvdmlkZXIiLCJjaGlsZHJlbiIsInNsb3RBZnRlciIsInNsb3RCZWZvcmUiLCJlZGl0b3JDb250YWluZXJQcm9wcyIsImVkaXRvck9wdGlvbnMiLCJQcm92aWRlciIsIkJ1YmJsZU1lbnUiLCJzZXRFbGVtZW50IiwicGx1Z2luS2V5IiwidGlwcHlPcHRpb25zIiwidXBkYXRlRGVsYXkiLCJzaG91bGRTaG93IiwibWVudUVkaXRvciIsInBsdWdpbiIsInJlZ2lzdGVyUGx1Z2luIiwidW5yZWdpc3RlclBsdWdpbiIsImNsYXNzTmFtZSIsInN0eWxlIiwidmlzaWJpbGl0eSIsIkZsb2F0aW5nTWVudSIsIlJlYWN0Tm9kZVZpZXdDb250ZXh0Iiwib25EcmFnU3RhcnQiLCJ1c2VSZWFjdE5vZGVWaWV3IiwiTm9kZVZpZXdDb250ZW50IiwiVGFnIiwiYXMiLCJub2RlVmlld0NvbnRlbnRSZWYiLCJ3aGl0ZVNwYWNlIiwiTm9kZVZpZXdXcmFwcGVyIiwiaXNDbGFzc0NvbXBvbmVudCIsImlzUmVhY3RDb21wb25lbnQiLCJpc0ZvcndhcmRSZWZDb21wb25lbnQiLCJSZWFjdFJlbmRlcmVyIiwiY29tcG9uZW50IiwiY2xhc3NMaXN0Iiwic3BsaXQiLCJpc0luaXRpYWxpemVkIiwidXBkYXRlUHJvcHMiLCJ1cGRhdGVBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsIlJlYWN0Tm9kZVZpZXciLCJtb3VudCIsImRlY29yYXRpb25zIiwiaW5uZXJEZWNvcmF0aW9ucyIsInNlbGVjdGVkIiwiSFRNTEF0dHJpYnV0ZXMiLCJnZXRQb3MiLCJkZWxldGVOb2RlIiwiZGlzcGxheU5hbWUiLCJjYXBpdGFsaXplRmlyc3RDaGFyIiwic3RyaW5nIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzdWJzdHJpbmciLCJuYW1lIiwiY29udGVudERPTUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImNvbnRleHQiLCJSZWFjdE5vZGVWaWV3UHJvdmlkZXIiLCJjb21wb25lbnRQcm9wcyIsImlzTGVhZiIsImNvbnRlbnRET01FbGVtZW50VGFnIiwiaXNJbmxpbmUiLCJkYXRhc2V0Iiwibm9kZVZpZXdDb250ZW50UmVhY3QiLCJoYW5kbGVTZWxlY3Rpb25VcGRhdGUiLCJ0eXBlIiwidHJpbSIsInVwZGF0ZUVsZW1lbnRBdHRyaWJ1dGVzIiwiZG9tIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJoYXNBdHRyaWJ1dGUiLCJjb250ZW50RE9NIiwiZnJvbSIsInRvIiwic2VsZWN0aW9uIiwicG9zIiwibm9kZVNpemUiLCJzZWxlY3ROb2RlIiwiZGVzZWxlY3ROb2RlIiwidXBkYXRlIiwicmVyZW5kZXJDb21wb25lbnQiLCJhdHRycyIsIm9sZE5vZGUiLCJvbGREZWNvcmF0aW9ucyIsIm9sZElubmVyRGVjb3JhdGlvbnMiLCJuZXdOb2RlIiwibmV3RGVjb3JhdGlvbnMiLCJyZW1vdmUiLCJhdHRyc09iaiIsImV4dGVuc2lvbkF0dHJpYnV0ZXMiLCJleHRlbnNpb25NYW5hZ2VyIiwiUmVhY3ROb2RlVmlld1JlbmRlcmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/starter-kit/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StarterKit: () => (/* binding */ StarterKit),\n/* harmony export */   \"default\": () => (/* binding */ StarterKit)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-blockquote */ \"(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-bold */ \"(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-bullet-list */ \"(ssr)/./node_modules/@tiptap/extension-bullet-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-code */ \"(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-code-block */ \"(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\");\n/* harmony import */ var _tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-document */ \"(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\");\n/* harmony import */ var _tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-dropcursor */ \"(ssr)/./node_modules/@tiptap/extension-dropcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-gapcursor */ \"(ssr)/./node_modules/@tiptap/extension-gapcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-hard-break */ \"(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\");\n/* harmony import */ var _tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-heading */ \"(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\");\n/* harmony import */ var _tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-history */ \"(ssr)/./node_modules/@tiptap/extension-history/dist/index.js\");\n/* harmony import */ var _tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-horizontal-rule */ \"(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\");\n/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-italic */ \"(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\");\n/* harmony import */ var _tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-list-item */ \"(ssr)/./node_modules/@tiptap/extension-list-item/dist/index.js\");\n/* harmony import */ var _tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-ordered-list */ \"(ssr)/./node_modules/@tiptap/extension-ordered-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/extension-paragraph */ \"(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tiptap/extension-strike */ \"(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tiptap/extension-text */ \"(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The starter kit is a collection of essential editor extensions.\n *\n * It’s a good starting point for building your own editor.\n */ const StarterKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_18__.Extension.create({\n    name: \"starterKit\",\n    addExtensions () {\n        const extensions = [];\n        if (this.options.bold !== false) {\n            extensions.push(_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__.Bold.configure(this.options.bold));\n        }\n        if (this.options.blockquote !== false) {\n            extensions.push(_tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__.Blockquote.configure(this.options.blockquote));\n        }\n        if (this.options.bulletList !== false) {\n            extensions.push(_tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__.BulletList.configure(this.options.bulletList));\n        }\n        if (this.options.code !== false) {\n            extensions.push(_tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__.Code.configure(this.options.code));\n        }\n        if (this.options.codeBlock !== false) {\n            extensions.push(_tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__.CodeBlock.configure(this.options.codeBlock));\n        }\n        if (this.options.document !== false) {\n            extensions.push(_tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__.Document.configure(this.options.document));\n        }\n        if (this.options.dropcursor !== false) {\n            extensions.push(_tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__.Dropcursor.configure(this.options.dropcursor));\n        }\n        if (this.options.gapcursor !== false) {\n            extensions.push(_tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__.Gapcursor.configure(this.options.gapcursor));\n        }\n        if (this.options.hardBreak !== false) {\n            extensions.push(_tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__.HardBreak.configure(this.options.hardBreak));\n        }\n        if (this.options.heading !== false) {\n            extensions.push(_tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__.Heading.configure(this.options.heading));\n        }\n        if (this.options.history !== false) {\n            extensions.push(_tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__.History.configure(this.options.history));\n        }\n        if (this.options.horizontalRule !== false) {\n            extensions.push(_tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__.HorizontalRule.configure(this.options.horizontalRule));\n        }\n        if (this.options.italic !== false) {\n            extensions.push(_tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__.Italic.configure(this.options.italic));\n        }\n        if (this.options.listItem !== false) {\n            extensions.push(_tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__.ListItem.configure(this.options.listItem));\n        }\n        if (this.options.orderedList !== false) {\n            extensions.push(_tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__.OrderedList.configure(this.options.orderedList));\n        }\n        if (this.options.paragraph !== false) {\n            extensions.push(_tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__.Paragraph.configure(this.options.paragraph));\n        }\n        if (this.options.strike !== false) {\n            extensions.push(_tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__.Strike.configure(this.options.strike));\n        }\n        if (this.options.text !== false) {\n            extensions.push(_tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__.Text.configure(this.options.text));\n        }\n        return extensions;\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdGFydGVyLWtpdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUNpQjtBQUNaO0FBQ2E7QUFDYjtBQUNXO0FBQ0g7QUFDSTtBQUNGO0FBQ0M7QUFDTDtBQUNBO0FBQ2U7QUFDakI7QUFDSztBQUNNO0FBQ0w7QUFDTjtBQUNKO0FBRTlDOzs7O0NBSUMsR0FDRCxNQUFNbUIsYUFBYW5CLG9EQUFTQSxDQUFDb0IsTUFBTSxDQUFDO0lBQ2hDQyxNQUFNO0lBQ05DO1FBQ0ksTUFBTUMsYUFBYSxFQUFFO1FBQ3JCLElBQUksSUFBSSxDQUFDQyxPQUFPLENBQUNDLElBQUksS0FBSyxPQUFPO1lBQzdCRixXQUFXRyxJQUFJLENBQUN4Qix3REFBSUEsQ0FBQ3lCLFNBQVMsQ0FBQyxJQUFJLENBQUNILE9BQU8sQ0FBQ0MsSUFBSTtRQUNwRDtRQUNBLElBQUksSUFBSSxDQUFDRCxPQUFPLENBQUNJLFVBQVUsS0FBSyxPQUFPO1lBQ25DTCxXQUFXRyxJQUFJLENBQUN6QixvRUFBVUEsQ0FBQzBCLFNBQVMsQ0FBQyxJQUFJLENBQUNILE9BQU8sQ0FBQ0ksVUFBVTtRQUNoRTtRQUNBLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLFVBQVUsS0FBSyxPQUFPO1lBQ25DTixXQUFXRyxJQUFJLENBQUN2QixxRUFBVUEsQ0FBQ3dCLFNBQVMsQ0FBQyxJQUFJLENBQUNILE9BQU8sQ0FBQ0ssVUFBVTtRQUNoRTtRQUNBLElBQUksSUFBSSxDQUFDTCxPQUFPLENBQUNNLElBQUksS0FBSyxPQUFPO1lBQzdCUCxXQUFXRyxJQUFJLENBQUN0Qix3REFBSUEsQ0FBQ3VCLFNBQVMsQ0FBQyxJQUFJLENBQUNILE9BQU8sQ0FBQ00sSUFBSTtRQUNwRDtRQUNBLElBQUksSUFBSSxDQUFDTixPQUFPLENBQUNPLFNBQVMsS0FBSyxPQUFPO1lBQ2xDUixXQUFXRyxJQUFJLENBQUNyQixtRUFB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cm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvc3RhcnRlci1raXQvZGlzdC9pbmRleC5qcz85ZGJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBCbG9ja3F1b3RlIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZSc7XG5pbXBvcnQgeyBCb2xkIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYm9sZCc7XG5pbXBvcnQgeyBCdWxsZXRMaXN0IH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3QnO1xuaW1wb3J0IHsgQ29kZSB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUnO1xuaW1wb3J0IHsgQ29kZUJsb2NrIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jayc7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWRvY3VtZW50JztcbmltcG9ydCB7IERyb3BjdXJzb3IgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1kcm9wY3Vyc29yJztcbmltcG9ydCB7IEdhcGN1cnNvciB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWdhcGN1cnNvcic7XG5pbXBvcnQgeyBIYXJkQnJlYWsgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oYXJkLWJyZWFrJztcbmltcG9ydCB7IEhlYWRpbmcgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oZWFkaW5nJztcbmltcG9ydCB7IEhpc3RvcnkgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oaXN0b3J5JztcbmltcG9ydCB7IEhvcml6b250YWxSdWxlIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlJztcbmltcG9ydCB7IEl0YWxpYyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWl0YWxpYyc7XG5pbXBvcnQgeyBMaXN0SXRlbSB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QtaXRlbSc7XG5pbXBvcnQgeyBPcmRlcmVkTGlzdCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLW9yZGVyZWQtbGlzdCc7XG5pbXBvcnQgeyBQYXJhZ3JhcGggfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1wYXJhZ3JhcGgnO1xuaW1wb3J0IHsgU3RyaWtlIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlJztcbmltcG9ydCB7IFRleHQgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi10ZXh0JztcblxuLyoqXG4gKiBUaGUgc3RhcnRlciBraXQgaXMgYSBjb2xsZWN0aW9uIG9mIGVzc2VudGlhbCBlZGl0b3IgZXh0ZW5zaW9ucy5cbiAqXG4gKiBJdOKAmXMgYSBnb29kIHN0YXJ0aW5nIHBvaW50IGZvciBidWlsZGluZyB5b3VyIG93biBlZGl0b3IuXG4gKi9cbmNvbnN0IFN0YXJ0ZXJLaXQgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnc3RhcnRlcktpdCcsXG4gICAgYWRkRXh0ZW5zaW9ucygpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJvbGQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goQm9sZC5jb25maWd1cmUodGhpcy5vcHRpb25zLmJvbGQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJsb2NrcXVvdGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goQmxvY2txdW90ZS5jb25maWd1cmUodGhpcy5vcHRpb25zLmJsb2NrcXVvdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldExpc3QgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goQnVsbGV0TGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zLmJ1bGxldExpc3QpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goQ29kZS5jb25maWd1cmUodGhpcy5vcHRpb25zLmNvZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvZGVCbG9jayAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChDb2RlQmxvY2suY29uZmlndXJlKHRoaXMub3B0aW9ucy5jb2RlQmxvY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvY3VtZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKERvY3VtZW50LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuZG9jdW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRyb3BjdXJzb3IgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goRHJvcGN1cnNvci5jb25maWd1cmUodGhpcy5vcHRpb25zLmRyb3BjdXJzb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdhcGN1cnNvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChHYXBjdXJzb3IuY29uZmlndXJlKHRoaXMub3B0aW9ucy5nYXBjdXJzb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhhcmRCcmVhayAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChIYXJkQnJlYWsuY29uZmlndXJlKHRoaXMub3B0aW9ucy5oYXJkQnJlYWspKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goSGVhZGluZy5jb25maWd1cmUodGhpcy5vcHRpb25zLmhlYWRpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpc3RvcnkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goSGlzdG9yeS5jb25maWd1cmUodGhpcy5vcHRpb25zLmhpc3RvcnkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhvcml6b250YWxSdWxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhvcml6b250YWxSdWxlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbFJ1bGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLml0YWxpYyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChJdGFsaWMuY29uZmlndXJlKHRoaXMub3B0aW9ucy5pdGFsaWMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxpc3RJdGVtICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKExpc3RJdGVtLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMubGlzdEl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9yZGVyZWRMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKE9yZGVyZWRMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMub3JkZXJlZExpc3QpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmFncmFwaCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChQYXJhZ3JhcGguY29uZmlndXJlKHRoaXMub3B0aW9ucy5wYXJhZ3JhcGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0cmlrZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChTdHJpa2UuY29uZmlndXJlKHRoaXMub3B0aW9ucy5zdHJpa2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRleHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goVGV4dC5jb25maWd1cmUodGhpcy5vcHRpb25zLnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucztcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IFN0YXJ0ZXJLaXQsIFN0YXJ0ZXJLaXQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiRXh0ZW5zaW9uIiwiQmxvY2txdW90ZSIsIkJvbGQiLCJCdWxsZXRMaXN0IiwiQ29kZSIsIkNvZGVCbG9jayIsIkRvY3VtZW50IiwiRHJvcGN1cnNvciIsIkdhcGN1cnNvciIsIkhhcmRCcmVhayIsIkhlYWRpbmciLCJIaXN0b3J5IiwiSG9yaXpvbnRhbFJ1bGUiLCJJdGFsaWMiLCJMaXN0SXRlbSIsIk9yZGVyZWRMaXN0IiwiUGFyYWdyYXBoIiwiU3RyaWtlIiwiVGV4dCIsIlN0YXJ0ZXJLaXQiLCJjcmVhdGUiLCJuYW1lIiwiYWRkRXh0ZW5zaW9ucyIsImV4dGVuc2lvbnMiLCJvcHRpb25zIiwiYm9sZCIsInB1c2giLCJjb25maWd1cmUiLCJibG9ja3F1b3RlIiwiYnVsbGV0TGlzdCIsImNvZGUiLCJjb2RlQmxvY2siLCJkb2N1bWVudCIsImRyb3BjdXJzb3IiLCJnYXBjdXJzb3IiLCJoYXJkQnJlYWsiLCJoZWFkaW5nIiwiaGlzdG9yeSIsImhvcml6b250YWxSdWxlIiwiaXRhbGljIiwibGlzdEl0ZW0iLCJvcmRlcmVkTGlzdCIsInBhcmFncmFwaCIsInN0cmlrZSIsInRleHQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/suggestion/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/suggestion/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Suggestion: () => (/* binding */ Suggestion),\n/* harmony export */   SuggestionPluginKey: () => (/* binding */ SuggestionPluginKey),\n/* harmony export */   \"default\": () => (/* binding */ Suggestion),\n/* harmony export */   findSuggestionMatch: () => (/* binding */ findSuggestionMatch)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/view/dist/index.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n\nfunction findSuggestionMatch(config) {\n    var _a;\n    const { char, allowSpaces: allowSpacesOption, allowToIncludeChar, allowedPrefixes, startOfLine, $position } = config;\n    const allowSpaces = allowSpacesOption && !allowToIncludeChar;\n    const escapedChar = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.escapeForRegEx)(char);\n    const suffix = new RegExp(`\\\\s${escapedChar}$`);\n    const prefix = startOfLine ? \"^\" : \"\";\n    const finalEscapedChar = allowToIncludeChar ? \"\" : escapedChar;\n    const regexp = allowSpaces ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${finalEscapedChar}|$)`, \"gm\") : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${finalEscapedChar}]*`, \"gm\");\n    const text = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;\n    if (!text) {\n        return null;\n    }\n    const textFrom = $position.pos - text.length;\n    const match = Array.from(text.matchAll(regexp)).pop();\n    if (!match || match.input === undefined || match.index === undefined) {\n        return null;\n    }\n    // JavaScript doesn't have lookbehinds. This hacks a check that first character\n    // is a space or the start of the line\n    const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);\n    const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join(\"\")}\\0]?$`).test(matchPrefix);\n    if (allowedPrefixes !== null && !matchPrefixIsAllowed) {\n        return null;\n    }\n    // The absolute position of the match in the document\n    const from = textFrom + match.index;\n    let to = from + match[0].length;\n    // Edge case handling; if spaces are allowed and we're directly in between\n    // two triggers\n    if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\n        match[0] += \" \";\n        to += 1;\n    }\n    // If the $position is located within the matched substring, return that range\n    if (from < $position.pos && to >= $position.pos) {\n        return {\n            range: {\n                from,\n                to\n            },\n            query: match[0].slice(char.length),\n            text: match[0]\n        };\n    }\n    return null;\n}\nconst SuggestionPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"suggestion\");\n/**\n * This utility allows you to create suggestions.\n * @see https://tiptap.dev/api/utilities/suggestion\n */ function Suggestion({ pluginKey = SuggestionPluginKey, editor, char = \"@\", allowSpaces = false, allowToIncludeChar = false, allowedPrefixes = [\n    \" \"\n], startOfLine = false, decorationTag = \"span\", decorationClass = \"suggestion\", command = ()=>null, items = ()=>[], render = ()=>({}), allow = ()=>true, findSuggestionMatch: findSuggestionMatch$1 = findSuggestionMatch }) {\n    let props;\n    const renderer = render === null || render === void 0 ? void 0 : render();\n    const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: pluginKey,\n        view () {\n            return {\n                update: async (view, prevState)=>{\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);\n                    const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);\n                    // See how the state changed\n                    const moved = prev.active && next.active && prev.range.from !== next.range.from;\n                    const started = !prev.active && next.active;\n                    const stopped = prev.active && !next.active;\n                    const changed = !started && !stopped && prev.query !== next.query;\n                    const handleStart = started || moved && changed;\n                    const handleChange = changed || moved;\n                    const handleExit = stopped || moved && changed;\n                    // Cancel when suggestion isn't active\n                    if (!handleStart && !handleChange && !handleExit) {\n                        return;\n                    }\n                    const state = handleExit && !handleStart ? prev : next;\n                    const decorationNode = view.dom.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`);\n                    props = {\n                        editor,\n                        range: state.range,\n                        query: state.query,\n                        text: state.text,\n                        items: [],\n                        command: (commandProps)=>{\n                            return command({\n                                editor,\n                                range: state.range,\n                                props: commandProps\n                            });\n                        },\n                        decorationNode,\n                        // virtual node for popper.js or tippy.js\n                        // this can be used for building popups without a DOM node\n                        clientRect: decorationNode ? ()=>{\n                            var _a;\n                            // because of `items` can be asynchrounous we’ll search for the current decoration node\n                            const { decorationId } = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(editor.state); // eslint-disable-line\n                            const currentDecorationNode = view.dom.querySelector(`[data-decoration-id=\"${decorationId}\"]`);\n                            return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;\n                        } : null\n                    };\n                    if (handleStart) {\n                        (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);\n                    }\n                    if (handleChange) {\n                        (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);\n                    }\n                    if (handleChange || handleStart) {\n                        props.items = await items({\n                            editor,\n                            query: state.query\n                        });\n                    }\n                    if (handleExit) {\n                        (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);\n                    }\n                    if (handleChange) {\n                        (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);\n                    }\n                    if (handleStart) {\n                        (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);\n                    }\n                },\n                destroy: ()=>{\n                    var _a;\n                    if (!props) {\n                        return;\n                    }\n                    (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);\n                }\n            };\n        },\n        state: {\n            // Initialize the plugin's internal state.\n            init () {\n                const state = {\n                    active: false,\n                    range: {\n                        from: 0,\n                        to: 0\n                    },\n                    query: null,\n                    text: null,\n                    composing: false\n                };\n                return state;\n            },\n            // Apply changes to the plugin state from a view transaction.\n            apply (transaction, prev, _oldState, state) {\n                const { isEditable } = editor;\n                const { composing } = editor.view;\n                const { selection } = transaction;\n                const { empty, from } = selection;\n                const next = {\n                    ...prev\n                };\n                next.composing = composing;\n                // We can only be suggesting if the view is editable, and:\n                //   * there is no selection, or\n                //   * a composition is active (see: https://github.com/ueberdosis/tiptap/issues/1449)\n                if (isEditable && (empty || editor.view.composing)) {\n                    // Reset active state if we just left the previous suggestion range\n                    if ((from < prev.range.from || from > prev.range.to) && !composing && !prev.composing) {\n                        next.active = false;\n                    }\n                    // Try to match against where our cursor currently is\n                    const match = findSuggestionMatch$1({\n                        char,\n                        allowSpaces,\n                        allowToIncludeChar,\n                        allowedPrefixes,\n                        startOfLine,\n                        $position: selection.$from\n                    });\n                    const decorationId = `id_${Math.floor(Math.random() * 0xffffffff)}`;\n                    // If we found a match, update the current state to show it\n                    if (match && allow({\n                        editor,\n                        state,\n                        range: match.range,\n                        isActive: prev.active\n                    })) {\n                        next.active = true;\n                        next.decorationId = prev.decorationId ? prev.decorationId : decorationId;\n                        next.range = match.range;\n                        next.query = match.query;\n                        next.text = match.text;\n                    } else {\n                        next.active = false;\n                    }\n                } else {\n                    next.active = false;\n                }\n                // Make sure to empty the range if suggestion is inactive\n                if (!next.active) {\n                    next.decorationId = null;\n                    next.range = {\n                        from: 0,\n                        to: 0\n                    };\n                    next.query = null;\n                    next.text = null;\n                }\n                return next;\n            }\n        },\n        props: {\n            // Call the keydown hook if suggestion is active.\n            handleKeyDown (view, event) {\n                var _a;\n                const { active, range } = plugin.getState(view.state);\n                if (!active) {\n                    return false;\n                }\n                return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, {\n                    view,\n                    event,\n                    range\n                })) || false;\n            },\n            // Setup decorator on the currently active suggestion.\n            decorations (state) {\n                const { active, range, decorationId } = plugin.getState(state);\n                if (!active) {\n                    return null;\n                }\n                return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.DecorationSet.create(state.doc, [\n                    _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.inline(range.from, range.to, {\n                        nodeName: decorationTag,\n                        class: decorationClass,\n                        \"data-decoration-id\": decorationId\n                    })\n                ]);\n            }\n        }\n    });\n    return plugin;\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdWdnZXN0aW9uL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFxRDtBQUNPO0FBQ2Q7QUFFOUMsU0FBU0ssb0JBQW9CQyxNQUFNO0lBQy9CLElBQUlDO0lBQ0osTUFBTSxFQUFFQyxJQUFJLEVBQUVDLGFBQWFDLGlCQUFpQixFQUFFQyxrQkFBa0IsRUFBRUMsZUFBZSxFQUFFQyxXQUFXLEVBQUVDLFNBQVMsRUFBRyxHQUFHUjtJQUMvRyxNQUFNRyxjQUFjQyxxQkFBcUIsQ0FBQ0M7SUFDMUMsTUFBTUksY0FBY1gsNERBQWNBLENBQUNJO0lBQ25DLE1BQU1RLFNBQVMsSUFBSUMsT0FBTyxDQUFDLEdBQUcsRUFBRUYsWUFBWSxDQUFDLENBQUM7SUFDOUMsTUFBTUcsU0FBU0wsY0FBYyxNQUFNO0lBQ25DLE1BQU1NLG1CQUFtQlIscUJBQXFCLEtBQUtJO0lBQ25ELE1BQU1LLFNBQVNYLGNBQ1QsSUFBSVEsT0FBTyxDQUFDLEVBQUVDLE9BQU8sRUFBRUgsWUFBWSxTQUFTLEVBQUVJLGlCQUFpQixHQUFHLENBQUMsRUFBRSxRQUNyRSxJQUFJRixPQUFPLENBQUMsRUFBRUMsT0FBTyxNQUFNLEVBQUVILFlBQVksS0FBSyxFQUFFSSxpQkFBaUIsRUFBRSxDQUFDLEVBQUU7SUFDNUUsTUFBTUUsT0FBTyxDQUFDLENBQUNkLEtBQUtPLFVBQVVRLFVBQVUsTUFBTSxRQUFRZixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdnQixNQUFNLEtBQUtULFVBQVVRLFVBQVUsQ0FBQ0QsSUFBSTtJQUN0SCxJQUFJLENBQUNBLE1BQU07UUFDUCxPQUFPO0lBQ1g7SUFDQSxNQUFNRyxXQUFXVixVQUFVVyxHQUFHLEdBQUdKLEtBQUtLLE1BQU07SUFDNUMsTUFBTUMsUUFBUUMsTUFBTUMsSUFBSSxDQUFDUixLQUFLUyxRQUFRLENBQUNWLFNBQVNXLEdBQUc7SUFDbkQsSUFBSSxDQUFDSixTQUFTQSxNQUFN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aW5kZXguanM/NmRlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbHVnaW5LZXksIFBsdWdpbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnO1xuaW1wb3J0IHsgRGVjb3JhdGlvblNldCwgRGVjb3JhdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldyc7XG5pbXBvcnQgeyBlc2NhcGVGb3JSZWdFeCB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbmZ1bmN0aW9uIGZpbmRTdWdnZXN0aW9uTWF0Y2goY29uZmlnKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgY2hhciwgYWxsb3dTcGFjZXM6IGFsbG93U3BhY2VzT3B0aW9uLCBhbGxvd1RvSW5jbHVkZUNoYXIsIGFsbG93ZWRQcmVmaXhlcywgc3RhcnRPZkxpbmUsICRwb3NpdGlvbiwgfSA9IGNvbmZpZztcbiAgICBjb25zdCBhbGxvd1NwYWNlcyA9IGFsbG93U3BhY2VzT3B0aW9uICYmICFhbGxvd1RvSW5jbHVkZUNoYXI7XG4gICAgY29uc3QgZXNjYXBlZENoYXIgPSBlc2NhcGVGb3JSZWdFeChjaGFyKTtcbiAgICBjb25zdCBzdWZmaXggPSBuZXcgUmVnRXhwKGBcXFxccyR7ZXNjYXBlZENoYXJ9JGApO1xuICAgIGNvbnN0IHByZWZpeCA9IHN0YXJ0T2ZMaW5lID8gJ14nIDogJyc7XG4gICAgY29uc3QgZmluYWxFc2NhcGVkQ2hhciA9IGFsbG93VG9JbmNsdWRlQ2hhciA/ICcnIDogZXNjYXBlZENoYXI7XG4gICAgY29uc3QgcmVnZXhwID0gYWxsb3dTcGFjZXNcbiAgICAgICAgPyBuZXcgUmVnRXhwKGAke3ByZWZpeH0ke2VzY2FwZWRDaGFyfS4qPyg/PVxcXFxzJHtmaW5hbEVzY2FwZWRDaGFyfXwkKWAsICdnbScpXG4gICAgICAgIDogbmV3IFJlZ0V4cChgJHtwcmVmaXh9KD86Xik/JHtlc2NhcGVkQ2hhcn1bXlxcXFxzJHtmaW5hbEVzY2FwZWRDaGFyfV0qYCwgJ2dtJyk7XG4gICAgY29uc3QgdGV4dCA9ICgoX2EgPSAkcG9zaXRpb24ubm9kZUJlZm9yZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVGV4dCkgJiYgJHBvc2l0aW9uLm5vZGVCZWZvcmUudGV4dDtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRleHRGcm9tID0gJHBvc2l0aW9uLnBvcyAtIHRleHQubGVuZ3RoO1xuICAgIGNvbnN0IG1hdGNoID0gQXJyYXkuZnJvbSh0ZXh0Lm1hdGNoQWxsKHJlZ2V4cCkpLnBvcCgpO1xuICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guaW5wdXQgPT09IHVuZGVmaW5lZCB8fCBtYXRjaC5pbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBKYXZhU2NyaXB0IGRvZXNuJ3QgaGF2ZSBsb29rYmVoaW5kcy4gVGhpcyBoYWNrcyBhIGNoZWNrIHRoYXQgZmlyc3QgY2hhcmFjdGVyXG4gICAgLy8gaXMgYSBzcGFjZSBvciB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcbiAgICBjb25zdCBtYXRjaFByZWZpeCA9IG1hdGNoLmlucHV0LnNsaWNlKE1hdGgubWF4KDAsIG1hdGNoLmluZGV4IC0gMSksIG1hdGNoLmluZGV4KTtcbiAgICBjb25zdCBtYXRjaFByZWZpeElzQWxsb3dlZCA9IG5ldyBSZWdFeHAoYF5bJHthbGxvd2VkUHJlZml4ZXMgPT09IG51bGwgfHwgYWxsb3dlZFByZWZpeGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGxvd2VkUHJlZml4ZXMuam9pbignJyl9XFwwXT8kYCkudGVzdChtYXRjaFByZWZpeCk7XG4gICAgaWYgKGFsbG93ZWRQcmVmaXhlcyAhPT0gbnVsbCAmJiAhbWF0Y2hQcmVmaXhJc0FsbG93ZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgbWF0Y2ggaW4gdGhlIGRvY3VtZW50XG4gICAgY29uc3QgZnJvbSA9IHRleHRGcm9tICsgbWF0Y2guaW5kZXg7XG4gICAgbGV0IHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAvLyBFZGdlIGNhc2UgaGFuZGxpbmc7IGlmIHNwYWNlcyBhcmUgYWxsb3dlZCBhbmQgd2UncmUgZGlyZWN0bHkgaW4gYmV0d2VlblxuICAgIC8vIHR3byB0cmlnZ2Vyc1xuICAgIGlmIChhbGxvd1NwYWNlcyAmJiBzdWZmaXgudGVzdCh0ZXh0LnNsaWNlKHRvIC0gMSwgdG8gKyAxKSkpIHtcbiAgICAgICAgbWF0Y2hbMF0gKz0gJyAnO1xuICAgICAgICB0byArPSAxO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgJHBvc2l0aW9uIGlzIGxvY2F0ZWQgd2l0aGluIHRoZSBtYXRjaGVkIHN1YnN0cmluZywgcmV0dXJuIHRoYXQgcmFuZ2VcbiAgICBpZiAoZnJvbSA8ICRwb3NpdGlvbi5wb3MgJiYgdG8gPj0gJHBvc2l0aW9uLnBvcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHF1ZXJ5OiBtYXRjaFswXS5zbGljZShjaGFyLmxlbmd0aCksXG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IFN1Z2dlc3Rpb25QbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCdzdWdnZXN0aW9uJyk7XG4vKipcbiAqIFRoaXMgdXRpbGl0eSBhbGxvd3MgeW91IHRvIGNyZWF0ZSBzdWdnZXN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS91dGlsaXRpZXMvc3VnZ2VzdGlvblxuICovXG5mdW5jdGlvbiBTdWdnZXN0aW9uKHsgcGx1Z2luS2V5ID0gU3VnZ2VzdGlvblBsdWdpbktleSwgZWRpdG9yLCBjaGFyID0gJ0AnLCBhbGxvd1NwYWNlcyA9IGZhbHNlLCBhbGxvd1RvSW5jbHVkZUNoYXIgPSBmYWxzZSwgYWxsb3dlZFByZWZpeGVzID0gWycgJ10sIHN0YXJ0T2ZMaW5lID0gZmFsc2UsIGRlY29yYXRpb25UYWcgPSAnc3BhbicsIGRlY29yYXRpb25DbGFzcyA9ICdzdWdnZXN0aW9uJywgY29tbWFuZCA9ICgpID0+IG51bGwsIGl0ZW1zID0gKCkgPT4gW10sIHJlbmRlciA9ICgpID0+ICh7fSksIGFsbG93ID0gKCkgPT4gdHJ1ZSwgZmluZFN1Z2dlc3Rpb25NYXRjaDogZmluZFN1Z2dlc3Rpb25NYXRjaCQxID0gZmluZFN1Z2dlc3Rpb25NYXRjaCwgfSkge1xuICAgIGxldCBwcm9wcztcbiAgICBjb25zdCByZW5kZXJlciA9IHJlbmRlciA9PT0gbnVsbCB8fCByZW5kZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcigpO1xuICAgIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IHBsdWdpbktleSxcbiAgICAgICAgdmlldygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBhc3luYyAodmlldywgcHJldlN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IChfYSA9IHRoaXMua2V5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdGUocHJldlN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IChfYiA9IHRoaXMua2V5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBob3cgdGhlIHN0YXRlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW92ZWQgPSBwcmV2LmFjdGl2ZSAmJiBuZXh0LmFjdGl2ZSAmJiBwcmV2LnJhbmdlLmZyb20gIT09IG5leHQucmFuZ2UuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRlZCA9ICFwcmV2LmFjdGl2ZSAmJiBuZXh0LmFjdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcHBlZCA9IHByZXYuYWN0aXZlICYmICFuZXh0LmFjdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlZCA9ICFzdGFydGVkICYmICFzdG9wcGVkICYmIHByZXYucXVlcnkgIT09IG5leHQucXVlcnk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZVN0YXJ0ID0gc3RhcnRlZCB8fCAobW92ZWQgJiYgY2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IGNoYW5nZWQgfHwgbW92ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUV4aXQgPSBzdG9wcGVkIHx8IChtb3ZlZCAmJiBjaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIHdoZW4gc3VnZ2VzdGlvbiBpc24ndCBhY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVTdGFydCAmJiAhaGFuZGxlQ2hhbmdlICYmICFoYW5kbGVFeGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBoYW5kbGVFeGl0ICYmICFoYW5kbGVTdGFydCA/IHByZXYgOiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uTm9kZSA9IHZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWRlY29yYXRpb24taWQ9XCIke3N0YXRlLmRlY29yYXRpb25JZH1cIl1gKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogc3RhdGUucmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogc3RhdGUucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzdGF0ZS50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZFByb3BzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLnJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogY29tbWFuZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25Ob2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmlydHVhbCBub2RlIGZvciBwb3BwZXIuanMgb3IgdGlwcHkuanNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FuIGJlIHVzZWQgZm9yIGJ1aWxkaW5nIHBvcHVwcyB3aXRob3V0IGEgRE9NIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFJlY3Q6IGRlY29yYXRpb25Ob2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBvZiBgaXRlbXNgIGNhbiBiZSBhc3luY2hyb3Vub3VzIHdl4oCZbGwgc2VhcmNoIGZvciB0aGUgY3VycmVudCBkZWNvcmF0aW9uIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWNvcmF0aW9uSWQgfSA9IChfYSA9IHRoaXMua2V5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdGUoZWRpdG9yLnN0YXRlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RGVjb3JhdGlvbk5vZGUgPSB2aWV3LmRvbS5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kZWNvcmF0aW9uLWlkPVwiJHtkZWNvcmF0aW9uSWR9XCJdYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3VycmVudERlY29yYXRpb25Ob2RlID09PSBudWxsIHx8IGN1cnJlbnREZWNvcmF0aW9uTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudERlY29yYXRpb25Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9jID0gcmVuZGVyZXIgPT09IG51bGwgfHwgcmVuZGVyZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uQmVmb3JlU3RhcnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHJlbmRlcmVyLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9kID0gcmVuZGVyZXIgPT09IG51bGwgfHwgcmVuZGVyZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uQmVmb3JlVXBkYXRlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChyZW5kZXJlciwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVDaGFuZ2UgfHwgaGFuZGxlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLml0ZW1zID0gYXdhaXQgaXRlbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogc3RhdGUucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlRXhpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9lID0gcmVuZGVyZXIgPT09IG51bGwgfHwgcmVuZGVyZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uRXhpdCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwocmVuZGVyZXIsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2YgPSByZW5kZXJlciA9PT0gbnVsbCB8fCByZW5kZXJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyZXIub25VcGRhdGUpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKHJlbmRlcmVyLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2cgPSByZW5kZXJlciA9PT0gbnVsbCB8fCByZW5kZXJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyZXIub25TdGFydCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmNhbGwocmVuZGVyZXIsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAoX2EgPSByZW5kZXJlciA9PT0gbnVsbCB8fCByZW5kZXJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyZXIub25FeGl0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChyZW5kZXJlciwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcGx1Z2luJ3MgaW50ZXJuYWwgc3RhdGUuXG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBBcHBseSBjaGFuZ2VzIHRvIHRoZSBwbHVnaW4gc3RhdGUgZnJvbSBhIHZpZXcgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICBhcHBseSh0cmFuc2FjdGlvbiwgcHJldiwgX29sZFN0YXRlLCBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNFZGl0YWJsZSB9ID0gZWRpdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29tcG9zaW5nIH0gPSBlZGl0b3IudmlldztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgZnJvbSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB7IC4uLnByZXYgfTtcbiAgICAgICAgICAgICAgICBuZXh0LmNvbXBvc2luZyA9IGNvbXBvc2luZztcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gb25seSBiZSBzdWdnZXN0aW5nIGlmIHRoZSB2aWV3IGlzIGVkaXRhYmxlLCBhbmQ6XG4gICAgICAgICAgICAgICAgLy8gICAqIHRoZXJlIGlzIG5vIHNlbGVjdGlvbiwgb3JcbiAgICAgICAgICAgICAgICAvLyAgICogYSBjb21wb3NpdGlvbiBpcyBhY3RpdmUgKHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xNDQ5KVxuICAgICAgICAgICAgICAgIGlmIChpc0VkaXRhYmxlICYmIChlbXB0eSB8fCBlZGl0b3Iudmlldy5jb21wb3NpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGFjdGl2ZSBzdGF0ZSBpZiB3ZSBqdXN0IGxlZnQgdGhlIHByZXZpb3VzIHN1Z2dlc3Rpb24gcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKChmcm9tIDwgcHJldi5yYW5nZS5mcm9tIHx8IGZyb20gPiBwcmV2LnJhbmdlLnRvKSAmJiAhY29tcG9zaW5nICYmICFwcmV2LmNvbXBvc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYWdhaW5zdCB3aGVyZSBvdXIgY3Vyc29yIGN1cnJlbnRseSBpc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGZpbmRTdWdnZXN0aW9uTWF0Y2gkMSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dTcGFjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd1RvSW5jbHVkZUNoYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkUHJlZml4ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE9mTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICRwb3NpdGlvbjogc2VsZWN0aW9uLiRmcm9tLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbklkID0gYGlkXyR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZil9YDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBtYXRjaCwgdXBkYXRlIHRoZSBjdXJyZW50IHN0YXRlIHRvIHNob3cgaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIGFsbG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvciwgc3RhdGUsIHJhbmdlOiBtYXRjaC5yYW5nZSwgaXNBY3RpdmU6IHByZXYuYWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5kZWNvcmF0aW9uSWQgPSBwcmV2LmRlY29yYXRpb25JZCA/IHByZXYuZGVjb3JhdGlvbklkIDogZGVjb3JhdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5yYW5nZSA9IG1hdGNoLnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5xdWVyeSA9IG1hdGNoLnF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50ZXh0ID0gbWF0Y2gudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBlbXB0eSB0aGUgcmFuZ2UgaWYgc3VnZ2VzdGlvbiBpcyBpbmFjdGl2ZVxuICAgICAgICAgICAgICAgIGlmICghbmV4dC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5kZWNvcmF0aW9uSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnJhbmdlID0geyBmcm9tOiAwLCB0bzogMCB9O1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC50ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgLy8gQ2FsbCB0aGUga2V5ZG93biBob29rIGlmIHN1Z2dlc3Rpb24gaXMgYWN0aXZlLlxuICAgICAgICAgICAgaGFuZGxlS2V5RG93bih2aWV3LCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFjdGl2ZSwgcmFuZ2UgfSA9IHBsdWdpbi5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoKF9hID0gcmVuZGVyZXIgPT09IG51bGwgfHwgcmVuZGVyZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uS2V5RG93bikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocmVuZGVyZXIsIHsgdmlldywgZXZlbnQsIHJhbmdlIH0pKSB8fCBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBTZXR1cCBkZWNvcmF0b3Igb24gdGhlIGN1cnJlbnRseSBhY3RpdmUgc3VnZ2VzdGlvbi5cbiAgICAgICAgICAgIGRlY29yYXRpb25zKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhY3RpdmUsIHJhbmdlLCBkZWNvcmF0aW9uSWQgfSA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtcbiAgICAgICAgICAgICAgICAgICAgRGVjb3JhdGlvbi5pbmxpbmUocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lOiBkZWNvcmF0aW9uVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGRlY29yYXRpb25DbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWRlY29yYXRpb24taWQnOiBkZWNvcmF0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gcGx1Z2luO1xufVxuXG5leHBvcnQgeyBTdWdnZXN0aW9uLCBTdWdnZXN0aW9uUGx1Z2luS2V5LCBTdWdnZXN0aW9uIGFzIGRlZmF1bHQsIGZpbmRTdWdnZXN0aW9uTWF0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIlBsdWdpbktleSIsIlBsdWdpbiIsIkRlY29yYXRpb25TZXQiLCJEZWNvcmF0aW9uIiwiZXNjYXBlRm9yUmVnRXgiLCJmaW5kU3VnZ2VzdGlvbk1hdGNoIiwiY29uZmlnIiwiX2EiLCJjaGFyIiwiYWxsb3dTcGFjZXMiLCJhbGxvd1NwYWNlc09wdGlvbiIsImFsbG93VG9JbmNsdWRlQ2hhciIsImFsbG93ZWRQcmVmaXhlcyIsInN0YXJ0T2ZMaW5lIiwiJHBvc2l0aW9uIiwiZXNjYXBlZENoYXIiLCJzdWZmaXgiLCJSZWdFeHAiLCJwcmVmaXgiLCJmaW5hbEVzY2FwZWRDaGFyIiwicmVnZXhwIiwidGV4dCIsIm5vZGVCZWZvcmUiLCJpc1RleHQiLCJ0ZXh0RnJvbSIsInBvcyIsImxlbmd0aCIsIm1hdGNoIiwiQXJyYXkiLCJmcm9tIiwibWF0Y2hBbGwiLCJwb3AiLCJpbnB1dCIsInVuZGVmaW5lZCIsImluZGV4IiwibWF0Y2hQcmVmaXgiLCJzbGljZSIsIk1hdGgiLCJtYXgiLCJtYXRjaFByZWZpeElzQWxsb3dlZCIsImpvaW4iLCJ0ZXN0IiwidG8iLCJyYW5nZSIsInF1ZXJ5IiwiU3VnZ2VzdGlvblBsdWdpbktleSIsIlN1Z2dlc3Rpb24iLCJwbHVnaW5LZXkiLCJlZGl0b3IiLCJkZWNvcmF0aW9uVGFnIiwiZGVjb3JhdGlvbkNsYXNzIiwiY29tbWFuZCIsIml0ZW1zIiwicmVuZGVyIiwiYWxsb3ciLCJmaW5kU3VnZ2VzdGlvbk1hdGNoJDEiLCJwcm9wcyIsInJlbmRlcmVyIiwicGx1Z2luIiwia2V5IiwidmlldyIsInVwZGF0ZSIsInByZXZTdGF0ZSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfZyIsInByZXYiLCJnZXRTdGF0ZSIsIm5leHQiLCJzdGF0ZSIsIm1vdmVkIiwiYWN0aXZlIiwic3RhcnRlZCIsInN0b3BwZWQiLCJjaGFuZ2VkIiwiaGFuZGxlU3RhcnQiLCJoYW5kbGVDaGFuZ2UiLCJoYW5kbGVFeGl0IiwiZGVjb3JhdGlvbk5vZGUiLCJkb20iLCJxdWVyeVNlbGVjdG9yIiwiZGVjb3JhdGlvbklkIiwiY29tbWFuZFByb3BzIiwiY2xpZW50UmVjdCIsImN1cnJlbnREZWNvcmF0aW9uTm9kZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIm9uQmVmb3JlU3RhcnQiLCJjYWxsIiwib25CZWZvcmVVcGRhdGUiLCJvbkV4aXQiLCJvblVwZGF0ZSIsIm9uU3RhcnQiLCJkZXN0cm95IiwiaW5pdCIsImNvbXBvc2luZyIsImFwcGx5IiwidHJhbnNhY3Rpb24iLCJfb2xkU3RhdGUiLCJpc0VkaXRhYmxlIiwic2VsZWN0aW9uIiwiZW1wdHkiLCIkZnJvbSIsImZsb29yIiwicmFuZG9tIiwiaXNBY3RpdmUiLCJoYW5kbGVLZXlEb3duIiwiZXZlbnQiLCJvbktleURvd24iLCJkZWNvcmF0aW9ucyIsImNyZWF0ZSIsImRvYyIsImlubGluZSIsIm5vZGVOYW1lIiwiY2xhc3MiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/suggestion/dist/index.js\n");

/***/ })

};
;